<div ng-controller="CompanyChartCtrl" id="CompanyChartCtrl" style="border: 1px solid #dddddd;
  border-top: none;
  padding: 10px 5px;
  padding-bottom: 0;
  border-radius: 0;" class="clearfix fit-height">
    <div id="treeContainer" class="col-md-8 ">
        <div class="panel panel-default ">
            <div class="panel-heading">
                <h3 class="panel-title">
                    //'chart'|translate//
                </h3>
            </div>
            <div class="panel-body fit-height">

                <div id="tree-container"
                     style="overflow: auto;"
                     dir="ltr">
                </div>
            </div>
        </div>
    </div>


    <div class="col-md-4">

        <div class="panel panel-default">
            <div class="panel-heading">
                <h3 class="panel-title">
                    // 'chartedit' | translate //
                    <button type="button" class="btn btn-primary fa fa-plus btn-md pull-right" id="btnAdd"
                            style="  margin-top: -8px;"></button>

                </h3>

            </div>


            <div class="panel-body">
                <form class="ng-pristine ng-valid col-md-12">
                    <div class="form-group">

                        <div class="input-group">
                            <input type="text"
                                   class="form-control underline"
                                   id="txtSematName"
                                   placeholder="select a position">
                                <span class="input-group-btn">
                                    <button type="button"
                                            class="btn btn-success fa fa-save btn-md"
                                            id="btnPost"></button>
                            <button type="button" class="btn btn-md btn-danger fa fa-trash"
                                    id="btnDelete"></button>
                                </span>
                        </div>
                    </div>
                </form>
            </div>

        </div>
        <div class="panel panel-default">
            <div class="panel-heading">
                <h3 class="panel-title">
                    // 'Secratrait Permissions' | translate //


                </h3>

            </div>


            <div class="panel-body">
                <form class="ng-pristine ng-valid col-md-12">
                    <div class="form-group">
                        <table class="table table-condensed table-bordered table-striped">
                            <thead>
                            <tr>
                                <th>//'Name'|translate//</th>
                                <th>//'Default'|translate//</th>
                                <th>//'Access'|translate//</th>
                                <th>//'Export'|translate//</th>
                                <th>//'Import'|translate//</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr ng-repeat="item in SecratraitsList">
                                <td>//item.Name//</td>
                                <td>
                                    <label class="checkbox1" for="xxOption//item.Id//">
                                        <input id="xxOption//item.Id//" type="checkbox" ng-model="item.default"
                                               ng-change="CheckOtherSecPer(item)">
                                        <span></span> </label>

                                </td>


                                <td ng-repeat="ii in item.perm track by $index">
                                    <label class="checkbox1" for="xxxOption//item.Id//qq//items.length - $index - 1//">
                                        <input id="xxxOption//item.Id//qq//items.length - $index - 1//" type="checkbox" ng-model="ii"
                                               ng-change="UpdatePerSecWithSelect(item,ii,$index)">
                                        <span></span> </label>

                                </td>

                            </tr>

                            <tr ng-if="SecratraitsList == []">
                                <td colspan="5">//"Please select a chart item to edit"|translate//</td>
                            </tr>
                            </tbody>
                        </table>

                    </div>
                </form>
            </div>

        </div>


        <div class="panel panel-default">
            <div class="panel-heading">
                <h3 class="panel-title">
                    // 'ChartZones' | translate //
                    <button class=" btn btn-md btn-primary fa fa-plus pull-right" ng-click="NewZone()"
                            style=" margin-top: -8px;">

                    </button>
                </h3>

            </div>
            <div class="panel-body">
                <input type="text" class="form-control underline" id="zoneSearch" placeholder="Search through zones...">
                <br>

                <div class="fit-height-zone">
                    <div ng-repeat="zone in Zones.results track by $index">
                        <label class="checkbox1" for="Option//$index//">
                            <input id="Option//$index//" type="checkbox" ng-model="zone.selected"
                                   ng-change="ChangeZonesChart(zone)">
                            <span></span> </label>
                        <span>//zone.title//</span>
                <span class="btn-group btn-group-xs pull-right">
                    <button ng-click="DeleteZone(zone, $index)"
                            class="btn btn-default btn-xs btn-danger fa fa-trash-o"></button>
                    <button ng-click="EditZone(zone, $index)"
                            class="btn btn-default btn-xs btn-info fa fa-pencil"></button>

                </span>

                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        $(document).ready(function () {
            $('.fit-height').css('height', window.innerHeight - 180 + 'px').css('overflow-y', 'scroll').css('overflow-x', 'hidden');
            $('.fit-height-zone').css('height', window.innerHeight - 403 + 'px').css('overflow-y', 'scroll').css('overflow-x', 'hidden');

        });
    </script>
    <style type="text/css">
        ::-webkit-scrollbar {
            -webkit-appearance: none;
            width: 0;
        }

        .node {
            cursor: pointer;
        }

        .overlay {
            background-color: #ffffff;
        }

        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 1.5px;
        }

        .node text {
            font-size: 10px;
            font-family: B Yekan;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        .templink {
            fill: none;
            stroke: red;
            stroke-width: 3px;
        }

        .ghostCircle.show {
            display: block;
        }

        .ghostCircle, .activeDrag .ghostCircle {
            display: none;
        }


    </style>


    <script type="text/javascript">
        var selectedItem;
        var treeJSON;
        var tree;
        var viewerHeight = 600;
        var viewerWidth = $("#treeContainer").width();
        var chartData = {};
        var chartRunFirstTime = true;
        {#    var currentChartUrl = "";#}


        function loadChart(chartUrl) {
            $("#tree-container").html('');

            chartRunFirstTime = false;
            treeJSON = d3.json(chartUrl, function (error, treeData) {
                        // Calculate total nodes, max label length
                        var totalNodes = 0;
                        var maxLabelLength = 35;
                        // variables for drag/drop
                        var selectedNode = null;
                        var draggingNode = null;
                        // panning variables
                        var panSpeed = 200;
                        var panBoundary = 10; // Within 20px from edges will pan when dragging.
                        // Misc. variables
                        var i = 0;
                        var duration = 1000;
                        var root;
                        chartData = treeData;


                        window.onresize = function (event) {
                            viewerWidth = $("#treeContainer").width();
                            tree.size([viewerHeight, viewerWidth]);
                        }


                        tree = d3.layout.tree().size([viewerHeight, viewerWidth]);

                        // define a d3 diagonal projection for use by the node paths later on.
                        var diagonal = d3.svg.diagonal()
                                .projection(function (d) {
                                    return [d.y, d.x];
                                });

                        // A recursive helper function for performing some setup by walking through all nodes


                        d3.selectAll("#btnPost").on(
                                "click", function () {

                                    $.ajax({
                                        type: "POST",
                                        url: currentChartUrl + selectedItem.id + "/ChangeChartName/",
                                        data: {
                                            "id": selectedItem.id,
                                            "name": $("#txtSematName").val(),
                                            csrfmiddlewaretoken: $.cookie('csrftoken')
                                        },
                                        success: function (msg) {
                                            selectedItem.name = $("#txtSematName").val();
                                            upDateJson(selectedItem.id, selectedItem.name);
                                        },
                                        error: function (XMLHttpRequest, textStatus, errorThrown) {
                                            XMLHttpRequest.responseJSON.message.forEach(function (err) {
                                                swal(err.name, err.message, "error")
                                            })
                                        }


                                    })


                                }
                        );

                        d3.selectAll("#btnAdd").on(
                                "click", function () {
                                    if (!(selectedItem)) {
                                        swal("No parent selected", "Please select a parent position in the chart!", "warning");
                                        return;
                                    }


                                    swal({
                                        title: "An input!",
                                        text: "Write something interesting:",
                                        type: "input",
                                        showCancelButton: true,
                                        showLoaderOnConfirm: true,
                                        closeOnConfirm: false,
                                        animation: "slide-from-top",
                                        inputPlaceholder: "Write something"
                                    }, function (inputValue) {
                                        if (inputValue === false) return false;
                                        if (inputValue === "") {
                                            swal.showInputError("You need to write something!");
                                            return false
                                        }
                                        $.post(currentChartUrl + selectedItem.id + "/AddNewChart/", {
                                            parentID: selectedItem.id,
                                            name: inputValue,
                                            csrfmiddlewaretoken: $.cookie('csrftoken')
                                        }, function (data) {
                                            addToJson(
                                                    data.top,
                                                    data.id,
                                                    data.title);
                                            swal("Nice!", inputValue + " successfully added ! ", "success");
                                        });


                                    });


                                    // second must to open the tree
                                });

                        d3.selectAll("#btnDelete").on(
                                "click", function () {

                                    if (!(selectedItem)) {
                                        swal("No parent selected", "Please select a parent position in the chart!", "warning");
                                        return
                                    }


                                    swal({
                                        title: "Are you sure?",
                                        text: "You will not be able to recover this imaginary file!",
                                        type: "warning",
                                        showCancelButton: true,
                                        showLoaderOnConfirm: true,
                                        confirmButtonColor: "#DD6B55",
                                        confirmButtonText: "Yes, delete it!",
                                        closeOnConfirm: false
                                    }, function () {
                                        $.ajax({
                                                    url: currentChartUrl + selectedItem.id + "/",
                                                    type: "DELETE",
                                                    data: {
                                                        id: selectedItem.id,
                                                        csrfmiddlewaretoken: $.cookie('csrftoken')
                                                    },
                                                    success: function (data) {
                                                        swal("Deleted!", "Your imaginary file has been deleted.", "success");
                                                        removeFromJson(selectedItem.id);
                                                    },
                                                    error: function () {
                                                        swal("Delete Fail", "This position has some branches please delete them first", "error");
                                                    }
                                                }
                                        );
                                    });
                                }
                        );


                        function removeFromJson(Id) {
                            //console.log(chartData);
                            function updj(items) {
                                for (var i = 0; items.length > i; i++) {
                                    if (Id == items[i].id) {
                                        items.splice(i, 1);
                                        return
                                    }
                                    if (items[i].children) {
                                        updj(items[i].children);
                                    }

                                }
                            }

                            if (chartData.children) {
                                updj(chartData.children);
                            }
                            update(root);
                        }


                        function upDateJson(Id, NewText) {
                            //console.log(chartData);
                            function updj(items) {
                                for (var i = 0; items.length > i; i++) {
                                    if (Id == items[i].id) {
                                        items[i].name = NewText;
                                        return
                                    }
                                    if (items[i].children) {
                                        updj(items[i].children);
                                    }

                                }
                            }

                            if (chartData.children) {
                                updj(chartData.children);
                            }
                            update(root);
                        }

                        function addToJson(parentID, NewId, NewText) {
                            function updj(items) {
                                for (var i = 0; items.length > i; i++) {
                                    if (parentID == items[i].id) {
                                        if (items[i]._children != undefined) {
                                            toggleChildren(items[i])
                                        }
                                        if (items[i].children == undefined) {
                                            items[i].children = [];
                                        }
                                        items[i].children.push({
                                            id: NewId,
                                            name: NewText
                                        });
                                        return
                                    }
                                    if (items[i].children) {
                                        updj(items[i].children);
                                    }
                                }
                            }

                            if (chartData.children) {
                                updj(chartData.children);
                            }
                            update(root);
                        }


                        function visit(parent, visitFn, childrenFn) {
                            if (!parent) return;

                            visitFn(parent);

                            var children = childrenFn(parent);
                            if (children) {
                                var count = children.length;
                                for (var i = 0; i < count; i++) {
                                    visit(children[i], visitFn, childrenFn);
                                }
                            }
                        }

                        // Call visit function to establish maxLabelLength
                        visit(chartData, function (d) {
                            totalNodes++;
                            maxLabelLength = Math.max(d.name.length, maxLabelLength);

                        }, function (d) {
                            return d.children && d.children.length > 0 ? d.children : null;
                        });


                        // sort the tree according to the node names

                        function sortTree() {
                            tree.sort(function (a, b) {
                                return b.name.toLowerCase() < a.name.toLowerCase() ? 1 : -1;
                            });
                        }

                        // Sort the tree initially incase the JSON isn't in a sorted order.
                        sortTree();

                        // TODO: Pan function, can be better implemented.

                        function pan(domNode, direction) {
                            var speed = panSpeed;
                            if (panTimer) {
                                clearTimeout(panTimer);
                                translateCoords = d3.transform(svgGroup.attr("transform"));
                                if (direction == 'left' || direction == 'right') {
                                    translateX = direction == 'left' ? translateCoords.translate[0] + speed : translateCoords.translate[0] - speed;
                                    translateY = translateCoords.translate[1];
                                } else if (direction == 'up' || direction == 'down') {
                                    translateX = translateCoords.translate[0];
                                    translateY = direction == 'up' ? translateCoords.translate[1] + speed : translateCoords.translate[1] - speed;
                                }
                                scaleX = translateCoords.scale[0];
                                scaleY = translateCoords.scale[1];
                                scale = zoomListener.scale();
                                svgGroup.transition().attr("transform", "translate(" + translateX + "," + translateY + ")scale(" + scale + ")");
                                d3.select(domNode).select('g.node').attr("transform", "translate(" + translateX + "," + translateY + ")");
                                zoomListener.scale(zoomListener.scale());
                                zoomListener.translate([translateX, translateY]);
                                panTimer = setTimeout(function () {
                                    pan(domNode, speed, direction);
                                }, 50);
                            }
                        }

                        // Define the zoom function for the zoomable tree

                        function zoom() {
                            svgGroup.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
                        }


                        // define the zoomListener which calls the zoom function on the "zoom" event constrained within the scaleExtents
                        var zoomListener = d3.behavior.zoom().scaleExtent([0.1, 3]).on("zoom", zoom);

                        function initiateDrag(d, domNode) {
                            draggingNode = d;
                            d3.select(domNode).select('.ghostCircle').attr('pointer-events', 'none');
                            d3.selectAll('.ghostCircle').attr('class', 'ghostCircle show');
                            d3.select(domNode).attr('class', 'node activeDrag');

                            svgGroup.selectAll("g.node").sort(function (a, b) { // select the parent and sort the path's
                                if (a.id != draggingNode.id) return 1; // a is not the hovered element, send "a" to the back
                                else return -1; // a is the hovered element, bring "a" to the front
                            });
                            // if nodes has children, remove the links and nodes
                            if (nodes.length > 1) {
                                // remove link paths
                                links = tree.links(nodes);
                                nodePaths = svgGroup.selectAll("path.link")
                                        .data(links, function (d) {
                                            return d.target.id;
                                        }).remove();
                                // remove child nodes
                                nodesExit = svgGroup.selectAll("g.node")
                                        .data(nodes, function (d) {
                                            return d.id;
                                        }).filter(function (d, i) {
                                            if (d.id == draggingNode.id) {
                                                return false;
                                            }
                                            return true;
                                        }).remove();
                            }

                            // remove parent link
                            parentLink = tree.links(tree.nodes(draggingNode.parent));
                            svgGroup.selectAll('path.link').filter(function (d, i) {
                                if (d.target.id == draggingNode.id) {
                                    return true;
                                }
                                return false;
                            }).remove();

                            dragStarted = null;
                        }

                        // define the baseSvg, attaching a class for styling and the zoomListener
                        var baseSvg = d3.select("#tree-container").append("svg")
                                .attr("width", viewerWidth)
                                .attr("height", viewerHeight)
                                .attr("class", "overlay")
                                .call(zoomListener);


                        // Define the drag listeners for drag/drop behaviour of nodes.
                        dragListener = d3.behavior.drag()
                                .on("dragstart", function (d) {
                                    if (d == root) {
                                        return;
                                    }
                                    dragStarted = true;
                                    nodes = tree.nodes(d);
                                    d3.event.sourceEvent.stopPropagation();
                                    // it's important that we suppress the mouseover event on the node being dragged. Otherwise it will absorb the mouseover event and the underlying node will not detect it d3.select(this).attr('pointer-events', 'none');
                                })
                                .on("drag", function (d) {
                                    if (d == root) {
                                        return;
                                    }
                                    if (dragStarted) {
                                        domNode = this;
                                        initiateDrag(d, domNode);
                                    }

                                    // get coords of mouseEvent relative to svg container to allow for panning
                                    relCoords = d3.mouse($('svg').get(0));
                                    if (relCoords[0] < panBoundary) {
                                        panTimer = true;
                                        pan(this, 'left');
                                    } else if (relCoords[0] > ($('svg').width() - panBoundary)) {

                                        panTimer = true;
                                        pan(this, 'right');
                                    } else if (relCoords[1] < panBoundary) {
                                        panTimer = true;
                                        pan(this, 'up');
                                    } else if (relCoords[1] > ($('svg').height() - panBoundary)) {
                                        panTimer = true;
                                        pan(this, 'down');
                                    } else {
                                        try {
                                            clearTimeout(panTimer);
                                        } catch (e) {

                                        }
                                    }

                                    d.x0 += d3.event.dy;
                                    d.y0 += d3.event.dx;
                                    var node = d3.select(this);
                                    node.attr("transform", "translate(" + d.y0 + "," + d.x0 + ")");
                                    updateTempConnector();
                                }).on("dragend", function (d) {
                                    if (d == root) {
                                        return;
                                    }
                                    domNode = this;
                                    if (selectedNode) {
                                        // now remove the element from the parent, and insert it into the new elements children
                                        var index = draggingNode.parent.children.indexOf(draggingNode);
                                        if (index > -1) {
                                            draggingNode.parent.children.splice(index, 1);
                                        }
                                        if (typeof selectedNode.children !== 'undefined' || typeof selectedNode._children !== 'undefined') {
                                            if (typeof selectedNode.children !== 'undefined') {
                                                selectedNode.children.push(draggingNode);
                                            } else {
                                                selectedNode._children.push(draggingNode);
                                            }
                                        } else {
                                            selectedNode.children = [];
                                            selectedNode.children.push(draggingNode);
                                        }
                                        // Make sure that the node being added to is expanded so user can see added node is correctly moved
                                        expand(selectedNode);
                                        sortTree();
                                        endDrag();
                                        // debugger;
                                        updateParentOfSemat(d.parent.id, d.id);
                                    } else {
                                        endDrag();
                                    }

                                    generateMapForNav_mrb(d);


                                });

                        function updateParentOfSemat(parentID, sematID) {
                            var scope = angular.element($("#CompanyChartCtrl")).scope();


                            $.post(currentChartUrl + "" + sematID + "/ChangeLevel/", {
                                        id: sematID,
                                        parentId: parentID,
                                        csrfmiddlewaretoken: $.cookie('csrftoken')
                                    },
                                    function (data) {

                                    });
                        }


                        function generateMapForNav_mrb(d) {
                            $("#itemMap").html("");
                            var s = "";

                            function gs(dp) {
                                if (dp.parent) {
                                    s = dp.parent.name + " <i class='fa fa-chevron-right'></i> " + s
                                    gs(dp.parent)
                                }
                            }

                            s = d.name;

                            gs(d)
                            $("#itemMap").html(s);
                            $("#txtSematName").val(d.name);
                            selectedItem = d;
                        }


                        function endDrag() {
                            selectedNode = null;
                            d3.selectAll('.ghostCircle').attr('class', 'ghostCircle');
                            d3.select(domNode).attr('class', 'node');
                            // now restore the mouseover event or we won't be able to drag a 2nd time
                            d3.select(domNode).select('.ghostCircle').attr('pointer-events', '');
                            updateTempConnector();
                            if (draggingNode !== null) {
                                update(root);
                                centerNode(draggingNode);
                                draggingNode = null;
                            }
                        }

                        // Helper functions for collapsing and expanding nodes.

                        function collapse(d) {
                            if (d.children) {
                                d._children = d.children;
                                d._children.forEach(collapse);
                                d.children = null;
                            }
                        }

                        function expand(d) {
                            if (d._children) {
                                d.children = d._children;
                                d.children.forEach(expand);
                                d._children = null;
                            }
                        }

                        var overCircle = function (d) {
                            selectedNode = d;
                            updateTempConnector();
                        };
                        var outCircle = function (d) {
                            selectedNode = null;
                            updateTempConnector();
                        };

                        // Function to update the temporary connector indicating dragging affiliation
                        var updateTempConnector = function () {
                            var data = [];
                            if (draggingNode !== null && selectedNode !== null) {
                                // have to flip the source coordinates since we did this for the existing connectors on the original tree
                                data = [{
                                    source: {
                                        x: selectedNode.y0,
                                        y: selectedNode.x0
                                    },
                                    target: {
                                        x: draggingNode.y0,
                                        y: draggingNode.x0
                                    }
                                }];
                            }
                            var link = svgGroup.selectAll(".templink").data(data);

                            link.enter().append("path")
                                    .attr("class", "templink")
                                    .attr("d", d3.svg.diagonal())
                                    .attr('pointer-events', 'none');

                            link.attr("d", d3.svg.diagonal());

                            link.exit().remove();
                        };

                        // Function to center node when clicked/dropped so node doesn't get lost when collapsing/moving with large amount of children.

                        function centerNode(source) {
                            scale = zoomListener.scale();
                            x = -source.y0;
                            y = -source.x0;
                            x = x * scale + viewerWidth / 2;
                            y = y * scale + viewerHeight / 2;

                        }

                        // Toggle children function

                        function toggleChildren(d) {
                            if (d.children) {
                                d._children = d.children;
                                d.children = null;
                            } else if (d._children) {
                                d.children = d._children;
                                d._children = null;
                            }
                            return d;
                        }

                        // Toggle children on click.

                        function click(d) {
                            if (d3.event.defaultPrevented) return; // click suppressed
                            d = toggleChildren(d);
                            update(d);
                            centerNode(d);

                            // i have to run the scope from outside
                            var scope = angular.element($("#CompanyChartCtrl")).scope();
                            scope.GetZoneList(d.id);
                            scope.GetSecList(d.id);
                            scope.SelectedChartID = d.id;


                        }

                        function update(source) {
                            // Compute the new height, function counts total children of root node and sets tree height accordingly.
                            // This prevents the layout looking squashed when new nodes are made visible or looking sparse when nodes are removed
                            // This makes the layout more consistent.
                            var levelWidth = [1];
                            var childCount = function (level, n) {

                                if (n.children && n.children.length > 0) {
                                    if (levelWidth.length <= level + 1) levelWidth.push(0);

                                    levelWidth[level + 1] += n.children.length;
                                    n.children.forEach(function (d) {
                                        childCount(level + 1, d);
                                    });
                                }
                            };
                            childCount(0, root);
                            var newHeight = d3.max(levelWidth) * 25; // 25 pixels per line
                            tree = tree.size([newHeight, viewerWidth]);

                            // Compute the new tree layout.
                            var nodes = tree.nodes(root).reverse(),
                                    links = tree.links(nodes);

                            // Set widths between levels based on maxLabelLength.
                            nodes.forEach(function (d) {
                                d.y = (d.depth * (maxLabelLength * 5)); //maxLabelLength * 10px
                                // alternatively to keep a fixed scale one can set a fixed depth per level
                                // Normalize for fixed-depth by commenting out below line
                                // d.y = (d.depth * 500); //500px per level.
                            });

                            // Update the nodes…
                            node = svgGroup.selectAll("g.node")
                                    .data(nodes, function (d) {
                                        return d.id || (d.id = ++i);
                                    });

                            // Enter any new nodes at the parent's previous position.
                            var nodeEnter = node.enter().append("g")
                                    .call(dragListener)
                                    .attr("class", "node")
                                    .attr("transform", function (d) {
                                        return "translate(" + source.y0 + "," + source.x0 + ")";
                                    })
                                    .on('click', click);

                            nodeEnter.append("circle")
                                    .attr('class', 'nodeCircle')
                                    .attr("r", 0)
                                    .style("fill", function (d) {
                                        return d._children ? "lightsteelblue" : "#fff";
                                    });

                            nodeEnter.append("text")
                                    .attr("x", function (d) {
                                        return d.children || d._children ? -10 : 10;
                                    })
                                    .attr("dy", ".35em")
                                    .attr('class', 'nodeText')
                                    .attr("text-anchor", function (d) {
                                        return d.children || d._children ? "end" : "start";
                                    })
                                    .text(function (d) {
                                        return d.name;
                                    })
                                    .style("fill-opacity", 0);

                            // phantom node to give us mouseover in a radius around it
                            nodeEnter.append("circle")
                                    .attr('class', 'ghostCircle')
                                    .attr("r", 30)
                                    .attr("opacity", 0.2) // change this to zero to hide the target area
                                    .style("fill", "red")
                                    .attr('pointer-events', 'mouseover')
                                    .on("mouseover", function (node) {
                                        overCircle(node);
                                    })
                                    .on("mouseout", function (node) {
                                        outCircle(node);
                                    });

                            // Update the text to reflect whether node has children or not.
                            node.select('text')
                                    .attr("x", function (d) {
                                        return d.children || d._children ? -10 : 10;
                                    })
                                    .attr("text-anchor", function (d) {
                                        return d.children || d._children ? "end" : "start";
                                    })
                                    .text(function (d) {
                                        return d.name;
                                    });

                            // Change the circle fill depending on whether it has children and is collapsed
                            node.select("circle.nodeCircle")
                                    .attr("r", 4.5)
                                    .style("fill", function (d) {
                                        return d._children ? "lightsteelblue" : "#fff";
                                    });

                            // Transition nodes to their new position.
                            var nodeUpdate = node.transition()
                                    .duration(duration)
                                    .attr("transform", function (d) {
                                        return "translate(" + d.y + "," + d.x + ")";
                                    });

                            // Fade the text in
                            nodeUpdate.select("text")
                                    .style("fill-opacity", 1);

                            // Transition exiting nodes to the parent's new position.
                            var nodeExit = node.exit().transition()
                                    .duration(duration)
                                    .attr("transform", function (d) {
                                        return "translate(" + source.y + "," + source.x + ")";
                                    })
                                    .remove();

                            nodeExit.select("circle")
                                    .attr("r", 0);

                            nodeExit.select("text")
                                    .style("fill-opacity", 0);

                            // Update the links…
                            var link = svgGroup.selectAll("path.link")
                                    .data(links, function (d) {
                                        return d.target.id;
                                    });

                            // Enter any new links at the parent's previous position.
                            link.enter().insert("path", "g")
                                    .attr("class", "link")
                                    .attr("d", function (d) {
                                        var o = {
                                            x: source.x0,
                                            y: source.y0
                                        };
                                        return diagonal({
                                            source: o,
                                            target: o
                                        });
                                    });

                            // Transition links to their new position.
                            link.transition()
                                    .duration(duration)
                                    .attr("d", diagonal);

                            // Transition exiting nodes to the parent's new position.
                            link.exit().transition()
                                    .duration(duration)
                                    .attr("d", function (d) {
                                        var o = {
                                            x: source.x,
                                            y: source.y
                                        };
                                        return diagonal({
                                            source: o,
                                            target: o
                                        });
                                    })
                                    .remove();

                            // Stash the old positions for transition.
                            nodes.forEach(function (d) {
                                d.x0 = d.x;
                                d.y0 = d.y;
                            });
                        }

                        // Append a group which holds all nodes and which the zoom Listener can act upon.
                        var svgGroup = baseSvg.append("g");

                        // Define the root
                        root = chartData;
                        root.x0 = viewerHeight / 2;
                        root.y0 = 0;

                        // Layout the tree initially and center on the root node.
                        update(root);
                        centerNode(root);
                    }
            )
            ;

        }
    </script>

</div>
    
