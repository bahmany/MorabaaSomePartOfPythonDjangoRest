(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a)return a(o, !0);
                if (i)return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f
            }
            var l = n[o] = {exports: {}};
            t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }

    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)s(r[o]);
    return s
})({
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/app/index.js":
    [function (require, module, exports) {
        'use strict';

        var $ = require('jquery'),
            BpmnModeler = require('bpmn-js/lib/Modeler');

        var container = $('#js-drop-zone');

        var canvas = $('#js-canvas');

        var renderer = new BpmnModeler({container: canvas});

        var newDiagramXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bpmn2:definitions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:bpmn2=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" xmlns:dc=\"http://www.omg.org/spec/DD/20100524/DC\" xmlns:di=\"http://www.omg.org/spec/DD/20100524/DI\" xsi:schemaLocation=\"http://www.omg.org/spec/BPMN/20100524/MODEL BPMN20.xsd\" id=\"sample-diagram\" targetNamespace=\"http://bpmn.io/schema/bpmn\">\n  <bpmn2:process id=\"Process_1\" isExecutable=\"false\">\n    <bpmn2:startEvent id=\"StartEvent_1\"/>\n  </bpmn2:process>\n  <bpmndi:BPMNDiagram id=\"BPMNDiagram_1\">\n    <bpmndi:BPMNPlane id=\"BPMNPlane_1\" bpmnElement=\"Process_1\">\n      <bpmndi:BPMNShape id=\"_BPMNShape_StartEvent_2\" bpmnElement=\"StartEvent_1\">\n        <dc:Bounds height=\"36.0\" width=\"36.0\" x=\"412.0\" y=\"240.0\"/>\n      </bpmndi:BPMNShape>\n    </bpmndi:BPMNPlane>\n  </bpmndi:BPMNDiagram>\n</bpmn2:definitions>";

        function createNewDiagram() {
            openDiagram(newDiagramXML);
        }

        function openDiagram(xml) {

            renderer.importXML(xml, function (err) {

                if (err) {
                    container
                        .removeClass('with-diagram')
                        .addClass('with-error');

                    container.find('.error pre').text(err.message);

                    console.error(err);
                } else {
                    container
                        .removeClass('with-error')
                        .addClass('with-diagram');
                }


            });
        }

        function saveSVG(done) {
            renderer.saveSVG(done);
        }

        function saveDiagram(done) {

            renderer.saveXML({format: true}, function (err, xml) {
                done(err, xml);
            });
        }

        function registerFileDrop(container, callback) {

            function handleFileSelect(e) {
                e.stopPropagation();
                e.preventDefault();

                var files = e.dataTransfer.files;

                var file = files[0];

                var reader = new FileReader();

                reader.onload = function (e) {

                    var xml = e.target.result;

                    callback(xml);
                };

                reader.readAsText(file);
            }

            function handleDragOver(e) {
                e.stopPropagation();
                e.preventDefault();

                e.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
            }

            container.get(0).addEventListener('dragover', handleDragOver, false);
            container.get(0).addEventListener('drop', handleFileSelect, false);
        }


////// file drag / drop ///////////////////////

// check file api availability
        if (!window.FileList || !window.FileReader) {
            window.alert(
                'Looks like you use an older browser that does not support drag and drop. ' +
                'Try using Chrome, Firefox or the Internet Explorer > 10.');
        } else {
            registerFileDrop(container, openDiagram);
        }

// bootstrap diagram functions



   $(document).on('ready', function () {



   $('#start-edite').click(function () {
        if(globalxml==""){
        createNewDiagram();
        }else{
       openDiagram(globalxml);
       }
       $('#start-edite-div').css('display','none');
});

            var downloadLink = $('#js-download-diagram');
            var downloadSvgLink = $('#js-download-svg');

            $('.buttons a').click(function (e) {

                if (!$(this).is('.active')) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            //this function save the diagram in server
             $('#js-save-diagram').click(function () {
             renderer.saveXML({format: true}, function (err, xml) {
               angular.element($('#bpmnModelerCtrl')).scope().saveBpmn(xml);
                });

            });
            $('#js-download-diagram').click(function () {
                renderer.saveXML({format: true}, function (err, xml) {

                });

            });
            function setEncoded(link, name, data) {
                var encodedData = encodeURIComponent(data);

                if (data) {
                    link.addClass('active').attr({
                        'href': 'data:application/bpmn20-xml;charset=UTF-8,' + encodedData,
                        'download': name
                    });

                } else {
                    link.removeClass('active');
                }
            }

            var _ = require('lodash');

            var exportArtifacts = _.debounce(function () {

                saveSVG(function (err, svg) {
                    setEncoded(downloadSvgLink, 'diagram.svg', err ? null : svg);
                });

                saveDiagram(function (err, xml) {
                    setEncoded(downloadLink, 'diagram.bpmn', err ? null : xml);

                });
            }, 500);

            renderer.on('commandStack.changed', exportArtifacts);
        });
    }, {
        "bpmn-js/lib/Modeler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/Modeler.js",
        "jquery": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/jquery/dist/jquery.js",
        "lodash": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/Modeler.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var IdSupport = require('bpmn-moddle/lib/id-support'),
            Ids = require('ids');

        var Viewer = require('./Viewer');

        var initialDiagram =
            '<?xml version="1.0" encoding="UTF-8"?>' +
            '<bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' +
            'xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" ' +
            'xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" ' +
            'xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" ' +
            'targetNamespace="http://bpmn.io/schema/bpmn" ' +
            'id="Definitions_1">' +
            '<bpmn:process id="Process_1" isExecutable="false">' +
            '<bpmn:startEvent id="StartEvent_1"/>' +
            '</bpmn:process>' +
            '<bpmndi:BPMNDiagram id="BPMNDiagram_1">' +
            '<bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">' +
            '<bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">' +
            '<dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/>' +
            '</bpmndi:BPMNShape>' +
            '</bpmndi:BPMNPlane>' +
            '</bpmndi:BPMNDiagram>' +
            '</bpmn:definitions>';


        /**
         * A modeler for BPMN 2.0 diagrams.
         *
         *
         * ## Extending the Modeler
         *
         * In order to extend the viewer pass extension modules to bootstrap via the
         * `additionalModules` option. An extension module is an object that exposes
         * named services.
         *
         * The following example depicts the integration of a simple
         * logging component that integrates with interaction events:
         *
         *
         * ```javascript
         *
         * // logging component
         * function InteractionLogger(eventBus) {
 *   eventBus.on('element.hover', function(event) {
 *     console.log()
 *   })
 * }
         *
         * InteractionLogger.$inject = [ 'eventBus' ]; // minification save
         *
         * // extension module
         * var extensionModule = {
 *   __init__: [ 'interactionLogger' ],
 *   interactionLogger: [ 'type', InteractionLogger ]
 * };
         *
         * // extend the viewer
         * var bpmnModeler = new Modeler({ additionalModules: [ extensionModule ] });
         * bpmnModeler.importXML(...);
         * ```
         *
         *
         * ## Customizing / Replacing Components
         *
         * You can replace individual diagram components by redefining them in override modules.
         * This works for all components, including those defined in the core.
         *
         * Pass in override modules via the `options.additionalModules` flag like this:
         *
         * ```javascript
         * function CustomContextPadProvider(contextPad) {
 *
 *   contextPad.registerProvider(this);
 *
 *   this.getContextPadEntries = function(element) {
 *     // no entries, effectively disable the context pad
 *     return {};
 *   };
 * }
         *
         * CustomContextPadProvider.$inject = [ 'contextPad' ];
         *
         * var overrideModule = {
 *   contextPadProvider: [ 'type', CustomContextPadProvider ]
 * };
         *
         * var bpmnModeler = new Modeler({ additionalModules: [ overrideModule ]});
         * ```
         *
         * @param {Object} [options] configuration options to pass to the viewer
         * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
         * @param {String|Number} [options.width] the width of the viewer
         * @param {String|Number} [options.height] the height of the viewer
         * @param {Object} [options.moddleExtensions] extension packages to provide
         * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
         * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
         */
        function Modeler(options) {
            Viewer.call(this, options);
        }

        inherits(Modeler, Viewer);

        Modeler.prototype.createDiagram = function (done) {
            return this.importXML(initialDiagram, done);
        };

        Modeler.prototype.createModdle = function () {
            var moddle = Viewer.prototype.createModdle.call(this);

            IdSupport.extend(moddle, new Ids([32, 36, 1]));

            return moddle;
        };


        Modeler.prototype._interactionModules = [
            // non-modeling components
            require('./features/label-editing'),
            require('diagram-js/lib/navigation/zoomscroll'),
            require('diagram-js/lib/navigation/movecanvas'),
            require('diagram-js/lib/navigation/touch')
        ];

        Modeler.prototype._modelingModules = [
            // modeling components
            require('diagram-js/lib/features/move'),
            require('diagram-js/lib/features/bendpoints'),
            require('diagram-js/lib/features/resize'),
            require('diagram-js/lib/features/space-tool'),
            require('diagram-js/lib/features/lasso-tool'),
            require('./features/keyboard'),
            require('./features/snapping'),
            require('./features/modeling'),
            require('./features/context-pad'),
            require('./features/palette')
        ];


// modules the modeler is composed of
//
// - viewer modules
// - interaction modules
// - modeling modules

        Modeler.prototype._modules = [].concat(
            Modeler.prototype._modules,
            Modeler.prototype._interactionModules,
            Modeler.prototype._modelingModules);


        module.exports = Modeler;

    }, {
        "./Viewer": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/Viewer.js",
        "./features/context-pad": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/context-pad/index.js",
        "./features/keyboard": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/keyboard/index.js",
        "./features/label-editing": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/index.js",
        "./features/modeling": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/index.js",
        "./features/palette": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/palette/index.js",
        "./features/snapping": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/snapping/index.js",
        "bpmn-moddle/lib/id-support": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/lib/id-support.js",
        "diagram-js/lib/features/bendpoints": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/index.js",
        "diagram-js/lib/features/lasso-tool": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/lasso-tool/index.js",
        "diagram-js/lib/features/move": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/move/index.js",
        "diagram-js/lib/features/resize": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/resize/index.js",
        "diagram-js/lib/features/space-tool": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/space-tool/index.js",
        "diagram-js/lib/navigation/movecanvas": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/movecanvas/index.js",
        "diagram-js/lib/navigation/touch": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/touch/index.js",
        "diagram-js/lib/navigation/zoomscroll": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/zoomscroll/index.js",
        "ids": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/ids/index.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/Viewer.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            omit = require('lodash/object/omit'),
            isString = require('lodash/lang/isString'),
            isNumber = require('lodash/lang/isNumber');

        var domify = require('min-dom/lib/domify'),
            domQuery = require('min-dom/lib/query'),
            domRemove = require('min-dom/lib/remove');

        var Diagram = require('diagram-js'),
            BpmnModdle = require('bpmn-moddle');

        var Importer = require('./import/Importer');


        function initListeners(diagram, listeners) {
            var events = diagram.get('eventBus');

            listeners.forEach(function (l) {
                events.on(l.event, l.handler);
            });
        }

        function checkValidationError(err) {

            // check if we can help the user by indicating wrong BPMN 2.0 xml
            // (in case he or the exporting tool did not get that right)

            var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
            var match = pattern.exec(err.message);

            if (match) {
                err.message =
                    'unparsable content <' + match[1] + '> detected; ' +
                    'this may indicate an invalid BPMN 2.0 diagram file' + match[2];
            }

            return err;
        }

        var DEFAULT_OPTIONS = {
            width: '100%',
            height: '100%',
            position: 'relative',
            container: 'body'
        };


        /**
         * Ensure the passed argument is a proper unit (defaulting to px)
         */
        function ensureUnit(val) {
            return val + (isNumber(val) ? 'px' : '');
        }

        /**
         * A viewer for BPMN 2.0 diagrams.
         *
         * Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include
         * additional features.
         *
         *
         * ## Extending the Viewer
         *
         * In order to extend the viewer pass extension modules to bootstrap via the
         * `additionalModules` option. An extension module is an object that exposes
         * named services.
         *
         * The following example depicts the integration of a simple
         * logging component that integrates with interaction events:
         *
         *
         * ```javascript
         *
         * // logging component
         * function InteractionLogger(eventBus) {
 *   eventBus.on('element.hover', function(event) {
 *     console.log()
 *   })
 * }
         *
         * InteractionLogger.$inject = [ 'eventBus' ]; // minification save
         *
         * // extension module
         * var extensionModule = {
 *   __init__: [ 'interactionLogger' ],
 *   interactionLogger: [ 'type', InteractionLogger ]
 * };
         *
         * // extend the viewer
         * var bpmnViewer = new Viewer({ additionalModules: [ extensionModule ] });
         * bpmnViewer.importXML(...);
         * ```
         *
         * @param {Object} [options] configuration options to pass to the viewer
         * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
         * @param {String|Number} [options.width] the width of the viewer
         * @param {String|Number} [options.height] the height of the viewer
         * @param {Object} [options.moddleExtensions] extension packages to provide
         * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
         * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
         */
        function Viewer(options) {

            this.options = options = assign({}, DEFAULT_OPTIONS, options || {});

            var parent = options.container;

            // support jquery element
            // unwrap it if passed
            if (parent.get) {
                parent = parent.get(0);
            }

            // support selector
            if (isString(parent)) {
                parent = domQuery(parent);
            }

            var container = this.container = domify('<div class="bjs-container"></div>');
            parent.appendChild(container);

            assign(container.style, {
                width: ensureUnit(options.width),
                height: ensureUnit(options.height),
                position: options.position
            });

            /**
             * The code in the <project-logo></project-logo> area
             * must not be changed, see http://bpmn.io/license for more information
             *
             * <project-logo>
             */

            /* jshint -W101 */

            // inlined ../resources/bpmnjs.png
            var logoData = 'iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFiMte9PrwldFwfcZPqtqN0+zEyOe1XLgjvuKncsJAZ70y6fXh3vDT////UrQV////G2zN+AAAABB0Uk5T////////////////////AOAjXRkAAAHDSURBVHjavJZJkoUgDEBJmAX8979tM8u3E6x20VlYJfFFMoL4vBDxATxZcakIOJTWSmxvKWVIkJ8jHvlRv1F2LFrVISCZI+tCtQx+XfewgVTfyY3plPiQEAzI3zWy+kR6NBhFBYeBuscJLOUuA2WVLpCjVIaFzrNQZArxAZKUQm6gsj37L9Cb7dnIBUKxENaaMJQqMpDXvSL+ktxdGRm2IsKgJGGPg7atwUG5CcFUEuSv+CwQqizTrvDTNXdMU2bMiDWZd8d7QIySWVRsb2vBBioxOFt4OinPBapL+neAb5KL5IJ8szOza2/DYoipUCx+CjO0Bpsv0V6mktNZ+k8rlABlWG0FrOpKYVo8DT3dBeLEjUBAj7moDogVii7nSS9QzZnFcOVBp1g2PyBQ3Vr5aIapN91VJy33HTJLC1iX2FY6F8gRdaAeIEfVONgtFCzZTmoLEdOjBDfsIOA6128gw3eu1shAajdZNAORxuQDJN5A5PbEG6gNIu24QJD5iNyRMZIr6bsHbCtCU/OaOaSvgkUyDMdDa1BXGf5HJ1To+/Ym6mCKT02Y+/Sa126ZKyd3jxhzpc1r8zVL6YM1Qy/kR4ABAFJ6iQUnivhAAAAAAElFTkSuQmCC';

            /* jshint +W101 */

            var linkMarkup =
                '<a href="http://bpmn.io" ' +
                'target="_blank" ' +
                'class="bjs-powered-by" ' +
                'title="Powered by bpmn.io" ' +
                'style="position: absolute; bottom: 15px; right: 15px; z-index: 100">' +
                '<img src="data:image/png;base64,' + logoData + '">' +
                '</a>';

            container.appendChild(domify(linkMarkup));

            /* </project-logo> */
        }

        Viewer.prototype.importXML = function (xml, done) {

            var self = this;

            this.moddle = this.createModdle();

            this.moddle.fromXML(xml, 'bpmn:Definitions', function (err, definitions, context) {

                if (err) {
                    err = checkValidationError(err);
                    return done(err);
                }

                var parseWarnings = context.warnings;

                self.importDefinitions(definitions, function (err, importWarnings) {
                    if (err) {
                        return done(err);
                    }

                    done(null, parseWarnings.concat(importWarnings || []));
                });
            });
        };

        Viewer.prototype.saveXML = function (options, done) {

            if (!done) {
                done = options;
                options = {};
            }

            var definitions = this.definitions;

            if (!definitions) {
                return done(new Error('no definitions loaded'));
            }

            this.moddle.toXML(definitions, options, done);
        };

        Viewer.prototype.createModdle = function () {
            return new BpmnModdle(this.options.moddleExtensions);
        };

        Viewer.prototype.saveSVG = function (options, done) {

            if (!done) {
                done = options;
                options = {};
            }

            var canvas = this.get('canvas');

            var contentNode = canvas.getDefaultLayer(),
                defsNode = canvas._svg.select('defs');

            var contents = contentNode.innerSVG(),
                defs = (defsNode && defsNode.outerSVG()) || '';

            var bbox = contentNode.getBBox();

            var svg =
                '<?xml version="1.0" encoding="utf-8"?>\n' +
                '<!-- created with bpmn-js / http://bpmn.io -->\n' +
                '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
                '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' +
                'width="' + bbox.width + '" height="' + bbox.height + '" ' +
                'viewBox="' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '" version="1.1">' +
                defs + contents +
                '</svg>';

            done(null, svg);
        };

        Viewer.prototype.get = function (name) {

            if (!this.diagram) {
                throw new Error('no diagram loaded');
            }

            return this.diagram.get(name);
        };

        Viewer.prototype.invoke = function (fn) {

            if (!this.diagram) {
                throw new Error('no diagram loaded');
            }

            return this.diagram.invoke(fn);
        };

        Viewer.prototype.importDefinitions = function (definitions, done) {

            // use try/catch to not swallow synchronous exceptions
            // that may be raised during model parsing
            try {
                if (this.diagram) {
                    this.clear();
                }

                this.definitions = definitions;

                var diagram = this.diagram = this._createDiagram(this.options);

                this._init(diagram);

                Importer.importBpmnDiagram(diagram, definitions, done);
            } catch (e) {
                done(e);
            }
        };

        Viewer.prototype._init = function (diagram) {
            initListeners(diagram, this.__listeners || []);
        };

        Viewer.prototype._createDiagram = function (options) {

            var modules = [].concat(options.modules || this.getModules(), options.additionalModules || []);

            // add self as an available service
            modules.unshift({
                bpmnjs: ['value', this],
                moddle: ['value', this.moddle]
            });

            options = omit(options, 'additionalModules');

            options = assign(options, {
                canvas: {container: this.container},
                modules: modules
            });

            return new Diagram(options);
        };


        Viewer.prototype.getModules = function () {
            return this._modules;
        };

        /**
         * Remove all drawn elements from the viewer.
         *
         * After calling this method the viewer can still
         * be reused for opening another diagram.
         */
        Viewer.prototype.clear = function () {
            var diagram = this.diagram;

            if (diagram) {
                diagram.destroy();
            }
        };

        /**
         * Destroy the viewer instance and remove all its remainders
         * from the document tree.
         */
        Viewer.prototype.destroy = function () {
            // clear underlying diagram
            this.clear();

            // remove container
            domRemove(this.container);
        };

        /**
         * Register an event listener on the viewer
         *
         * @param {String} event
         * @param {Function} handler
         */
        Viewer.prototype.on = function (event, handler) {
            var diagram = this.diagram,
                listeners = this.__listeners = this.__listeners || [];

            listeners.push({event: event, handler: handler});

            if (diagram) {
                diagram.get('eventBus').on(event, handler);
            }
        };

// modules the viewer is composed of
        Viewer.prototype._modules = [
            require('./core'),
            require('diagram-js/lib/features/selection'),
            require('diagram-js/lib/features/overlays')
        ];

        module.exports = Viewer;

    }, {
        "./core": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/core/index.js",
        "./import/Importer": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/Importer.js",
        "bpmn-moddle": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/index.js",
        "diagram-js": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/index.js",
        "diagram-js/lib/features/overlays": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/overlays/index.js",
        "diagram-js/lib/features/selection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/index.js",
        "lodash/lang/isNumber": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isNumber.js",
        "lodash/lang/isString": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isString.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "lodash/object/omit": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/omit.js",
        "min-dom/lib/domify": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/domify.js",
        "min-dom/lib/query": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/query.js",
        "min-dom/lib/remove": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/remove.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/core/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../draw'),
                require('../import')
            ]
        };
    }, {
        "../draw": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/draw/index.js",
        "../import": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/draw/BpmnRenderer.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits'),
            isArray = require('lodash/lang/isArray'),
            isObject = require('lodash/lang/isObject'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            every = require('lodash/collection/every'),
            includes = require('lodash/collection/includes'),
            some = require('lodash/collection/some');

        var DefaultRenderer = require('diagram-js/lib/draw/Renderer'),
            TextUtil = require('diagram-js/lib/util/Text'),
            DiUtil = require('../util/DiUtil');

        var createLine = DefaultRenderer.createLine;


        function BpmnRenderer(events, styles, pathMap) {

            DefaultRenderer.call(this, styles);

            var TASK_BORDER_RADIUS = 10;
            var INNER_OUTER_DIST = 3;

            var LABEL_STYLE = {
                fontFamily: 'Arial, sans-serif',
                fontSize: '12px'
            };

            var textUtil = new TextUtil({
                style: LABEL_STYLE,
                size: {width: 100}
            });

            var markers = {};

            function addMarker(id, element) {
                markers[id] = element;
            }

            function marker(id) {
                return markers[id];
            }

            function initMarkers(svg) {

                function createMarker(id, options) {
                    var attrs = assign({
                        fill: 'black',
                        strokeWidth: 1,
                        strokeLinecap: 'round',
                        strokeDasharray: 'none'
                    }, options.attrs);

                    var ref = options.ref || {x: 0, y: 0};

                    var scale = options.scale || 1;

                    // fix for safari / chrome / firefox bug not correctly
                    // resetting stroke dash array
                    if (attrs.strokeDasharray === 'none') {
                        attrs.strokeDasharray = [10000, 1];
                    }

                    var marker = options.element
                        .attr(attrs)
                        .marker(0, 0, 20, 20, ref.x, ref.y)
                        .attr({
                            markerWidth: 20 * scale,
                            markerHeight: 20 * scale
                        });

                    return addMarker(id, marker);
                }


                createMarker('sequenceflow-end', {
                    element: svg.path('M 1 5 L 11 10 L 1 15 Z'),
                    ref: {x: 11, y: 10},
                    scale: 0.5
                });

                createMarker('messageflow-start', {
                    element: svg.circle(6, 6, 3.5),
                    attrs: {
                        fill: 'white',
                        stroke: 'black'
                    },
                    ref: {x: 6, y: 6}
                });

                createMarker('messageflow-end', {
                    element: svg.path('m 1 5 l 0 -3 l 7 3 l -7 3 z'),
                    attrs: {
                        fill: 'white',
                        stroke: 'black',
                        strokeLinecap: 'butt'
                    },
                    ref: {x: 8.5, y: 5}
                });

                createMarker('data-association-end', {
                    element: svg.path('M 1 5 L 11 10 L 1 15'),
                    attrs: {
                        fill: 'white',
                        stroke: 'black'
                    },
                    ref: {x: 11, y: 10},
                    scale: 0.5
                });

                createMarker('conditional-flow-marker', {
                    element: svg.path('M 0 10 L 8 6 L 16 10 L 8 14 Z'),
                    attrs: {
                        fill: 'white',
                        stroke: 'black'
                    },
                    ref: {x: -1, y: 10},
                    scale: 0.5
                });

                createMarker('conditional-default-flow-marker', {
                    element: svg.path('M 1 4 L 5 16'),
                    attrs: {
                        stroke: 'black'
                    },
                    ref: {x: -5, y: 10},
                    scale: 0.5
                });
            }

            function computeStyle(custom, traits, defaultStyles) {
                if (!isArray(traits)) {
                    defaultStyles = traits;
                    traits = [];
                }

                return styles.style(traits || [], assign(defaultStyles, custom || {}));
            }

            function drawCircle(p, width, height, offset, attrs) {

                if (isObject(offset)) {
                    attrs = offset;
                    offset = 0;
                }

                offset = offset || 0;

                attrs = computeStyle(attrs, {
                    stroke: 'black',
                    strokeWidth: 2,
                    fill: 'white'
                });

                var cx = width / 2,
                    cy = height / 2;

                return p.circle(cx, cy, Math.round((width + height) / 4 - offset)).attr(attrs);
            }

            function drawRect(p, width, height, r, offset, attrs) {

                if (isObject(offset)) {
                    attrs = offset;
                    offset = 0;
                }

                offset = offset || 0;

                attrs = computeStyle(attrs, {
                    stroke: 'black',
                    strokeWidth: 2,
                    fill: 'white'
                });

                return p.rect(offset, offset, width - offset * 2, height - offset * 2, r).attr(attrs);
            }

            function drawDiamond(p, width, height, attrs) {

                var x_2 = width / 2;
                var y_2 = height / 2;

                var points = [x_2, 0, width, y_2, x_2, height, 0, y_2];

                attrs = computeStyle(attrs, {
                    stroke: 'black',
                    strokeWidth: 2,
                    fill: 'white'
                });

                return p.polygon(points).attr(attrs);
            }

            function drawLine(p, waypoints, attrs) {
                attrs = computeStyle(attrs, ['no-fill'], {
                    stroke: 'black',
                    strokeWidth: 2,
                    fill: 'none'
                });

                return createLine(waypoints, attrs).appendTo(p);
            }

            function drawPath(p, d, attrs) {

                attrs = computeStyle(attrs, ['no-fill'], {
                    strokeWidth: 2,
                    stroke: 'black'
                });

                return p.path(d).attr(attrs);
            }

            function as(type) {
                return function (p, element) {
                    return handlers[type](p, element);
                };
            }

            function renderer(type) {
                return handlers[type];
            }

            function renderEventContent(element, p) {

                var event = getSemantic(element);
                var isThrowing = isThrowEvent(event);

                if (isTypedEvent(event, 'bpmn:MessageEventDefinition')) {
                    return renderer('bpmn:MessageEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:TimerEventDefinition')) {
                    return renderer('bpmn:TimerEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:ConditionalEventDefinition')) {
                    return renderer('bpmn:ConditionalEventDefinition')(p, element);
                }

                if (isTypedEvent(event, 'bpmn:SignalEventDefinition')) {
                    return renderer('bpmn:SignalEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&
                    isTypedEvent(event, 'bpmn:TerminateEventDefinition', {parallelMultiple: false})) {
                    return renderer('bpmn:MultipleEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&
                    isTypedEvent(event, 'bpmn:TerminateEventDefinition', {parallelMultiple: true})) {
                    return renderer('bpmn:ParallelMultipleEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:EscalationEventDefinition')) {
                    return renderer('bpmn:EscalationEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:LinkEventDefinition')) {
                    return renderer('bpmn:LinkEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:ErrorEventDefinition')) {
                    return renderer('bpmn:ErrorEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:CancelEventDefinition')) {
                    return renderer('bpmn:CancelEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:CompensateEventDefinition')) {
                    return renderer('bpmn:CompensateEventDefinition')(p, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:TerminateEventDefinition')) {
                    return renderer('bpmn:TerminateEventDefinition')(p, element, isThrowing);
                }

                return null;
            }

            function renderLabel(p, label, options) {
                return textUtil.createText(p, label || '', options).addClass('djs-label');
            }

            function renderEmbeddedLabel(p, element, align) {
                var semantic = getSemantic(element);
                return renderLabel(p, semantic.name, {box: element, align: align, padding: 5});
            }

            function renderExternalLabel(p, element, align) {
                var semantic = getSemantic(element);

                if (!semantic.name) {
                    element.hidden = true;
                }

                return renderLabel(p, semantic.name, {box: element, align: align, style: {fontSize: '11px'}});
            }

            function renderLaneLabel(p, text, element) {
                var textBox = renderLabel(p, text, {
                    box: {height: 30, width: element.height},
                    align: 'center-middle'
                });

                var top = -1 * element.height;
                textBox.transform(
                    'rotate(270) ' +
                    'translate(' + top + ',' + 0 + ')'
                );
            }

            function createPathFromConnection(connection) {
                var waypoints = connection.waypoints;

                var pathData = 'm  ' + waypoints[0].x + ',' + waypoints[0].y;
                for (var i = 1; i < waypoints.length; i++) {
                    pathData += 'L' + waypoints[i].x + ',' + waypoints[i].y + ' ';
                }
                return pathData;
            }

            var handlers = {
                'bpmn:Event': function (p, element, attrs) {
                    return drawCircle(p, element.width, element.height, attrs);
                },
                'bpmn:StartEvent': function (p, element) {
                    var attrs = {};
                    var semantic = getSemantic(element);

                    if (!semantic.isInterrupting) {
                        attrs = {
                            strokeDasharray: '6',
                            strokeLinecap: 'round'
                        };
                    }

                    var circle = renderer('bpmn:Event')(p, element, attrs);

                    renderEventContent(element, p);

                    return circle;
                },
                'bpmn:MessageEventDefinition': function (p, element, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {
                        xScaleFactor: 0.9,
                        yScaleFactor: 0.9,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.235,
                            my: 0.315
                        }
                    });

                    var fill = isThrowing ? 'black' : 'white';
                    var stroke = isThrowing ? 'white' : 'black';

                    var messagePath = drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: fill,
                        stroke: stroke
                    });

                    return messagePath;
                },
                'bpmn:TimerEventDefinition': function (p, element) {

                    var circle = drawCircle(p, element.width, element.height, 0.2 * element.height, {
                        strokeWidth: 2
                    });

                    var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {
                        xScaleFactor: 0.75,
                        yScaleFactor: 0.75,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.5,
                            my: 0.5
                        }
                    });

                    drawPath(p, pathData, {
                        strokeWidth: 2,
                        strokeLinecap: 'square'
                    });

                    for (var i = 0; i < 12; i++) {

                        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {
                            xScaleFactor: 0.75,
                            yScaleFactor: 0.75,
                            containerWidth: element.width,
                            containerHeight: element.height,
                            position: {
                                mx: 0.5,
                                my: 0.5
                            }
                        });

                        var width = element.width / 2;
                        var height = element.height / 2;

                        drawPath(p, linePathData, {
                            strokeWidth: 1,
                            strokeLinecap: 'square',
                            transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')'
                        });
                    }

                    return circle;
                },
                'bpmn:EscalationEventDefinition': function (p, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.5,
                            my: 0.555
                        }
                    });

                    var fill = isThrowing ? 'black' : 'none';

                    return drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: fill
                    });
                },
                'bpmn:ConditionalEventDefinition': function (p, event) {
                    var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.5,
                            my: 0.222
                        }
                    });

                    return drawPath(p, pathData, {
                        strokeWidth: 1
                    });
                },
                'bpmn:LinkEventDefinition': function (p, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_LINK', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.57,
                            my: 0.263
                        }
                    });

                    var fill = isThrowing ? 'black' : 'none';

                    return drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: fill
                    });
                },
                'bpmn:ErrorEventDefinition': function (p, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_ERROR', {
                        xScaleFactor: 1.1,
                        yScaleFactor: 1.1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.2,
                            my: 0.722
                        }
                    });

                    var fill = isThrowing ? 'black' : 'none';

                    return drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: fill
                    });
                },
                'bpmn:CancelEventDefinition': function (p, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {
                        xScaleFactor: 1.0,
                        yScaleFactor: 1.0,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.638,
                            my: -0.055
                        }
                    });

                    var fill = isThrowing ? 'black' : 'none';

                    return drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: fill
                    }).transform('rotate(45)');
                },
                'bpmn:CompensateEventDefinition': function (p, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.201,
                            my: 0.472
                        }
                    });

                    var fill = isThrowing ? 'black' : 'none';

                    return drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: fill
                    });
                },
                'bpmn:SignalEventDefinition': function (p, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {
                        xScaleFactor: 0.9,
                        yScaleFactor: 0.9,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.5,
                            my: 0.2
                        }
                    });

                    var fill = isThrowing ? 'black' : 'none';

                    return drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: fill
                    });
                },
                'bpmn:MultipleEventDefinition': function (p, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {
                        xScaleFactor: 1.1,
                        yScaleFactor: 1.1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.222,
                            my: 0.36
                        }
                    });

                    var fill = isThrowing ? 'black' : 'none';

                    return drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: fill
                    });
                },
                'bpmn:ParallelMultipleEventDefinition': function (p, event) {
                    var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {
                        xScaleFactor: 1.2,
                        yScaleFactor: 1.2,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.458,
                            my: 0.194
                        }
                    });

                    return drawPath(p, pathData, {
                        strokeWidth: 1
                    });
                },
                'bpmn:EndEvent': function (p, element) {
                    var circle = renderer('bpmn:Event')(p, element, {
                        strokeWidth: 4
                    });

                    renderEventContent(element, p, true);

                    return circle;
                },
                'bpmn:TerminateEventDefinition': function (p, element) {
                    var circle = drawCircle(p, element.width, element.height, 8, {
                        strokeWidth: 4,
                        fill: 'black'
                    });

                    return circle;
                },
                'bpmn:IntermediateEvent': function (p, element) {
                    var outer = renderer('bpmn:Event')(p, element, {strokeWidth: 1});
                    /* inner */
                    drawCircle(p, element.width, element.height, INNER_OUTER_DIST, {strokeWidth: 1, fill: 'none'});

                    renderEventContent(element, p);

                    return outer;
                },
                'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),
                'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),

                'bpmn:Activity': function (p, element, attrs) {
                    return drawRect(p, element.width, element.height, TASK_BORDER_RADIUS, attrs);
                },

                'bpmn:Task': function (p, element, attrs) {
                    var rect = renderer('bpmn:Activity')(p, element, attrs);
                    renderEmbeddedLabel(p, element, 'center-middle');
                    attachTaskMarkers(p, element);
                    return rect;
                },
                'bpmn:ServiceTask': function (p, element) {
                    var task = renderer('bpmn:Task')(p, element);

                    var pathDataBG = pathMap.getScaledPath('TASK_TYPE_SERVICE', {
                        abspos: {
                            x: 12,
                            y: 18
                        }
                    });

                    /* service bg */
                    drawPath(p, pathDataBG, {
                        strokeWidth: 1,
                        fill: 'none'
                    });

                    var fillPathData = pathMap.getScaledPath('TASK_TYPE_SERVICE_FILL', {
                        abspos: {
                            x: 17.2,
                            y: 18
                        }
                    });

                    /* service fill */
                    drawPath(p, fillPathData, {
                        strokeWidth: 0,
                        stroke: 'none',
                        fill: 'white'
                    });

                    var pathData = pathMap.getScaledPath('TASK_TYPE_SERVICE', {
                        abspos: {
                            x: 17,
                            y: 22
                        }
                    });

                    /* service */
                    drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: 'white'
                    });

                    return task;
                },
                'bpmn:UserTask': function (p, element) {
                    var task = renderer('bpmn:Task')(p, element);

                    var x = 15;
                    var y = 12;

                    var pathData = pathMap.getScaledPath('TASK_TYPE_USER_1', {
                        abspos: {
                            x: x,
                            y: y
                        }
                    });

                    /* user path */
                    drawPath(p, pathData, {
                        strokeWidth: 0.5,
                        fill: 'none'
                    });

                    var pathData2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {
                        abspos: {
                            x: x,
                            y: y
                        }
                    });

                    /* user2 path */
                    drawPath(p, pathData2, {
                        strokeWidth: 0.5,
                        fill: 'none'
                    });

                    var pathData3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {
                        abspos: {
                            x: x,
                            y: y
                        }
                    });

                    /* user3 path */
                    drawPath(p, pathData3, {
                        strokeWidth: 0.5,
                        fill: 'black'
                    });

                    return task;
                },
                'bpmn:ManualTask': function (p, element) {
                    var task = renderer('bpmn:Task')(p, element);

                    var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {
                        abspos: {
                            x: 17,
                            y: 15
                        }
                    });

                    /* manual path */
                    drawPath(p, pathData, {
                        strokeWidth: 0.25,
                        fill: 'white',
                        stroke: 'black'
                    });

                    return task;
                },
                'bpmn:SendTask': function (p, element) {
                    var task = renderer('bpmn:Task')(p, element);

                    var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: 21,
                        containerHeight: 14,
                        position: {
                            mx: 0.285,
                            my: 0.357
                        }
                    });

                    /* send path */
                    drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: 'black',
                        stroke: 'white'
                    });

                    return task;
                },
                'bpmn:ReceiveTask': function (p, element) {
                    var semantic = getSemantic(element);

                    var task = renderer('bpmn:Task')(p, element);
                    var pathData;

                    if (semantic.instantiate) {
                        drawCircle(p, 28, 28, 20 * 0.22, {strokeWidth: 1});

                        pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {
                            abspos: {
                                x: 7.77,
                                y: 9.52
                            }
                        });
                    } else {

                        pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {
                            xScaleFactor: 0.9,
                            yScaleFactor: 0.9,
                            containerWidth: 21,
                            containerHeight: 14,
                            position: {
                                mx: 0.3,
                                my: 0.4
                            }
                        });
                    }

                    /* receive path */
                    drawPath(p, pathData, {
                        strokeWidth: 1
                    });

                    return task;
                },
                'bpmn:ScriptTask': function (p, element) {
                    var task = renderer('bpmn:Task')(p, element);

                    var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {
                        abspos: {
                            x: 15,
                            y: 20
                        }
                    });

                    /* script path */
                    drawPath(p, pathData, {
                        strokeWidth: 1
                    });

                    return task;
                },
                'bpmn:BusinessRuleTask': function (p, element) {
                    var task = renderer('bpmn:Task')(p, element);

                    var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {
                        abspos: {
                            x: 8,
                            y: 8
                        }
                    });

                    var businessHeaderPath = drawPath(p, headerPathData);
                    businessHeaderPath.attr({
                        strokeWidth: 1,
                        fill: 'AAA'
                    });

                    var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {
                        abspos: {
                            x: 8,
                            y: 8
                        }
                    });

                    var businessPath = drawPath(p, headerData);
                    businessPath.attr({
                        strokeWidth: 1
                    });

                    return task;
                },
                'bpmn:SubProcess': function (p, element, attrs) {
                    var rect = renderer('bpmn:Activity')(p, element, attrs);

                    var semantic = getSemantic(element);

                    var expanded = DiUtil.isExpanded(semantic);

                    var isEventSubProcess = !!semantic.triggeredByEvent;
                    if (isEventSubProcess) {
                        rect.attr({
                            strokeDasharray: '1,2'
                        });
                    }

                    renderEmbeddedLabel(p, element, expanded ? 'center-top' : 'center-middle');

                    if (expanded) {
                        attachTaskMarkers(p, element);
                    } else {
                        attachTaskMarkers(p, element, ['SubProcessMarker']);
                    }

                    return rect;
                },
                'bpmn:AdHocSubProcess': function (p, element) {
                    return renderer('bpmn:SubProcess')(p, element);
                },
                'bpmn:Transaction': function (p, element) {
                    var outer = renderer('bpmn:SubProcess')(p, element);

                    var innerAttrs = styles.style(['no-fill', 'no-events']);

                    /* inner path */
                    drawRect(p, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);

                    return outer;
                },
                'bpmn:CallActivity': function (p, element) {
                    return renderer('bpmn:Task')(p, element, {
                        strokeWidth: 5
                    });
                },
                'bpmn:Participant': function (p, element) {

                    var lane = renderer('bpmn:Lane')(p, element, {
                        fill: 'White'
                    });

                    var expandedPool = DiUtil.isExpanded(element);

                    if (expandedPool) {
                        drawLine(p, [
                            {x: 30, y: 0},
                            {x: 30, y: element.height}
                        ]);
                        var text = getSemantic(element).name;
                        renderLaneLabel(p, text, element);
                    } else {
                        // Collapsed pool draw text inline
                        var text2 = getSemantic(element).name;
                        renderLabel(p, text2, {box: element, align: 'center-middle'});
                    }

                    var participantMultiplicity = !!(getSemantic(element).participantMultiplicity);

                    if (participantMultiplicity) {
                        renderer('ParticipantMultiplicityMarker')(p, element);
                    }

                    return lane;
                },
                'bpmn:Lane': function (p, element, attrs) {
                    var rect = drawRect(p, element.width, element.height, 0, attrs || {
                        fill: 'none'
                    });

                    var semantic = getSemantic(element);

                    if (semantic.$type === 'bpmn:Lane') {
                        var text = semantic.name;
                        renderLaneLabel(p, text, element);
                    }

                    return rect;
                },
                'bpmn:InclusiveGateway': function (p, element) {
                    var diamond = drawDiamond(p, element.width, element.height);

                    /* circle path */
                    drawCircle(p, element.width, element.height, element.height * 0.24, {
                        strokeWidth: 2.5,
                        fill: 'none'
                    });

                    return diamond;
                },
                'bpmn:ExclusiveGateway': function (p, element) {
                    var diamond = drawDiamond(p, element.width, element.height);

                    var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {
                        xScaleFactor: 0.4,
                        yScaleFactor: 0.4,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.32,
                            my: 0.3
                        }
                    });

                    if (!!(getDi(element).isMarkerVisible)) {
                        drawPath(p, pathData, {
                            strokeWidth: 1,
                            fill: 'black'
                        });
                    }

                    return diamond;
                },
                'bpmn:ComplexGateway': function (p, element) {
                    var diamond = drawDiamond(p, element.width, element.height);

                    var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {
                        xScaleFactor: 0.5,
                        yScaleFactor: 0.5,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.46,
                            my: 0.26
                        }
                    });

                    /* complex path */
                    drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: 'black'
                    });

                    return diamond;
                },
                'bpmn:ParallelGateway': function (p, element) {
                    var diamond = drawDiamond(p, element.width, element.height);

                    var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {
                        xScaleFactor: 0.6,
                        yScaleFactor: 0.6,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.46,
                            my: 0.2
                        }
                    });

                    /* parallel path */
                    drawPath(p, pathData, {
                        strokeWidth: 1,
                        fill: 'black'
                    });

                    return diamond;
                },
                'bpmn:EventBasedGateway': function (p, element) {

                    var semantic = getSemantic(element);

                    var diamond = drawDiamond(p, element.width, element.height);

                    /* outer circle path */
                    drawCircle(p, element.width, element.height, element.height * 0.20, {
                        strokeWidth: 1,
                        fill: 'none'
                    });

                    var type = semantic.eventGatewayType;
                    var instantiate = !!semantic.instantiate;

                    function drawEvent() {

                        var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {
                            xScaleFactor: 0.18,
                            yScaleFactor: 0.18,
                            containerWidth: element.width,
                            containerHeight: element.height,
                            position: {
                                mx: 0.36,
                                my: 0.44
                            }
                        });

                        /* event path */
                        drawPath(p, pathData, {
                            strokeWidth: 2,
                            fill: 'none'
                        });
                    }

                    if (type === 'Parallel') {

                        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {
                            xScaleFactor: 0.4,
                            yScaleFactor: 0.4,
                            containerWidth: element.width,
                            containerHeight: element.height,
                            position: {
                                mx: 0.474,
                                my: 0.296
                            }
                        });

                        var parallelPath = drawPath(p, pathData);
                        parallelPath.attr({
                            strokeWidth: 1,
                            fill: 'none'
                        });
                    } else if (type === 'Exclusive') {

                        if (!instantiate) {
                            var innerCircle = drawCircle(p, element.width, element.height, element.height * 0.26);
                            innerCircle.attr({
                                strokeWidth: 1,
                                fill: 'none'
                            });
                        }

                        drawEvent();
                    }


                    return diamond;
                },
                'bpmn:Gateway': function (p, element) {
                    return drawDiamond(p, element.width, element.height);
                },
                'bpmn:SequenceFlow': function (p, element) {
                    var pathData = createPathFromConnection(element);
                    var path = drawPath(p, pathData, {
                        strokeLinejoin: 'round',
                        markerEnd: marker('sequenceflow-end')
                    });

                    var sequenceFlow = getSemantic(element);
                    var source = element.source.businessObject;

                    // conditional flow marker
                    if (sequenceFlow.conditionExpression && source.$instanceOf('bpmn:Task')) {
                        path.attr({
                            markerStart: marker('conditional-flow-marker')
                        });
                    }

                    // default marker
                    if (source.default && source.$instanceOf('bpmn:Gateway') && source.default === sequenceFlow) {
                        path.attr({
                            markerStart: marker('conditional-default-flow-marker')
                        });
                    }

                    return path;
                },
                'bpmn:Association': function (p, element, attrs) {

                    attrs = assign({
                        strokeDasharray: '1,6',
                        strokeLinecap: 'round',
                        strokeLinejoin: 'round'
                    }, attrs || {});

                    // TODO(nre): style according to directed state
                    return drawLine(p, element.waypoints, attrs);
                },
                'bpmn:DataInputAssociation': function (p, element) {
                    return renderer('bpmn:Association')(p, element, {
                        markerEnd: marker('data-association-end')
                    });
                },
                'bpmn:DataOutputAssociation': function (p, element) {
                    return renderer('bpmn:Association')(p, element, {
                        markerEnd: marker('data-association-end')
                    });
                },
                'bpmn:MessageFlow': function (p, element) {

                    var semantic = getSemantic(element),
                        di = getDi(element);

                    var pathData = createPathFromConnection(element);
                    var path = drawPath(p, pathData, {
                        markerEnd: marker('messageflow-end'),
                        markerStart: marker('messageflow-start'),
                        strokeDasharray: '10, 12',
                        strokeLinecap: 'round',
                        strokeLinejoin: 'round',
                        strokeWidth: '1.5px'
                    });

                    if (semantic.messageRef) {
                        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);

                        var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {
                            abspos: {
                                x: midPoint.x,
                                y: midPoint.y
                            }
                        });

                        var messageAttrs = {strokeWidth: 1};

                        if (di.messageVisibleKind === 'initiating') {
                            messageAttrs.fill = 'white';
                            messageAttrs.stroke = 'black';
                        } else {
                            messageAttrs.fill = '#888';
                            messageAttrs.stroke = 'white';
                        }

                        drawPath(p, markerPathData, messageAttrs);
                    }

                    return path;
                },
                'bpmn:DataObject': function (p, element) {
                    var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.474,
                            my: 0.296
                        }
                    });

                    var elementObject = drawPath(p, pathData, {fill: 'white'});

                    var semantic = getSemantic(element);

                    if (isCollection(semantic)) {
                        renderDataItemCollection(p, element);
                    }

                    return elementObject;
                },
                'bpmn:DataObjectReference': as('bpmn:DataObject'),
                'bpmn:DataInput': function (p, element) {

                    var arrowPathData = pathMap.getRawPath('DATA_ARROW');

                    // page
                    var elementObject = renderer('bpmn:DataObject')(p, element);

                    /* input arrow path */
                    drawPath(p, arrowPathData, {strokeWidth: 1});

                    return elementObject;
                },
                'bpmn:DataOutput': function (p, element) {
                    var arrowPathData = pathMap.getRawPath('DATA_ARROW');

                    // page
                    var elementObject = renderer('bpmn:DataObject')(p, element);

                    /* output arrow path */
                    drawPath(p, arrowPathData, {
                        strokeWidth: 1,
                        fill: 'black'
                    });

                    return elementObject;
                },
                'bpmn:DataStoreReference': function (p, element) {
                    var DATA_STORE_PATH = pathMap.getScaledPath('DATA_STORE', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0,
                            my: 0.133
                        }
                    });

                    var elementStore = drawPath(p, DATA_STORE_PATH, {
                        strokeWidth: 2,
                        fill: 'white'
                    });

                    return elementStore;
                },
                'bpmn:BoundaryEvent': function (p, element) {

                    var semantic = getSemantic(element),
                        cancel = semantic.cancelActivity;

                    var attrs = {
                        strokeLinecap: 'round',
                        strokeWidth: 1
                    };

                    if (!cancel) {
                        attrs.strokeDasharray = '6';
                    }

                    var outer = renderer('bpmn:Event')(p, element, attrs);
                    /* inner path */
                    drawCircle(p, element.width, element.height, INNER_OUTER_DIST, attrs);

                    renderEventContent(element, p);

                    return outer;
                },
                'bpmn:Group': function (p, element) {
                    return drawRect(p, element.width, element.height, TASK_BORDER_RADIUS, {
                        strokeWidth: 1,
                        strokeDasharray: '8,3,1,3',
                        fill: 'none',
                        pointerEvents: 'none'
                    });
                },
                'label': function (p, element) {
                    return renderExternalLabel(p, element, '');
                },
                'bpmn:TextAnnotation': function (p, element) {
                    var style = {
                        'fill': 'none',
                        'stroke': 'none'
                    };
                    var textElement = drawRect(p, element.width, element.height, 0, 0, style);
                    var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.0,
                            my: 0.0
                        }
                    });
                    drawPath(p, textPathData);

                    var text = getSemantic(element).text || '';
                    renderLabel(p, text, {box: element, align: 'left-middle', padding: 5});

                    return textElement;
                },
                'ParticipantMultiplicityMarker': function (p, element) {
                    var subProcessPath = pathMap.getScaledPath('MARKER_PARALLEL', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2) / element.width),
                            my: (element.height - 15) / element.height
                        }
                    });

                    drawPath(p, subProcessPath);
                },
                'SubProcessMarker': function (p, element) {
                    var markerRect = drawRect(p, 14, 14, 0, {
                        strokeWidth: 1
                    });

                    // Process marker is placed in the middle of the box
                    // therefore fixed values can be used here
                    markerRect.transform('translate(' + (element.width / 2 - 7.5) + ',' + (element.height - 20) + ')');

                    var subProcessPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {
                        xScaleFactor: 1.5,
                        yScaleFactor: 1.5,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: (element.width / 2 - 7.5) / element.width,
                            my: (element.height - 20) / element.height
                        }
                    });

                    drawPath(p, subProcessPath);
                },
                'ParallelMarker': function (p, element, position) {
                    var subProcessPath = pathMap.getScaledPath('MARKER_PARALLEL', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.parallel) / element.width),
                            my: (element.height - 20) / element.height
                        }
                    });
                    drawPath(p, subProcessPath);
                },
                'SequentialMarker': function (p, element, position) {
                    var sequentialPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.seq) / element.width),
                            my: (element.height - 19) / element.height
                        }
                    });
                    drawPath(p, sequentialPath);
                },
                'CompensationMarker': function (p, element, position) {
                    var compensationPath = pathMap.getScaledPath('MARKER_COMPENSATION', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.compensation) / element.width),
                            my: (element.height - 13) / element.height
                        }
                    });
                    drawPath(p, compensationPath, {strokeWidth: 1});
                },
                'LoopMarker': function (p, element, position) {
                    var loopPath = pathMap.getScaledPath('MARKER_LOOP', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.loop) / element.width),
                            my: (element.height - 7) / element.height
                        }
                    });

                    drawPath(p, loopPath, {
                        strokeWidth: 1,
                        fill: 'none',
                        strokeLinecap: 'round',
                        strokeMiterlimit: 0.5
                    });
                },
                'AdhocMarker': function (p, element, position) {
                    var loopPath = pathMap.getScaledPath('MARKER_ADHOC', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.adhoc) / element.width),
                            my: (element.height - 15) / element.height
                        }
                    });

                    drawPath(p, loopPath, {
                        strokeWidth: 1,
                        fill: 'black'
                    });
                }
            };

            function attachTaskMarkers(p, element, taskMarkers) {
                var obj = getSemantic(element);

                var subprocess = includes(taskMarkers, 'SubProcessMarker');
                var position;

                if (subprocess) {
                    position = {
                        seq: -21,
                        parallel: -22,
                        compensation: -42,
                        loop: -18,
                        adhoc: 10
                    };
                } else {
                    position = {
                        seq: -3,
                        parallel: -6,
                        compensation: -27,
                        loop: 0,
                        adhoc: 10
                    };
                }

                forEach(taskMarkers, function (marker) {
                    renderer(marker)(p, element, position);
                });

                if (obj.$type === 'bpmn:AdHocSubProcess') {
                    renderer('AdhocMarker')(p, element, position);
                }
                if (obj.loopCharacteristics && obj.loopCharacteristics.isSequential === undefined) {
                    renderer('LoopMarker')(p, element, position);
                    return;
                }
                if (obj.loopCharacteristics &&
                    obj.loopCharacteristics.isSequential !== undefined && !obj.loopCharacteristics.isSequential) {
                    renderer('ParallelMarker')(p, element, position);
                }
                if (obj.loopCharacteristics && !!obj.loopCharacteristics.isSequential) {
                    renderer('SequentialMarker')(p, element, position);
                }
                if (!!obj.isForCompensation) {
                    renderer('CompensationMarker')(p, element, position);
                }
            }

            function drawShape(parent, element) {
                var type = element.type;
                var h = handlers[type];

                /* jshint -W040 */
                if (!h) {
                    return DefaultRenderer.prototype.drawShape.apply(this, [parent, element]);
                } else {
                    return h(parent, element);
                }
            }

            function drawConnection(parent, element) {
                var type = element.type;
                var h = handlers[type];

                /* jshint -W040 */
                if (!h) {
                    return DefaultRenderer.prototype.drawConnection.apply(this, [parent, element]);
                } else {
                    return h(parent, element);
                }
            }

            function renderDataItemCollection(p, element) {

                var yPosition = (element.height - 16) / element.height;

                var pathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {
                    xScaleFactor: 1,
                    yScaleFactor: 1,
                    containerWidth: element.width,
                    containerHeight: element.height,
                    position: {
                        mx: 0.451,
                        my: yPosition
                    }
                });

                /* collection path */
                drawPath(p, pathData, {
                    strokeWidth: 2
                });
            }

            function isCollection(element, filter) {
                return element.isCollection ||
                    (element.elementObjectRef && element.elementObjectRef.isCollection);
            }

            function getDi(element) {
                return element.businessObject.di;
            }

            function getSemantic(element) {
                return element.businessObject;
            }

            /**
             * Checks if eventDefinition of the given element matches with semantic type.
             *
             * @return {boolean} true if element is of the given semantic type
             */
            function isTypedEvent(event, eventDefinitionType, filter) {

                function matches(definition, filter) {
                    return every(filter, function (val, key) {

                        // we want a == conversion here, to be able to catch
                        // undefined == false and friends
                        /* jshint -W116 */
                        return definition[key] == val;
                    });
                }

                return some(event.eventDefinitions, function (definition) {
                    return definition.$type === eventDefinitionType && matches(event, filter);
                });
            }

            function isThrowEvent(event) {
                return (event.$type === 'bpmn:IntermediateThrowEvent') || (event.$type === 'bpmn:EndEvent');
            }


            /////// cropping path customizations /////////////////////////

            function componentsToPath(elements) {
                return elements.join(',').replace(/,?([A-z]),?/g, '$1');
            }

            function getCirclePath(shape) {

                var cx = shape.x + shape.width / 2,
                    cy = shape.y + shape.height / 2,
                    radius = shape.width / 2;

                var circlePath = [
                    ['M', cx, cy],
                    ['m', 0, -radius],
                    ['a', radius, radius, 0, 1, 1, 0, 2 * radius],
                    ['a', radius, radius, 0, 1, 1, 0, -2 * radius],
                    ['z']
                ];

                return componentsToPath(circlePath);
            }

            function getRoundRectPath(shape) {

                var radius = TASK_BORDER_RADIUS,
                    x = shape.x,
                    y = shape.y,
                    width = shape.width,
                    height = shape.height;

                var roundRectPath = [
                    ['M', x + radius, y],
                    ['l', width - radius * 2, 0],
                    ['a', radius, radius, 0, 0, 1, radius, radius],
                    ['l', 0, height - radius * 2],
                    ['a', radius, radius, 0, 0, 1, -radius, radius],
                    ['l', radius * 2 - width, 0],
                    ['a', radius, radius, 0, 0, 1, -radius, -radius],
                    ['l', 0, radius * 2 - height],
                    ['a', radius, radius, 0, 0, 1, radius, -radius],
                    ['z']
                ];

                return componentsToPath(roundRectPath);
            }

            function getDiamondPath(shape) {

                var width = shape.width,
                    height = shape.height,
                    x = shape.x,
                    y = shape.y,
                    halfWidth = width / 2,
                    halfHeight = height / 2;

                var diamondPath = [
                    ['M', x + halfWidth, y],
                    ['l', halfWidth, halfHeight],
                    ['l', -halfWidth, halfHeight],
                    ['l', -halfWidth, -halfHeight],
                    ['z']
                ];

                return componentsToPath(diamondPath);
            }

            function getRectPath(shape) {
                var x = shape.x,
                    y = shape.y,
                    width = shape.width,
                    height = shape.height;

                var rectPath = [
                    ['M', x, y],
                    ['l', width, 0],
                    ['l', 0, height],
                    ['l', -width, 0],
                    ['z']
                ];

                return componentsToPath(rectPath);
            }

            function getShapePath(element) {
                var obj = getSemantic(element);

                if (obj.$instanceOf('bpmn:Event')) {
                    return getCirclePath(element);
                }

                if (obj.$instanceOf('bpmn:Activity')) {
                    return getRoundRectPath(element);
                }

                if (obj.$instanceOf('bpmn:Gateway')) {
                    return getDiamondPath(element);
                }

                return getRectPath(element);
            }


            // hook onto canvas init event to initialize
            // connection start/end markers on svg
            events.on('canvas.init', function (event) {
                initMarkers(event.svg);
            });

            this.drawShape = drawShape;
            this.drawConnection = drawConnection;

            this.getShapePath = getShapePath;
        }

        inherits(BpmnRenderer, DefaultRenderer);


        BpmnRenderer.$inject = ['eventBus', 'styles', 'pathMap'];

        module.exports = BpmnRenderer;

    }, {
        "../util/DiUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/DiUtil.js",
        "diagram-js/lib/draw/Renderer": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/draw/Renderer.js",
        "diagram-js/lib/util/Text": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Text.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js",
        "lodash/collection/every": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/every.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/collection/includes": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/includes.js",
        "lodash/collection/some": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/some.js",
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "lodash/lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/draw/PathMap.js": [function (require, module, exports) {
        'use strict';

        var Snap = require('diagram-js/vendor/snapsvg');

        /**
         * Map containing SVG paths needed by BpmnRenderer.
         */

        function PathMap() {

            /**
             * Contains a map of path elements
             *
             * <h1>Path definition</h1>
             * A parameterized path is defined like this:
             * <pre>
             * 'GATEWAY_PARALLEL': {
   *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
   *   height: 17.5,
   *   width:  17.5,
   *   heightElements: [2.5, 7.5],
   *   widthElements: [2.5, 7.5]
   * }
             * </pre>
             * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling
             * is based on the ratio between the specified height and width in this object and the
             * height and width that is set as scale target (Note x,y coordinates will be scaled with
             * individual ratios).</p>
             * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.
             * The scaling is based on the computed ratios.
             * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using
             * the computed ratio coefficient.
             * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.
             *   <ul>
             *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>
             *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>
             *   </ul>
             *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.
             * </p>
             */
            this.pathMap = {
                'EVENT_MESSAGE': {
                    d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
                    height: 36,
                    width: 36,
                    heightElements: [6, 14],
                    widthElements: [10.5, 21]
                },
                'EVENT_SIGNAL': {
                    d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',
                    height: 36,
                    width: 36,
                    heightElements: [18],
                    widthElements: [10, 20]
                },
                'EVENT_ESCALATION': {
                    d: 'm {mx},{my} c -{e.x1},{e.y0} -{e.x3},{e.y1} -{e.x5},{e.y4} {e.x1},-{e.y3} {e.x3},-{e.y5} {e.x5},-{e.y6} ' +
                    '{e.x0},{e.y3} {e.x2},{e.y5} {e.x4},{e.y6} -{e.x0},-{e.y0} -{e.x2},-{e.y1} -{e.x4},-{e.y4} z',
                    height: 36,
                    width: 36,
                    heightElements: [2.382, 4.764, 4.926, 6.589333, 7.146, 13.178667, 19.768],
                    widthElements: [2.463, 2.808, 4.926, 5.616, 7.389, 8.424]
                },
                'EVENT_CONDITIONAL': {
                    d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +
                    'M {e.x2},{e.y3} l {e.x0},0 ' +
                    'M {e.x2},{e.y4} l {e.x0},0 ' +
                    'M {e.x2},{e.y5} l {e.x0},0 ' +
                    'M {e.x2},{e.y6} l {e.x0},0 ' +
                    'M {e.x2},{e.y7} l {e.x0},0 ' +
                    'M {e.x2},{e.y8} l {e.x0},0 ',
                    height: 36,
                    width: 36,
                    heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
                    widthElements: [10.5, 14.5, 12.5]
                },
                'EVENT_LINK': {
                    d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',
                    height: 36,
                    width: 36,
                    heightElements: [4.4375, 6.75, 7.8125],
                    widthElements: [9.84375, 13.5]
                },
                'EVENT_ERROR': {
                    d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',
                    height: 36,
                    width: 36,
                    heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
                    widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
                },
                'EVENT_CANCEL_45': {
                    d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
                    '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
                    height: 36,
                    width: 36,
                    heightElements: [4.75, 8.5],
                    widthElements: [4.75, 8.5]
                },
                'EVENT_COMPENSATION': {
                    d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x0},0 {e.x0},-{e.y0} 0,{e.y1} z',
                    height: 36,
                    width: 36,
                    heightElements: [5, 10],
                    widthElements: [10]
                },
                'EVENT_TIMER_WH': {
                    d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',
                    height: 36,
                    width: 36,
                    heightElements: [10, 2],
                    widthElements: [3, 7]
                },
                'EVENT_TIMER_LINE': {
                    d: 'M {mx},{my} ' +
                    'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',
                    height: 36,
                    width: 36,
                    heightElements: [10, 3],
                    widthElements: [0, 0]
                },
                'EVENT_MULTIPLE': {
                    d: 'm {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',
                    height: 36,
                    width: 36,
                    heightElements: [6.28099, 12.56199],
                    widthElements: [3.1405, 9.42149, 12.56198]
                },
                'EVENT_PARALLEL_MULTIPLE': {
                    d: 'm {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
                    '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
                    height: 36,
                    width: 36,
                    heightElements: [2.56228, 7.68683],
                    widthElements: [2.56228, 7.68683]
                },
                'GATEWAY_EXCLUSIVE': {
                    d: 'm {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +
                    '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +
                    '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',
                    height: 17.5,
                    width: 17.5,
                    heightElements: [8.5, 6.5312, -6.5312, -8.5],
                    widthElements: [6.5, -6.5, 3, -3, 5, -5]
                },
                'GATEWAY_PARALLEL': {
                    d: 'm {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
                    '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
                    height: 30,
                    width: 30,
                    heightElements: [5, 12.5],
                    widthElements: [5, 12.5]
                },
                'GATEWAY_EVENT_BASED': {
                    d: 'm {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',
                    height: 11,
                    width: 11,
                    heightElements: [-6, 6, 12, -12],
                    widthElements: [9, -3, -12]
                },
                'GATEWAY_COMPLEX': {
                    d: 'm {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +
                    '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +
                    '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +
                    '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',
                    height: 17.125,
                    width: 17.125,
                    heightElements: [4.875, 3.4375, 2.125, 3],
                    widthElements: [3.4375, 2.125, 4.875, 3]
                },
                'DATA_OBJECT_PATH': {
                    d: 'm 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',
                    height: 61,
                    width: 51,
                    heightElements: [10, 50, 60],
                    widthElements: [10, 40, 50, 60]
                },
                'DATA_OBJECT_COLLECTION_PATH': {
                    d: 'm {mx}, {my} ' +
                    'm  0 15  l 0 -15 ' +
                    'm  4 15  l 0 -15 ' +
                    'm  4 15  l 0 -15 ',
                    height: 61,
                    width: 51,
                    heightElements: [12],
                    widthElements: [1, 6, 12, 15]
                },
                'DATA_ARROW': {
                    d: 'm 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',
                    height: 61,
                    width: 51,
                    heightElements: [],
                    widthElements: []
                },
                'DATA_STORE': {
                    d: 'm  {mx},{my} ' +
                    'l  0,{e.y2} ' +
                    'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
                    'l  0,-{e.y2} ' +
                    'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +
                    'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
                    'm  -{e.x2},{e.y0}' +
                    'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +
                    'm  -{e.x2},{e.y0}' +
                    'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',
                    height: 61,
                    width: 61,
                    heightElements: [7, 10, 45],
                    widthElements: [2, 58, 60]
                },
                'TEXT_ANNOTATION': {
                    d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',
                    height: 30,
                    width: 10,
                    heightElements: [30],
                    widthElements: [10]
                },
                'MARKER_SUB_PROCESS': {
                    d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',
                    height: 10,
                    width: 10,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_PARALLEL': {
                    d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',
                    height: 10,
                    width: 10,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_SEQUENTIAL': {
                    d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',
                    height: 10,
                    width: 10,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_COMPENSATION': {
                    d: 'm {mx},{my} 8,-5 0,10 z m 9,0 8,-5 0,10 z',
                    height: 10,
                    width: 21,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_LOOP': {
                    d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +
                    '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +
                    '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +
                    'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',
                    height: 13.9,
                    width: 13.7,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_ADHOC': {
                    d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +
                    '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +
                    '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +
                    '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +
                    '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',
                    height: 4,
                    width: 15,
                    heightElements: [],
                    widthElements: []
                },
                'TASK_TYPE_SEND': {
                    d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
                    height: 14,
                    width: 21,
                    heightElements: [6, 14],
                    widthElements: [10.5, 21]
                },
                'TASK_TYPE_SCRIPT': {
                    d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +
                    'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +
                    'm -7,-12 l 5,0 ' +
                    'm -4.5,3 l 4.5,0 ' +
                    'm -3,3 l 5,0' +
                    'm -4,3 l 5,0',
                    height: 15,
                    width: 12.6,
                    heightElements: [6, 14],
                    widthElements: [10.5, 21]
                },
                'TASK_TYPE_USER_1': {
                    d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +
                    '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +
                    '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +
                    'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +
                    'm -8,6 l 0,5.5 m 11,0 l 0,-5'
                },
                'TASK_TYPE_USER_2': {
                    d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +
                    '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '
                },
                'TASK_TYPE_USER_3': {
                    d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +
                    '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +
                    '-4.20799998,3.36699999 -4.20699998,4.34799999 z'
                },
                'TASK_TYPE_MANUAL': {
                    d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +
                    '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +
                    '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +
                    '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +
                    '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +
                    '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +
                    '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +
                    '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +
                    '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +
                    '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +
                    '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +
                    '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'
                },
                'TASK_TYPE_INSTANTIATING_SEND': {
                    d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'
                },
                'TASK_TYPE_SERVICE': {
                    d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +
                    '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +
                    '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +
                    'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +
                    '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +
                    '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +
                    'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +
                    '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +
                    'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +
                    'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +
                    '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +
                    'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +
                    'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
                    '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
                    '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
                },
                'TASK_TYPE_SERVICE_FILL': {
                    d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
                    '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
                    '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
                },
                'TASK_TYPE_BUSINESS_RULE_HEADER': {
                    d: 'm {mx},{my} 0,4 20,0 0,-4 z'
                },
                'TASK_TYPE_BUSINESS_RULE_MAIN': {
                    d: 'm {mx},{my} 0,12 20,0 0,-12 z' +
                    'm 0,8 l 20,0 ' +
                    'm -13,-4 l 0,8'
                },
                'MESSAGE_FLOW_MARKER': {
                    d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'
                }
            };

            this.getRawPath = function getRawPath(pathId) {
                return this.pathMap[pathId].d;
            };

            /**
             * Scales the path to the given height and width.
             * <h1>Use case</h1>
             * <p>Use case is to scale the content of elements (event, gateways) based
             * on the element bounding box's size.
             * </p>
             * <h1>Why not transform</h1>
             * <p>Scaling a path with transform() will also scale the stroke and IE does not support
             * the option 'non-scaling-stroke' to prevent this.
             * Also there are use cases where only some parts of a path should be
             * scaled.</p>
             *
             * @param {String} pathId The ID of the path.
             * @param {Object} param <p>
             *   Example param object scales the path to 60% size of the container (data.width, data.height).
             *   <pre>
             *   {
   *     xScaleFactor: 0.6,
   *     yScaleFactor:0.6,
   *     containerWidth: data.width,
   *     containerHeight: data.height,
   *     position: {
   *       mx: 0.46,
   *       my: 0.2,
   *     }
   *   }
             *   </pre>
             *   <ul>
             *    <li>targetpathwidth = xScaleFactor * containerWidth</li>
             *    <li>targetpathheight = yScaleFactor * containerHeight</li>
             *    <li>Position is used to set the starting coordinate of the path. M is computed:
             *    <ul>
             *      <li>position.x * containerWidth</li>
             *      <li>position.y * containerHeight</li>
             *    </ul>
             *    Center of the container <pre> position: {
   *       mx: 0.5,
   *       my: 0.5,
   *     }</pre>
             *     Upper left corner of the container
             *     <pre> position: {
   *       mx: 0.0,
   *       my: 0.0,
   *     }</pre>
             *    </li>
             *   </ul>
             * </p>
             *
             */
            this.getScaledPath = function getScaledPath(pathId, param) {
                var rawPath = this.pathMap[pathId];

                // positioning
                // compute the start point of the path
                var mx, my;

                if (!!param.abspos) {
                    mx = param.abspos.x;
                    my = param.abspos.y;
                } else {
                    mx = param.containerWidth * param.position.mx;
                    my = param.containerHeight * param.position.my;
                }

                var coordinates = {}; //map for the scaled coordinates
                if (param.position) {

                    // path
                    var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;
                    var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;


                    //Apply height ratio
                    for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
                        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
                    }

                    //Apply width ratio
                    for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
                        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
                    }
                }

                //Apply value to raw path
                var path = Snap.format(
                    rawPath.d, {
                        mx: mx,
                        my: my,
                        e: coordinates
                    }
                );
                return path;
            };
        }

        module.exports = PathMap;

    }, {"diagram-js/vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/draw/index.js": [function (require, module, exports) {
        module.exports = {
            renderer: ['type', require('./BpmnRenderer')],
            pathMap: ['type', require('./PathMap')]
        };
    }, {
        "./BpmnRenderer": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/draw/BpmnRenderer.js",
        "./PathMap": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/draw/PathMap.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/context-pad/ContextPadProvider.js": [function (require, module, exports) {
        'use strict';


        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');


        /**
         * A provider for BPMN 2.0 elements context pad
         */
        function ContextPadProvider(contextPad, modeling, elementFactory,
                                    connect, create, bpmnReplace,
                                    canvas) {

            contextPad.registerProvider(this);

            this._contextPad = contextPad;

            this._modeling = modeling;

            this._elementFactory = elementFactory;
            this._connect = connect;
            this._create = create;
            this._bpmnReplace = bpmnReplace;
            this._canvas = canvas;
        }

        ContextPadProvider.$inject = [
            'contextPad',
            'modeling',
            'elementFactory',
            'connect',
            'create',
            'bpmnReplace',
            'canvas'
        ];

        ContextPadProvider.prototype.getContextPadEntries = function (element) {

            var contextPad = this._contextPad,
                modeling = this._modeling,

                elementFactory = this._elementFactory,
                connect = this._connect,
                create = this._create,
                bpmnReplace = this._bpmnReplace,
                canvas = this._canvas;

            var actions = {};

            if (element.type === 'label') {
                return actions;
            }

            var bpmnElement = element.businessObject;

            function startConnect(event, element, autoActivate) {
                connect.start(event, element, autoActivate);
            }

            function removeElement(e) {
                if (element.waypoints) {
                    modeling.removeConnection(element);
                } else {
                    modeling.removeShape(element);
                }
            }

            function getReplaceMenuPosition(element) {

                var Y_OFFSET = 5;

                var diagramContainer = canvas.getContainer(),
                    pad = contextPad.getPad(element).html;

                var diagramRect = diagramContainer.getBoundingClientRect(),
                    padRect = pad.getBoundingClientRect();

                var top = padRect.top - diagramRect.top;
                var left = padRect.left - diagramRect.left;

                var pos = {
                    x: left,
                    y: top + padRect.height + Y_OFFSET
                };

                return pos;
            }


            function appendAction(type, className, options) {

                function appendListener(event, element) {

                    var shape = elementFactory.createShape(assign({type: type}, options));
                    create.start(event, shape, element);
                }

                var shortType = type.replace(/^bpmn\:/, '');

                return {
                    group: 'model',
                    className: className,
                    title: 'Append ' + shortType,
                    action: {
                        dragstart: appendListener,
                        click: appendListener
                    }
                };
            }

            if (bpmnElement.$instanceOf('bpmn:FlowNode')) {

                if (!bpmnElement.$instanceOf('bpmn:EndEvent') && !bpmnElement.$instanceOf('bpmn:EventBasedGateway') && !isEventType(bpmnElement, 'bpmn:IntermediateThrowEvent', 'bpmn:LinkEventDefinition')) {

                    assign(actions, {
                        'append.end-event': appendAction('bpmn:EndEvent', 'icon-end-event-none'),
                        'append.gateway': appendAction('bpmn:ExclusiveGateway', 'icon-gateway-xor'),
                        'append.append-task': appendAction('bpmn:Task', 'icon-task'),
                        'append.intermediate-event': appendAction('bpmn:IntermediateThrowEvent',
                            'icon-intermediate-event-none')
                    });
                }

                if (bpmnElement.$instanceOf('bpmn:EventBasedGateway')) {

                    assign(actions, {
                        'append.receive-task': appendAction('bpmn:ReceiveTask', 'icon-receive-task'),
                        'append.message-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',
                            'icon-intermediate-event-catch-message',
                            {_eventDefinitionType: 'bpmn:MessageEventDefinition'}),
                        'append.timer-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',
                            'icon-intermediate-event-catch-timer',
                            {_eventDefinitionType: 'bpmn:TimerEventDefinition'}),
                        'append.condtion-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',
                            'icon-intermediate-event-catch-condition',
                            {_eventDefinitionType: 'bpmn:ConditionalEventDefinition'}),
                        'append.signal-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',
                            'icon-intermediate-event-catch-signal',
                            {_eventDefinitionType: 'bpmn:SignalEventDefinition'})
                    });
                }


                // Replace menu entry
                if (!bpmnElement.$instanceOf('bpmn:SubProcess')) {
                    assign(actions, {
                        'replace': {
                            group: 'edit',
                            className: 'icon-screw-wrench',
                            title: 'Change type',
                            action: {
                                click: function (event, element) {
                                    bpmnReplace.openChooser(getReplaceMenuPosition(element), element);
                                }
                            }
                        }
                    });
                }
            }

            if (bpmnElement.$instanceOf('bpmn:FlowNode') ||
                bpmnElement.$instanceOf('bpmn:InteractionNode')) {

                assign(actions, {
                    'append.text-annotation': appendAction('bpmn:TextAnnotation', 'icon-text-annotation'),

                    'connect': {
                        group: 'connect',
                        className: 'icon-connection-multi',
                        title: 'Connect using Sequence/MessageFlow',
                        action: {
                            click: startConnect,
                            dragstart: startConnect
                        }
                    }
                });
            }

            // Delete Element Entry
            assign(actions, {
                'delete': {
                    group: 'edit',
                    className: 'icon-trash',
                    title: 'Remove',
                    action: {
                        click: removeElement,
                        dragstart: removeElement
                    }
                }
            });

            return actions;
        };

        function isEventType(eventBo, type, definition) {

            var isType = eventBo.$instanceOf(type);
            var isDefinition = false;

            var definitions = eventBo.eventDefinitions || [];
            forEach(definitions, function (def) {
                if (def.$type === definition) {
                    isDefinition = true;
                }
            });

            return isType && isDefinition;
        }


        module.exports = ContextPadProvider;

    }, {
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/context-pad/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js-direct-editing'),
                require('diagram-js/lib/features/context-pad'),
                require('diagram-js/lib/features/selection'),
                require('diagram-js/lib/features/connect'),
                require('diagram-js/lib/features/create'),
                require('../replace')
            ],
            __init__: ['contextPadProvider'],
            contextPadProvider: ['type', require('./ContextPadProvider')]
        };
    }, {
        "../replace": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/replace/index.js",
        "./ContextPadProvider": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/context-pad/ContextPadProvider.js",
        "diagram-js-direct-editing": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/diagram-js-direct-editing/index.js",
        "diagram-js/lib/features/connect": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/connect/index.js",
        "diagram-js/lib/features/context-pad": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/context-pad/index.js",
        "diagram-js/lib/features/create": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/create/index.js",
        "diagram-js/lib/features/selection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/keyboard/BpmnKeyBindings.js": [function (require, module, exports) {
        'use strict';


        function BpmnKeyBindings(keyboard, spaceTool, lassoTool, directEditing, selection) {

            keyboard.addListener(function (key, modifiers) {

                if (keyboard.hasModifier(modifiers)) {
                    return;
                }

                // S -> activate space tool
                if (key === 83) {
                    spaceTool.activateSelection();

                    return true;
                }

                // L -> activate lasso tool
                if (key === 108) {
                    lassoTool.activateSelection();

                    return true;
                }

                var currentSelection = selection.get();

                // E -> activate direct editing
                if (key === 69) {
                    if (currentSelection.length) {
                        directEditing.activate(currentSelection[0]);
                    }

                    return true;
                }
            });
        }

        BpmnKeyBindings.$inject = ['keyboard', 'spaceTool', 'lassoTool', 'directEditing', 'selection'];

        module.exports = BpmnKeyBindings;
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/keyboard/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/keyboard')
            ],
            __init__: ['bpmnKeyBindings'],
            bpmnKeyBindings: ['type', require('./BpmnKeyBindings')]
        };
    }, {
        "./BpmnKeyBindings": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/keyboard/BpmnKeyBindings.js",
        "diagram-js/lib/features/keyboard": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/keyboard/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/LabelEditingProvider.js": [function (require, module, exports) {
        'use strict';

        var UpdateLabelHandler = require('./cmd/UpdateLabelHandler');

        var LabelUtil = require('./LabelUtil');

        var is = require('../../util/ModelUtil').is,
            isExpanded = require('../../util/DiUtil').isExpanded;


        var MIN_BOUNDS = {
            width: 150,
            height: 50
        };


        function LabelEditingProvider(eventBus, canvas, directEditing, commandStack, injector) {

            directEditing.registerProvider(this);
            commandStack.registerHandler('element.updateLabel', UpdateLabelHandler);

            // listen to dblclick on non-root elements
            eventBus.on('element.dblclick', function (event) {
                directEditing.activate(event.element);
            });

            // complete on followup canvas operation
            eventBus.on(['element.mousedown', 'drag.activate', 'canvas.viewbox.changed'], function (event) {
                directEditing.complete();
            });

            // cancel on command stack changes
            eventBus.on(['commandStack.changed'], function () {
                directEditing.cancel();
            });


            // activate direct editing for activities and text annotations


            if ('ontouchstart' in document.documentElement) {
                // we deactivate automatic label editing on mobile devices
                // as it breaks the user interaction workflow

                // TODO(nre): we should temporarily focus the edited element here
                // and release the focused viewport after the direct edit operation is finished
            } else {
                eventBus.on('create.end', 500, function (e) {

                    var element = e.shape,
                        canExecute = e.context.canExecute;

                    if (!canExecute) {
                        return;
                    }

                    if (is(element, 'bpmn:Task') || is(element, 'bpmn:TextAnnotation') ||
                        (is(element, 'bpmn:SubProcess') && !isExpanded(element))) {

                        directEditing.activate(element);
                    }
                });
            }

            this._canvas = canvas;
            this._commandStack = commandStack;
        }

        LabelEditingProvider.$inject = ['eventBus', 'canvas', 'directEditing', 'commandStack', 'injector'];

        module.exports = LabelEditingProvider;


        LabelEditingProvider.prototype.activate = function (element) {

            var text = LabelUtil.getLabel(element);

            if (text === undefined) {
                return;
            }

            var bbox = this.getEditingBBox(element);

            // adjust for expanded pools AND lanes
            if ((is(element, 'bpmn:Participant') && isExpanded(element)) || is(element, 'bpmn:Lane')) {

                bbox.width = MIN_BOUNDS.width;
                bbox.height = MIN_BOUNDS.height;

                bbox.x = bbox.x + 10 - bbox.width / 2;
                bbox.y = bbox.mid.y - bbox.height / 2;
            }

            // adjust for expanded sub processes
            if (is(element, 'bpmn:SubProcess') && isExpanded(element)) {

                bbox.height = MIN_BOUNDS.height;

                bbox.x = bbox.mid.x - bbox.width / 2;
                bbox.y = bbox.y + 10 - bbox.height / 2;
            }

            return {bounds: bbox, text: text};
        };


        LabelEditingProvider.prototype.getEditingBBox = function (element, maxBounds) {

            var target = element.label || element;

            var bbox = this._canvas.getAbsoluteBBox(target);

            var mid = {
                x: bbox.x + bbox.width / 2,
                y: bbox.y + bbox.height / 2
            };

            // external label
            if (target.labelTarget) {
                bbox.width = Math.max(bbox.width, MIN_BOUNDS.width);
                bbox.height = Math.max(bbox.height, MIN_BOUNDS.height);

                bbox.x = mid.x - bbox.width / 2;
            }

            bbox.mid = mid;

            return bbox;
        };


        LabelEditingProvider.prototype.update = function (element, newLabel) {
            this._commandStack.execute('element.updateLabel', {
                element: element,
                newLabel: newLabel
            });
        };
    }, {
        "../../util/DiUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/DiUtil.js",
        "../../util/ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js",
        "./LabelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js",
        "./cmd/UpdateLabelHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/cmd/UpdateLabelHandler.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js": [function (require, module, exports) {
        'use strict';

        function getLabelAttr(semantic) {
            if (semantic.$instanceOf('bpmn:FlowElement') ||
                semantic.$instanceOf('bpmn:Participant') ||
                semantic.$instanceOf('bpmn:Lane') ||
                semantic.$instanceOf('bpmn:SequenceFlow') ||
                semantic.$instanceOf('bpmn:MessageFlow')) {
                return 'name';
            }

            if (semantic.$instanceOf('bpmn:TextAnnotation')) {
                return 'text';
            }
        }

        module.exports.getLabel = function (element) {
            var semantic = element.businessObject,
                attr = getLabelAttr(semantic);

            if (attr) {
                return semantic[attr] || '';
            }
        };


        module.exports.setLabel = function (element, text) {
            var semantic = element.businessObject,
                attr = getLabelAttr(semantic);

            if (attr) {
                semantic[attr] = text;
            }

            var label = element.label || element;

            // show label
            label.hidden = false;

            return label;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/cmd/UpdateLabelHandler.js": [function (require, module, exports) {
        'use strict';

        var LabelUtil = require('../LabelUtil');


        /**
         * A handler that updates the text of a BPMN element.
         *
         * @param {EventBus} eventBus
         */
        function UpdateTextHandler(eventBus) {

            function setText(element, text) {
                var label = LabelUtil.setLabel(element, text);

                eventBus.fire('element.changed', {element: label});
            }

            function execute(ctx) {
                ctx.oldLabel = LabelUtil.getLabel(ctx.element);
                return setText(ctx.element, ctx.newLabel);
            }

            function revert(ctx) {
                return setText(ctx.element, ctx.oldLabel);
            }


            function canExecute(ctx) {
                return true;
            }

            // API

            this.execute = execute;
            this.revert = revert;

            this.canExecute = canExecute;
        }


        UpdateTextHandler.$inject = ['eventBus'];

        module.exports = UpdateTextHandler;
    }, {"../LabelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/command'),
                require('diagram-js/lib/features/change-support'),
                require('diagram-js-direct-editing')
            ],
            __init__: ['labelEditingProvider'],
            labelEditingProvider: ['type', require('./LabelEditingProvider')]
        };
    }, {
        "./LabelEditingProvider": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/LabelEditingProvider.js",
        "diagram-js-direct-editing": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/diagram-js-direct-editing/index.js",
        "diagram-js/lib/command": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/index.js",
        "diagram-js/lib/features/change-support": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/change-support/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/BpmnFactory.js": [function (require, module, exports) {
        'use strict';

        var map = require('lodash/collection/map'),
            assign = require('lodash/object/assign'),
            pick = require('lodash/object/pick');


        function BpmnFactory(moddle) {
            this._model = moddle;
        }

        BpmnFactory.$inject = ['moddle'];


        BpmnFactory.prototype._needsId = function (element) {
            return element.$instanceOf('bpmn:RootElement') ||
                element.$instanceOf('bpmn:FlowElement') ||
                element.$instanceOf('bpmn:MessageFlow') ||
                element.$instanceOf('bpmn:Artifact') ||
                element.$instanceOf('bpmn:Participant') ||
                element.$instanceOf('bpmn:Process') ||
                element.$instanceOf('bpmn:Collaboration') ||
                element.$instanceOf('bpmndi:BPMNShape') ||
                element.$instanceOf('bpmndi:BPMNEdge') ||
                element.$instanceOf('bpmndi:BPMNDiagram') ||
                element.$instanceOf('bpmndi:BPMNPlane');
        };

        BpmnFactory.prototype._ensureId = function (element) {

            // generate semantic ids for elements
            // bpmn:SequenceFlow -> SequenceFlow_ID
            var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';

            if (!element.id && this._needsId(element)) {
                element.id = this._model.ids.nextPrefixed(prefix, element);
            }
        };


        BpmnFactory.prototype.create = function (type, attrs) {
            var element = this._model.create(type, attrs || {});

            this._ensureId(element);

            return element;
        };


        BpmnFactory.prototype.createDiLabel = function () {
            return this.create('bpmndi:BPMNLabel', {
                bounds: this.createDiBounds()
            });
        };


        BpmnFactory.prototype.createDiShape = function (semantic, bounds, attrs) {

            return this.create('bpmndi:BPMNShape', assign({
                bpmnElement: semantic,
                bounds: this.createDiBounds(bounds)
            }, attrs));
        };


        BpmnFactory.prototype.createDiBounds = function (bounds) {
            return this.create('dc:Bounds', bounds);
        };


        BpmnFactory.prototype.createDiWaypoints = function (waypoints) {
            return map(waypoints, function (pos) {
                return this.createDiWaypoint(pos);
            }, this);
        };

        BpmnFactory.prototype.createDiWaypoint = function (point) {
            return this.create('dc:Point', pick(point, ['x', 'y']));
        };


        BpmnFactory.prototype.createDiEdge = function (semantic, waypoints, attrs) {
            return this.create('bpmndi:BPMNEdge', assign({
                bpmnElement: semantic
            }, attrs));
        };

        BpmnFactory.prototype.createDiPlane = function (semantic) {
            return this.create('bpmndi:BPMNPlane', {
                bpmnElement: semantic
            });
        };

        module.exports = BpmnFactory;

    }, {
        "lodash/collection/map": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/map.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "lodash/object/pick": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/pick.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var assign = require('lodash/object/assign');

        var BaseLayouter = require('diagram-js/lib/layout/BaseLayouter'),
            LayoutUtil = require('diagram-js/lib/layout/LayoutUtil'),
            ManhattanLayout = require('diagram-js/lib/layout/ManhattanLayout');

        var is = require('../../util/ModelUtil').is;


        function BpmnLayouter() {
        }

        inherits(BpmnLayouter, BaseLayouter);

        module.exports = BpmnLayouter;


        function getAttachment(waypoints, idx, shape) {
            var point = waypoints && waypoints[idx];

            return point ? (point.original || point) : LayoutUtil.getMidPoint(shape);
        }


        BpmnLayouter.prototype.layoutConnection = function (connection, hints) {
            var source = connection.source,
                target = connection.target,
                waypoints = connection.waypoints,
                start,
                end;

            var layoutManhattan,
                updatedWaypoints;

            start = getAttachment(waypoints, 0, source);
            end = getAttachment(waypoints, waypoints && waypoints.length - 1, target);

            // manhattan layout sequence / message flows
            if (is(connection, 'bpmn:MessageFlow')) {
                layoutManhattan = {
                    preferStraight: true,
                    preferVertical: true
                };
            }

            if (is(connection, 'bpmn:SequenceFlow')) {
                layoutManhattan = {};
            }

            if (layoutManhattan) {

                layoutManhattan = assign(layoutManhattan, hints);

                updatedWaypoints =
                    ManhattanLayout.repairConnection(
                        source, target, start, end,
                        waypoints,
                        layoutManhattan);
            }

            return updatedWaypoints || [start, end];
        };
    }, {
        "../../util/ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js",
        "diagram-js/lib/layout/BaseLayouter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/BaseLayouter.js",
        "diagram-js/lib/layout/LayoutUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/LayoutUtil.js",
        "diagram-js/lib/layout/ManhattanLayout": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/ManhattanLayout.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            inherits = require('inherits');

        var Collections = require('diagram-js/lib/util/Collections'),
            Model = require('diagram-js/lib/model');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');


        /**
         * A handler responsible for updating the underlying BPMN 2.0 XML + DI
         * once changes on the diagram happen
         */
        function BpmnUpdater(eventBus, bpmnFactory, connectionDocking) {

            CommandInterceptor.call(this, eventBus);

            this._bpmnFactory = bpmnFactory;

            var self = this;


            ////// connection cropping /////////////////////////

            // crop connection ends during create/update
            function cropConnection(e) {
                var context = e.context,
                    connection;

                if (!context.cropped) {
                    connection = context.connection;
                    connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
                    context.cropped = true;
                }
            }

            this.executed([
                'connection.layout',
                'connection.create',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], cropConnection);

            this.reverted(['connection.layout'], function (e) {
                delete e.context.cropped;
            });


            ////// BPMN + DI update /////////////////////////


            // update parent
            function updateParent(e) {
                self.updateParent(e.context.shape || e.context.connection);
            }

            this.executed(['shape.move',
                'shape.create',
                'shape.delete',
                'connection.create',
                'connection.move',
                'connection.delete'], updateParent);
            this.reverted(['shape.move',
                'shape.create',
                'shape.delete',
                'connection.create',
                'connection.move',
                'connection.delete'], updateParent);

            /*
             * ## Updating Parent
             *
             * When morphing a Process into a Collaboration or vice-versa, 
             * make sure that both the *semantic* and *di* parent of each element
             * is updated.
             *
             */
            function updateRoot(event) {
                var context = event.context,
                    oldRoot = context.oldRoot,
                    children = oldRoot.children;

                forEach(children, function (child) {
                    self.updateParent(child);
                });
            }

            this.executed(['canvas.updateRoot'], updateRoot);
            this.reverted(['canvas.updateRoot'], updateRoot);


            // update bounds
            function updateBounds(e) {
                self.updateBounds(e.context.shape);
            }

            this.executed(['shape.move', 'shape.create', 'shape.resize'], updateBounds);
            this.reverted(['shape.move', 'shape.create', 'shape.resize'], updateBounds);


            // attach / detach connection
            function updateConnection(e) {
                self.updateConnection(e.context.connection);
            }

            this.executed([
                'connection.create',
                'connection.move',
                'connection.delete',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], updateConnection);

            this.reverted([
                'connection.create',
                'connection.move',
                'connection.delete',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], updateConnection);


            // update waypoints
            function updateConnectionWaypoints(e) {
                self.updateConnectionWaypoints(e.context.connection);
            }

            this.executed([
                'connection.layout',
                'connection.move',
                'connection.updateWaypoints',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], updateConnectionWaypoints);

            this.reverted([
                'connection.layout',
                'connection.move',
                'connection.updateWaypoints',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], updateConnectionWaypoints);
        }

        inherits(BpmnUpdater, CommandInterceptor);

        module.exports = BpmnUpdater;

        BpmnUpdater.$inject = ['eventBus', 'bpmnFactory', 'connectionDocking'];


/////// implementation //////////////////////////////////


        BpmnUpdater.prototype.updateParent = function (element) {

            // do not update BPMN 2.0 label parent
            if (element instanceof Model.Label) {
                return;
            }

            var parentShape = element.parent;

            var businessObject = element.businessObject,
                parentBusinessObject = parentShape && parentShape.businessObject,
                parentDi = parentBusinessObject && parentBusinessObject.di;

            this.updateSemanticParent(businessObject, parentBusinessObject);

            this.updateDiParent(businessObject.di, parentDi);
        };


        BpmnUpdater.prototype.updateBounds = function (shape) {

            var di = shape.businessObject.di;

            var bounds = (shape instanceof Model.Label) ? this._getLabel(di).bounds : di.bounds;

            assign(bounds, {
                x: shape.x,
                y: shape.y,
                width: shape.width,
                height: shape.height
            });
        };


        BpmnUpdater.prototype.updateDiParent = function (di, parentDi) {

            if (parentDi && !parentDi.$instanceOf('bpmndi:BPMNPlane')) {
                parentDi = parentDi.$parent;
            }

            if (di.$parent === parentDi) {
                return;
            }

            var planeElements = (parentDi || di.$parent).get('planeElement');

            if (parentDi) {
                planeElements.push(di);
                di.$parent = parentDi;
            } else {
                Collections.remove(planeElements, di);
                di.$parent = null;
            }
        };

        function getDefinitions(element) {
            while (element && !element.$instanceOf('bpmn:Definitions')) {
                element = element.$parent;
            }

            return element;
        }

        BpmnUpdater.prototype.updateSemanticParent = function (businessObject, newParent) {

            var containment;

            if (businessObject.$parent === newParent) {
                return;
            }

            if (businessObject.$instanceOf('bpmn:FlowElement')) {

                if (newParent && newParent.$instanceOf('bpmn:Participant')) {
                    newParent = newParent.processRef;
                }

                containment = 'flowElements';

            } else if (businessObject.$instanceOf('bpmn:Artifact')) {

                while (newParent && !newParent.$instanceOf('bpmn:Process') && !newParent.$instanceOf('bpmn:SubProcess') && !newParent.$instanceOf('bpmn:Collaboration')) {

                    if (newParent.$instanceOf('bpmn:Participant')) {
                        newParent = newParent.processRef;
                        break;
                    } else {
                        newParent = newParent.$parent;
                    }
                }

                containment = 'artifacts';
            } else if (businessObject.$instanceOf('bpmn:MessageFlow')) {
                containment = 'messageFlows';

            } else if (businessObject.$instanceOf('bpmn:Participant')) {
                containment = 'participants';

                // make sure the participants process is properly attached / detached
                // from the XML document

                var process = businessObject.processRef,
                    definitions;

                if (process) {
                    definitions = getDefinitions(businessObject.$parent || newParent);

                    if (businessObject.$parent) {
                        Collections.remove(definitions.get('rootElements'), process);
                        process.$parent = null;
                    }

                    if (newParent) {
                        Collections.add(definitions.get('rootElements'), process);
                        process.$parent = definitions;
                    }
                }
            }

            if (!containment) {
                throw new Error('no parent for ', businessObject, newParent);
            }

            var children;

            if (businessObject.$parent) {
                // remove from old parent
                children = businessObject.$parent.get(containment);
                Collections.remove(children, businessObject);
            }

            if (!newParent) {
                businessObject.$parent = null;
            } else {
                // add to new parent
                children = newParent.get(containment);
                children.push(businessObject);
                businessObject.$parent = newParent;
            }
        };


        BpmnUpdater.prototype.updateConnectionWaypoints = function (connection) {

            connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));
        };


        BpmnUpdater.prototype.updateConnection = function (connection) {

            var businessObject = connection.businessObject,
                newSource = connection.source && connection.source.businessObject,
                newTarget = connection.target && connection.target.businessObject;

            var inverseSet = businessObject.$instanceOf('bpmn:SequenceFlow');

            if (businessObject.sourceRef !== newSource) {
                if (inverseSet) {
                    Collections.remove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);

                    if (newSource) {
                        newSource.get('outgoing').push(businessObject);
                    }
                }

                businessObject.sourceRef = newSource;
            }
            if (businessObject.targetRef !== newTarget) {
                if (inverseSet) {
                    Collections.remove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);

                    if (newTarget) {
                        newTarget.get('incoming').push(businessObject);
                    }
                }

                businessObject.targetRef = newTarget;
            }

            businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));
        };


/////// helpers /////////////////////////////////////////

        BpmnUpdater.prototype._getLabel = function (di) {
            if (!di.label) {
                di.label = this._bpmnFactory.createDiLabel();
            }

            return di.label;
        };
    }, {
        "diagram-js/lib/command/CommandInterceptor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/CommandInterceptor.js",
        "diagram-js/lib/model": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/model/index.js",
        "diagram-js/lib/util/Collections": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Collections.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/ElementFactory.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            inherits = require('inherits');

        var BaseElementFactory = require('diagram-js/lib/core/ElementFactory'),
            LabelUtil = require('../../util/LabelUtil');


        /**
         * A bpmn-aware factory for diagram-js shapes
         */
        function ElementFactory(bpmnFactory, moddle) {
            BaseElementFactory.call(this);

            this._bpmnFactory = bpmnFactory;
            this._moddle = moddle;
        }

        inherits(ElementFactory, BaseElementFactory);


        ElementFactory.$inject = ['bpmnFactory', 'moddle'];

        module.exports = ElementFactory;

        ElementFactory.prototype.baseCreate = BaseElementFactory.prototype.create;

        ElementFactory.prototype.create = function (elementType, attrs) {

            // no special magic for labels,
            // we assume their businessObjects have already been created
            // and wired via attrs
            if (elementType === 'label') {
                return this.baseCreate(elementType, assign({type: 'label'}, LabelUtil.DEFAULT_LABEL_SIZE, attrs));
            }

            attrs = attrs || {};

            var businessObject = attrs.businessObject,
                size;

            if (!businessObject) {
                if (!attrs.type) {
                    throw new Error('no shape type specified');
                }

                businessObject = this._bpmnFactory.create(attrs.type);
            }

            if (!businessObject.di) {
                if (elementType === 'root') {
                    businessObject.di = this._bpmnFactory.createDiPlane(businessObject, [], {
                        id: businessObject.id + '_di'
                    });
                } else if (elementType === 'connection') {
                    businessObject.di = this._bpmnFactory.createDiEdge(businessObject, [], {
                        id: businessObject.id + '_di'
                    });
                } else {
                    businessObject.di = this._bpmnFactory.createDiShape(businessObject, {}, {
                        id: businessObject.id + '_di'
                    });
                }
            }

            if (!!attrs.isExpanded) {
                businessObject.di.isExpanded = attrs.isExpanded;
            }

            if (businessObject.$instanceOf('bpmn:ExclusiveGateway')) {
                businessObject.di.isMarkerVisible = true;
            }

            if (attrs._eventDefinitionType) {
                var eventDefinitions = businessObject.get('eventDefinitions') || [],
                    newEventDefinition = this._moddle.create(attrs._eventDefinitionType);

                eventDefinitions.push(newEventDefinition);
                businessObject.eventDefinitions = eventDefinitions;
            }

            size = this._getDefaultSize(businessObject);

            attrs = assign({
                businessObject: businessObject,
                id: businessObject.id
            }, size, attrs);

            return this.baseCreate(elementType, attrs);
        };


        ElementFactory.prototype._getDefaultSize = function (semantic) {

            if (semantic.$instanceOf('bpmn:SubProcess')) {
                var isExpanded = semantic.di.isExpanded === true;

                if (isExpanded) {
                    return {width: 350, height: 200};
                } else {
                    return {width: 100, height: 80};
                }
            }

            if (semantic.$instanceOf('bpmn:Task')) {
                return {width: 100, height: 80};
            }

            if (semantic.$instanceOf('bpmn:Gateway')) {
                return {width: 50, height: 50};
            }

            if (semantic.$instanceOf('bpmn:Event')) {
                return {width: 36, height: 36};
            }

            if (semantic.$instanceOf('bpmn:Participant')) {
                return {width: 600, height: 250};
            }

            return {width: 100, height: 80};
        };


        ElementFactory.prototype.createParticipantShape = function (collapsed) {

            var participantShape = this.createShape({type: 'bpmn:Participant'});

            if (!collapsed) {
                participantShape.businessObject.processRef = this._bpmnFactory.create('bpmn:Process');
            }

            return participantShape;
        };
    }, {
        "../../util/LabelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/LabelUtil.js",
        "diagram-js/lib/core/ElementFactory": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/ElementFactory.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/LabelSupport.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var LabelUtil = require('../../util/LabelUtil');

        var hasExternalLabel = LabelUtil.hasExternalLabel,
            getExternalLabelMid = LabelUtil.getExternalLabelMid;


        function LabelSupport(eventBus, modeling, bpmnFactory) {

            // create external labels on shape creation

            eventBus.on([
                'commandStack.shape.create.postExecute',
                'commandStack.connection.create.postExecute'
            ], function (e) {
                var context = e.context;

                var element = context.shape || context.connection,
                    businessObject = element.businessObject;

                var position;

                if (hasExternalLabel(businessObject)) {
                    position = getExternalLabelMid(element);
                    modeling.createLabel(element, position, {
                        id: businessObject.id + '_label',
                        businessObject: businessObject
                    });
                }
            });


            // indicate label is dragged during move

            // we need to add labels to the list of selected
            // shapes before the visuals get drawn.
            //
            // Hence this awesome magic number.
            //
            eventBus.on('shape.move.start', function (e) {

                var context = e.context,
                    shapes = context.shapes;

                var labels = [];

                forEach(shapes, function (element) {
                    var label = element.label;

                    if (label && !label.hidden && context.shapes.indexOf(label) === -1) {
                        labels.push(label);
                    }
                });

                forEach(labels, function (label) {
                    shapes.push(label);
                });
            });


            // move labels with shapes

            eventBus.on([
                'commandStack.shapes.move.postExecute'
            ], function (e) {

                var context = e.context,
                    closure = context.closure,
                    enclosedElements = closure.enclosedElements;

                // ensure we move all labels with their respective elements
                // if they have not been moved already

                forEach(enclosedElements, function (e) {
                    if (e.label && !enclosedElements[e.label.id]) {
                        modeling.moveShape(e.label, context.delta, e.parent);
                    }
                });
            });


            // update di information on label movement and creation

            eventBus.on([
                'commandStack.label.create.executed',
                'commandStack.shape.moved.executed'
            ], function (e) {

                var element = e.context.shape,
                    businessObject = element.businessObject,
                    di = businessObject.di;

                // we want to trigger on real labels only
                if (!element.labelTarget) {
                    return;
                }

                if (!di.label) {
                    di.label = bpmnFactory.create('bpmndi:BPMNLabel', {
                        bounds: bpmnFactory.create('dc:Bounds')
                    });
                }

                assign(di.label.bounds, {
                    x: element.x,
                    y: element.y,
                    width: element.width,
                    height: element.height
                });
            });
        }

        LabelSupport.$inject = ['eventBus', 'modeling', 'bpmnFactory'];

        module.exports = LabelSupport;

    }, {
        "../../util/LabelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/LabelUtil.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/Modeling.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var BaseModeling = require('diagram-js/lib/features/modeling/Modeling');

        var UpdatePropertiesHandler = require('./cmd/UpdatePropertiesHandler'),
            UpdateCanvasRootHandler = require('./cmd/UpdateCanvasRootHandler');


        /**
         * BPMN 2.0 modeling features activator
         *
         * @param {EventBus} eventBus
         * @param {ElementFactory} elementFactory
         * @param {CommandStack} commandStack
         * @param {BpmnRules} bpmnRules
         */
        function Modeling(eventBus, elementFactory, commandStack, bpmnRules) {
            BaseModeling.call(this, eventBus, elementFactory, commandStack);

            this._bpmnRules = bpmnRules;
        }

        inherits(Modeling, BaseModeling);

        Modeling.$inject = ['eventBus', 'elementFactory', 'commandStack', 'bpmnRules'];

        module.exports = Modeling;


        Modeling.prototype.getHandlers = function () {
            var handlers = BaseModeling.prototype.getHandlers.call(this);

            handlers['element.updateProperties'] = UpdatePropertiesHandler;
            handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;

            return handlers;
        };


        Modeling.prototype.updateLabel = function (element, newLabel) {
            this._commandStack.execute('element.updateLabel', {
                element: element,
                newLabel: newLabel
            });
        };


        var getSharedParent = require('./ModelingUtil').getSharedParent;

        Modeling.prototype.connect = function (source, target, attrs) {

            var bpmnRules = this._bpmnRules;

            if (!attrs) {
                if (bpmnRules.canConnectMessageFlow(source, target)) {
                    attrs = {
                        type: 'bpmn:MessageFlow'
                    };
                } else if (bpmnRules.canConnectSequenceFlow(source, target)) {
                    attrs = {
                        type: 'bpmn:SequenceFlow'
                    };
                } else {
                    attrs = {
                        type: 'bpmn:Association'
                    };
                }
            }

            return this.createConnection(source, target, attrs, getSharedParent(source, target));
        };


        Modeling.prototype.updateProperties = function (element, properties) {
            this._commandStack.execute('element.updateProperties', {
                element: element,
                properties: properties
            });
        };


        /**
         * Transform the current diagram into a collaboration.
         *
         * @return {djs.model.Root} the new root element
         */
        Modeling.prototype.makeCollaboration = function () {

            var collaborationElement = this._create('root', {
                type: 'bpmn:Collaboration'
            });

            var context = {
                newRoot: collaborationElement
            };

            this._commandStack.execute('canvas.updateRoot', context);

            return collaborationElement;
        };

        /**
         * Transform the current diagram into a process.
         *
         * @return {djs.model.Root} the new root element
         */
        Modeling.prototype.makeProcess = function () {

            var processElement = this._create('root', {
                type: 'bpmn:Process'
            });

            var context = {
                newRoot: processElement
            };

            this._commandStack.execute('canvas.updateRoot', context);
        };
    }, {
        "./ModelingUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/ModelingUtil.js",
        "./cmd/UpdateCanvasRootHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/cmd/UpdateCanvasRootHandler.js",
        "./cmd/UpdatePropertiesHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/cmd/UpdatePropertiesHandler.js",
        "diagram-js/lib/features/modeling/Modeling": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/Modeling.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/ModelingUtil.js": [function (require, module, exports) {
        'use strict';

        var find = require('lodash/collection/find');


        function getParents(element) {

            var parents = [];

            while (element) {
                element = element.parent;

                if (element) {
                    parents.push(element);
                }
            }

            return parents;
        }

        module.exports.getParents = getParents;


        function getSharedParent(a, b) {

            var parentsA = getParents(a),
                parentsB = getParents(b);

            return find(parentsA, function (parent) {
                return parentsB.indexOf(parent) !== -1;
            });
        }

        module.exports.getSharedParent = getSharedParent;
    }, {"lodash/collection/find": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/find.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/AppendBehavior.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var is = require('../../../util/ModelUtil').is;

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');


        function AppendBehavior(eventBus, elementFactory, bpmnRules) {

            CommandInterceptor.call(this, eventBus);

            // assign correct shape position unless already set

            this.preExecute('shape.append', function (context) {

                var source = context.source,
                    shape = context.shape;

                if (!context.position) {

                    if (is(shape, 'bpmn:TextAnnotation')) {
                        context.position = {
                            x: source.x + source.width / 2 + 75,
                            y: source.y - (50) - shape.height / 2
                        };
                    } else {
                        context.position = {
                            x: source.x + source.width + 80 + shape.width / 2,
                            y: source.y + source.height / 2
                        };
                    }
                }
            }, true);
        }


        AppendBehavior.$inject = ['eventBus', 'elementFactory', 'bpmnRules'];

        inherits(AppendBehavior, CommandInterceptor);

        module.exports = AppendBehavior;
    }, {
        "../../../util/ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js",
        "diagram-js/lib/command/CommandInterceptor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/CommandInterceptor.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/CreateBehavior.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is;

        /**
         * BPMN specific create behavior
         */
        function CreateBehavior(eventBus, modeling) {

            CommandInterceptor.call(this, eventBus);


            /**
             * morph process into collaboration before adding
             * participant onto collaboration
             */

            this.preExecute('shape.create', function (context) {

                var parent = context.parent,
                    shape = context.shape,
                    position = context.position;

                if (is(parent, 'bpmn:Process') && is(shape, 'bpmn:Participant')) {

                    // this is going to detach the process root
                    // and set the returned collaboration element
                    // as the new root element
                    var collaborationElement = modeling.makeCollaboration();

                    // monkey patch the create context
                    // so that the participant is being dropped
                    // onto the new collaboration root instead
                    context.position = position;
                    context.parent = collaborationElement;

                    context.processRoot = parent;
                }
            }, true);

            this.execute('shape.create', function (context) {

                var processRoot = context.processRoot,
                    shape = context.shape;

                if (processRoot) {
                    context.oldProcessRef = shape.businessObject.processRef;

                    // assign the participant processRef
                    shape.businessObject.processRef = processRoot.businessObject;
                }
            }, true);

            this.revert('shape.create', function (context) {
                var processRoot = context.processRoot,
                    shape = context.shape;

                if (processRoot) {
                    // assign the participant processRef
                    shape.businessObject.processRef = context.oldProcessRef;
                }
            }, true);

            this.postExecute('shape.create', function (context) {

                var processRoot = context.processRoot,
                    shape = context.shape;

                if (processRoot) {
                    // process root is already detached at this point
                    var processChildren = processRoot.children.slice();
                    modeling.moveShapes(processChildren, {x: 0, y: 0}, shape);
                }
            }, true);

        }

        CreateBehavior.$inject = ['eventBus', 'modeling'];

        inherits(CreateBehavior, CommandInterceptor);

        module.exports = CreateBehavior;
    }, {
        "../../../util/ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js",
        "diagram-js/lib/command/CommandInterceptor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/CommandInterceptor.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/DropBehavior.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is,
            getSharedParent = require('../ModelingUtil').getSharedParent;


        function DropBehavior(eventBus, modeling, bpmnRules) {

            CommandInterceptor.call(this, eventBus);

            // remove sequence flows that should not be allowed
            // after a move operation

            this.postExecute('shapes.move', function (context) {

                var closure = context.closure,
                    allConnections = closure.allConnections;

                forEach(allConnections, function (c) {

                    var source = c.source,
                        target = c.target;

                    var replacementType,
                        remove;

                    /**
                     * Check if incoming or outgoing connections
                     * can stay or could be substituted with an
                     * appropriate replacement.
                     *
                     * This holds true for SequenceFlow <> MessageFlow.
                     */

                    if (is(c, 'bpmn:SequenceFlow')) {
                        if (!bpmnRules.canConnectSequenceFlow(source, target)) {
                            remove = true;
                        }

                        if (bpmnRules.canConnectMessageFlow(source, target)) {
                            replacementType = 'bpmn:MessageFlow';
                        }
                    }

                    // transform message flows into sequence flows, if possible

                    if (is(c, 'bpmn:MessageFlow')) {

                        if (!bpmnRules.canConnectMessageFlow(source, target)) {
                            remove = true;
                        }

                        if (bpmnRules.canConnectSequenceFlow(source, target)) {
                            replacementType = 'bpmn:SequenceFlow';
                        }
                    }

                    if (is(c, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {
                        remove = true;
                    }


                    // remove invalid connection
                    if (remove) {
                        modeling.removeConnection(c);
                    }

                    // replace SequenceFlow <> MessageFlow

                    if (replacementType) {
                        modeling.createConnection(source, target, {
                            type: replacementType,
                            waypoints: c.waypoints.slice()
                        }, getSharedParent(source, target));
                    }
                });
            }, true);
        }

        inherits(DropBehavior, CommandInterceptor);

        DropBehavior.$inject = ['eventBus', 'modeling', 'bpmnRules'];

        module.exports = DropBehavior;
    }, {
        "../../../util/ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js",
        "../ModelingUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/ModelingUtil.js",
        "diagram-js/lib/command/CommandInterceptor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/CommandInterceptor.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/ModelingFeedback.js": [function (require, module, exports) {
        'use strict';

        var is = require('../../../util/ModelUtil').is;


        function ModelingFeedback(eventBus, tooltips) {

            function showError(position, message) {
                tooltips.add({
                    position: {
                        x: position.x + 5,
                        y: position.y + 5
                    },
                    type: 'error',
                    timeout: 2000,
                    html: '<div>' + message + '</div>'
                });
            }

            eventBus.on(['shape.move.rejected', 'create.rejected'], function (event) {

                var context = event.context,
                    shape = context.shape,
                    target = context.target;

                if (is(target, 'bpmn:Collaboration') && is(shape, 'bpmn:FlowNode')) {
                    showError(event, 'flow elements must be children of pools/participants');
                }
            });

        }


        ModelingFeedback.$inject = ['eventBus', 'tooltips'];

        module.exports = ModelingFeedback;
    }, {"../../../util/ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/RemoveBehavior.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is;


        /**
         * BPMN specific remove behavior
         */
        function RemoveBehavior(eventBus, modeling) {

            CommandInterceptor.call(this, eventBus);


            /**
             * morph collaboration diagram into process diagram
             * after the last participant has been removed
             */

            this.preExecute('shape.delete', function (context) {

                var shape = context.shape,
                    parent = shape.parent;

                // activate the behavior if the shape to be removed
                // is a participant
                if (is(shape, 'bpmn:Participant')) {
                    context.collaborationRoot = parent;
                }
            }, true);

            this.postExecute('shape.delete', function (context) {

                var collaborationRoot = context.collaborationRoot;

                if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {
                    // replace empty collaboration with process diagram
                    modeling.makeProcess();
                }
            }, true);

        }

        RemoveBehavior.$inject = ['eventBus', 'modeling'];

        inherits(RemoveBehavior, CommandInterceptor);

        module.exports = RemoveBehavior;
    }, {
        "../../../util/ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js",
        "diagram-js/lib/command/CommandInterceptor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/CommandInterceptor.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: [
                'appendBehavior',
                'createBehavior',
                'dropBehavior',
                'removeBehavior',
                'modelingFeedback'
            ],
            appendBehavior: ['type', require('./AppendBehavior')],
            dropBehavior: ['type', require('./DropBehavior')],
            createBehavior: ['type', require('./CreateBehavior')],
            removeBehavior: ['type', require('./RemoveBehavior')],
            modelingFeedback: ['type', require('./ModelingFeedback')]
        };
    }, {
        "./AppendBehavior": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/AppendBehavior.js",
        "./CreateBehavior": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/CreateBehavior.js",
        "./DropBehavior": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/DropBehavior.js",
        "./ModelingFeedback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/ModelingFeedback.js",
        "./RemoveBehavior": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/RemoveBehavior.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/cmd/UpdateCanvasRootHandler.js": [function (require, module, exports) {
        'use strict';

        var Collections = require('diagram-js/lib/util/Collections');


        function UpdateCanvasRootHandler(canvas, modeling) {
            this._canvas = canvas;
            this._modeling = modeling;
        }

        UpdateCanvasRootHandler.$inject = ['canvas', 'modeling'];

        module.exports = UpdateCanvasRootHandler;


        UpdateCanvasRootHandler.prototype.execute = function (context) {

            var canvas = this._canvas;

            var newRoot = context.newRoot,
                newRootBusinessObject = newRoot.businessObject,
                oldRoot = canvas.getRootElement(),
                oldRootBusinessObject = oldRoot.businessObject,
                bpmnDefinitions = oldRootBusinessObject.$parent,
                diPlane = oldRootBusinessObject.di;

            // (1) replace process old <> new root
            canvas.setRootElement(newRoot, true);

            // (2) update root elements
            Collections.add(bpmnDefinitions.rootElements, newRootBusinessObject);
            newRootBusinessObject.$parent = bpmnDefinitions;

            Collections.remove(bpmnDefinitions.rootElements, oldRootBusinessObject);
            oldRootBusinessObject.$parent = null;

            // (3) wire di
            oldRootBusinessObject.di = null;

            diPlane.bpmnElement = newRootBusinessObject;
            newRootBusinessObject.di = diPlane;

            context.oldRoot = oldRoot;
        };


        UpdateCanvasRootHandler.prototype.revert = function (context) {

            var canvas = this._canvas;

            var newRoot = context.newRoot,
                newRootBusinessObject = newRoot.businessObject,
                oldRoot = context.oldRoot,
                oldRootBusinessObject = oldRoot.businessObject,
                bpmnDefinitions = newRootBusinessObject.$parent,
                diPlane = newRootBusinessObject.di;

            // (1) replace process old <> new root
            canvas.setRootElement(oldRoot, true);

            // (2) update root elements
            Collections.remove(bpmnDefinitions.rootElements, newRootBusinessObject);
            newRootBusinessObject.$parent = null;

            Collections.add(bpmnDefinitions.rootElements, oldRootBusinessObject);
            oldRootBusinessObject.$parent = bpmnDefinitions;

            // (3) wire di
            newRootBusinessObject.di = null;

            diPlane.bpmnElement = oldRootBusinessObject;
            oldRootBusinessObject.di = diPlane;
        };
    }, {"diagram-js/lib/util/Collections": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Collections.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/cmd/UpdatePropertiesHandler.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            pick = require('lodash/object/pick'),
            keys = require('lodash/object/keys');

        var DEFAULT_FLOW = 'default',
            NAME = 'name',
            ID = 'id';


        /**
         * A handler that implements a BPMN 2.0 property update.
         *
         * This should be used to set simple properties on elements with
         * an underlying BPMN business object.
         *
         * Use respective diagram-js provided handlers if you would
         * like to perform automated modeling.
         */
        function UpdatePropertiesHandler(elementRegistry) {
            this._elementRegistry = elementRegistry;
        }

        UpdatePropertiesHandler.$inject = ['elementRegistry'];

        module.exports = UpdatePropertiesHandler;


////// api /////////////////////////////////////////////

        /**
         * Updates a BPMN element with a list of new properties
         *
         * @param {Object} context
         * @param {djs.model.Base} context.element the element to update
         * @param {Object} context.properties a list of properties to set on the element's
         *                                    businessObject (the BPMN model element)
         *
         * @return {Array<djs.mode.Base>} the updated element
         */
        UpdatePropertiesHandler.prototype.execute = function (context) {

            var element = context.element,
                changed = [element];

            if (!element) {
                throw new Error('element required');
            }

            var elementRegistry = this._elementRegistry;

            var businessObject = element.businessObject,
                properties = context.properties,
                oldProperties = context.oldProperties || pick(businessObject, keys(properties));

            if (ID in properties) {
                elementRegistry.updateId(element, properties[ID]);
            }

            // correctly indicate visual changes on default flow updates
            if (DEFAULT_FLOW in properties) {

                if (properties[DEFAULT_FLOW]) {
                    changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));
                }

                if (businessObject[DEFAULT_FLOW]) {
                    changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));
                }
            }

            if (NAME in properties && element.label) {
                changed.push(element.label);
            }

            // update properties
            assign(businessObject, properties);


            // store old values
            context.oldProperties = oldProperties;
            context.changed = changed;

            // indicate changed on objects affected by the update
            return changed;
        };

        /**
         * Reverts the update on a BPMN elements properties.
         *
         * @param  {Object} context
         *
         * @return {djs.mode.Base} the updated element
         */
        UpdatePropertiesHandler.prototype.revert = function (context) {

            var element = context.element,
                oldProperties = context.oldProperties,
                businessObject = element.businessObject,
                elementRegistry = this._elementRegistry;

            assign(businessObject, context.oldProperties);

            if (ID in oldProperties) {
                elementRegistry.updateId(element, oldProperties[ID]);
            }

            return context.changed;
        };
    }, {
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "lodash/object/keys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js",
        "lodash/object/pick": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/pick.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['modeling', 'bpmnUpdater', 'labelSupport'],
            __depends__: [
                require('../label-editing'),
                require('./rules'),
                require('./behavior'),
                require('diagram-js/lib/command'),
                require('diagram-js/lib/features/tooltips'),
                require('diagram-js/lib/features/change-support')
            ],
            bpmnFactory: ['type', require('./BpmnFactory')],
            bpmnUpdater: ['type', require('./BpmnUpdater')],
            elementFactory: ['type', require('./ElementFactory')],
            modeling: ['type', require('./Modeling')],
            labelSupport: ['type', require('./LabelSupport')],
            layouter: ['type', require('./BpmnLayouter')],
            connectionDocking: ['type', require('diagram-js/lib/layout/CroppingConnectionDocking')]
        };

    }, {
        "../label-editing": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/label-editing/index.js",
        "./BpmnFactory": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/BpmnFactory.js",
        "./BpmnLayouter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js",
        "./BpmnUpdater": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js",
        "./ElementFactory": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/ElementFactory.js",
        "./LabelSupport": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/LabelSupport.js",
        "./Modeling": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/Modeling.js",
        "./behavior": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/behavior/index.js",
        "./rules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/rules/index.js",
        "diagram-js/lib/command": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/index.js",
        "diagram-js/lib/features/change-support": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/change-support/index.js",
        "diagram-js/lib/features/tooltips": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/tooltips/index.js",
        "diagram-js/lib/layout/CroppingConnectionDocking": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/rules/BpmnRules.js": [function (require, module, exports) {
        'use strict';

        var groupBy = require('lodash/collection/groupBy'),
            size = require('lodash/collection/size'),
            find = require('lodash/collection/find'),
            inherits = require('inherits');

        var getParents = require('../ModelingUtil').getParents,
            is = require('../../../util/ModelUtil').is,
            getBusinessObject = require('../../../util/ModelUtil').getBusinessObject,
            isExpanded = require('../../../util/DiUtil').isExpanded;


        var RuleProvider = require('diagram-js/lib/features/rules/RuleProvider');

        /**
         * BPMN specific modeling rule
         */
        function BpmnRules(eventBus) {
            RuleProvider.call(this, eventBus);
        }

        inherits(BpmnRules, RuleProvider);

        BpmnRules.$inject = ['eventBus'];

        module.exports = BpmnRules;

        BpmnRules.prototype.init = function () {

            this.addRule('connection.create', function (context) {
                var source = context.source,
                    target = context.target;

                return canConnect(source, target);
            });

            this.addRule('connection.reconnectStart', function (context) {

                var connection = context.connection,
                    source = context.hover || context.source,
                    target = connection.target;

                return canConnect(source, target, connection);
            });

            this.addRule('connection.reconnectEnd', function (context) {

                var connection = context.connection,
                    source = connection.source,
                    target = context.hover || context.target;

                return canConnect(source, target, connection);
            });

            this.addRule('connection.updateWaypoints', function (context) {
                // OK! but visually ignore
                return null;
            });

            this.addRule('shape.resize', function (context) {

                var shape = context.shape,
                    newBounds = context.newBounds;

                return canResize(shape, newBounds);
            });

            this.addRule('shapes.move', function (context) {

                var target = context.newParent,
                    shapes = context.shapes;

                return canMove(shapes, target);
            });

            this.addRule(['shape.create', 'shape.append'], function (context) {
                var target = context.parent,
                    shape = context.shape,
                    source = context.source;

                return canCreate(shape, target, source);
            });

        };

        BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;

        BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;

        BpmnRules.prototype.canConnectAssociation = canConnectAssociation;

        BpmnRules.prototype.canMove = canMove;

        BpmnRules.prototype.canDrop = canDrop;

        BpmnRules.prototype.canCreate = canCreate;

        BpmnRules.prototype.canConnect = canConnect;

        BpmnRules.prototype.canResize = canResize;

        /**
         * Utility functions for rule checking
         */

        function nonExistantOrLabel(element) {
            return !element || isLabel(element);
        }

        function isSame(a, b) {
            return a === b;
        }

        function getOrganizationalParent(element) {

            var bo = getBusinessObject(element);

            while (bo && !is(bo, 'bpmn:Process')) {
                if (is(bo, 'bpmn:Participant')) {
                    return bo.processRef || bo;
                }

                bo = bo.$parent;
            }

            return bo;
        }

        function isSameOrganization(a, b) {
            var parentA = getOrganizationalParent(a),
                parentB = getOrganizationalParent(b);

            return parentA === parentB;
        }

        function isMessageFlowSource(element) {
            return is(element, 'bpmn:InteractionNode') && (
                !is(element, 'bpmn:Event') || (
                is(element, 'bpmn:ThrowEvent') &&
                hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')
                )
                );
        }

        function isMessageFlowTarget(element) {
            return is(element, 'bpmn:InteractionNode') && (
                !is(element, 'bpmn:Event') || (
                is(element, 'bpmn:CatchEvent') &&
                hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')
                )
                );
        }

        function getScopeParent(element) {

            var bo = getBusinessObject(element);

            if (is(bo, 'bpmn:Participant')) {
                return null;
            }

            while (bo) {
                bo = bo.$parent;

                if (is(bo, 'bpmn:FlowElementsContainer')) {
                    return bo;
                }
            }

            return bo;
        }

        function isSameScope(a, b) {
            var scopeParentA = getScopeParent(a),
                scopeParentB = getScopeParent(b);

            return scopeParentA && (scopeParentA === scopeParentB);
        }

        function hasEventDefinition(element, eventDefinition) {
            var bo = getBusinessObject(element);

            return !!find(bo.eventDefinitions || [], function (definition) {
                return is(definition, eventDefinition);
            });
        }

        function hasEventDefinitionOrNone(element, eventDefinition) {
            var bo = getBusinessObject(element);

            return (bo.eventDefinitions || []).every(function (definition) {
                return is(definition, eventDefinition);
            });
        }

        function isSequenceFlowSource(element) {
            return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:EndEvent') && !(
                is(element, 'bpmn:IntermediateThrowEvent') &&
                hasEventDefinition(element, 'bpmn:LinkEventDefinition')
                );
        }

        function isSequenceFlowTarget(element) {
            return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:StartEvent') && !(
                is(element, 'bpmn:IntermediateCatchEvent') &&
                hasEventDefinition(element, 'bpmn:LinkEventDefinition')
                );
        }

        function isEventBasedTarget(element) {
            return is(element, 'bpmn:ReceiveTask') || (
                is(element, 'bpmn:IntermediateCatchEvent') && (
                hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||
                hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||
                hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||
                hasEventDefinition(element, 'bpmn:SignalEventDefinition')
                )
                );
        }

        function isLabel(element) {
            return element.labelTarget;
        }

        function isConnection(element) {
            return element.waypoints;
        }

        function isParent(possibleParent, element) {
            var allParents = getParents(element);
            return allParents.indexOf(possibleParent) !== -1;
        }

        function canConnect(source, target, connection) {

            if (nonExistantOrLabel(source) || nonExistantOrLabel(target)) {
                return null;
            }

            // See https://github.com/bpmn-io/bpmn-js/issues/178
            // as a workround we disallow connections with same
            // target and source element.
            // This rule must be removed if a auto layout for this
            // connections is implemented.
            if (isSame(source, target)) {
                return false;
            }

            if (canConnectMessageFlow(source, target) ||
                canConnectSequenceFlow(source, target)) {

                return true;
            }

            if (is(connection, 'bpmn:Association')) {
                return canConnectAssociation(source, target);
            }

            return false;
        }

        /**
         * Can an element be dropped into the target element
         *
         * @return {Boolean}
         */
        function canDrop(element, target) {

            // can move labels everywhere
            if (isLabel(element) && !isConnection(target)) {
                return true;
            }

            // allow to create new participants on
            // on existing collaboration and process diagrams
            if (is(element, 'bpmn:Participant')) {
                return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');
            }

            // drop flow elements onto flow element containers
            // and participants
            if (is(element, 'bpmn:FlowElement')) {
                if (is(target, 'bpmn:FlowElementsContainer')) {
                    return isExpanded(target) !== false;
                }

                return is(target, 'bpmn:Participant');
            }

            if (is(element, 'bpmn:Artifact')) {
                return is(target, 'bpmn:Collaboration') ||
                    is(target, 'bpmn:Participant') ||
                    is(target, 'bpmn:Process');
            }

            if (is(element, 'bpmn:MessageFlow')) {
                return is(target, 'bpmn:Collaboration');
            }

            return false;
        }

        function canMove(elements, target) {

            // only move if they have the same parent
            var sameParent = size(groupBy(elements, function (s) {
                    return s.parent && s.parent.id;
                })) === 1;

            if (!sameParent) {
                return false;
            }

            if (!target) {
                return true;
            }

            return elements.every(function (element) {
                return canDrop(element, target);
            });
        }

        function canCreate(shape, target, source) {

            if (!target) {
                return false;
            }

            if (isLabel(target)) {
                return null;
            }

            if (isSame(source, target)) {
                return false;
            }

            // ensure we do not drop the element
            // into source
            if (source && isParent(source, target)) {
                return false;
            }

            return canDrop(shape, target);
        }

        function canResize(shape, newBounds) {
            if (is(shape, 'bpmn:SubProcess')) {
                return isExpanded(shape) && (
                    !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)
                    );
            }

            if (is(shape, 'bpmn:Participant')) {
                return !newBounds || (newBounds.width >= 100 && newBounds.height >= 80);
            }

            if (is(shape, 'bpmn:TextAnnotation')) {
                return true;
            }

            return false;
        }

        function canConnectAssociation(source, target) {

            // do not connect connections
            if (isConnection(source) || isConnection(target)) {
                return false;
            }

            // connect if different parent
            return !isParent(target, source) && !isParent(source, target);
        }

        function canConnectMessageFlow(source, target) {

            return isMessageFlowSource(source) &&
                isMessageFlowTarget(target) && !isSameOrganization(source, target);
        }

        function canConnectSequenceFlow(source, target) {

            return isSequenceFlowSource(source) &&
                isSequenceFlowTarget(target) &&
                isSameScope(source, target) && !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));
        }
    }, {
        "../../../util/DiUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/DiUtil.js",
        "../../../util/ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js",
        "../ModelingUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/ModelingUtil.js",
        "diagram-js/lib/features/rules/RuleProvider": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/RuleProvider.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js",
        "lodash/collection/find": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/find.js",
        "lodash/collection/groupBy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/groupBy.js",
        "lodash/collection/size": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/size.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/rules/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/rules')
            ],
            __init__: ['bpmnRules'],
            bpmnRules: ['type', require('./BpmnRules')]
        };

    }, {
        "./BpmnRules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/rules/BpmnRules.js",
        "diagram-js/lib/features/rules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/palette/PaletteProvider.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');

        /**
         * A palette provider for BPMN 2.0 elements.
         */
        function PaletteProvider(palette, create, elementFactory, spaceTool, lassoTool) {

            this._create = create;
            this._elementFactory = elementFactory;
            this._spaceTool = spaceTool;
            this._lassoTool = lassoTool;

            palette.registerProvider(this);
        }

        module.exports = PaletteProvider;

        PaletteProvider.$inject = ['palette', 'create', 'elementFactory', 'spaceTool', 'lassoTool'];


        PaletteProvider.prototype.getPaletteEntries = function (element) {

            var actions = {},
                create = this._create,
                elementFactory = this._elementFactory,
                spaceTool = this._spaceTool,
                lassoTool = this._lassoTool;


            function createAction(type, group, className, title, options) {

                function createListener(event) {
                    var shape = elementFactory.createShape(assign({type: type}, options));

                    if (options) {
                        shape.businessObject.di.isExpanded = options.isExpanded;
                    }

                    create.start(event, shape);
                }

                var shortType = type.replace(/^bpmn\:/, '');

                return {
                    group: group,
                    className: className,
                    title: title || 'Create ' + shortType,
                    action: {
                        dragstart: createListener,
                        click: createListener
                    }
                };
            }

            function createParticipant(event, collapsed) {
                create.start(event, elementFactory.createParticipantShape(collapsed));
            }

            assign(actions, {
                'lasso-tool': {
                    group: 'tools',
                    className: 'icon-lasso-tool',
                    title: 'Activate the lasso tool',
                    action: {
                        click: function (event) {
                            lassoTool.activateSelection(event);
                        }
                    }
                },
                'space-tool': {
                    group: 'tools',
                    className: 'icon-space-tool',
                    title: 'Activate the create/remove space tool',
                    action: {
                        click: function (event) {
                            spaceTool.activateSelection(event);
                        }
                    }
                },
                'tool-separator': {
                    group: 'tools',
                    separator: true
                },
                'create.start-event': createAction(
                    'bpmn:StartEvent', 'event', 'icon-start-event-none'
                ),
                'create.intermediate-event': createAction(
                    'bpmn:IntermediateThrowEvent', 'event', 'icon-intermediate-event-none'
                ),
                'create.end-event': createAction(
                    'bpmn:EndEvent', 'event', 'icon-end-event-none'
                ),
                'create.exclusive-gateway': createAction(
                    'bpmn:ExclusiveGateway', 'gateway', 'icon-gateway-xor'
                ),
                'create.task': createAction(
                    'bpmn:Task', 'activity', 'icon-task'
                ),
                'create.subprocess-collapsed': createAction(
                    'bpmn:SubProcess', 'activity', 'icon-subprocess-collapsed', 'Create collapsed Sub Process',
                    {isExpanded: false}
                ),
                'create.subprocess-expanded': createAction(
                    'bpmn:SubProcess', 'activity', 'icon-subprocess-expanded', 'Create expanded SubProcess',
                    {isExpanded: true}
                ),
                'create.participant-expanded': {
                    group: 'collaboration',
                    className: 'icon-participant',
                    title: 'Create Pool/Participant',
                    action: {
                        dragstart: createParticipant,
                        click: createParticipant
                    }
                }
            });

            return actions;
        };

    }, {"lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/palette/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/palette'),
                require('diagram-js/lib/features/create')
            ],
            __init__: ['paletteProvider'],
            paletteProvider: ['type', require('./PaletteProvider')]
        };

    }, {
        "./PaletteProvider": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/palette/PaletteProvider.js",
        "diagram-js/lib/features/create": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/create/index.js",
        "diagram-js/lib/features/palette": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/palette/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/replace/BpmnReplace.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter');

        var REPLACE_OPTIONS = require('./ReplaceOptions');

        var startEventReplace = REPLACE_OPTIONS.START_EVENT,
            intermediateEventReplace = REPLACE_OPTIONS.INTERMEDIATE_EVENT,
            endEventReplace = REPLACE_OPTIONS.END_EVENT,
            gatewayReplace = REPLACE_OPTIONS.GATEWAY,
            taskReplace = REPLACE_OPTIONS.TASK;


        /**
         * A replace menu provider that gives users the controls to choose
         * and replace BPMN elements with each other.
         *
         * @param {BpmnFactory} bpmnFactory
         * @param {Moddle} moddle
         * @param {PopupMenu} popupMenu
         * @param {Replace} replace
         */
        function BpmnReplace(bpmnFactory, moddle, popupMenu, replace, selection) {

            /**
             * Prepares a new business object for the replacement element
             * and triggers the replace operation.
             *
             * @param  {djs.model.Base} element
             * @param  {Object} target
             * @return {djs.model.Base} the newly created element
             */
            function replaceElement(element, target) {

                var type = target.type,
                    oldBusinessObject = element.businessObject,
                    businessObject = bpmnFactory.create(type);

                var newElement = {
                    type: type,
                    businessObject: businessObject
                };

                // initialize custom BPMN extensions

                if (target.eventDefinition) {
                    var eventDefinitions = businessObject.get('eventDefinitions'),
                        eventDefinition = moddle.create(target.eventDefinition);

                    eventDefinitions.push(eventDefinition);
                }

                if (target.instantiate !== undefined) {
                    businessObject.instantiate = target.instantiate;
                }

                if (target.eventGatewayType !== undefined) {
                    businessObject.eventGatewayType = target.eventGatewayType;
                }

                // copy size (for activities only)
                if (oldBusinessObject.$instanceOf('bpmn:Activity')) {

                    // TODO: need also to respect min/max Size

                    newElement.width = element.width;
                    newElement.height = element.height;
                }

                // TODO: copy other elligable properties from old business object
                businessObject.name = oldBusinessObject.name;

                newElement = replace.replaceElement(element, newElement);

                selection.select(newElement);

                return newElement;
            }


            function getReplaceOptions(element) {

                var menuEntries = [];
                var businessObject = element.businessObject;

                if (businessObject.$instanceOf('bpmn:StartEvent')) {
                    addEntries(startEventReplace, filterEvents);
                } else if (businessObject.$instanceOf('bpmn:IntermediateCatchEvent') ||
                    businessObject.$instanceOf('bpmn:IntermediateThrowEvent')) {

                    addEntries(intermediateEventReplace, filterEvents);
                } else if (businessObject.$instanceOf('bpmn:EndEvent')) {

                    addEntries(endEventReplace, filterEvents);
                } else if (businessObject.$instanceOf('bpmn:Gateway')) {

                    addEntries(gatewayReplace, function (entry) {

                        return entry.target.type !== businessObject.$type;
                    });
                } else if (businessObject.$instanceOf('bpmn:FlowNode')) {
                    addEntries(taskReplace, function (entry) {
                        return entry.target.type !== businessObject.$type;
                    });
                }

                function filterEvents(entry) {

                    var target = entry.target;

                    var eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0].$type;
                    var isEventDefinitionEqual = target.eventDefinition == eventDefinition;
                    var isEventTypeEqual = businessObject.$type == target.type;

                    return ((!isEventDefinitionEqual && isEventTypeEqual) || !isEventTypeEqual) || !(isEventDefinitionEqual && isEventTypeEqual);
                }

                function addEntries(entries, filterFun) {
                    // Filter selected type from the array
                    var filteredEntries = filter(entries, filterFun);

                    // Add entries to replace menu
                    forEach(filteredEntries, function (definition) {

                        var entry = addMenuEntry(definition);
                        menuEntries.push(entry);
                    });
                }

                function addMenuEntry(definition) {

                    return {
                        label: definition.label,
                        className: definition.className,
                        action: {
                            name: definition.actionName,
                            handler: function () {
                                replaceElement(element, definition.target);
                            }
                        }
                    };
                }

                return menuEntries;
            }


            // API

            this.openChooser = function (position, element) {
                var entries = this.getReplaceOptions(element);

                popupMenu.open('replace-menu', position, entries);
            };

            this.getReplaceOptions = getReplaceOptions;

            this.replaceElement = replaceElement;
        }

        BpmnReplace.$inject = ['bpmnFactory', 'moddle', 'popupMenu', 'replace', 'selection'];

        module.exports = BpmnReplace;
    }, {
        "./ReplaceOptions": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/replace/ReplaceOptions.js",
        "lodash/collection/filter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/filter.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/replace/ReplaceOptions.js": [function (require, module, exports) {
        'use strict';

        module.exports.START_EVENT = [
            {
                label: 'Start Event',
                actionName: 'replace-with-none-start',
                className: 'icon-start-event-none',
                target: {
                    type: 'bpmn:StartEvent'
                }
            },
            {
                label: 'Intermediate Throw Event',
                actionName: 'replace-with-intermediate-throwing',
                className: 'icon-intermediate-event-none',
                target: {
                    type: 'bpmn:IntermediateThrowEvent'
                }
            },
            {
                label: 'End Event',
                actionName: 'replace-with-message-end',
                className: 'icon-end-event-none',
                target: {
                    type: 'bpmn:EndEvent'
                }
            },
            {
                label: 'Message Start Event',
                actionName: 'replace-with-message-start',
                className: 'icon-start-event-message',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinition: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Timer Start Event',
                actionName: 'replace-with-timer-start',
                className: 'icon-start-event-timer',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinition: 'bpmn:TimerEventDefinition'
                }
            },
            {
                label: 'Conditional Start Event',
                actionName: 'replace-with-conditional-start',
                className: 'icon-start-event-condition',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinition: 'bpmn:ConditionalEventDefinition'
                }
            },
            {
                label: 'Signal Start Event',
                actionName: 'replace-with-signal-start',
                className: 'icon-start-event-signal',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinition: 'bpmn:SignalEventDefinition'
                }
            }
        ];

        module.exports.INTERMEDIATE_EVENT = [
            {
                label: 'Start Event',
                actionName: 'replace-with-none-start',
                className: 'icon-start-event-none',
                target: {
                    type: 'bpmn:StartEvent'
                }
            },
            {
                label: 'Intermediate Throw Event',
                actionName: 'replace-with-message-intermediate-throw',
                className: 'icon-intermediate-event-none',
                target: {
                    type: 'bpmn:IntermediateThrowEvent'
                }
            },
            {
                label: 'End Event',
                actionName: 'replace-with-message-end',
                className: 'icon-end-event-none',
                target: {
                    type: 'bpmn:EndEvent'
                }
            },
            {
                label: 'Message Intermediate Catch Event',
                actionName: 'replace-with-intermediate-catch',
                className: 'icon-intermediate-event-catch-message',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinition: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Message Intermediate Throw Event',
                actionName: 'replace-with-intermediate-throw',
                className: 'icon-intermediate-event-throw-message',
                target: {
                    type: 'bpmn:IntermediateThrowEvent',
                    eventDefinition: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Timer Intermediate Catch Event',
                actionName: 'replace-with-timer-intermediate-catch',
                className: 'icon-intermediate-event-catch-timer',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinition: 'bpmn:TimerEventDefinition'
                }
            },
            {
                label: 'Escalation Intermediate Catch Event',
                actionName: 'replace-with-escalation-catch',
                className: 'icon-intermediate-event-catch-escalation',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinition: 'bpmn:EscalationEventDefinition'
                }
            },
            {
                label: 'Conditional Intermediate Catch Event',
                actionName: 'replace-with-conditional-intermediate-catch',
                className: 'icon-intermediate-event-catch-condition',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinition: 'bpmn:ConditionalEventDefinition'
                }
            },
            {
                label: 'Link Intermediate Catch Event',
                actionName: 'replace-with-link-intermediate-catch',
                className: 'icon-intermediate-event-catch-link',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinition: 'bpmn:LinkEventDefinition'
                }
            },
            {
                label: 'Link Intermediate Throw Event',
                actionName: 'replace-with-link-intermediate-throw',
                className: 'icon-intermediate-event-throw-link',
                target: {
                    type: 'bpmn:IntermediateThrowEvent',
                    eventDefinition: 'bpmn:LinkEventDefinition'
                }
            },
            {
                label: 'Compensation Intermediate Throw Event',
                actionName: 'replace-with-compensation-intermediate-throw',
                className: 'icon-intermediate-event-throw-compensation',
                target: {
                    type: 'bpmn:IntermediateThrowEvent',
                    eventDefinition: 'bpmn:CompensateEventDefinition'
                }
            },
            {
                label: 'Signal Throw Catch Event',
                actionName: 'replace-with-throw-intermediate-catch',
                className: 'icon-intermediate-event-catch-signal',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinition: 'bpmn:SignalEventDefinition'
                }
            },
            {
                label: 'Signal Intermediate Throw Event',
                actionName: 'replace-with-signal-intermediate-throw',
                className: 'icon-intermediate-event-throw-signal',
                target: {
                    type: 'bpmn:IntermediateThrowEvent',
                    eventDefinition: 'bpmn:SignalEventDefinition'
                }
            }
        ];

        module.exports.END_EVENT = [
            {
                label: 'Start Event',
                actionName: 'replace-with-none-start',
                className: 'icon-start-event-none',
                target: {
                    type: 'bpmn:StartEvent'
                }
            },
            {
                label: 'Intermediate Throw Event',
                actionName: 'replace-with-message-intermediate-throw',
                className: 'icon-intermediate-event-none',
                target: {
                    type: 'bpmn:IntermediateThrowEvent'
                }
            },
            {
                label: 'End Event',
                actionName: 'replace-with-none-end',
                className: 'icon-end-event-none',
                target: {
                    type: 'bpmn:EndEvent'
                }
            },
            {
                label: 'Message End Event',
                actionName: 'replace-with-message-end',
                className: 'icon-end-event-message',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinition: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Escalation End Event',
                actionName: 'replace-with-escalation-end',
                className: 'icon-end-event-escalation',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinition: 'bpmn:EscalationEventDefinition'
                }
            },
            {
                label: 'Error End Event',
                actionName: 'replace-with-error-end',
                className: 'icon-end-event-error',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinition: 'bpmn:ErrorEventDefinition'
                }
            },
            {
                label: 'Cancel End Event',
                actionName: 'replace-with-cancel-end',
                className: 'icon-end-event-cancel',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinition: 'bpmn:CancelEventDefinition'
                }
            },
            {
                label: 'Compensation End Event',
                actionName: 'replace-with-compensation-end',
                className: 'icon-end-event-compensation',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinition: 'bpmn:CompensateEventDefinition'
                }
            },
            {
                label: 'Signal End Event',
                actionName: 'replace-with-signal-end',
                className: 'icon-end-event-signal',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinition: 'bpmn:SignalEventDefinition'
                }
            },
            {
                label: 'Terminate End Event',
                actionName: 'replace-with-terminate-end',
                className: 'icon-end-event-terminate',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinition: 'bpmn:TerminateEventDefinition'
                }
            }
        ];

        module.exports.GATEWAY = [
            {
                label: 'Exclusive Gateway',
                actionName: 'replace-with-exclusive-gateway',
                className: 'icon-gateway-xor',
                target: {
                    type: 'bpmn:ExclusiveGateway'
                }
            },
            {
                label: 'Parallel Gateway',
                actionName: 'replace-with-parallel-gateway',
                className: 'icon-gateway-parallel',
                target: {
                    type: 'bpmn:ParallelGateway'
                }
            },
            {
                label: 'Inclusive Gateway',
                actionName: 'replace-with-inclusive-gateway',
                className: 'icon-gateway-or',
                target: {
                    type: 'bpmn:InclusiveGateway'
                }
            },
            {
                label: 'Complex Gateway',
                actionName: 'replace-with-complex-gateway',
                className: 'icon-gateway-complex',
                target: {
                    type: 'bpmn:ComplexGateway'
                }
            },
            {
                label: 'Event based Gateway',
                actionName: 'replace-with-event-based-gateway',
                className: 'icon-gateway-eventbased',
                target: {
                    type: 'bpmn:EventBasedGateway',
                    instantiate: false,
                    eventGatewayType: 'Exclusive'
                }
            }
            // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194
            // {
            //   label: 'Event based instantiating Gateway',
            //   actionName: 'replace-with-exclusive-event-based-gateway',
            //   className: 'icon-exclusive-event-based',
            //   target: {
            //     type: 'bpmn:EventBasedGateway'
            //   },
            //   options: {
            //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }
            //   }
            // },
            // {
            //   label: 'Parallel Event based instantiating Gateway',
            //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',
            //   className: 'icon-parallel-event-based-instantiate-gateway',
            //   target: {
            //     type: 'bpmn:EventBasedGateway'
            //   },
            //   options: {
            //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }
            //   }
            // }
        ];


        module.exports.TASK = [
            {
                label: 'Task',
                actionName: 'replace-with-task',
                className: 'icon-task',
                target: {
                    type: 'bpmn:Task'
                }
            },
            {
                label: 'Send Task',
                actionName: 'replace-with-send-task',
                className: 'icon-send',
                target: {
                    type: 'bpmn:SendTask'
                }
            },
            {
                label: 'Receive Task',
                actionName: 'replace-with-receive-task',
                className: 'icon-receive',
                target: {
                    type: 'bpmn:ReceiveTask'
                }
            },
            {
                label: 'User Task',
                actionName: 'replace-with-user-task',
                className: 'icon-user',
                target: {
                    type: 'bpmn:UserTask'
                }
            },
            {
                label: 'Manual Task',
                actionName: 'replace-with-manual-task',
                className: 'icon-manual',
                target: {
                    type: 'bpmn:ManualTask'
                }
            },
            {
                label: 'Business Rule Task',
                actionName: 'replace-with-rule-task',
                className: 'icon-business-rule',
                target: {
                    type: 'bpmn:BusinessRuleTask'
                }
            },
            {
                label: 'Service Task',
                actionName: 'replace-with-service-task',
                className: 'icon-service',
                target: {
                    type: 'bpmn:ServiceTask'
                }
            },
            {
                label: 'Script Task',
                actionName: 'replace-with-script-task',
                className: 'icon-script',
                target: {
                    type: 'bpmn:ScriptTask'
                }
            }
        ];
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/replace/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/popup-menu'),
                require('diagram-js/lib/features/replace'),
                require('diagram-js/lib/features/selection')
            ],
            bpmnReplace: ['type', require('./BpmnReplace')]
        };
    }, {
        "./BpmnReplace": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/replace/BpmnReplace.js",
        "diagram-js/lib/features/popup-menu": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/popup-menu/index.js",
        "diagram-js/lib/features/replace": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/replace/index.js",
        "diagram-js/lib/features/selection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/snapping/BpmnSnapping.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var forEach = require('lodash/collection/forEach');

        var getBoundingBox = require('diagram-js/lib/util/Elements').getBBox;
        var is = require('../modeling/ModelingUtil').is;

        var Snapping = require('diagram-js/lib/features/snapping/Snapping'),
            SnapUtil = require('diagram-js/lib/features/snapping/SnapUtil');

        var is = require('../../util/ModelUtil').is;

        var mid = SnapUtil.mid,
            topLeft = SnapUtil.topLeft,
            bottomRight = SnapUtil.bottomRight;

        var round = Math.round;


        /**
         * BPMN specific snapping functionality
         *
         *  * snap on process elements if a pool is created inside a
         *    process diagram
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         */
        function BpmnSnapping(eventBus, canvas) {

            // instantiate super
            Snapping.call(this, eventBus, canvas);


            /**
             * Drop participant on process <> process elements snapping
             */

            function initParticipantSnapping(context, shape, elements) {

                if (!elements.length) {
                    return;
                }

                var snapBox = getBoundingBox(elements.filter(function (e) {
                    return !e.labelTarget && !e.waypoints;
                }));

                snapBox.x -= 50;
                snapBox.y -= 20;
                snapBox.width += 70;
                snapBox.height += 40;

                // adjust shape height to include bounding box
                shape.width = Math.max(shape.width, snapBox.width);
                shape.height = Math.max(shape.height, snapBox.height);

                context.participantSnapBox = snapBox;
            }

            function snapParticipant(snapBox, shape, event) {

                var shapeHalfWidth = shape.width / 2 - 30,
                    shapeHalfHeight = shape.height / 2;

                var currentTopLeft = {
                    x: event.x - shapeHalfWidth - 30,
                    y: event.y - shapeHalfHeight
                };

                var currentBottomRight = {
                    x: event.x + shapeHalfWidth + 30,
                    y: event.y + shapeHalfHeight
                };

                var snapTopLeft = snapBox,
                    snapBottomRight = bottomRight(snapBox);

                if (currentTopLeft.x >= snapTopLeft.x) {
                    event.x = snapTopLeft.x + 30 + shapeHalfWidth;
                    event.snapped = true;
                } else if (currentBottomRight.x <= snapBottomRight.x) {
                    event.x = snapBottomRight.x - 30 - shapeHalfWidth;
                    event.snapped = true;
                }

                if (currentTopLeft.y >= snapTopLeft.y) {
                    event.y = snapTopLeft.y + shapeHalfHeight;
                    event.snapped = true;
                } else if (currentBottomRight.y <= snapBottomRight.y) {
                    event.y = snapBottomRight.y - shapeHalfHeight;
                    event.snapped = true;
                }
            }

            eventBus.on('create.start', function (event) {

                var context = event.context,
                    shape = context.shape,
                    rootElement = canvas.getRootElement();

                // snap participant around existing elements (if any)
                if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {

                    initParticipantSnapping(context, shape, rootElement.children);
                }
            });

            eventBus.on(['create.move', 'create.end'], 1500, function (event) {

                var context = event.context,
                    shape = context.shape,
                    participantSnapBox = context.participantSnapBox;

                if (!event.snapped && participantSnapBox) {
                    snapParticipant(participantSnapBox, shape, event);
                }
            });

            eventBus.on('resize.start', 1500, function (event) {
                var context = event.context,
                    shape = context.shape;

                if (is(shape, 'bpmn:SubProcess')) {
                    context.minDimensions = {width: 140, height: 120};
                }

                if (is(shape, 'bpmn:Participant')) {
                    context.minDimensions = {width: 400, height: 200};
                }

                if (is(shape, 'bpmn:TextAnnotation')) {
                    context.minDimensions = {width: 50, height: 50};
                }
            });

        }

        inherits(BpmnSnapping, Snapping);

        BpmnSnapping.$inject = ['eventBus', 'canvas'];

        module.exports = BpmnSnapping;


        BpmnSnapping.prototype.initSnap = function (event) {

            var context = event.context,
                shape = context.shape,
                shapeMid,
                shapeBounds,
                shapeTopLeft,
                shapeBottomRight,
                snapContext;


            snapContext = Snapping.prototype.initSnap.call(this, event);

            if (is(shape, 'bpmn:Participant')) {
                // assign higher priority for outer snaps on participants
                snapContext.setSnapLocations(['top-left', 'bottom-right', 'mid']);
            }


            if (shape) {

                shapeMid = mid(shape, event);

                shapeBounds = {
                    width: shape.width,
                    height: shape.height,
                    x: isNaN(shape.x) ? round(shapeMid.x - shape.width / 2) : shape.x,
                    y: isNaN(shape.y) ? round(shapeMid.y - shape.height / 2) : shape.y,
                };

                shapeTopLeft = topLeft(shapeBounds);
                shapeBottomRight = bottomRight(shapeBounds);

                snapContext.setSnapOrigin('top-left', {
                    x: shapeTopLeft.x - event.x,
                    y: shapeTopLeft.y - event.y
                });

                snapContext.setSnapOrigin('bottom-right', {
                    x: shapeBottomRight.x - event.x,
                    y: shapeBottomRight.y - event.y
                });


                forEach(shape.outgoing, function (c) {
                    var docking = c.waypoints[0];

                    docking = docking.original || docking;

                    snapContext.setSnapOrigin(c.id + '-docking', {
                        x: docking.x - event.x,
                        y: docking.y - event.y
                    });
                });

                forEach(shape.incoming, function (c) {
                    var docking = c.waypoints[c.waypoints.length - 1];

                    docking = docking.original || docking;

                    snapContext.setSnapOrigin(c.id + '-docking', {
                        x: docking.x - event.x,
                        y: docking.y - event.y
                    });
                });

            }

            var source = context.source;

            if (source) {
                snapContext.addDefaultSnap('mid', mid(source));
            }
        };


        BpmnSnapping.prototype.addTargetSnaps = function (snapPoints, shape, target) {

            var siblings = this.getSiblings(shape, target);


            forEach(siblings, function (s) {
                snapPoints.add('mid', mid(s));

                if (is(s, 'bpmn:Participant')) {
                    snapPoints.add('top-left', topLeft(s));
                    snapPoints.add('bottom-right', bottomRight(s));
                }
            });

            forEach(shape.incoming, function (c) {

                if (siblings.indexOf(c.source) === -1) {
                    snapPoints.add('mid', mid(c.source));

                    var docking = c.waypoints[0];
                    snapPoints.add(c.id + '-docking', docking.original || docking);
                }
            });


            forEach(shape.outgoing, function (c) {

                if (siblings.indexOf(c.target) === -1) {
                    snapPoints.add('mid', mid(c.target));

                    var docking = c.waypoints[c.waypoints.length - 1];
                    snapPoints.add(c.id + '-docking', docking.original || docking);
                }
            });

        };
    }, {
        "../../util/ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js",
        "../modeling/ModelingUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/modeling/ModelingUtil.js",
        "diagram-js/lib/features/snapping/SnapUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/snapping/SnapUtil.js",
        "diagram-js/lib/features/snapping/Snapping": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/snapping/Snapping.js",
        "diagram-js/lib/util/Elements": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Elements.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/snapping/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['snapping'],
            snapping: ['type', require('./BpmnSnapping')]
        };
    }, {"./BpmnSnapping": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/features/snapping/BpmnSnapping.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/BpmnImporter.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            map = require('lodash/collection/map');

        var LabelUtil = require('../util/LabelUtil');

        var hasExternalLabel = LabelUtil.hasExternalLabel,
            getExternalLabelBounds = LabelUtil.getExternalLabelBounds,
            isExpanded = require('../util/DiUtil').isExpanded,
            elementToString = require('./Util').elementToString;


        function elementData(semantic, attrs) {
            return assign({
                id: semantic.id,
                type: semantic.$type,
                businessObject: semantic
            }, attrs);
        }

        function collectWaypoints(waypoints) {
            return map(waypoints, function (p) {
                return {x: p.x, y: p.y};
            });
        }


        /**
         * An importer that adds bpmn elements to the canvas
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         * @param {ElementFactory} elementFactory
         * @param {ElementRegistry} elementRegistry
         */
        function BpmnImporter(eventBus, canvas, elementFactory, elementRegistry) {
            this._eventBus = eventBus;
            this._canvas = canvas;

            this._elementFactory = elementFactory;
            this._elementRegistry = elementRegistry;
        }

        BpmnImporter.$inject = ['eventBus', 'canvas', 'elementFactory', 'elementRegistry'];

        module.exports = BpmnImporter;


        /**
         * Add bpmn element (semantic) to the canvas onto the
         * specified parent shape.
         */
        BpmnImporter.prototype.add = function (semantic, parentElement) {

            var di = semantic.di,
                element;

            // ROOT ELEMENT
            // handle the special case that we deal with a
            // invisible root element (process or collaboration)
            if (di.$instanceOf('bpmndi:BPMNPlane')) {

                // add a virtual element (not being drawn)
                element = this._elementFactory.createRoot(elementData(semantic));

                this._canvas.setRootElement(element);
            }

            // SHAPE
            else if (di.$instanceOf('bpmndi:BPMNShape')) {

                var collapsed = !isExpanded(semantic);
                var hidden = parentElement && (parentElement.hidden || parentElement.collapsed);

                var bounds = semantic.di.bounds;

                element = this._elementFactory.createShape(elementData(semantic, {
                    collapsed: collapsed,
                    hidden: hidden,
                    x: Math.round(bounds.x),
                    y: Math.round(bounds.y),
                    width: Math.round(bounds.width),
                    height: Math.round(bounds.height)
                }));

                this._canvas.addShape(element, parentElement);
            }

            // CONNECTION
            else if (di.$instanceOf('bpmndi:BPMNEdge')) {

                var source = this._getSource(semantic),
                    target = this._getTarget(semantic);

                element = this._elementFactory.createConnection(elementData(semantic, {
                    source: source,
                    target: target,
                    waypoints: collectWaypoints(semantic.di.waypoint)
                }));

                this._canvas.addConnection(element, parentElement);
            } else {
                throw new Error('unknown di ' + elementToString(di) + ' for element ' + elementToString(semantic));
            }

            // (optional) LABEL
            if (hasExternalLabel(semantic)) {
                this.addLabel(semantic, element);
            }


            this._eventBus.fire('bpmnElement.added', {element: element});

            return element;
        };


        /**
         * add label for an element
         */
        BpmnImporter.prototype.addLabel = function (semantic, element) {
            var bounds = getExternalLabelBounds(semantic, element);

            var label = this._elementFactory.createLabel(elementData(semantic, {
                id: semantic.id + '_label',
                labelTarget: element,
                type: 'label',
                hidden: element.hidden,
                x: Math.round(bounds.x),
                y: Math.round(bounds.y),
                width: Math.round(bounds.width),
                height: Math.round(bounds.height)
            }));

            return this._canvas.addShape(label, element.parent);
        };

        /**
         * Return the drawn connection end based on the given side.
         *
         * @throws {Error} if the end is not yet drawn
         */
        BpmnImporter.prototype._getEnd = function (semantic, side) {

            var element,
                refSemantic,
                type = semantic.$type;

            refSemantic = semantic[side + 'Ref'];

            // handle mysterious isMany DataAssociation#sourceRef
            if (side === 'source' && type === 'bpmn:DataInputAssociation') {
                refSemantic = refSemantic && refSemantic[0];
            }

            // fix source / target for DataInputAssociation / DataOutputAssociation
            if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||
                side === 'target' && type === 'bpmn:DataInputAssociation') {

                refSemantic = semantic.$parent;
            }

            element = refSemantic && this._getElement(refSemantic);

            if (element) {
                return element;
            }

            if (refSemantic) {
                throw new Error(
                    'element ' + elementToString(refSemantic) + ' referenced by ' +
                    elementToString(semantic) + '#' + side + 'Ref not yet drawn');
            } else {
                throw new Error(elementToString(semantic) + '#' + side + 'Ref not specified');
            }
        };

        BpmnImporter.prototype._getSource = function (semantic) {
            return this._getEnd(semantic, 'source');
        };

        BpmnImporter.prototype._getTarget = function (semantic) {
            return this._getEnd(semantic, 'target');
        };


        BpmnImporter.prototype._getElement = function (semantic) {
            return this._elementRegistry.get(semantic.id);
        };

    }, {
        "../util/DiUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/DiUtil.js",
        "../util/LabelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/LabelUtil.js",
        "./Util": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/Util.js",
        "lodash/collection/map": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/map.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/BpmnTreeWalker.js": [function (require, module, exports) {
        'use strict';

        var filter = require('lodash/collection/filter'),
            find = require('lodash/collection/find'),
            forEach = require('lodash/collection/forEach');

        var Refs = require('object-refs');

        var elementToString = require('./Util').elementToString;

        var diRefs = new Refs({name: 'bpmnElement', enumerable: true}, {name: 'di'});

        /**
         * Returns true if an element has the given meta-model type
         *
         * @param  {ModdleElement}  element
         * @param  {String}         type
         *
         * @return {Boolean}
         */
        function is(element, type) {
            return element.$instanceOf(type);
        }


        /**
         * Find a suitable display candidate for definitions where the DI does not
         * correctly specify one.
         */
        function findDisplayCandidate(definitions) {
            return find(definitions.rootElements, function (e) {
                return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');
            });
        }


        function BpmnTreeWalker(handler) {

            // list of containers already walked
            var handledProcesses = [];

            // list of elements to handle deferred to ensure
            // prerequisites are drawn
            var deferred = [];

            ///// Helpers /////////////////////////////////

            function contextual(fn, ctx) {
                return function (e) {
                    fn(e, ctx);
                };
            }

            function visit(element, ctx) {

                var gfx = element.gfx;

                // avoid multiple rendering of elements
                if (gfx) {
                    throw new Error('already rendered ' + elementToString(element));
                }

                // call handler
                return handler.element(element, ctx);
            }

            function visitRoot(element, diagram) {
                return handler.root(element, diagram);
            }

            function visitIfDi(element, ctx) {
                try {
                    return element.di && visit(element, ctx);
                } catch (e) {
                    logError(e.message, {element: element, error: e});

                    console.error('failed to import ' + elementToString(element));
                    console.error(e);
                }
            }

            function logError(message, context) {
                handler.error(message, context);
            }

            ////// DI handling ////////////////////////////

            function registerDi(di) {
                var bpmnElement = di.bpmnElement;

                if (bpmnElement) {
                    if (bpmnElement.di) {
                        logError('multiple DI elements defined for ' + elementToString(bpmnElement), {element: bpmnElement});
                    } else {
                        diRefs.bind(bpmnElement, 'di');
                        bpmnElement.di = di;
                    }
                } else {
                    logError('no bpmnElement referenced in ' + elementToString(di), {element: di});
                }
            }

            function handleDiagram(diagram) {
                handlePlane(diagram.plane);
            }

            function handlePlane(plane) {
                registerDi(plane);

                forEach(plane.planeElement, handlePlaneElement);
            }

            function handlePlaneElement(planeElement) {
                registerDi(planeElement);
            }


            ////// Semantic handling //////////////////////

            function handleDefinitions(definitions, diagram) {
                // make sure we walk the correct bpmnElement

                var diagrams = definitions.diagrams;

                if (diagram && diagrams.indexOf(diagram) === -1) {
                    throw new Error('diagram not part of bpmn:Definitions');
                }

                if (!diagram && diagrams && diagrams.length) {
                    diagram = diagrams[0];
                }

                // no diagram -> nothing to import
                if (!diagram) {
                    return;
                }

                // load DI from selected diagram only
                handleDiagram(diagram);


                var plane = diagram.plane;

                if (!plane) {
                    throw new Error('no plane for ' + elementToString(diagram));
                }


                var rootElement = plane.bpmnElement;

                // ensure we default to a suitable display candidate (process or collaboration),
                // even if non is specified in DI
                if (!rootElement) {
                    rootElement = findDisplayCandidate(definitions);

                    if (!rootElement) {
                        return logError('no process or collaboration present to display');
                    } else {

                        logError('correcting missing bpmnElement on ' + elementToString(plane) + ' to ' + elementToString(rootElement));

                        // correct DI on the fly
                        plane.bpmnElement = rootElement;
                        registerDi(plane);
                    }
                }


                var ctx = visitRoot(rootElement, plane);

                if (is(rootElement, 'bpmn:Process')) {
                    handleProcess(rootElement, ctx);
                } else if (is(rootElement, 'bpmn:Collaboration')) {
                    handleCollaboration(rootElement, ctx);

                    // force drawing of everything not yet drawn that is part of the target DI
                    handleUnhandledProcesses(definitions.rootElements, ctx);
                } else {
                    throw new Error('unsupported bpmnElement for ' + elementToString(plane) + ' : ' + elementToString(rootElement));
                }

                // handle all deferred elements
                handleDeferred(deferred);
            }

            function handleDeferred(deferred) {
                forEach(deferred, function (d) {
                    d();
                });
            }

            function handleProcess(process, context) {
                handleFlowElementsContainer(process, context);
                handleIoSpecification(process.ioSpecification, context);

                handleArtifacts(process.artifacts, context);

                // log process handled
                handledProcesses.push(process);
            }

            function handleUnhandledProcesses(rootElements) {

                // walk through all processes that have not yet been drawn and draw them
                // if they contain lanes with DI information.
                // we do this to pass the free-floating lane test cases in the MIWG test suite
                var processes = filter(rootElements, function (e) {
                    return is(e, 'bpmn:Process') && e.laneSets && handledProcesses.indexOf(e) === -1;
                });

                processes.forEach(contextual(handleProcess));
            }

            function handleMessageFlow(messageFlow, context) {
                visitIfDi(messageFlow, context);
            }

            function handleMessageFlows(messageFlows, context) {
                forEach(messageFlows, contextual(handleMessageFlow, context));
            }

            function handleDataAssociation(association, context) {
                visitIfDi(association, context);
            }

            function handleDataInput(dataInput, context) {
                visitIfDi(dataInput, context);
            }

            function handleDataOutput(dataOutput, context) {
                visitIfDi(dataOutput, context);
            }

            function handleArtifact(artifact, context) {

                // bpmn:TextAnnotation
                // bpmn:Group
                // bpmn:Association

                visitIfDi(artifact, context);
            }

            function handleArtifacts(artifacts, context) {

                forEach(artifacts, function (e) {
                    if (is(e, 'bpmn:Association')) {
                        deferred.push(function () {
                            handleArtifact(e, context);
                        });
                    } else {
                        handleArtifact(e, context);
                    }
                });
            }

            function handleIoSpecification(ioSpecification, context) {

                if (!ioSpecification) {
                    return;
                }

                forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));
                forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));
            }

            function handleSubProcess(subProcess, context) {
                handleFlowElementsContainer(subProcess, context);
                handleArtifacts(subProcess.artifacts, context);
            }

            function handleFlowNode(flowNode, context) {
                var childCtx = visitIfDi(flowNode, context);

                if (is(flowNode, 'bpmn:SubProcess')) {
                    handleSubProcess(flowNode, childCtx || context);
                }
            }

            function handleSequenceFlow(sequenceFlow, context) {
                visitIfDi(sequenceFlow, context);
            }

            function handleDataElement(dataObject, context) {
                visitIfDi(dataObject, context);
            }

            function handleBoundaryEvent(dataObject, context) {
                visitIfDi(dataObject, context);
            }

            function handleLane(lane, context) {
                var newContext = visitIfDi(lane, context);

                if (lane.childLaneSet) {
                    handleLaneSet(lane.childLaneSet, newContext || context);
                } else {
                    var filterList = filter(lane.flowNodeRef, function (e) {
                        return e.$type !== 'bpmn:BoundaryEvent';
                    });
                    handleFlowElements(filterList, newContext || context);
                }
            }

            function handleLaneSet(laneSet, context) {
                forEach(laneSet.lanes, contextual(handleLane, context));
            }

            function handleLaneSets(laneSets, context) {
                forEach(laneSets, contextual(handleLaneSet, context));
            }

            function handleFlowElementsContainer(container, context) {

                if (container.laneSets) {
                    handleLaneSets(container.laneSets, context);
                    handleNonFlowNodes(container.flowElements);
                } else {
                    handleFlowElements(container.flowElements, context);
                }
            }

            function handleNonFlowNodes(flowElements, context) {
                forEach(flowElements, function (e) {
                    if (is(e, 'bpmn:SequenceFlow')) {
                        deferred.push(function () {
                            handleSequenceFlow(e, context);
                        });
                    } else if (is(e, 'bpmn:BoundaryEvent')) {
                        deferred.unshift(function () {
                            handleBoundaryEvent(e, context);
                        });
                    } else if (is(e, 'bpmn:DataObject')) {
                        // SKIP (assume correct referencing via DataObjectReference)
                    } else if (is(e, 'bpmn:DataStoreReference')) {
                        handleDataElement(e, context);
                    } else if (is(e, 'bpmn:DataObjectReference')) {
                        handleDataElement(e, context);
                    }
                });
            }

            function handleFlowElements(flowElements, context) {
                forEach(flowElements, function (e) {
                    if (is(e, 'bpmn:SequenceFlow')) {
                        deferred.push(function () {
                            handleSequenceFlow(e, context);
                        });
                    } else if (is(e, 'bpmn:BoundaryEvent')) {
                        deferred.unshift(function () {
                            handleBoundaryEvent(e, context);
                        });
                    } else if (is(e, 'bpmn:FlowNode')) {
                        handleFlowNode(e, context);

                        if (is(e, 'bpmn:Activity')) {

                            handleIoSpecification(e.ioSpecification, context);

                            // defer handling of associations
                            deferred.push(function () {
                                forEach(e.dataInputAssociations, contextual(handleDataAssociation, context));
                                forEach(e.dataOutputAssociations, contextual(handleDataAssociation, context));
                            });
                        }
                    } else if (is(e, 'bpmn:DataObject')) {
                        // SKIP (assume correct referencing via DataObjectReference)
                    } else if (is(e, 'bpmn:DataStoreReference')) {
                        handleDataElement(e, context);
                    } else if (is(e, 'bpmn:DataObjectReference')) {
                        handleDataElement(e, context);
                    } else {
                        logError(
                            'unrecognized flowElement ' + elementToString(e) + ' in context ' +
                            (context ? elementToString(context.businessObject) : null),
                            {element: e, context: context});
                    }
                });
            }

            function handleParticipant(participant, context) {
                var newCtx = visitIfDi(participant, context);

                var process = participant.processRef;
                if (process) {
                    handleProcess(process, newCtx || context);
                }
            }

            function handleCollaboration(collaboration) {

                forEach(collaboration.participants, contextual(handleParticipant));

                handleArtifacts(collaboration.artifacts);

                // handle message flows latest in the process
                deferred.push(function () {
                    handleMessageFlows(collaboration.messageFlows);
                });
            }


            ///// API ////////////////////////////////

            return {
                handleDefinitions: handleDefinitions
            };
        }

        module.exports = BpmnTreeWalker;
    }, {
        "./Util": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/Util.js",
        "lodash/collection/filter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/filter.js",
        "lodash/collection/find": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/find.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "object-refs": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/Importer.js": [function (require, module, exports) {
        'use strict';

        var BpmnTreeWalker = require('./BpmnTreeWalker');


        /**
         * Import the definitions into a diagram.
         *
         * Errors and warnings are reported through the specified callback.
         *
         * @param  {Diagram} diagram
         * @param  {ModdleElement} definitions
         * @param  {Function} done the callback, invoked with (err, [ warning ]) once the import is done
         */
        function importBpmnDiagram(diagram, definitions, done) {

            var importer = diagram.get('bpmnImporter'),
                eventBus = diagram.get('eventBus');

            var error,
                warnings = [];

            function parse(definitions) {

                var visitor = {

                    root: function (element) {
                        return importer.add(element);
                    },

                    element: function (element, parentShape) {
                        return importer.add(element, parentShape);
                    },

                    error: function (message, context) {
                        warnings.push({message: message, context: context});
                    }
                };

                var walker = new BpmnTreeWalker(visitor);

                // import
                walker.handleDefinitions(definitions);
            }

            eventBus.fire('import.start');

            try {
                parse(definitions);
            } catch (e) {
                error = e;
            }

            eventBus.fire(error ? 'import.error' : 'import.success', {error: error, warnings: warnings});
            done(error, warnings);
        }

        module.exports.importBpmnDiagram = importBpmnDiagram;
    }, {"./BpmnTreeWalker": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/BpmnTreeWalker.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/Util.js": [function (require, module, exports) {
        'use strict';

        module.exports.elementToString = function (e) {
            if (!e) {
                return '<null>';
            }

            return '<' + e.$type + (e.id ? ' id="' + e.id : '') + '" />';
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/index.js": [function (require, module, exports) {
        module.exports = {
            bpmnImporter: ['type', require('./BpmnImporter')]
        };
    }, {"./BpmnImporter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/import/BpmnImporter.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/DiUtil.js": [function (require, module, exports) {
        'use strict';

        var is = require('./ModelUtil').is,
            getBusinessObject = require('./ModelUtil').getBusinessObject;

        module.exports.isExpanded = function (element) {

            if (is(element, 'bpmn:CallActivity')) {
                return false;
            }

            if (is(element, 'bpmn:SubProcess')) {
                return getBusinessObject(element).di.isExpanded;
            }

            if (is(element, 'bpmn:Participant')) {
                return !!getBusinessObject(element).processRef;
            }

            return true;
        };

    }, {"./ModelUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/LabelUtil.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');


        var DEFAULT_LABEL_SIZE = module.exports.DEFAULT_LABEL_SIZE = {
            width: 90,
            height: 20
        };


        /**
         * Returns true if the given semantic has an external label
         *
         * @param {BpmnElement} semantic
         * @return {Boolean} true if has label
         */
        module.exports.hasExternalLabel = function (semantic) {

            return semantic.$instanceOf('bpmn:Event') ||
                semantic.$instanceOf('bpmn:Gateway') ||
                semantic.$instanceOf('bpmn:DataStoreReference') ||
                semantic.$instanceOf('bpmn:DataObjectReference') ||
                semantic.$instanceOf('bpmn:SequenceFlow') ||
                semantic.$instanceOf('bpmn:MessageFlow');
        };


        /**
         * Get the middle of a number of waypoints
         *
         * @param  {Array<Point>} waypoints
         * @return {Point} the mid point
         */
        var getWaypointsMid = module.exports.getWaypointsMid = function (waypoints) {

            var mid = waypoints.length / 2 - 1;

            var first = waypoints[Math.floor(mid)];
            var second = waypoints[Math.ceil(mid + 0.01)];

            return {
                x: first.x + (second.x - first.x) / 2,
                y: first.y + (second.y - first.y) / 2
            };
        };


        var getExternalLabelMid = module.exports.getExternalLabelMid = function (element) {

            if (element.waypoints) {
                return getWaypointsMid(element.waypoints);
            } else {
                return {
                    x: element.x + element.width / 2,
                    y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2
                };
            }
        };

        /**
         * Returns the bounds of an elements label, parsed from the elements DI or
         * generated from its bounds.
         *
         * @param {BpmnElement} semantic
         * @param {djs.model.Base} element
         */
        module.exports.getExternalLabelBounds = function (semantic, element) {

            var mid,
                size,
                bounds,
                di = semantic.di,
                label = di.label;

            if (label && label.bounds) {
                bounds = label.bounds;

                size = {
                    width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),
                    height: bounds.height
                };

                mid = {
                    x: bounds.x + bounds.width / 2,
                    y: bounds.y + bounds.height / 2
                };
            } else {

                mid = getExternalLabelMid(element);

                size = DEFAULT_LABEL_SIZE;
            }

            return assign({
                x: mid.x - size.width / 2,
                y: mid.y - size.height / 2
            }, size);
        };
    }, {"lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/lib/util/ModelUtil.js": [function (require, module, exports) {
        'use strict';

        /**
         * Is an element of the given BPMN type?
         *
         * @param  {djs.model.Base|ModdleElement} element
         * @param  {String} type
         *
         * @return {Boolean}
         */
        function is(element, type) {
            var bo = getBusinessObject(element);

            return bo && bo.$instanceOf(type);
        }

        module.exports.is = is;


        /**
         * Return the business object for a given element.
         *
         * @param  {djs.model.Base|ModdleElement} element
         *
         * @return {ModdleElement}
         */
        function getBusinessObject(element) {
            return (element && element.businessObject) || element;
        }

        module.exports.getBusinessObject = getBusinessObject;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/index.js": [function (require, module, exports) {
        module.exports = require('./lib/simple');
    }, {"./lib/simple": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/lib/simple.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/lib/bpmn-moddle.js": [function (require, module, exports) {
        'use strict';

        var isString = require('lodash/lang/isString'),
            isFunction = require('lodash/lang/isFunction'),
            assign = require('lodash/object/assign');

        var Moddle = require('moddle'),
            XmlReader = require('moddle-xml/lib/reader'),
            XmlWriter = require('moddle-xml/lib/writer');

        /**
         * A sub class of {@link Moddle} with support for import and export of BPMN 2.0 xml files.
         *
         * @class BpmnModdle
         * @extends Moddle
         *
         * @param {Object|Array} packages to use for instantiating the model
         * @param {Object} [options] additional options to pass over
         */
        function BpmnModdle(packages, options) {
            Moddle.call(this, packages, options);
        }

        BpmnModdle.prototype = Object.create(Moddle.prototype);

        module.exports = BpmnModdle;


        /**
         * Instantiates a BPMN model tree from a given xml string.
         *
         * @param {String}   xmlStr
         * @param {String}   [typeName='bpmn:Definitions'] name of the root element
         * @param {Object}   [options]  options to pass to the underlying reader
         * @param {Function} done       callback that is invoked with (err, result, parseContext)
         *                              once the import completes
         */
        BpmnModdle.prototype.fromXML = function (xmlStr, typeName, options, done) {

            if (!isString(typeName)) {
                done = options;
                options = typeName;
                typeName = 'bpmn:Definitions';
            }

            if (isFunction(options)) {
                done = options;
                options = {};
            }

            var reader = new XmlReader(assign({model: this, lax: true}, options));
            var rootHandler = reader.handler(typeName);

            reader.fromXML(xmlStr, rootHandler, done);
        };


        /**
         * Serializes a BPMN 2.0 object tree to XML.
         *
         * @param {String}   element    the root element, typically an instance of `bpmn:Definitions`
         * @param {Object}   [options]  to pass to the underlying writer
         * @param {Function} done       callback invoked with (err, xmlStr) once the import completes
         */
        BpmnModdle.prototype.toXML = function (element, options, done) {

            if (isFunction(options)) {
                done = options;
                options = {};
            }

            var writer = new XmlWriter(options);
            try {
                var result = writer.toXML(element);
                done(null, result);
            } catch (e) {
                done(e);
            }
        };

    }, {
        "lodash/lang/isFunction": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isFunction.js",
        "lodash/lang/isString": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isString.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "moddle": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/index.js",
        "moddle-xml/lib/reader": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/lib/reader.js",
        "moddle-xml/lib/writer": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/lib/writer.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/lib/id-support.js": [function (require, module, exports) {
        'use strict';

        var ID_PATTERN = /^(.*:)?id$/;

        /**
         * Extends the bpmn instance with id support.
         *
         * @example
         *
         * var moddle, ids;
         *
         * require('id-support').extend(moddle, ids);
         *
         * moddle.ids.next(); // create a next id
         * moddle.ids; // ids instance
         *
         * // claims id as used
         * moddle.create('foo:Bar', { id: 'fooobar1' });
         *
         *
         * @param  {Moddle} model
         * @param  {Ids} ids
         *
         * @return {Moddle} the extended moddle instance
         */
        module.exports.extend = function (model, ids) {

            var set = model.properties.set;

            // do not reinitialize setter
            // unless it is already initialized
            if (!model.ids) {

                model.properties.set = function (target, property, value) {

                    // ensure we log used ids once they are assigned
                    // to model elements
                    if (ID_PATTERN.test(property)) {

                        var assigned = model.ids.assigned(value);
                        if (assigned && assigned !== target) {
                            throw new Error('id <' + value + '> already used');
                        }

                        model.ids.claim(value, target);
                    }

                    set.call(this, target, property, value);
                };
            }

            model.ids = ids;

            return model;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/lib/simple.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');

        var BpmnModdle = require('./bpmn-moddle');

        var packages = {
            bpmn: require('../resources/bpmn/json/bpmn.json'),
            bpmndi: require('../resources/bpmn/json/bpmndi.json'),
            dc: require('../resources/bpmn/json/dc.json'),
            di: require('../resources/bpmn/json/di.json')
        };

        module.exports = function (additionalPackages, options) {
            return new BpmnModdle(assign({}, packages, additionalPackages), options);
        };
    }, {
        "../resources/bpmn/json/bpmn.json": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/resources/bpmn/json/bpmn.json",
        "../resources/bpmn/json/bpmndi.json": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/resources/bpmn/json/bpmndi.json",
        "../resources/bpmn/json/dc.json": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/resources/bpmn/json/dc.json",
        "../resources/bpmn/json/di.json": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/resources/bpmn/json/di.json",
        "./bpmn-moddle": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/lib/bpmn-moddle.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/lib/common.js": [function (require, module, exports) {
        'use strict';

        function capitalize(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function lower(string) {
            return string.charAt(0).toLowerCase() + string.slice(1);
        }

        function hasLowerCaseAlias(pkg) {
            return pkg.xml && pkg.xml.tagAlias === 'lowerCase';
        }


        module.exports.aliasToName = function (alias, pkg) {
            if (hasLowerCaseAlias(pkg)) {
                return capitalize(alias);
            } else {
                return alias;
            }
        };

        module.exports.nameToAlias = function (name, pkg) {
            if (hasLowerCaseAlias(pkg)) {
                return lower(name);
            } else {
                return name;
            }
        };

        module.exports.DEFAULT_NS_MAP = {
            'xsi': 'http://www.w3.org/2001/XMLSchema-instance'
        };

        module.exports.XSI_TYPE = 'xsi:type';
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/lib/reader.js": [function (require, module, exports) {
        'use strict';

        var reduce = require('lodash/collection/reduce'),
            forEach = require('lodash/collection/forEach'),
            find = require('lodash/collection/find'),
            assign = require('lodash/object/assign'),
            defer = require('lodash/function/defer');

        var Stack = require('tiny-stack'),
            SaxParser = require('sax').parser,
            Moddle = require('moddle'),
            parseNameNs = require('moddle/lib/ns').parseName,
            Types = require('moddle/lib/types'),
            coerceType = Types.coerceType,
            isSimpleType = Types.isSimple,
            common = require('./common'),
            XSI_TYPE = common.XSI_TYPE,
            XSI_URI = common.DEFAULT_NS_MAP.xsi,
            aliasToName = common.aliasToName;

        function parseNodeAttributes(node) {
            var nodeAttrs = node.attributes;

            return reduce(nodeAttrs, function (result, v, k) {
                var name, ns;

                if (!v.local) {
                    name = v.prefix;
                } else {
                    ns = parseNameNs(v.name, v.prefix);
                    name = ns.name;
                }

                result[name] = v.value;
                return result;
            }, {});
        }

        function normalizeType(node, attr, model) {
            var nameNs = parseNameNs(attr.value);

            var uri = node.ns[nameNs.prefix || ''],
                localName = nameNs.localName,
                pkg = uri && model.getPackage(uri),
                typePrefix;

            if (pkg) {
                typePrefix = pkg.xml && pkg.xml.typePrefix;

                if (typePrefix && localName.indexOf(typePrefix) === 0) {
                    localName = localName.slice(typePrefix.length);
                }

                attr.value = pkg.prefix + ':' + localName;
            }
        }

        /**
         * Normalizes namespaces for a node given an optional default namespace and a
         * number of mappings from uris to default prefixes.
         *
         * @param  {XmlNode} node
         * @param  {Model} model the model containing all registered namespaces
         * @param  {Uri} defaultNsUri
         */
        function normalizeNamespaces(node, model, defaultNsUri) {
            var uri, prefix;

            uri = node.uri || defaultNsUri;

            if (uri) {
                var pkg = model.getPackage(uri);

                if (pkg) {
                    prefix = pkg.prefix;
                } else {
                    prefix = node.prefix;
                }

                node.prefix = prefix;
                node.uri = uri;
            }

            forEach(node.attributes, function (attr) {

                // normalize xsi:type attributes because the
                // assigned type may or may not be namespace prefixed
                if (attr.uri === XSI_URI && attr.local === 'type') {
                    normalizeType(node, attr, model);
                }

                normalizeNamespaces(attr, model, null);
            });
        }


        /**
         * A parse context.
         *
         * @class
         *
         * @param {Object} options
         * @param {ElementHandler} options.parseRoot the root handler for parsing a document
         * @param {boolean} [options.lax=false] whether or not to ignore invalid elements
         */
        function Context(options) {

            /**
             * @property {ElementHandler} parseRoot
             */

            /**
             * @property {Boolean} lax
             */

            assign(this, options);

            var elementsById = this.elementsById = {};
            var references = this.references = [];
            var warnings = this.warnings = [];

            this.addReference = function (reference) {
                references.push(reference);
            };

            this.addElement = function (id, element) {

                if (!id || !element) {
                    throw new Error('[xml-reader] id or ctx must not be null');
                }

                elementsById[id] = element;
            };

            this.addWarning = function (w) {
                warnings.push(w);
            };
        }

        function BaseHandler() {
        }

        BaseHandler.prototype.handleEnd = function () {
        };
        BaseHandler.prototype.handleText = function () {
        };
        BaseHandler.prototype.handleNode = function () {
        };


        /**
         * A simple pass through handler that does nothing except for
         * ignoring all input it receives.
         *
         * This is used to ignore unknown elements and
         * attributes.
         */
        function NoopHandler() {
        }

        NoopHandler.prototype = new BaseHandler();

        NoopHandler.prototype.handleNode = function () {
            return this;
        };

        function BodyHandler() {
        }

        BodyHandler.prototype = new BaseHandler();

        BodyHandler.prototype.handleText = function (text) {
            this.body = (this.body || '') + text;
        };

        function ReferenceHandler(property, context) {
            this.property = property;
            this.context = context;
        }

        ReferenceHandler.prototype = new BodyHandler();

        ReferenceHandler.prototype.handleNode = function (node) {

            if (this.element) {
                throw new Error('expected no sub nodes');
            } else {
                this.element = this.createReference(node);
            }

            return this;
        };

        ReferenceHandler.prototype.handleEnd = function () {
            this.element.id = this.body;
        };

        ReferenceHandler.prototype.createReference = function () {
            return {
                property: this.property.ns.name,
                id: ''
            };
        };

        function ValueHandler(propertyDesc, element) {
            this.element = element;
            this.propertyDesc = propertyDesc;
        }

        ValueHandler.prototype = new BodyHandler();

        ValueHandler.prototype.handleEnd = function () {

            var value = this.body,
                element = this.element,
                propertyDesc = this.propertyDesc;

            value = coerceType(propertyDesc.type, value);

            if (propertyDesc.isMany) {
                element.get(propertyDesc.name).push(value);
            } else {
                element.set(propertyDesc.name, value);
            }
        };


        function BaseElementHandler() {
        }

        BaseElementHandler.prototype = Object.create(BodyHandler.prototype);

        BaseElementHandler.prototype.handleNode = function (node) {
            var parser = this,
                element = this.element,
                id;

            if (!element) {
                element = this.element = this.createElement(node);
                id = element.id;

                if (id) {
                    this.context.addElement(id, element);
                }
            } else {
                parser = this.handleChild(node);
            }

            return parser;
        };

        /**
         * @class XMLReader.ElementHandler
         *
         */
        function ElementHandler(model, type, context) {
            this.model = model;
            this.type = model.getType(type);
            this.context = context;
        }

        ElementHandler.prototype = new BaseElementHandler();

        ElementHandler.prototype.addReference = function (reference) {
            this.context.addReference(reference);
        };

        ElementHandler.prototype.handleEnd = function () {

            var value = this.body,
                element = this.element,
                descriptor = element.$descriptor,
                bodyProperty = descriptor.bodyProperty;

            if (bodyProperty && value !== undefined) {
                value = coerceType(bodyProperty.type, value);
                element.set(bodyProperty.name, value);
            }
        };

        /**
         * Create an instance of the model from the given node.
         *
         * @param  {Element} node the xml node
         */
        ElementHandler.prototype.createElement = function (node) {
            var attributes = parseNodeAttributes(node),
                Type = this.type,
                descriptor = Type.$descriptor,
                context = this.context,
                instance = new Type({});

            forEach(attributes, function (value, name) {

                var prop = descriptor.propertiesByName[name];

                if (prop && prop.isReference) {
                    context.addReference({
                        element: instance,
                        property: prop.ns.name,
                        id: value
                    });
                } else {
                    if (prop) {
                        value = coerceType(prop.type, value);
                    }

                    instance.set(name, value);
                }
            });

            return instance;
        };

        ElementHandler.prototype.getPropertyForNode = function (node) {

            var nameNs = parseNameNs(node.local, node.prefix);

            var type = this.type,
                model = this.model,
                descriptor = type.$descriptor;

            var propertyName = nameNs.name,
                property = descriptor.propertiesByName[propertyName],
                elementTypeName,
                elementType,
                typeAnnotation;

            // search for properties by name first

            if (property) {

                if (property.serialize === XSI_TYPE) {
                    typeAnnotation = node.attributes[XSI_TYPE];

                    // xsi type is optional, if it does not exists the
                    // default type is assumed
                    if (typeAnnotation) {

                        elementTypeName = typeAnnotation.value;

                        // TODO: extract real name from attribute
                        elementType = model.getType(elementTypeName);

                        return assign({}, property, {effectiveType: elementType.$descriptor.name});
                    }
                }

                // search for properties by name first
                return property;
            }


            var pkg = model.getPackage(nameNs.prefix);

            if (pkg) {
                elementTypeName = nameNs.prefix + ':' + aliasToName(nameNs.localName, descriptor.$pkg);
                elementType = model.getType(elementTypeName);

                // search for collection members later
                property = find(descriptor.properties, function (p) {
                    return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
                });

                if (property) {
                    return assign({}, property, {effectiveType: elementType.$descriptor.name});
                }
            } else {
                // parse unknown element (maybe extension)
                property = find(descriptor.properties, function (p) {
                    return !p.isReference && !p.isAttribute && p.type === 'Element';
                });

                if (property) {
                    return property;
                }
            }

            throw new Error('unrecognized element <' + nameNs.name + '>');
        };

        ElementHandler.prototype.toString = function () {
            return 'ElementDescriptor[' + this.type.$descriptor.name + ']';
        };

        ElementHandler.prototype.valueHandler = function (propertyDesc, element) {
            return new ValueHandler(propertyDesc, element);
        };

        ElementHandler.prototype.referenceHandler = function (propertyDesc) {
            return new ReferenceHandler(propertyDesc, this.context);
        };

        ElementHandler.prototype.handler = function (type) {
            if (type === 'Element') {
                return new GenericElementHandler(this.model, type, this.context);
            } else {
                return new ElementHandler(this.model, type, this.context);
            }
        };

        /**
         * Handle the child element parsing
         *
         * @param  {Element} node the xml node
         */
        ElementHandler.prototype.handleChild = function (node) {
            var propertyDesc, type, element, childHandler;

            propertyDesc = this.getPropertyForNode(node);
            element = this.element;

            type = propertyDesc.effectiveType || propertyDesc.type;

            if (isSimpleType(type)) {
                return this.valueHandler(propertyDesc, element);
            }

            if (propertyDesc.isReference) {
                childHandler = this.referenceHandler(propertyDesc).handleNode(node);
            } else {
                childHandler = this.handler(type).handleNode(node);
            }

            var newElement = childHandler.element;

            // child handles may decide to skip elements
            // by not returning anything
            if (newElement !== undefined) {

                if (propertyDesc.isMany) {
                    element.get(propertyDesc.name).push(newElement);
                } else {
                    element.set(propertyDesc.name, newElement);
                }

                if (propertyDesc.isReference) {
                    assign(newElement, {
                        element: element
                    });

                    this.context.addReference(newElement);
                } else {
                    // establish child -> parent relationship
                    newElement.$parent = element;
                }
            }

            return childHandler;
        };


        function GenericElementHandler(model, type, context) {
            this.model = model;
            this.context = context;
        }

        GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);

        GenericElementHandler.prototype.createElement = function (node) {

            var name = node.name,
                prefix = node.prefix,
                uri = node.ns[prefix],
                attributes = node.attributes;

            return this.model.createAny(name, uri, attributes);
        };

        GenericElementHandler.prototype.handleChild = function (node) {

            var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
                element = this.element;

            var newElement = handler.element,
                children;

            if (newElement !== undefined) {
                children = element.$children = element.$children || [];
                children.push(newElement);

                // establish child -> parent relationship
                newElement.$parent = element;
            }

            return handler;
        };

        GenericElementHandler.prototype.handleText = function (text) {
            this.body = this.body || '' + text;
        };

        GenericElementHandler.prototype.handleEnd = function () {
            if (this.body) {
                this.element.$body = this.body;
            }
        };

        /**
         * A reader for a meta-model
         *
         * @param {Object} options
         * @param {Model} options.model used to read xml files
         * @param {Boolean} options.lax whether to make parse errors warnings
         */
        function XMLReader(options) {

            if (options instanceof Moddle) {
                options = {
                    model: options
                };
            }

            assign(this, {lax: false}, options);
        }


        XMLReader.prototype.fromXML = function (xml, rootHandler, done) {

            var model = this.model,
                lax = this.lax,
                context = new Context({
                    parseRoot: rootHandler
                });

            var parser = new SaxParser(true, {xmlns: true, trim: true}),
                stack = new Stack();

            rootHandler.context = context;

            // push root handler
            stack.push(rootHandler);


            function resolveReferences() {

                var elementsById = context.elementsById;
                var references = context.references;

                var i, r;

                for (i = 0; !!(r = references[i]); i++) {
                    var element = r.element;
                    var reference = elementsById[r.id];
                    var property = element.$descriptor.propertiesByName[r.property];

                    if (!reference) {
                        context.addWarning({
                            message: 'unresolved reference <' + r.id + '>',
                            element: r.element,
                            property: r.property,
                            value: r.id
                        });
                    }

                    if (property.isMany) {
                        var collection = element.get(property.name),
                            idx = collection.indexOf(r);

                        if (!reference) {
                            // remove unresolvable reference
                            collection.splice(idx, 1);
                        } else {
                            // update reference
                            collection[idx] = reference;
                        }
                    } else {
                        element.set(property.name, reference);
                    }
                }
            }

            function handleClose(tagName) {
                stack.pop().handleEnd();
            }

            function handleOpen(node) {
                var handler = stack.peek();

                normalizeNamespaces(node, model);

                try {
                    stack.push(handler.handleNode(node));
                } catch (e) {

                    var line = this.line,
                        column = this.column;

                    var message =
                        'unparsable content <' + node.name + '> detected\n\t' +
                        'line: ' + line + '\n\t' +
                        'column: ' + column + '\n\t' +
                        'nested error: ' + e.message;

                    if (lax) {
                        context.addWarning({
                            message: message,
                            error: e
                        });

                        console.warn('could not parse node');
                        console.warn(e);

                        stack.push(new NoopHandler());
                    } else {
                        console.error('could not parse document');
                        console.error(e);

                        throw new Error(message);
                    }
                }
            }

            function handleText(text) {
                stack.peek().handleText(text);
            }

            parser.onopentag = handleOpen;
            parser.oncdata = parser.ontext = handleText;
            parser.onclosetag = handleClose;
            parser.onend = resolveReferences;

            // deferred parse XML to make loading really ascnchronous
            // this ensures the execution environment (node or browser)
            // is kept responsive and that certain optimization strategies
            // can kick in
            defer(function () {
                var error;

                try {
                    parser.write(xml).close();
                } catch (e) {
                    error = e;
                }

                done(error, error ? undefined : rootHandler.element, context);
            });
        };

        XMLReader.prototype.handler = function (name) {
            return new ElementHandler(this.model, name);
        };

        module.exports = XMLReader;
        module.exports.ElementHandler = ElementHandler;
    }, {
        "./common": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/lib/common.js",
        "lodash/collection/find": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/find.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/collection/reduce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/reduce.js",
        "lodash/function/defer": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/defer.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "moddle": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/index.js",
        "moddle/lib/ns": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/ns.js",
        "moddle/lib/types": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/types.js",
        "sax": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/node_modules/sax/lib/sax.js",
        "tiny-stack": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/node_modules/tiny-stack/lib/tiny-stack.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/lib/writer.js": [function (require, module, exports) {
        'use strict';

        var map = require('lodash/collection/map'),
            forEach = require('lodash/collection/forEach'),
            isString = require('lodash/lang/isString'),
            filter = require('lodash/collection/filter'),
            assign = require('lodash/object/assign');

        var Types = require('moddle/lib/types'),
            parseNameNs = require('moddle/lib/ns').parseName,
            common = require('./common'),
            nameToAlias = common.nameToAlias;

        var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n',
            ESCAPE_CHARS = /(<|>|'|"|&|\n\r|\n)/g,
            DEFAULT_NS_MAP = common.DEFAULT_NS_MAP,
            XSI_TYPE = common.XSI_TYPE;


        function nsName(ns) {
            if (isString(ns)) {
                return ns;
            } else {
                return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
            }
        }

        function getElementNs(ns, descriptor) {
            if (descriptor.isGeneric) {
                return descriptor.name;
            } else {
                return assign({localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg)}, ns);
            }
        }

        function getPropertyNs(ns, descriptor) {
            return assign({localName: descriptor.ns.localName}, ns);
        }

        function getSerializableProperties(element) {
            var descriptor = element.$descriptor;

            return filter(descriptor.properties, function (p) {
                var name = p.name;

                // do not serialize defaults
                if (!element.hasOwnProperty(name)) {
                    return false;
                }

                var value = element[name];

                // do not serialize default equals
                if (value === p.default) {
                    return false;
                }

                return p.isMany ? value.length : true;
            });
        }

        var ESCAPE_MAP = {
            '\n': '10',
            '\n\r': '10',
            '"': '34',
            '\'': '39',
            '<': '60',
            '>': '62',
            '&': '38'
        };

        /**
         * Escape a string attribute to not contain any bad values (line breaks, '"', ...)
         *
         * @param {String} str the string to escape
         * @return {String} the escaped string
         */
        function escapeAttr(str) {

            // ensure we are handling strings here
            str = isString(str) ? str : '' + str;

            return str.replace(ESCAPE_CHARS, function (str) {
                return '&#' + ESCAPE_MAP[str] + ';';
            });
        }

        function filterAttributes(props) {
            return filter(props, function (p) {
                return p.isAttr;
            });
        }

        function filterContained(props) {
            return filter(props, function (p) {
                return !p.isAttr;
            });
        }


        function ReferenceSerializer(parent, ns) {
            this.ns = ns;
        }

        ReferenceSerializer.prototype.build = function (element) {
            this.element = element;
            return this;
        };

        ReferenceSerializer.prototype.serializeTo = function (writer) {
            writer
                .appendIndent()
                .append('<' + nsName(this.ns) + '>' + this.element.id + '</' + nsName(this.ns) + '>')
                .appendNewLine();
        };

        function BodySerializer() {
        }

        BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {
            var escape = this.escape;

            if (escape) {
                writer.append('<![CDATA[');
            }

            writer.append(this.value);

            if (escape) {
                writer.append(']]>');
            }
        };

        BodySerializer.prototype.build = function (prop, value) {
            this.value = value;

            if (prop.type === 'String' && ESCAPE_CHARS.test(value)) {
                this.escape = true;
            }

            return this;
        };

        function ValueSerializer(ns) {
            this.ns = ns;
        }

        ValueSerializer.prototype = new BodySerializer();

        ValueSerializer.prototype.serializeTo = function (writer) {

            writer
                .appendIndent()
                .append('<' + nsName(this.ns) + '>');

            this.serializeValue(writer);

            writer
                .append('</' + nsName(this.ns) + '>')
                .appendNewLine();
        };

        function ElementSerializer(parent, ns) {
            this.body = [];
            this.attrs = [];

            this.parent = parent;
            this.ns = ns;
        }

        ElementSerializer.prototype.build = function (element) {
            this.element = element;

            var otherAttrs = this.parseNsAttributes(element);

            if (!this.ns) {
                this.ns = this.nsTagName(element.$descriptor);
            }

            if (element.$descriptor.isGeneric) {
                this.parseGeneric(element);
            } else {
                var properties = getSerializableProperties(element);

                this.parseAttributes(filterAttributes(properties));
                this.parseContainments(filterContained(properties));

                this.parseGenericAttributes(element, otherAttrs);
            }

            return this;
        };

        ElementSerializer.prototype.nsTagName = function (descriptor) {
            var effectiveNs = this.logNamespaceUsed(descriptor.ns);
            return getElementNs(effectiveNs, descriptor);
        };

        ElementSerializer.prototype.nsPropertyTagName = function (descriptor) {
            var effectiveNs = this.logNamespaceUsed(descriptor.ns);
            return getPropertyNs(effectiveNs, descriptor);
        };

        ElementSerializer.prototype.isLocalNs = function (ns) {
            return ns.uri === this.ns.uri;
        };

        ElementSerializer.prototype.nsAttributeName = function (element) {

            var ns;

            if (isString(element)) {
                ns = parseNameNs(element);
            } else if (element.ns) {
                ns = element.ns;
            }

            var effectiveNs = this.logNamespaceUsed(ns);

            // strip prefix if same namespace like parent
            if (this.isLocalNs(effectiveNs)) {
                return {localName: ns.localName};
            } else {
                return assign({localName: ns.localName}, effectiveNs);
            }
        };

        ElementSerializer.prototype.parseGeneric = function (element) {

            var self = this,
                body = this.body,
                attrs = this.attrs;

            forEach(element, function (val, key) {

                if (key === '$body') {
                    body.push(new BodySerializer().build({type: 'String'}, val));
                } else if (key === '$children') {
                    forEach(val, function (child) {
                        body.push(new ElementSerializer(self).build(child));
                    });
                } else if (key.indexOf('$') !== 0) {
                    attrs.push({name: key, value: escapeAttr(val)});
                }
            });
        };

        /**
         * Parse namespaces and return a list of left over generic attributes
         *
         * @param  {Object} element
         * @return {Array<Object>}
         */
        ElementSerializer.prototype.parseNsAttributes = function (element) {
            var self = this;

            var genericAttrs = element.$attrs;

            var attributes = [];

            // parse namespace attributes first
            // and log them. push non namespace attributes to a list
            // and process them later
            forEach(genericAttrs, function (value, name) {
                var nameNs = parseNameNs(name);

                if (nameNs.prefix === 'xmlns') {
                    self.logNamespace({prefix: nameNs.localName, uri: value});
                } else if (!nameNs.prefix && nameNs.localName === 'xmlns') {
                    self.logNamespace({uri: value});
                } else {
                    attributes.push({name: name, value: value});
                }
            });

            return attributes;
        };

        ElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {

            var self = this;

            forEach(attributes, function (attr) {

                // do not serialize xsi:type attribute
                // it is set manually based on the actual implementation type
                if (attr.name === XSI_TYPE) {
                    return;
                }

                try {
                    self.addAttribute(self.nsAttributeName(attr.name), attr.value);
                } catch (e) {
                    console.warn('[writer] missing namespace information for ', attr.name, '=', attr.value, 'on', element, e);
                }
            });
        };

        ElementSerializer.prototype.parseContainments = function (properties) {

            var self = this,
                body = this.body,
                element = this.element;

            forEach(properties, function (p) {
                var value = element.get(p.name),
                    isReference = p.isReference,
                    isMany = p.isMany;

                var ns = self.nsPropertyTagName(p);

                if (!isMany) {
                    value = [value];
                }

                if (p.isBody) {
                    body.push(new BodySerializer().build(p, value[0]));
                } else if (Types.isSimple(p.type)) {
                    forEach(value, function (v) {
                        body.push(new ValueSerializer(ns).build(p, v));
                    });
                } else if (isReference) {
                    forEach(value, function (v) {
                        body.push(new ReferenceSerializer(self, ns).build(v));
                    });
                } else {
                    // allow serialization via type
                    // rather than element name
                    var asType = p.serialize === XSI_TYPE;

                    forEach(value, function (v) {
                        var serializer;

                        if (asType) {
                            serializer = new TypeSerializer(self, ns);
                        } else {
                            serializer = new ElementSerializer(self);
                        }

                        body.push(serializer.build(v));
                    });
                }
            });
        };

        ElementSerializer.prototype.getNamespaces = function () {
            if (!this.parent) {
                if (!this.namespaces) {
                    this.namespaces = {
                        prefixMap: {},
                        uriMap: {},
                        used: {}
                    };
                }
            } else {
                this.namespaces = this.parent.getNamespaces();
            }

            return this.namespaces;
        };

        ElementSerializer.prototype.logNamespace = function (ns) {
            var namespaces = this.getNamespaces();

            var existing = namespaces.uriMap[ns.uri];

            if (!existing) {
                namespaces.uriMap[ns.uri] = ns;
            }

            namespaces.prefixMap[ns.prefix] = ns.uri;

            return ns;
        };

        ElementSerializer.prototype.logNamespaceUsed = function (ns) {
            var element = this.element,
                model = element.$model,
                namespaces = this.getNamespaces();

            // ns may be
            //
            //   * prefix only
            //   * prefix:uri

            var prefix = ns.prefix;
            var uri = ns.uri || DEFAULT_NS_MAP[prefix] ||
                namespaces.prefixMap[prefix] || (model ? (model.getPackage(prefix) || {}).uri : null);

            if (!uri) {
                throw new Error('no namespace uri given for prefix <' + ns.prefix + '>');
            }

            ns = namespaces.uriMap[uri];

            if (!ns) {
                ns = this.logNamespace({prefix: prefix, uri: uri});
            }

            if (!namespaces.used[ns.uri]) {
                namespaces.used[ns.uri] = ns;
            }

            return ns;
        };

        ElementSerializer.prototype.parseAttributes = function (properties) {
            var self = this,
                element = this.element;

            forEach(properties, function (p) {
                self.logNamespaceUsed(p.ns);

                var value = element.get(p.name);

                if (p.isReference) {
                    value = value.id;
                }

                self.addAttribute(self.nsAttributeName(p), value);
            });
        };

        ElementSerializer.prototype.addAttribute = function (name, value) {
            var attrs = this.attrs;

            if (isString(value)) {
                value = escapeAttr(value);
            }

            attrs.push({name: name, value: value});
        };

        ElementSerializer.prototype.serializeAttributes = function (writer) {
            var attrs = this.attrs,
                root = !this.parent,
                namespaces = this.namespaces;

            function collectNsAttrs() {
                return map(namespaces.used, function (ns) {
                    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
                    return {name: name, value: ns.uri};
                });
            }

            if (root) {
                attrs = collectNsAttrs().concat(attrs);
            }

            forEach(attrs, function (a) {
                writer
                    .append(' ')
                    .append(nsName(a.name)).append('="').append(a.value).append('"');
            });
        };

        ElementSerializer.prototype.serializeTo = function (writer) {
            var hasBody = this.body.length,
                indent = !(this.body.length === 1 && this.body[0] instanceof BodySerializer);

            writer
                .appendIndent()
                .append('<' + nsName(this.ns));

            this.serializeAttributes(writer);

            writer.append(hasBody ? '>' : ' />');

            if (hasBody) {

                if (indent) {
                    writer
                        .appendNewLine()
                        .indent();
                }

                forEach(this.body, function (b) {
                    b.serializeTo(writer);
                });

                if (indent) {
                    writer
                        .unindent()
                        .appendIndent();
                }

                writer.append('</' + nsName(this.ns) + '>');
            }

            writer.appendNewLine();
        };

        /**
         * A serializer for types that handles serialization of data types
         */
        function TypeSerializer(parent, ns) {
            ElementSerializer.call(this, parent, ns);
        }

        TypeSerializer.prototype = new ElementSerializer();

        TypeSerializer.prototype.build = function (element) {
            var descriptor = element.$descriptor;

            this.element = element;

            this.typeNs = this.nsTagName(descriptor);

            // add xsi:type attribute to represent the elements
            // actual type

            var typeNs = this.typeNs,
                pkg = element.$model.getPackage(typeNs.uri),
                typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';

            this.addAttribute(this.nsAttributeName(XSI_TYPE),
                (typeNs.prefix ? typeNs.prefix + ':' : '') +
                typePrefix + descriptor.ns.localName);

            // do the usual stuff
            return ElementSerializer.prototype.build.call(this, element);
        };

        TypeSerializer.prototype.isLocalNs = function (ns) {
            return ns.uri === this.typeNs.uri;
        };

        function SavingWriter() {
            this.value = '';

            this.write = function (str) {
                this.value += str;
            };
        }

        function FormatingWriter(out, format) {

            var indent = [''];

            this.append = function (str) {
                out.write(str);

                return this;
            };

            this.appendNewLine = function () {
                if (format) {
                    out.write('\n');
                }

                return this;
            };

            this.appendIndent = function () {
                if (format) {
                    out.write(indent.join('  '));
                }

                return this;
            };

            this.indent = function () {
                indent.push('');
                return this;
            };

            this.unindent = function () {
                indent.pop();
                return this;
            };
        }

        /**
         * A writer for meta-model backed document trees
         *
         * @param {Object} options output options to pass into the writer
         */
        function XMLWriter(options) {

            options = assign({format: false, preamble: true}, options || {});

            function toXML(tree, writer) {
                var internalWriter = writer || new SavingWriter();
                var formatingWriter = new FormatingWriter(internalWriter, options.format);

                if (options.preamble) {
                    formatingWriter.append(XML_PREAMBLE);
                }

                new ElementSerializer().build(tree).serializeTo(formatingWriter);

                if (!writer) {
                    return internalWriter.value;
                }
            }

            return {
                toXML: toXML
            };
        }

        module.exports = XMLWriter;
    }, {
        "./common": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/lib/common.js",
        "lodash/collection/filter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/filter.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/collection/map": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/map.js",
        "lodash/lang/isString": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isString.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "moddle/lib/ns": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/ns.js",
        "moddle/lib/types": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/types.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/node_modules/sax/lib/sax.js": [function (require, module, exports) {
        (function (Buffer) {
// wrapper for non-node envs
            ;
            (function (sax) {

                sax.parser = function (strict, opt) {
                    return new SAXParser(strict, opt)
                }
                sax.SAXParser = SAXParser
                sax.SAXStream = SAXStream
                sax.createStream = createStream

// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
// since that's the earliest that a buffer overrun could occur.  This way, checks are
// as rare as required, but as often as necessary to ensure never crossing this bound.
// Furthermore, buffers are only tested at most once per write(), so passing a very
// large string into write() might have undesirable effects, but this is manageable by
// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
// edge case, result in creating at most one complete copy of the string passed in.
// Set to Infinity to have unlimited buffers.
                sax.MAX_BUFFER_LENGTH = 64 * 1024

                var buffers = [
                    "comment", "sgmlDecl", "textNode", "tagName", "doctype",
                    "procInstName", "procInstBody", "entity", "attribName",
                    "attribValue", "cdata", "script"
                ]

                sax.EVENTS = // for discoverability.
                    ["text"
                        , "processinginstruction"
                        , "sgmldeclaration"
                        , "doctype"
                        , "comment"
                        , "attribute"
                        , "opentag"
                        , "closetag"
                        , "opencdata"
                        , "cdata"
                        , "closecdata"
                        , "error"
                        , "end"
                        , "ready"
                        , "script"
                        , "opennamespace"
                        , "closenamespace"
                    ]

                function SAXParser(strict, opt) {
                    if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)

                    var parser = this
                    clearBuffers(parser)
                    parser.q = parser.c = ""
                    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
                    parser.opt = opt || {}
                    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
                    parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase"
                    parser.tags = []
                    parser.closed = parser.closedRoot = parser.sawRoot = false
                    parser.tag = parser.error = null
                    parser.strict = !!strict
                    parser.noscript = !!(strict || parser.opt.noscript)
                    parser.state = S.BEGIN
                    parser.ENTITIES = Object.create(sax.ENTITIES)
                    parser.attribList = []

                    // namespaces form a prototype chain.
                    // it always points at the current tag,
                    // which protos to its parent tag.
                    if (parser.opt.xmlns) parser.ns = Object.create(rootNS)

                    // mostly just for error reporting
                    parser.trackPosition = parser.opt.position !== false
                    if (parser.trackPosition) {
                        parser.position = parser.line = parser.column = 0
                    }
                    emit(parser, "onready")
                }

                if (!Object.create) Object.create = function (o) {
                    function f() {
                        this.__proto__ = o
                    }

                    f.prototype = o
                    return new f
                }

                if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {
                    return o.__proto__
                }

                if (!Object.keys) Object.keys = function (o) {
                    var a = []
                    for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
                    return a
                }

                function checkBufferLength(parser) {
                    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
                        , maxActual = 0
                    for (var i = 0, l = buffers.length; i < l; i++) {
                        var len = parser[buffers[i]].length
                        if (len > maxAllowed) {
                            // Text/cdata nodes can get big, and since they're buffered,
                            // we can get here under normal conditions.
                            // Avoid issues by emitting the text node now,
                            // so at least it won't get any bigger.
                            switch (buffers[i]) {
                                case "textNode":
                                    closeText(parser)
                                    break

                                case "cdata":
                                    emitNode(parser, "oncdata", parser.cdata)
                                    parser.cdata = ""
                                    break

                                case "script":
                                    emitNode(parser, "onscript", parser.script)
                                    parser.script = ""
                                    break

                                default:
                                    error(parser, "Max buffer length exceeded: " + buffers[i])
                            }
                        }
                        maxActual = Math.max(maxActual, len)
                    }
                    // schedule the next check for the earliest possible buffer overrun.
                    parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)
                    + parser.position
                }

                function clearBuffers(parser) {
                    for (var i = 0, l = buffers.length; i < l; i++) {
                        parser[buffers[i]] = ""
                    }
                }

                function flushBuffers(parser) {
                    closeText(parser)
                    if (parser.cdata !== "") {
                        emitNode(parser, "oncdata", parser.cdata)
                        parser.cdata = ""
                    }
                    if (parser.script !== "") {
                        emitNode(parser, "onscript", parser.script)
                        parser.script = ""
                    }
                }

                SAXParser.prototype =
                {
                    end: function () {
                        end(this)
                    }
                    , write: write
                    , resume: function () {
                    this.error = null;
                    return this
                }
                    , close: function () {
                    return this.write(null)
                }
                    , flush: function () {
                    flushBuffers(this)
                }
                }

                try {
                    var Stream = require("stream").Stream
                } catch (ex) {
                    var Stream = function () {
                    }
                }


                var streamWraps = sax.EVENTS.filter(function (ev) {
                    return ev !== "error" && ev !== "end"
                })

                function createStream(strict, opt) {
                    return new SAXStream(strict, opt)
                }

                function SAXStream(strict, opt) {
                    if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)

                    Stream.apply(this)

                    this._parser = new SAXParser(strict, opt)
                    this.writable = true
                    this.readable = true


                    var me = this

                    this._parser.onend = function () {
                        me.emit("end")
                    }

                    this._parser.onerror = function (er) {
                        me.emit("error", er)

                        // if didn't throw, then means error was handled.
                        // go ahead and clear error, so we can write again.
                        me._parser.error = null
                    }

                    this._decoder = null;

                    streamWraps.forEach(function (ev) {
                        Object.defineProperty(me, "on" + ev, {
                            get: function () {
                                return me._parser["on" + ev]
                            },
                            set: function (h) {
                                if (!h) {
                                    me.removeAllListeners(ev)
                                    return me._parser["on" + ev] = h
                                }
                                me.on(ev, h)
                            },
                            enumerable: true,
                            configurable: false
                        })
                    })
                }

                SAXStream.prototype = Object.create(Stream.prototype,
                    {constructor: {value: SAXStream}})

                SAXStream.prototype.write = function (data) {
                    if (typeof Buffer === 'function' &&
                        typeof Buffer.isBuffer === 'function' &&
                        Buffer.isBuffer(data)) {
                        if (!this._decoder) {
                            var SD = require('string_decoder').StringDecoder
                            this._decoder = new SD('utf8')
                        }
                        data = this._decoder.write(data);
                    }

                    this._parser.write(data.toString())
                    this.emit("data", data)
                    return true
                }

                SAXStream.prototype.end = function (chunk) {
                    if (chunk && chunk.length) this.write(chunk)
                    this._parser.end()
                    return true
                }

                SAXStream.prototype.on = function (ev, handler) {
                    var me = this
                    if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
                        me._parser["on" + ev] = function () {
                            var args = arguments.length === 1 ? [arguments[0]]
                                : Array.apply(null, arguments)
                            args.splice(0, 0, ev)
                            me.emit.apply(me, args)
                        }
                    }

                    return Stream.prototype.on.call(me, ev, handler)
                }


// character classes and tokens
                var whitespace = "\r\n\t "
                // this really needs to be replaced with character classes.
                // XML allows all manner of ridiculous numbers and digits.
                    , number = "0124356789"
                    , letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
                // (Letter | "_" | ":")
                    , quote = "'\""
                    , entity = number + letter + "#"
                    , attribEnd = whitespace + ">"
                    , CDATA = "[CDATA["
                    , DOCTYPE = "DOCTYPE"
                    , XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
                    , XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
                    , rootNS = {xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE}

// turn all the string character sets into character class objects.
                whitespace = charClass(whitespace)
                number = charClass(number)
                letter = charClass(letter)

// http://www.w3.org/TR/REC-xml/#NT-NameStartChar
// This implementation works on strings, a single character at a time
// as such, it cannot ever support astral-plane characters (10000-EFFFF)
// without a significant breaking change to either this  parser, or the
// JavaScript language.  Implementation of an emoji-capable xml parser
// is left as an exercise for the reader.
                var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

                var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

                quote = charClass(quote)
                entity = charClass(entity)
                attribEnd = charClass(attribEnd)

                function charClass(str) {
                    return str.split("").reduce(function (s, c) {
                        s[c] = true
                        return s
                    }, {})
                }

                function isRegExp(c) {
                    return Object.prototype.toString.call(c) === '[object RegExp]'
                }

                function is(charclass, c) {
                    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
                }

                function not(charclass, c) {
                    return !is(charclass, c)
                }

                var S = 0
                sax.STATE =
                {
                    BEGIN: S++
                    , TEXT: S++ // general stuff
                    , TEXT_ENTITY: S++ // &amp and such.
                    , OPEN_WAKA: S++ // <
                    , SGML_DECL: S++ // <!BLARG
                    , SGML_DECL_QUOTED: S++ // <!BLARG foo "bar
                    , DOCTYPE: S++ // <!DOCTYPE
                    , DOCTYPE_QUOTED: S++ // <!DOCTYPE "//blah
                    , DOCTYPE_DTD: S++ // <!DOCTYPE "//blah" [ ...
                    , DOCTYPE_DTD_QUOTED: S++ // <!DOCTYPE "//blah" [ "foo
                    , COMMENT_STARTING: S++ // <!-
                    , COMMENT: S++ // <!--
                    , COMMENT_ENDING: S++ // <!-- blah -
                    , COMMENT_ENDED: S++ // <!-- blah --
                    , CDATA: S++ // <![CDATA[ something
                    , CDATA_ENDING: S++ // ]
                    , CDATA_ENDING_2: S++ // ]]
                    , PROC_INST: S++ // <?hi
                    , PROC_INST_BODY: S++ // <?hi there
                    , PROC_INST_ENDING: S++ // <?hi "there" ?
                    , OPEN_TAG: S++ // <strong
                    , OPEN_TAG_SLASH: S++ // <strong /
                    , ATTRIB: S++ // <a
                    , ATTRIB_NAME: S++ // <a foo
                    , ATTRIB_NAME_SAW_WHITE: S++ // <a foo _
                    , ATTRIB_VALUE: S++ // <a foo=
                    , ATTRIB_VALUE_QUOTED: S++ // <a foo="bar
                    , ATTRIB_VALUE_CLOSED: S++ // <a foo="bar"
                    , ATTRIB_VALUE_UNQUOTED: S++ // <a foo=bar
                    , ATTRIB_VALUE_ENTITY_Q: S++ // <foo bar="&quot;"
                    , ATTRIB_VALUE_ENTITY_U: S++ // <foo bar=&quot;
                    , CLOSE_TAG: S++ // </a
                    , CLOSE_TAG_SAW_WHITE: S++ // </a   >
                    , SCRIPT: S++ // <script> ...
                    , SCRIPT_ENDING: S++ // <script> ... <
                }

                sax.ENTITIES =
                {
                    "amp": "&"
                    , "gt": ">"
                    , "lt": "<"
                    , "quot": "\""
                    , "apos": "'"
                    , "AElig": 198
                    , "Aacute": 193
                    , "Acirc": 194
                    , "Agrave": 192
                    , "Aring": 197
                    , "Atilde": 195
                    , "Auml": 196
                    , "Ccedil": 199
                    , "ETH": 208
                    , "Eacute": 201
                    , "Ecirc": 202
                    , "Egrave": 200
                    , "Euml": 203
                    , "Iacute": 205
                    , "Icirc": 206
                    , "Igrave": 204
                    , "Iuml": 207
                    , "Ntilde": 209
                    , "Oacute": 211
                    , "Ocirc": 212
                    , "Ograve": 210
                    , "Oslash": 216
                    , "Otilde": 213
                    , "Ouml": 214
                    , "THORN": 222
                    , "Uacute": 218
                    , "Ucirc": 219
                    , "Ugrave": 217
                    , "Uuml": 220
                    , "Yacute": 221
                    , "aacute": 225
                    , "acirc": 226
                    , "aelig": 230
                    , "agrave": 224
                    , "aring": 229
                    , "atilde": 227
                    , "auml": 228
                    , "ccedil": 231
                    , "eacute": 233
                    , "ecirc": 234
                    , "egrave": 232
                    , "eth": 240
                    , "euml": 235
                    , "iacute": 237
                    , "icirc": 238
                    , "igrave": 236
                    , "iuml": 239
                    , "ntilde": 241
                    , "oacute": 243
                    , "ocirc": 244
                    , "ograve": 242
                    , "oslash": 248
                    , "otilde": 245
                    , "ouml": 246
                    , "szlig": 223
                    , "thorn": 254
                    , "uacute": 250
                    , "ucirc": 251
                    , "ugrave": 249
                    , "uuml": 252
                    , "yacute": 253
                    , "yuml": 255
                    , "copy": 169
                    , "reg": 174
                    , "nbsp": 160
                    , "iexcl": 161
                    , "cent": 162
                    , "pound": 163
                    , "curren": 164
                    , "yen": 165
                    , "brvbar": 166
                    , "sect": 167
                    , "uml": 168
                    , "ordf": 170
                    , "laquo": 171
                    , "not": 172
                    , "shy": 173
                    , "macr": 175
                    , "deg": 176
                    , "plusmn": 177
                    , "sup1": 185
                    , "sup2": 178
                    , "sup3": 179
                    , "acute": 180
                    , "micro": 181
                    , "para": 182
                    , "middot": 183
                    , "cedil": 184
                    , "ordm": 186
                    , "raquo": 187
                    , "frac14": 188
                    , "frac12": 189
                    , "frac34": 190
                    , "iquest": 191
                    , "times": 215
                    , "divide": 247
                    , "OElig": 338
                    , "oelig": 339
                    , "Scaron": 352
                    , "scaron": 353
                    , "Yuml": 376
                    , "fnof": 402
                    , "circ": 710
                    , "tilde": 732
                    , "Alpha": 913
                    , "Beta": 914
                    , "Gamma": 915
                    , "Delta": 916
                    , "Epsilon": 917
                    , "Zeta": 918
                    , "Eta": 919
                    , "Theta": 920
                    , "Iota": 921
                    , "Kappa": 922
                    , "Lambda": 923
                    , "Mu": 924
                    , "Nu": 925
                    , "Xi": 926
                    , "Omicron": 927
                    , "Pi": 928
                    , "Rho": 929
                    , "Sigma": 931
                    , "Tau": 932
                    , "Upsilon": 933
                    , "Phi": 934
                    , "Chi": 935
                    , "Psi": 936
                    , "Omega": 937
                    , "alpha": 945
                    , "beta": 946
                    , "gamma": 947
                    , "delta": 948
                    , "epsilon": 949
                    , "zeta": 950
                    , "eta": 951
                    , "theta": 952
                    , "iota": 953
                    , "kappa": 954
                    , "lambda": 955
                    , "mu": 956
                    , "nu": 957
                    , "xi": 958
                    , "omicron": 959
                    , "pi": 960
                    , "rho": 961
                    , "sigmaf": 962
                    , "sigma": 963
                    , "tau": 964
                    , "upsilon": 965
                    , "phi": 966
                    , "chi": 967
                    , "psi": 968
                    , "omega": 969
                    , "thetasym": 977
                    , "upsih": 978
                    , "piv": 982
                    , "ensp": 8194
                    , "emsp": 8195
                    , "thinsp": 8201
                    , "zwnj": 8204
                    , "zwj": 8205
                    , "lrm": 8206
                    , "rlm": 8207
                    , "ndash": 8211
                    , "mdash": 8212
                    , "lsquo": 8216
                    , "rsquo": 8217
                    , "sbquo": 8218
                    , "ldquo": 8220
                    , "rdquo": 8221
                    , "bdquo": 8222
                    , "dagger": 8224
                    , "Dagger": 8225
                    , "bull": 8226
                    , "hellip": 8230
                    , "permil": 8240
                    , "prime": 8242
                    , "Prime": 8243
                    , "lsaquo": 8249
                    , "rsaquo": 8250
                    , "oline": 8254
                    , "frasl": 8260
                    , "euro": 8364
                    , "image": 8465
                    , "weierp": 8472
                    , "real": 8476
                    , "trade": 8482
                    , "alefsym": 8501
                    , "larr": 8592
                    , "uarr": 8593
                    , "rarr": 8594
                    , "darr": 8595
                    , "harr": 8596
                    , "crarr": 8629
                    , "lArr": 8656
                    , "uArr": 8657
                    , "rArr": 8658
                    , "dArr": 8659
                    , "hArr": 8660
                    , "forall": 8704
                    , "part": 8706
                    , "exist": 8707
                    , "empty": 8709
                    , "nabla": 8711
                    , "isin": 8712
                    , "notin": 8713
                    , "ni": 8715
                    , "prod": 8719
                    , "sum": 8721
                    , "minus": 8722
                    , "lowast": 8727
                    , "radic": 8730
                    , "prop": 8733
                    , "infin": 8734
                    , "ang": 8736
                    , "and": 8743
                    , "or": 8744
                    , "cap": 8745
                    , "cup": 8746
                    , "int": 8747
                    , "there4": 8756
                    , "sim": 8764
                    , "cong": 8773
                    , "asymp": 8776
                    , "ne": 8800
                    , "equiv": 8801
                    , "le": 8804
                    , "ge": 8805
                    , "sub": 8834
                    , "sup": 8835
                    , "nsub": 8836
                    , "sube": 8838
                    , "supe": 8839
                    , "oplus": 8853
                    , "otimes": 8855
                    , "perp": 8869
                    , "sdot": 8901
                    , "lceil": 8968
                    , "rceil": 8969
                    , "lfloor": 8970
                    , "rfloor": 8971
                    , "lang": 9001
                    , "rang": 9002
                    , "loz": 9674
                    , "spades": 9824
                    , "clubs": 9827
                    , "hearts": 9829
                    , "diams": 9830
                }

                Object.keys(sax.ENTITIES).forEach(function (key) {
                    var e = sax.ENTITIES[key]
                    var s = typeof e === 'number' ? String.fromCharCode(e) : e
                    sax.ENTITIES[key] = s
                })

                for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S

// shorthand
                S = sax.STATE

                function emit(parser, event, data) {
                    parser[event] && parser[event](data)
                }

                function emitNode(parser, nodeType, data) {
                    if (parser.textNode) closeText(parser)
                    emit(parser, nodeType, data)
                }

                function closeText(parser) {
                    parser.textNode = textopts(parser.opt, parser.textNode)
                    if (parser.textNode) emit(parser, "ontext", parser.textNode)
                    parser.textNode = ""
                }

                function textopts(opt, text) {
                    if (opt.trim) text = text.trim()
                    if (opt.normalize) text = text.replace(/\s+/g, " ")
                    return text
                }

                function error(parser, er) {
                    closeText(parser)
                    if (parser.trackPosition) {
                        er += "\nLine: " + parser.line +
                        "\nColumn: " + parser.column +
                        "\nChar: " + parser.c
                    }
                    er = new Error(er)
                    parser.error = er
                    emit(parser, "onerror", er)
                    return parser
                }

                function end(parser) {
                    if (!parser.closedRoot) strictFail(parser, "Unclosed root tag")
                    if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, "Unexpected end")
                    closeText(parser)
                    parser.c = ""
                    parser.closed = true
                    emit(parser, "onend")
                    SAXParser.call(parser, parser.strict, parser.opt)
                    return parser
                }

                function strictFail(parser, message) {
                    if (typeof parser !== 'object' || !(parser instanceof SAXParser))
                        throw new Error('bad call to strictFail');
                    if (parser.strict) error(parser, message)
                }

                function newTag(parser) {
                    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
                    var parent = parser.tags[parser.tags.length - 1] || parser
                        , tag = parser.tag = {name: parser.tagName, attributes: {}}

                    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
                    if (parser.opt.xmlns) tag.ns = parent.ns
                    parser.attribList.length = 0
                }

                function qname(name, attribute) {
                    var i = name.indexOf(":")
                        , qualName = i < 0 ? ["", name] : name.split(":")
                        , prefix = qualName[0]
                        , local = qualName[1]

                    // <x "xmlns"="http://foo">
                    if (attribute && name === "xmlns") {
                        prefix = "xmlns"
                        local = ""
                    }

                    return {prefix: prefix, local: local}
                }

                function attrib(parser) {
                    if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()

                    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
                        parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                        return parser.attribName = parser.attribValue = ""
                    }

                    if (parser.opt.xmlns) {
                        var qn = qname(parser.attribName, true)
                            , prefix = qn.prefix
                            , local = qn.local

                        if (prefix === "xmlns") {
                            // namespace binding attribute; push the binding into scope
                            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                                strictFail(parser
                                    , "xml: prefix must be bound to " + XML_NAMESPACE + "\n"
                                    + "Actual: " + parser.attribValue)
                            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                                strictFail(parser
                                    , "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n"
                                    + "Actual: " + parser.attribValue)
                            } else {
                                var tag = parser.tag
                                    , parent = parser.tags[parser.tags.length - 1] || parser
                                if (tag.ns === parent.ns) {
                                    tag.ns = Object.create(parent.ns)
                                }
                                tag.ns[local] = parser.attribValue
                            }
                        }

                        // defer onattribute events until all attributes have been seen
                        // so any new bindings can take effect; preserve attribute order
                        // so deferred events can be emitted in document order
                        parser.attribList.push([parser.attribName, parser.attribValue])
                    } else {
                        // in non-xmlns mode, we can emit the event right away
                        parser.tag.attributes[parser.attribName] = parser.attribValue
                        emitNode(parser
                            , "onattribute"
                            , {
                                name: parser.attribName
                                , value: parser.attribValue
                            })
                    }

                    parser.attribName = parser.attribValue = ""
                }

                function openTag(parser, selfClosing) {
                    if (parser.opt.xmlns) {
                        // emit namespace binding events
                        var tag = parser.tag

                        // add namespace info to tag
                        var qn = qname(parser.tagName)
                        tag.prefix = qn.prefix
                        tag.local = qn.local
                        tag.uri = tag.ns[qn.prefix] || ""

                        if (tag.prefix && !tag.uri) {
                            strictFail(parser, "Unbound namespace prefix: "
                            + JSON.stringify(parser.tagName))
                            tag.uri = qn.prefix
                        }

                        var parent = parser.tags[parser.tags.length - 1] || parser
                        if (tag.ns && parent.ns !== tag.ns) {
                            Object.keys(tag.ns).forEach(function (p) {
                                emitNode(parser
                                    , "onopennamespace"
                                    , {prefix: p, uri: tag.ns[p]})
                            })
                        }

                        // handle deferred onattribute events
                        // Note: do not apply default ns to attributes:
                        //   http://www.w3.org/TR/REC-xml-names/#defaulting
                        for (var i = 0, l = parser.attribList.length; i < l; i++) {
                            var nv = parser.attribList[i]
                            var name = nv[0]
                                , value = nv[1]
                                , qualName = qname(name, true)
                                , prefix = qualName.prefix
                                , local = qualName.local
                                , uri = prefix == "" ? "" : (tag.ns[prefix] || "")
                                , a = {
                                    name: name
                                    , value: value
                                    , prefix: prefix
                                    , local: local
                                    , uri: uri
                                }

                            // if there's any attributes with an undefined namespace,
                            // then fail on them now.
                            if (prefix && prefix != "xmlns" && !uri) {
                                strictFail(parser, "Unbound namespace prefix: "
                                + JSON.stringify(prefix))
                                a.uri = prefix
                            }
                            parser.tag.attributes[name] = a
                            emitNode(parser, "onattribute", a)
                        }
                        parser.attribList.length = 0
                    }

                    parser.tag.isSelfClosing = !!selfClosing

                    // process the tag
                    parser.sawRoot = true
                    parser.tags.push(parser.tag)
                    emitNode(parser, "onopentag", parser.tag)
                    if (!selfClosing) {
                        // special case for <script> in non-strict mode.
                        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
                            parser.state = S.SCRIPT
                        } else {
                            parser.state = S.TEXT
                        }
                        parser.tag = null
                        parser.tagName = ""
                    }
                    parser.attribName = parser.attribValue = ""
                    parser.attribList.length = 0
                }

                function closeTag(parser) {
                    if (!parser.tagName) {
                        strictFail(parser, "Weird empty close tag.")
                        parser.textNode += "</>"
                        parser.state = S.TEXT
                        return
                    }

                    if (parser.script) {
                        if (parser.tagName !== "script") {
                            parser.script += "</" + parser.tagName + ">"
                            parser.tagName = ""
                            parser.state = S.SCRIPT
                            return
                        }
                        emitNode(parser, "onscript", parser.script)
                        parser.script = ""
                    }

                    // first make sure that the closing tag actually exists.
                    // <a><b></c></b></a> will close everything, otherwise.
                    var t = parser.tags.length
                    var tagName = parser.tagName
                    if (!parser.strict) tagName = tagName[parser.looseCase]()
                    var closeTo = tagName
                    while (t--) {
                        var close = parser.tags[t]
                        if (close.name !== closeTo) {
                            // fail the first time in strict mode
                            strictFail(parser, "Unexpected close tag")
                        } else break
                    }

                    // didn't find it.  we already failed for strict, so just abort.
                    if (t < 0) {
                        strictFail(parser, "Unmatched closing tag: " + parser.tagName)
                        parser.textNode += "</" + parser.tagName + ">"
                        parser.state = S.TEXT
                        return
                    }
                    parser.tagName = tagName
                    var s = parser.tags.length
                    while (s-- > t) {
                        var tag = parser.tag = parser.tags.pop()
                        parser.tagName = parser.tag.name
                        emitNode(parser, "onclosetag", parser.tagName)

                        var x = {}
                        for (var i in tag.ns) x[i] = tag.ns[i]

                        var parent = parser.tags[parser.tags.length - 1] || parser
                        if (parser.opt.xmlns && tag.ns !== parent.ns) {
                            // remove namespace bindings introduced by tag
                            Object.keys(tag.ns).forEach(function (p) {
                                var n = tag.ns[p]
                                emitNode(parser, "onclosenamespace", {prefix: p, uri: n})
                            })
                        }
                    }
                    if (t === 0) parser.closedRoot = true
                    parser.tagName = parser.attribValue = parser.attribName = ""
                    parser.attribList.length = 0
                    parser.state = S.TEXT
                }

                function parseEntity(parser) {
                    var entity = parser.entity
                        , entityLC = entity.toLowerCase()
                        , num
                        , numStr = ""
                    if (parser.ENTITIES[entity])
                        return parser.ENTITIES[entity]
                    if (parser.ENTITIES[entityLC])
                        return parser.ENTITIES[entityLC]
                    entity = entityLC
                    if (entity.charAt(0) === "#") {
                        if (entity.charAt(1) === "x") {
                            entity = entity.slice(2)
                            num = parseInt(entity, 16)
                            numStr = num.toString(16)
                        } else {
                            entity = entity.slice(1)
                            num = parseInt(entity, 10)
                            numStr = num.toString(10)
                        }
                    }
                    entity = entity.replace(/^0+/, "")
                    if (numStr.toLowerCase() !== entity) {
                        strictFail(parser, "Invalid character entity")
                        return "&" + parser.entity + ";"
                    }

                    return String.fromCodePoint(num)
                }

                function write(chunk) {
                    var parser = this
                    if (this.error) throw this.error
                    if (parser.closed) return error(parser,
                        "Cannot write after close. Assign an onready handler.")
                    if (chunk === null) return end(parser)
                    var i = 0, c = ""
                    while (parser.c = c = chunk.charAt(i++)) {
                        if (parser.trackPosition) {
                            parser.position++
                            if (c === "\n") {
                                parser.line++
                                parser.column = 0
                            } else parser.column++
                        }
                        switch (parser.state) {

                            case S.BEGIN:
                                if (c === "<") {
                                    parser.state = S.OPEN_WAKA
                                    parser.startTagPosition = parser.position
                                } else if (not(whitespace, c)) {
                                    // have to process this as a text node.
                                    // weird, but happens.
                                    strictFail(parser, "Non-whitespace before first tag.")
                                    parser.textNode = c
                                    parser.state = S.TEXT
                                }
                                continue

                            case S.TEXT:
                                if (parser.sawRoot && !parser.closedRoot) {
                                    var starti = i - 1
                                    while (c && c !== "<" && c !== "&") {
                                        c = chunk.charAt(i++)
                                        if (c && parser.trackPosition) {
                                            parser.position++
                                            if (c === "\n") {
                                                parser.line++
                                                parser.column = 0
                                            } else parser.column++
                                        }
                                    }
                                    parser.textNode += chunk.substring(starti, i - 1)
                                }
                                if (c === "<") {
                                    parser.state = S.OPEN_WAKA
                                    parser.startTagPosition = parser.position
                                } else {
                                    if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))
                                        strictFail(parser, "Text data outside of root node.")
                                    if (c === "&") parser.state = S.TEXT_ENTITY
                                    else parser.textNode += c
                                }
                                continue

                            case S.SCRIPT:
                                // only non-strict
                                if (c === "<") {
                                    parser.state = S.SCRIPT_ENDING
                                } else parser.script += c
                                continue

                            case S.SCRIPT_ENDING:
                                if (c === "/") {
                                    parser.state = S.CLOSE_TAG
                                } else {
                                    parser.script += "<" + c
                                    parser.state = S.SCRIPT
                                }
                                continue

                            case S.OPEN_WAKA:
                                // either a /, ?, !, or text is coming next.
                                if (c === "!") {
                                    parser.state = S.SGML_DECL
                                    parser.sgmlDecl = ""
                                } else if (is(whitespace, c)) {
                                    // wait for it...
                                } else if (is(nameStart, c)) {
                                    parser.state = S.OPEN_TAG
                                    parser.tagName = c
                                } else if (c === "/") {
                                    parser.state = S.CLOSE_TAG
                                    parser.tagName = ""
                                } else if (c === "?") {
                                    parser.state = S.PROC_INST
                                    parser.procInstName = parser.procInstBody = ""
                                } else {
                                    strictFail(parser, "Unencoded <")
                                    // if there was some whitespace, then add that in.
                                    if (parser.startTagPosition + 1 < parser.position) {
                                        var pad = parser.position - parser.startTagPosition
                                        c = new Array(pad).join(" ") + c
                                    }
                                    parser.textNode += "<" + c
                                    parser.state = S.TEXT
                                }
                                continue

                            case S.SGML_DECL:
                                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                                    emitNode(parser, "onopencdata")
                                    parser.state = S.CDATA
                                    parser.sgmlDecl = ""
                                    parser.cdata = ""
                                } else if (parser.sgmlDecl + c === "--") {
                                    parser.state = S.COMMENT
                                    parser.comment = ""
                                    parser.sgmlDecl = ""
                                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                                    parser.state = S.DOCTYPE
                                    if (parser.doctype || parser.sawRoot) strictFail(parser,
                                        "Inappropriately located doctype declaration")
                                    parser.doctype = ""
                                    parser.sgmlDecl = ""
                                } else if (c === ">") {
                                    emitNode(parser, "onsgmldeclaration", parser.sgmlDecl)
                                    parser.sgmlDecl = ""
                                    parser.state = S.TEXT
                                } else if (is(quote, c)) {
                                    parser.state = S.SGML_DECL_QUOTED
                                    parser.sgmlDecl += c
                                } else parser.sgmlDecl += c
                                continue

                            case S.SGML_DECL_QUOTED:
                                if (c === parser.q) {
                                    parser.state = S.SGML_DECL
                                    parser.q = ""
                                }
                                parser.sgmlDecl += c
                                continue

                            case S.DOCTYPE:
                                if (c === ">") {
                                    parser.state = S.TEXT
                                    emitNode(parser, "ondoctype", parser.doctype)
                                    parser.doctype = true // just remember that we saw it.
                                } else {
                                    parser.doctype += c
                                    if (c === "[") parser.state = S.DOCTYPE_DTD
                                    else if (is(quote, c)) {
                                        parser.state = S.DOCTYPE_QUOTED
                                        parser.q = c
                                    }
                                }
                                continue

                            case S.DOCTYPE_QUOTED:
                                parser.doctype += c
                                if (c === parser.q) {
                                    parser.q = ""
                                    parser.state = S.DOCTYPE
                                }
                                continue

                            case S.DOCTYPE_DTD:
                                parser.doctype += c
                                if (c === "]") parser.state = S.DOCTYPE
                                else if (is(quote, c)) {
                                    parser.state = S.DOCTYPE_DTD_QUOTED
                                    parser.q = c
                                }
                                continue

                            case S.DOCTYPE_DTD_QUOTED:
                                parser.doctype += c
                                if (c === parser.q) {
                                    parser.state = S.DOCTYPE_DTD
                                    parser.q = ""
                                }
                                continue

                            case S.COMMENT:
                                if (c === "-") parser.state = S.COMMENT_ENDING
                                else parser.comment += c
                                continue

                            case S.COMMENT_ENDING:
                                if (c === "-") {
                                    parser.state = S.COMMENT_ENDED
                                    parser.comment = textopts(parser.opt, parser.comment)
                                    if (parser.comment) emitNode(parser, "oncomment", parser.comment)
                                    parser.comment = ""
                                } else {
                                    parser.comment += "-" + c
                                    parser.state = S.COMMENT
                                }
                                continue

                            case S.COMMENT_ENDED:
                                if (c !== ">") {
                                    strictFail(parser, "Malformed comment")
                                    // allow <!-- blah -- bloo --> in non-strict mode,
                                    // which is a comment of " blah -- bloo "
                                    parser.comment += "--" + c
                                    parser.state = S.COMMENT
                                } else parser.state = S.TEXT
                                continue

                            case S.CDATA:
                                if (c === "]") parser.state = S.CDATA_ENDING
                                else parser.cdata += c
                                continue

                            case S.CDATA_ENDING:
                                if (c === "]") parser.state = S.CDATA_ENDING_2
                                else {
                                    parser.cdata += "]" + c
                                    parser.state = S.CDATA
                                }
                                continue

                            case S.CDATA_ENDING_2:
                                if (c === ">") {
                                    if (parser.cdata) emitNode(parser, "oncdata", parser.cdata)
                                    emitNode(parser, "onclosecdata")
                                    parser.cdata = ""
                                    parser.state = S.TEXT
                                } else if (c === "]") {
                                    parser.cdata += "]"
                                } else {
                                    parser.cdata += "]]" + c
                                    parser.state = S.CDATA
                                }
                                continue

                            case S.PROC_INST:
                                if (c === "?") parser.state = S.PROC_INST_ENDING
                                else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY
                                else parser.procInstName += c
                                continue

                            case S.PROC_INST_BODY:
                                if (!parser.procInstBody && is(whitespace, c)) continue
                                else if (c === "?") parser.state = S.PROC_INST_ENDING
                                else parser.procInstBody += c
                                continue

                            case S.PROC_INST_ENDING:
                                if (c === ">") {
                                    emitNode(parser, "onprocessinginstruction", {
                                        name: parser.procInstName,
                                        body: parser.procInstBody
                                    })
                                    parser.procInstName = parser.procInstBody = ""
                                    parser.state = S.TEXT
                                } else {
                                    parser.procInstBody += "?" + c
                                    parser.state = S.PROC_INST_BODY
                                }
                                continue

                            case S.OPEN_TAG:
                                if (is(nameBody, c)) parser.tagName += c
                                else {
                                    newTag(parser)
                                    if (c === ">") openTag(parser)
                                    else if (c === "/") parser.state = S.OPEN_TAG_SLASH
                                    else {
                                        if (not(whitespace, c)) strictFail(
                                            parser, "Invalid character in tag name")
                                        parser.state = S.ATTRIB
                                    }
                                }
                                continue

                            case S.OPEN_TAG_SLASH:
                                if (c === ">") {
                                    openTag(parser, true)
                                    closeTag(parser)
                                } else {
                                    strictFail(parser, "Forward-slash in opening tag not followed by >")
                                    parser.state = S.ATTRIB
                                }
                                continue

                            case S.ATTRIB:
                                // haven't read the attribute name yet.
                                if (is(whitespace, c)) continue
                                else if (c === ">") openTag(parser)
                                else if (c === "/") parser.state = S.OPEN_TAG_SLASH
                                else if (is(nameStart, c)) {
                                    parser.attribName = c
                                    parser.attribValue = ""
                                    parser.state = S.ATTRIB_NAME
                                } else strictFail(parser, "Invalid attribute name")
                                continue

                            case S.ATTRIB_NAME:
                                if (c === "=") parser.state = S.ATTRIB_VALUE
                                else if (c === ">") {
                                    strictFail(parser, "Attribute without value")
                                    parser.attribValue = parser.attribName
                                    attrib(parser)
                                    openTag(parser)
                                }
                                else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE
                                else if (is(nameBody, c)) parser.attribName += c
                                else strictFail(parser, "Invalid attribute name")
                                continue

                            case S.ATTRIB_NAME_SAW_WHITE:
                                if (c === "=") parser.state = S.ATTRIB_VALUE
                                else if (is(whitespace, c)) continue
                                else {
                                    strictFail(parser, "Attribute without value")
                                    parser.tag.attributes[parser.attribName] = ""
                                    parser.attribValue = ""
                                    emitNode(parser, "onattribute",
                                        {name: parser.attribName, value: ""})
                                    parser.attribName = ""
                                    if (c === ">") openTag(parser)
                                    else if (is(nameStart, c)) {
                                        parser.attribName = c
                                        parser.state = S.ATTRIB_NAME
                                    } else {
                                        strictFail(parser, "Invalid attribute name")
                                        parser.state = S.ATTRIB
                                    }
                                }
                                continue

                            case S.ATTRIB_VALUE:
                                if (is(whitespace, c)) continue
                                else if (is(quote, c)) {
                                    parser.q = c
                                    parser.state = S.ATTRIB_VALUE_QUOTED
                                } else {
                                    strictFail(parser, "Unquoted attribute value")
                                    parser.state = S.ATTRIB_VALUE_UNQUOTED
                                    parser.attribValue = c
                                }
                                continue

                            case S.ATTRIB_VALUE_QUOTED:
                                if (c !== parser.q) {
                                    if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q
                                    else parser.attribValue += c
                                    continue
                                }
                                attrib(parser)
                                parser.q = ""
                                parser.state = S.ATTRIB_VALUE_CLOSED
                                continue

                            case S.ATTRIB_VALUE_CLOSED:
                                if (is(whitespace, c)) {
                                    parser.state = S.ATTRIB
                                } else if (c === ">") openTag(parser)
                                else if (c === "/") parser.state = S.OPEN_TAG_SLASH
                                else if (is(nameStart, c)) {
                                    strictFail(parser, "No whitespace between attributes")
                                    parser.attribName = c
                                    parser.attribValue = ""
                                    parser.state = S.ATTRIB_NAME
                                } else strictFail(parser, "Invalid attribute name")
                                continue

                            case S.ATTRIB_VALUE_UNQUOTED:
                                if (not(attribEnd, c)) {
                                    if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U
                                    else parser.attribValue += c
                                    continue
                                }
                                attrib(parser)
                                if (c === ">") openTag(parser)
                                else parser.state = S.ATTRIB
                                continue

                            case S.CLOSE_TAG:
                                if (!parser.tagName) {
                                    if (is(whitespace, c)) continue
                                    else if (not(nameStart, c)) {
                                        if (parser.script) {
                                            parser.script += "</" + c
                                            parser.state = S.SCRIPT
                                        } else {
                                            strictFail(parser, "Invalid tagname in closing tag.")
                                        }
                                    } else parser.tagName = c
                                }
                                else if (c === ">") closeTag(parser)
                                else if (is(nameBody, c)) parser.tagName += c
                                else if (parser.script) {
                                    parser.script += "</" + parser.tagName
                                    parser.tagName = ""
                                    parser.state = S.SCRIPT
                                } else {
                                    if (not(whitespace, c)) strictFail(parser,
                                        "Invalid tagname in closing tag")
                                    parser.state = S.CLOSE_TAG_SAW_WHITE
                                }
                                continue

                            case S.CLOSE_TAG_SAW_WHITE:
                                if (is(whitespace, c)) continue
                                if (c === ">") closeTag(parser)
                                else strictFail(parser, "Invalid characters in closing tag")
                                continue

                            case S.TEXT_ENTITY:
                            case S.ATTRIB_VALUE_ENTITY_Q:
                            case S.ATTRIB_VALUE_ENTITY_U:
                                switch (parser.state) {
                                    case S.TEXT_ENTITY:
                                        var returnState = S.TEXT, buffer = "textNode"
                                        break

                                    case S.ATTRIB_VALUE_ENTITY_Q:
                                        var returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue"
                                        break

                                    case S.ATTRIB_VALUE_ENTITY_U:
                                        var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue"
                                        break
                                }
                                if (c === ";") {
                                    parser[buffer] += parseEntity(parser)
                                    parser.entity = ""
                                    parser.state = returnState
                                }
                                else if (is(entity, c)) parser.entity += c
                                else {
                                    strictFail(parser, "Invalid character entity")
                                    parser[buffer] += "&" + parser.entity + c
                                    parser.entity = ""
                                    parser.state = returnState
                                }
                                continue

                            default:
                                throw new Error(parser, "Unknown state: " + parser.state)
                        }
                    } // while
                    // cdata blocks can get very big under normal conditions. emit and move on.
                    // if (parser.state === S.CDATA && parser.cdata) {
                    //   emitNode(parser, "oncdata", parser.cdata)
                    //   parser.cdata = ""
                    // }
                    if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)
                    return parser
                }

                /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
                if (!String.fromCodePoint) {
                    (function () {
                        var stringFromCharCode = String.fromCharCode;
                        var floor = Math.floor;
                        var fromCodePoint = function () {
                            var MAX_SIZE = 0x4000;
                            var codeUnits = [];
                            var highSurrogate;
                            var lowSurrogate;
                            var index = -1;
                            var length = arguments.length;
                            if (!length) {
                                return '';
                            }
                            var result = '';
                            while (++index < length) {
                                var codePoint = Number(arguments[index]);
                                if (
                                    !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                                    codePoint < 0 || // not a valid Unicode code point
                                    codePoint > 0x10FFFF || // not a valid Unicode code point
                                    floor(codePoint) != codePoint // not an integer
                                ) {
                                    throw RangeError('Invalid code point: ' + codePoint);
                                }
                                if (codePoint <= 0xFFFF) { // BMP code point
                                    codeUnits.push(codePoint);
                                } else { // Astral code point; split in surrogate halves
                                    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                                    codePoint -= 0x10000;
                                    highSurrogate = (codePoint >> 10) + 0xD800;
                                    lowSurrogate = (codePoint % 0x400) + 0xDC00;
                                    codeUnits.push(highSurrogate, lowSurrogate);
                                }
                                if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                                    result += stringFromCharCode.apply(null, codeUnits);
                                    codeUnits.length = 0;
                                }
                            }
                            return result;
                        };
                        if (Object.defineProperty) {
                            Object.defineProperty(String, 'fromCodePoint', {
                                'value': fromCodePoint,
                                'configurable': true,
                                'writable': true
                            });
                        } else {
                            String.fromCodePoint = fromCodePoint;
                        }
                    }());
                }

            })(typeof exports === "undefined" ? sax = {} : exports);

        }).call(this, undefined)
    }, {"stream": false, "string_decoder": false}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle-xml/node_modules/tiny-stack/lib/tiny-stack.js": [function (require, module, exports) {
        /**
         * Tiny stack for browser or server
         *
         * @author Jason Mulligan <jason.mulligan@avoidwork.com>
         * @copyright 2014 Jason Mulligan
         * @license BSD-3 <https://raw.github.com/avoidwork/tiny-stack/master/LICENSE>
         * @link http://avoidwork.github.io/tiny-stack
         * @module tiny-stack
         * @version 0.1.0
         */

        (function (global) {

            "use strict";

            /**
             * TinyStack
             *
             * @constructor
             */
            function TinyStack() {
                this.data = [null];
                this.top = 0;
            }

            /**
             * Clears the stack
             *
             * @method clear
             * @memberOf TinyStack
             * @return {Object} {@link TinyStack}
             */
            TinyStack.prototype.clear = function clear() {
                this.data = [null];
                this.top = 0;

                return this;
            };

            /**
             * Gets the size of the stack
             *
             * @method length
             * @memberOf TinyStack
             * @return {Number} Size of stack
             */
            TinyStack.prototype.length = function length() {
                return this.top;
            };

            /**
             * Gets the item at the top of the stack
             *
             * @method peek
             * @memberOf TinyStack
             * @return {Mixed} Item at the top of the stack
             */
            TinyStack.prototype.peek = function peek() {
                return this.data[this.top];
            };

            /**
             * Gets & removes the item at the top of the stack
             *
             * @method pop
             * @memberOf TinyStack
             * @return {Mixed} Item at the top of the stack
             */
            TinyStack.prototype.pop = function pop() {
                if (this.top > 0) {
                    this.top--;

                    return this.data.pop();
                }
                else {
                    return undefined;
                }
            };

            /**
             * Pushes an item onto the stack
             *
             * @method push
             * @memberOf TinyStack
             * @return {Object} {@link TinyStack}
             */
            TinyStack.prototype.push = function push(arg) {
                this.data[++this.top] = arg;

                return this;
            };

            /**
             * TinyStack factory
             *
             * @method factory
             * @return {Object} {@link TinyStack}
             */
            function factory() {
                return new TinyStack();
            }

// Node, AMD & window supported
            if (typeof exports != "undefined") {
                module.exports = factory;
            }
            else if (typeof define == "function") {
                define(function () {
                    return factory;
                });
            }
            else {
                global.stack = factory;
            }
        })(this);

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/index.js": [function (require, module, exports) {
        module.exports = require('./lib/moddle');
    }, {"./lib/moddle": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/moddle.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/base.js": [function (require, module, exports) {
        'use strict';

        function Base() {
        }

        Base.prototype.get = function (name) {
            return this.$model.properties.get(this, name);
        };

        Base.prototype.set = function (name, value) {
            this.$model.properties.set(this, name, value);
        };


        module.exports = Base;
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/descriptor-builder.js": [function (require, module, exports) {
        'use strict';

        var pick = require('lodash/object/pick'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var parseNameNs = require('./ns').parseName;


        function DescriptorBuilder(nameNs) {
            this.ns = nameNs;
            this.name = nameNs.name;
            this.allTypes = [];
            this.properties = [];
            this.propertiesByName = {};
        }

        module.exports = DescriptorBuilder;


        DescriptorBuilder.prototype.build = function () {
            return pick(this, ['ns', 'name', 'allTypes', 'properties', 'propertiesByName', 'bodyProperty']);
        };

        DescriptorBuilder.prototype.addProperty = function (p, idx) {
            this.addNamedProperty(p, true);

            var properties = this.properties;

            if (idx !== undefined) {
                properties.splice(idx, 0, p);
            } else {
                properties.push(p);
            }
        };


        DescriptorBuilder.prototype.replaceProperty = function (oldProperty, newProperty) {
            var oldNameNs = oldProperty.ns;

            var props = this.properties,
                propertiesByName = this.propertiesByName,
                rename = oldProperty.name !== newProperty.name;

            if (oldProperty.isBody) {

                if (!newProperty.isBody) {
                    throw new Error(
                        'property <' + newProperty.ns.name + '> must be body property ' +
                        'to refine <' + oldProperty.ns.name + '>');
                }

                // TODO: Check compatibility
                this.setBodyProperty(newProperty, false);
            }

            // replacing the named property is intentional
            // thus, validate only if this is a "rename" operation
            this.addNamedProperty(newProperty, rename);

            // replace old property at index with new one
            var idx = props.indexOf(oldProperty);
            if (idx === -1) {
                throw new Error('property <' + oldNameNs.name + '> not found in property list');
            }

            props[idx] = newProperty;

            // replace propertiesByName entry with new property
            propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
        };


        DescriptorBuilder.prototype.redefineProperty = function (p) {

            var nsPrefix = p.ns.prefix;
            var parts = p.redefines.split('#');

            var name = parseNameNs(parts[0], nsPrefix);
            var attrName = parseNameNs(parts[1], name.prefix).name;

            var redefinedProperty = this.propertiesByName[attrName];
            if (!redefinedProperty) {
                throw new Error('refined property <' + attrName + '> not found');
            } else {
                this.replaceProperty(redefinedProperty, p);
            }

            delete p.redefines;
        };

        DescriptorBuilder.prototype.addNamedProperty = function (p, validate) {
            var ns = p.ns,
                propsByName = this.propertiesByName;

            if (validate) {
                this.assertNotDefined(p, ns.name);
                this.assertNotDefined(p, ns.localName);
            }

            propsByName[ns.name] = propsByName[ns.localName] = p;
        };

        DescriptorBuilder.prototype.removeNamedProperty = function (p) {
            var ns = p.ns,
                propsByName = this.propertiesByName;

            delete propsByName[ns.name];
            delete propsByName[ns.localName];
        };

        DescriptorBuilder.prototype.setBodyProperty = function (p, validate) {

            if (validate && this.bodyProperty) {
                throw new Error(
                    'body property defined multiple times ' +
                    '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');
            }

            this.bodyProperty = p;
        };

        DescriptorBuilder.prototype.addIdProperty = function (name) {
            var nameNs = parseNameNs(name, this.ns.prefix);

            var p = {
                name: nameNs.localName,
                type: 'String',
                isAttr: true,
                ns: nameNs
            };

            // ensure that id is always the first attribute (if present)
            this.addProperty(p, 0);
        };

        DescriptorBuilder.prototype.assertNotDefined = function (p, name) {
            var propertyName = p.name,
                definedProperty = this.propertiesByName[propertyName];

            if (definedProperty) {
                throw new Error(
                    'property <' + propertyName + '> already defined; ' +
                    'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +
                    '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');
            }
        };

        DescriptorBuilder.prototype.hasProperty = function (name) {
            return this.propertiesByName[name];
        };

        DescriptorBuilder.prototype.addTrait = function (t) {

            var allTypes = this.allTypes;

            if (allTypes.indexOf(t) !== -1) {
                return;
            }

            forEach(t.properties, function (p) {

                // clone property to allow extensions
                p = assign({}, p, {
                    name: p.ns.localName
                });

                Object.defineProperty(p, 'definedBy', {
                    value: t
                });

                // add redefine support
                if (p.redefines) {
                    this.redefineProperty(p);
                } else {
                    if (p.isBody) {
                        this.setBodyProperty(p);
                    }
                    this.addProperty(p);
                }
            }, this);

            allTypes.push(t);
        };

    }, {
        "./ns": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/ns.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "lodash/object/pick": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/pick.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/factory.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var Base = require('./base');


        function Factory(model, properties) {
            this.model = model;
            this.properties = properties;
        }

        module.exports = Factory;


        Factory.prototype.createType = function (descriptor) {

            var model = this.model;

            var props = this.properties,
                prototype = Object.create(Base.prototype);

            // initialize default values
            forEach(descriptor.properties, function (p) {
                if (!p.isMany && p.default !== undefined) {
                    prototype[p.name] = p.default;
                }
            });

            props.defineModel(prototype, model);
            props.defineDescriptor(prototype, descriptor);

            var name = descriptor.ns.name;

            /**
             * The new type constructor
             */
            function ModdleElement(attrs) {
                props.define(this, '$type', {value: name, enumerable: true});
                props.define(this, '$attrs', {value: {}});
                props.define(this, '$parent', {writable: true});

                forEach(attrs, function (val, key) {
                    this.set(key, val);
                }, this);
            }

            ModdleElement.prototype = prototype;

            ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;

            // static links
            props.defineModel(ModdleElement, model);
            props.defineDescriptor(ModdleElement, descriptor);

            return ModdleElement;
        };
    }, {
        "./base": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/base.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/moddle.js": [function (require, module, exports) {
        'use strict';

        var isString = require('lodash/lang/isString'),
            isObject = require('lodash/lang/isObject'),
            forEach = require('lodash/collection/forEach'),
            find = require('lodash/collection/find');


        var Factory = require('./factory'),
            Registry = require('./registry'),
            Properties = require('./properties');

        var parseNameNs = require('./ns').parseName;


//// Moddle implementation /////////////////////////////////////////////////

        /**
         * @class Moddle
         *
         * A model that can be used to create elements of a specific type.
         *
         * @example
         *
         * var Moddle = require('moddle');
         *
         * var pkg = {
 *   name: 'mypackage',
 *   prefix: 'my',
 *   types: [
 *     { name: 'Root' }
 *   ]
 * };
         *
         * var moddle = new Moddle([pkg]);
         *
         * @param {Array<Package>} packages  the packages to contain
         * @param {Object} options  additional options to pass to the model
         */
        function Moddle(packages, options) {

            options = options || {};

            this.properties = new Properties(this);

            this.factory = new Factory(this, this.properties);
            this.registry = new Registry(packages, this.properties, options);

            this.typeCache = {};
        }

        module.exports = Moddle;


        /**
         * Create an instance of the specified type.
         *
         * @method Moddle#create
         *
         * @example
         *
         * var foo = moddle.create('my:Foo');
         * var bar = moddle.create('my:Bar', { id: 'BAR_1' });
         *
         * @param  {String|Object} descriptor the type descriptor or name know to the model
         * @param  {Object} attrs   a number of attributes to initialize the model instance with
         * @return {Object}         model instance
         */
        Moddle.prototype.create = function (descriptor, attrs) {
            var Type = this.getType(descriptor);

            if (!Type) {
                throw new Error('unknown type <' + descriptor + '>');
            }

            return new Type(attrs);
        };


        /**
         * Returns the type representing a given descriptor
         *
         * @method Moddle#getType
         *
         * @example
         *
         * var Foo = moddle.getType('my:Foo');
         * var foo = new Foo({ 'id' : 'FOO_1' });
         *
         * @param  {String|Object} descriptor the type descriptor or name know to the model
         * @return {Object}         the type representing the descriptor
         */
        Moddle.prototype.getType = function (descriptor) {

            var cache = this.typeCache;

            var name = isString(descriptor) ? descriptor : descriptor.ns.name;

            var type = cache[name];

            if (!type) {
                descriptor = this.registry.getEffectiveDescriptor(name);
                type = cache[name] = this.factory.createType(descriptor);
            }

            return type;
        };


        /**
         * Creates an any-element type to be used within model instances.
         *
         * This can be used to create custom elements that lie outside the meta-model.
         * The created element contains all the meta-data required to serialize it
         * as part of meta-model elements.
         *
         * @method Moddle#createAny
         *
         * @example
         *
         * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {
 *   value: 'bar'
 * });
         *
         * var container = moddle.create('my:Container', 'http://my', {
 *   any: [ foo ]
 * });
         *
         * // go ahead and serialize the stuff
         *
         *
         * @param  {String} name  the name of the element
         * @param  {String} nsUri the namespace uri of the element
         * @param  {Object} [properties] a map of properties to initialize the instance with
         * @return {Object} the any type instance
         */
        Moddle.prototype.createAny = function (name, nsUri, properties) {

            var nameNs = parseNameNs(name);

            var element = {
                $type: name
            };

            var descriptor = {
                name: name,
                isGeneric: true,
                ns: {
                    prefix: nameNs.prefix,
                    localName: nameNs.localName,
                    uri: nsUri
                }
            };

            this.properties.defineDescriptor(element, descriptor);
            this.properties.defineModel(element, this);
            this.properties.define(element, '$parent', {enumerable: false, writable: true});

            forEach(properties, function (a, key) {
                if (isObject(a) && a.value !== undefined) {
                    element[a.name] = a.value;
                } else {
                    element[key] = a;
                }
            });

            return element;
        };

        /**
         * Returns a registered package by uri or prefix
         *
         * @return {Object} the package
         */
        Moddle.prototype.getPackage = function (uriOrPrefix) {
            return this.registry.getPackage(uriOrPrefix);
        };

        /**
         * Returns a snapshot of all known packages
         *
         * @return {Object} the package
         */
        Moddle.prototype.getPackages = function () {
            return this.registry.getPackages();
        };

        /**
         * Returns the descriptor for an element
         */
        Moddle.prototype.getElementDescriptor = function (element) {
            return element.$descriptor;
        };

        /**
         * Returns true if the given descriptor or instance
         * represents the given type.
         *
         * May be applied to this, if element is omitted.
         */
        Moddle.prototype.hasType = function (element, type) {
            if (type === undefined) {
                type = element;
                element = this;
            }

            var descriptor = element.$model.getElementDescriptor(element);

            return !!find(descriptor.allTypes, function (t) {
                return t.name === type;
            });
        };


        /**
         * Returns the descriptor of an elements named property
         */
        Moddle.prototype.getPropertyDescriptor = function (element, property) {
            return this.getElementDescriptor(element).propertiesByName[property];
        };

    }, {
        "./factory": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/factory.js",
        "./ns": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/ns.js",
        "./properties": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/properties.js",
        "./registry": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/registry.js",
        "lodash/collection/find": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/find.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js",
        "lodash/lang/isString": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isString.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/ns.js": [function (require, module, exports) {
        'use strict';

        /**
         * Parses a namespaced attribute name of the form (ns:)localName to an object,
         * given a default prefix to assume in case no explicit namespace is given.
         *
         * @param {String} name
         * @param {String} [defaultPrefix] the default prefix to take, if none is present.
         *
         * @return {Object} the parsed name
         */
        module.exports.parseName = function (name, defaultPrefix) {
            var parts = name.split(/:/),
                localName, prefix;

            // no prefix (i.e. only local name)
            if (parts.length === 1) {
                localName = name;
                prefix = defaultPrefix;
            } else
            // prefix + local name
            if (parts.length === 2) {
                localName = parts[1];
                prefix = parts[0];
            } else {
                throw new Error('expected <prefix:localName> or <localName>, got ' + name);
            }

            name = (prefix ? prefix + ':' : '') + localName;

            return {
                name: name,
                prefix: prefix,
                localName: localName
            };
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/properties.js": [function (require, module, exports) {
        'use strict';


        /**
         * A utility that gets and sets properties of model elements.
         *
         * @param {Model} model
         */
        function Properties(model) {
            this.model = model;
        }

        module.exports = Properties;


        /**
         * Sets a named property on the target element
         *
         * @param {Object} target
         * @param {String} name
         * @param {Object} value
         */
        Properties.prototype.set = function (target, name, value) {

            var property = this.model.getPropertyDescriptor(target, name);

            if (!property) {
                target.$attrs[name] = value;
            } else {
                Object.defineProperty(target, property.name, {
                    enumerable: !property.isReference,
                    writable: true,
                    value: value
                });
            }
        };

        /**
         * Returns the named property of the given element
         *
         * @param  {Object} target
         * @param  {String} name
         *
         * @return {Object}
         */
        Properties.prototype.get = function (target, name) {

            var property = this.model.getPropertyDescriptor(target, name);

            if (!property) {
                return target.$attrs[name];
            }

            var propertyName = property.name;

            // check if access to collection property and lazily initialize it
            if (!target[propertyName] && property.isMany) {
                Object.defineProperty(target, propertyName, {
                    enumerable: !property.isReference,
                    writable: true,
                    value: []
                });
            }

            return target[propertyName];
        };


        /**
         * Define a property on the target element
         *
         * @param  {Object} target
         * @param  {String} name
         * @param  {Object} options
         */
        Properties.prototype.define = function (target, name, options) {
            Object.defineProperty(target, name, options);
        };


        /**
         * Define the descriptor for an element
         */
        Properties.prototype.defineDescriptor = function (target, descriptor) {
            this.define(target, '$descriptor', {value: descriptor});
        };

        /**
         * Define the model for an element
         */
        Properties.prototype.defineModel = function (target, model) {
            this.define(target, '$model', {value: model});
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/registry.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var Types = require('./types'),
            DescriptorBuilder = require('./descriptor-builder');

        var parseNameNs = require('./ns').parseName,
            isBuiltInType = Types.isBuiltIn;


        function Registry(packages, properties, options) {
            this.options = assign({generateId: 'id'}, options || {});

            this.packageMap = {};
            this.typeMap = {};

            this.packages = [];

            this.properties = properties;

            forEach(packages, this.registerPackage, this);
        }

        module.exports = Registry;


        Registry.prototype.getPackage = function (uriOrPrefix) {
            return this.packageMap[uriOrPrefix];
        };

        Registry.prototype.getPackages = function () {
            return this.packages;
        };


        Registry.prototype.registerPackage = function (pkg) {

            // copy package
            pkg = assign({}, pkg);

            // register types
            forEach(pkg.types, function (descriptor) {
                this.registerType(descriptor, pkg);
            }, this);

            this.packageMap[pkg.uri] = this.packageMap[pkg.prefix] = pkg;
            this.packages.push(pkg);
        };


        /**
         * Register a type from a specific package with us
         */
        Registry.prototype.registerType = function (type, pkg) {

            type = assign({}, type, {
                superClass: (type.superClass || []).slice(),
                extends: (type.extends || []).slice(),
                properties: (type.properties || []).slice()
            });

            var ns = parseNameNs(type.name, pkg.prefix),
                name = ns.name,
                propertiesByName = {};

            // parse properties
            forEach(type.properties, function (p) {

                // namespace property names
                var propertyNs = parseNameNs(p.name, ns.prefix),
                    propertyName = propertyNs.name;

                // namespace property types
                if (!isBuiltInType(p.type)) {
                    p.type = parseNameNs(p.type, propertyNs.prefix).name;
                }

                assign(p, {
                    ns: propertyNs,
                    name: propertyName
                });

                propertiesByName[propertyName] = p;
            });

            // update ns + name
            assign(type, {
                ns: ns,
                name: name,
                propertiesByName: propertiesByName
            });

            forEach(type.extends, function (extendsName) {
                var extended = this.typeMap[extendsName];

                extended.traits = extended.traits || [];
                extended.traits.push(name);
            }, this);

            // link to package
            this.definePackage(type, pkg);

            // register
            this.typeMap[name] = type;
        };


        /**
         * Traverse the type hierarchy from bottom to top.
         */
        Registry.prototype.mapTypes = function (nsName, iterator) {

            var type = isBuiltInType(nsName.name) ? {name: nsName.name} : this.typeMap[nsName.name];

            var self = this;

            /**
             * Traverse the selected super type or trait
             *
             * @param {String} cls
             */
            function traverseSuper(cls) {
                var parentNs = parseNameNs(cls, isBuiltInType(cls) ? '' : nsName.prefix);
                self.mapTypes(parentNs, iterator);
            }

            if (!type) {
                throw new Error('unknown type <' + nsName.name + '>');
            }

            forEach(type.superClass, traverseSuper);

            iterator(type);

            forEach(type.traits, traverseSuper);
        };


        /**
         * Returns the effective descriptor for a type.
         *
         * @param  {String} type the namespaced name (ns:localName) of the type
         *
         * @return {Descriptor} the resulting effective descriptor
         */
        Registry.prototype.getEffectiveDescriptor = function (name) {

            var nsName = parseNameNs(name);

            var builder = new DescriptorBuilder(nsName);

            this.mapTypes(nsName, function (type) {
                builder.addTrait(type);
            });

            // check we have an id assigned
            var id = this.options.generateId;
            if (id && !builder.hasProperty(id)) {
                builder.addIdProperty(id);
            }

            var descriptor = builder.build();

            // define package link
            this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);

            return descriptor;
        };


        Registry.prototype.definePackage = function (target, pkg) {
            this.properties.define(target, '$pkg', {value: pkg});
        };
    }, {
        "./descriptor-builder": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/descriptor-builder.js",
        "./ns": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/ns.js",
        "./types": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/types.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/node_modules/moddle/lib/types.js": [function (require, module, exports) {
        'use strict';

        /**
         * Built-in moddle types
         */
        var BUILTINS = {
            String: true,
            Boolean: true,
            Integer: true,
            Real: true,
            Element: true
        };

        /**
         * Converters for built in types from string representations
         */
        var TYPE_CONVERTERS = {
            String: function (s) {
                return s;
            },
            Boolean: function (s) {
                return s === 'true';
            },
            Integer: function (s) {
                return parseInt(s, 10);
            },
            Real: function (s) {
                return parseFloat(s, 10);
            }
        };

        /**
         * Convert a type to its real representation
         */
        module.exports.coerceType = function (type, value) {

            var converter = TYPE_CONVERTERS[type];

            if (converter) {
                return converter(value);
            } else {
                return value;
            }
        };

        /**
         * Return whether the given type is built-in
         */
        module.exports.isBuiltIn = function (type) {
            return !!BUILTINS[type];
        };

        /**
         * Return whether the given type is simple
         */
        module.exports.isSimple = function (type) {
            return !!TYPE_CONVERTERS[type];
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/resources/bpmn/json/bpmn.json": [function (require, module, exports) {
        module.exports = {
            "name": "BPMN20",
            "uri": "http://www.omg.org/spec/BPMN/20100524/MODEL",
            "associations": [],
            "types": [
                {
                    "name": "Interface",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "operations",
                            "type": "Operation",
                            "isMany": true
                        },
                        {
                            "name": "implementationRef",
                            "type": "String",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Operation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "inMessageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outMessageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "errorRefs",
                            "type": "Error",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "implementationRef",
                            "type": "String",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "EndPoint",
                    "superClass": [
                        "RootElement"
                    ]
                },
                {
                    "name": "Auditing",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "GlobalTask",
                    "superClass": [
                        "CallableElement"
                    ],
                    "properties": [
                        {
                            "name": "resources",
                            "type": "ResourceRole",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Monitoring",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "Performer",
                    "superClass": [
                        "ResourceRole"
                    ]
                },
                {
                    "name": "Process",
                    "superClass": [
                        "FlowElementsContainer",
                        "CallableElement"
                    ],
                    "properties": [
                        {
                            "name": "processType",
                            "type": "ProcessType",
                            "isAttr": true
                        },
                        {
                            "name": "isClosed",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "auditing",
                            "type": "Auditing"
                        },
                        {
                            "name": "monitoring",
                            "type": "Monitoring"
                        },
                        {
                            "name": "properties",
                            "type": "Property",
                            "isMany": true
                        },
                        {
                            "name": "supports",
                            "type": "Process",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "definitionalCollaborationRef",
                            "type": "Collaboration",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "isExecutable",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "resources",
                            "type": "ResourceRole",
                            "isMany": true
                        },
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "isMany": true
                        },
                        {
                            "name": "correlationSubscriptions",
                            "type": "CorrelationSubscription",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LaneSet",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "lanes",
                            "type": "Lane",
                            "isMany": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Lane",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "childLaneSet",
                            "type": "LaneSet",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "partitionElementRef",
                            "type": "BaseElement",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "flowNodeRef",
                            "type": "FlowNode",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "partitionElement",
                            "type": "BaseElement"
                        }
                    ]
                },
                {
                    "name": "GlobalManualTask",
                    "superClass": [
                        "GlobalTask"
                    ]
                },
                {
                    "name": "ManualTask",
                    "superClass": [
                        "Task"
                    ]
                },
                {
                    "name": "UserTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "renderings",
                            "type": "Rendering",
                            "isMany": true
                        },
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Rendering",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "HumanPerformer",
                    "superClass": [
                        "Performer"
                    ]
                },
                {
                    "name": "PotentialOwner",
                    "superClass": [
                        "HumanPerformer"
                    ]
                },
                {
                    "name": "GlobalUserTask",
                    "superClass": [
                        "GlobalTask"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "renderings",
                            "type": "Rendering",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Gateway",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode"
                    ],
                    "properties": [
                        {
                            "name": "gatewayDirection",
                            "type": "GatewayDirection",
                            "default": "Unspecified",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "EventBasedGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "instantiate",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "eventGatewayType",
                            "type": "EventBasedGatewayType",
                            "isAttr": true,
                            "default": "Exclusive"
                        }
                    ]
                },
                {
                    "name": "ComplexGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "activationCondition",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ExclusiveGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "InclusiveGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ParallelGateway",
                    "superClass": [
                        "Gateway"
                    ]
                },
                {
                    "name": "RootElement",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "Relationship",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "type",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "direction",
                            "type": "RelationshipDirection",
                            "isAttr": true
                        },
                        {
                            "name": "source",
                            "isMany": true,
                            "isReference": true,
                            "type": "Element"
                        },
                        {
                            "name": "target",
                            "isMany": true,
                            "isReference": true,
                            "type": "Element"
                        }
                    ]
                },
                {
                    "name": "BaseElement",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "id",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "documentation",
                            "type": "Documentation",
                            "isMany": true
                        },
                        {
                            "name": "extensionDefinitions",
                            "type": "ExtensionDefinition",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "extensionElements",
                            "type": "ExtensionElements"
                        }
                    ]
                },
                {
                    "name": "Extension",
                    "properties": [
                        {
                            "name": "mustUnderstand",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "definition",
                            "type": "ExtensionDefinition"
                        }
                    ]
                },
                {
                    "name": "ExtensionDefinition",
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "extensionAttributeDefinitions",
                            "type": "ExtensionAttributeDefinition",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ExtensionAttributeDefinition",
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "type",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isReference",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "extensionDefinition",
                            "type": "ExtensionDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ExtensionElements",
                    "properties": [
                        {
                            "name": "valueRef",
                            "isAttr": true,
                            "isReference": true,
                            "type": "Element"
                        },
                        {
                            "name": "values",
                            "type": "Element",
                            "isMany": true
                        },
                        {
                            "name": "extensionAttributeDefinition",
                            "type": "ExtensionAttributeDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Documentation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "text",
                            "type": "String",
                            "isBody": true
                        },
                        {
                            "name": "textFormat",
                            "default": "text/plain",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Event",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode",
                        "InteractionNode"
                    ],
                    "properties": [
                        {
                            "name": "properties",
                            "type": "Property",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "IntermediateCatchEvent",
                    "superClass": [
                        "CatchEvent"
                    ]
                },
                {
                    "name": "IntermediateThrowEvent",
                    "superClass": [
                        "ThrowEvent"
                    ]
                },
                {
                    "name": "EndEvent",
                    "superClass": [
                        "ThrowEvent"
                    ]
                },
                {
                    "name": "StartEvent",
                    "superClass": [
                        "CatchEvent"
                    ],
                    "properties": [
                        {
                            "name": "isInterrupting",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "ThrowEvent",
                    "isAbstract": true,
                    "superClass": [
                        "Event"
                    ],
                    "properties": [
                        {
                            "name": "inputSet",
                            "type": "InputSet"
                        },
                        {
                            "name": "eventDefinitionRefs",
                            "type": "EventDefinition",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "dataInputAssociation",
                            "type": "DataInputAssociation",
                            "isMany": true
                        },
                        {
                            "name": "dataInputs",
                            "type": "DataInput",
                            "isMany": true
                        },
                        {
                            "name": "eventDefinitions",
                            "type": "EventDefinition",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "CatchEvent",
                    "isAbstract": true,
                    "superClass": [
                        "Event"
                    ],
                    "properties": [
                        {
                            "name": "parallelMultiple",
                            "isAttr": true,
                            "type": "Boolean",
                            "default": false
                        },
                        {
                            "name": "outputSet",
                            "type": "OutputSet"
                        },
                        {
                            "name": "eventDefinitionRefs",
                            "type": "EventDefinition",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "dataOutputAssociation",
                            "type": "DataOutputAssociation",
                            "isMany": true
                        },
                        {
                            "name": "dataOutputs",
                            "type": "DataOutput",
                            "isMany": true
                        },
                        {
                            "name": "eventDefinitions",
                            "type": "EventDefinition",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "BoundaryEvent",
                    "superClass": [
                        "CatchEvent"
                    ],
                    "properties": [
                        {
                            "name": "cancelActivity",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "attachedToRef",
                            "type": "Activity",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "EventDefinition",
                    "isAbstract": true,
                    "superClass": [
                        "RootElement"
                    ]
                },
                {
                    "name": "CancelEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ]
                },
                {
                    "name": "ErrorEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "errorRef",
                            "type": "Error",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "TerminateEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ]
                },
                {
                    "name": "EscalationEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "escalationRef",
                            "type": "Escalation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Escalation",
                    "properties": [
                        {
                            "name": "structureRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "escalationCode",
                            "isAttr": true,
                            "type": "String"
                        }
                    ],
                    "superClass": [
                        "RootElement"
                    ]
                },
                {
                    "name": "CompensateEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "waitForCompletion",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "activityRef",
                            "type": "Activity",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "TimerEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "timeDate",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "timeCycle",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "timeDuration",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        }
                    ]
                },
                {
                    "name": "LinkEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "target",
                            "type": "LinkEventDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "source",
                            "type": "LinkEventDefinition",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "MessageEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ConditionalEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "condition",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        }
                    ]
                },
                {
                    "name": "SignalEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "signalRef",
                            "type": "Signal",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Signal",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "structureRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ImplicitThrowEvent",
                    "superClass": [
                        "ThrowEvent"
                    ]
                },
                {
                    "name": "DataState",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ItemAwareElement",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "itemSubjectRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "dataState",
                            "type": "DataState"
                        }
                    ]
                },
                {
                    "name": "DataAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "transformation",
                            "type": "FormalExpression"
                        },
                        {
                            "name": "assignment",
                            "type": "Assignment",
                            "isMany": true
                        },
                        {
                            "name": "sourceRef",
                            "type": "ItemAwareElement",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "ItemAwareElement",
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "DataInput",
                    "superClass": [
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "inputSetRefs",
                            "type": "InputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "inputSetWithOptional",
                            "type": "InputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "inputSetWithWhileExecuting",
                            "type": "InputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "DataOutput",
                    "superClass": [
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "outputSetRefs",
                            "type": "OutputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outputSetWithOptional",
                            "type": "OutputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outputSetWithWhileExecuting",
                            "type": "OutputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "InputSet",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "dataInputRefs",
                            "type": "DataInput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "optionalInputRefs",
                            "type": "DataInput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "whileExecutingInputRefs",
                            "type": "DataInput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outputSetRefs",
                            "type": "OutputSet",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "OutputSet",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "dataOutputRefs",
                            "type": "DataOutput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "inputSetRefs",
                            "type": "InputSet",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "optionalOutputRefs",
                            "type": "DataOutput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "whileExecutingOutputRefs",
                            "type": "DataOutput",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Property",
                    "superClass": [
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "DataInputAssociation",
                    "superClass": [
                        "DataAssociation"
                    ]
                },
                {
                    "name": "DataOutputAssociation",
                    "superClass": [
                        "DataAssociation"
                    ]
                },
                {
                    "name": "InputOutputSpecification",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "inputSets",
                            "type": "InputSet",
                            "isMany": true
                        },
                        {
                            "name": "outputSets",
                            "type": "OutputSet",
                            "isMany": true
                        },
                        {
                            "name": "dataInputs",
                            "type": "DataInput",
                            "isMany": true
                        },
                        {
                            "name": "dataOutputs",
                            "type": "DataOutput",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "DataObject",
                    "superClass": [
                        "FlowElement",
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "InputOutputBinding",
                    "properties": [
                        {
                            "name": "inputDataRef",
                            "type": "InputSet",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outputDataRef",
                            "type": "OutputSet",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Assignment",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "from",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "to",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        }
                    ]
                },
                {
                    "name": "DataStore",
                    "superClass": [
                        "RootElement",
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "capacity",
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "isUnlimited",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "DataStoreReference",
                    "superClass": [
                        "ItemAwareElement",
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "dataStoreRef",
                            "type": "DataStore",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "DataObjectReference",
                    "superClass": [
                        "ItemAwareElement",
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "dataObjectRef",
                            "type": "DataObject",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ConversationLink",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "sourceRef",
                            "type": "InteractionNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "InteractionNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ConversationAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "innerConversationNodeRef",
                            "type": "ConversationNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outerConversationNodeRef",
                            "type": "ConversationNode",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CallConversation",
                    "superClass": [
                        "ConversationNode"
                    ],
                    "properties": [
                        {
                            "name": "calledCollaborationRef",
                            "type": "Collaboration",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "participantAssociations",
                            "type": "ParticipantAssociation",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Conversation",
                    "superClass": [
                        "ConversationNode"
                    ]
                },
                {
                    "name": "SubConversation",
                    "superClass": [
                        "ConversationNode"
                    ],
                    "properties": [
                        {
                            "name": "conversationNodes",
                            "type": "ConversationNode",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ConversationNode",
                    "isAbstract": true,
                    "superClass": [
                        "InteractionNode",
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "participantRefs",
                            "type": "Participant",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "messageFlowRefs",
                            "type": "MessageFlow",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "correlationKeys",
                            "type": "CorrelationKey",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "GlobalConversation",
                    "superClass": [
                        "Collaboration"
                    ]
                },
                {
                    "name": "PartnerEntity",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "participantRef",
                            "type": "Participant",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "PartnerRole",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "participantRef",
                            "type": "Participant",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationProperty",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "correlationPropertyRetrievalExpression",
                            "type": "CorrelationPropertyRetrievalExpression",
                            "isMany": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "type",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Error",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "structureRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "errorCode",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "CorrelationKey",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "correlationPropertyRef",
                            "type": "CorrelationProperty",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Expression",
                    "superClass": [
                        "BaseElement"
                    ],
                    "isAbstract": true
                },
                {
                    "name": "FormalExpression",
                    "superClass": [
                        "Expression"
                    ],
                    "properties": [
                        {
                            "name": "language",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "body",
                            "type": "String",
                            "isBody": true
                        },
                        {
                            "name": "evaluatesToTypeRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Message",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "itemRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ItemDefinition",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "itemKind",
                            "type": "ItemKind",
                            "isAttr": true
                        },
                        {
                            "name": "structureRef",
                            "type": "String",
                            "isAttr": true
                        },
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "import",
                            "type": "Import",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "FlowElement",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "auditing",
                            "type": "Auditing"
                        },
                        {
                            "name": "monitoring",
                            "type": "Monitoring"
                        },
                        {
                            "name": "categoryValueRef",
                            "type": "CategoryValue",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "SequenceFlow",
                    "superClass": [
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "isImmediate",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "conditionExpression",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "sourceRef",
                            "type": "FlowNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "FlowNode",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "FlowElementsContainer",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "laneSets",
                            "type": "LaneSet",
                            "isMany": true
                        },
                        {
                            "name": "flowElements",
                            "type": "FlowElement",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "CallableElement",
                    "isAbstract": true,
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "ioSpecification",
                            "type": "InputOutputSpecification"
                        },
                        {
                            "name": "supportedInterfaceRefs",
                            "type": "Interface",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "ioBinding",
                            "type": "InputOutputBinding",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "FlowNode",
                    "isAbstract": true,
                    "superClass": [
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "incoming",
                            "type": "SequenceFlow",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outgoing",
                            "type": "SequenceFlow",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "lanes",
                            "type": "Lane",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationPropertyRetrievalExpression",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "messagePath",
                            "type": "FormalExpression"
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationPropertyBinding",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "dataPath",
                            "type": "FormalExpression"
                        },
                        {
                            "name": "correlationPropertyRef",
                            "type": "CorrelationProperty",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Resource",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "resourceParameters",
                            "type": "ResourceParameter",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ResourceParameter",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isRequired",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "type",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationSubscription",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "correlationKeyRef",
                            "type": "CorrelationKey",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "correlationPropertyBinding",
                            "type": "CorrelationPropertyBinding",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "MessageFlow",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "sourceRef",
                            "type": "InteractionNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "InteractionNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "MessageFlowAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "innerMessageFlowRef",
                            "type": "MessageFlow",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outerMessageFlowRef",
                            "type": "MessageFlow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "InteractionNode",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "incomingConversationLinks",
                            "type": "ConversationLink",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outgoingConversationLinks",
                            "type": "ConversationLink",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Participant",
                    "superClass": [
                        "InteractionNode",
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "interfaceRefs",
                            "type": "Interface",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "participantMultiplicity",
                            "type": "ParticipantMultiplicity"
                        },
                        {
                            "name": "endPointRefs",
                            "type": "EndPoint",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "processRef",
                            "type": "Process",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ParticipantAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "innerParticipantRef",
                            "type": "Participant",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outerParticipantRef",
                            "type": "Participant",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ParticipantMultiplicity",
                    "properties": [
                        {
                            "name": "minimum",
                            "default": 0,
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "maximum",
                            "default": 1,
                            "isAttr": true,
                            "type": "Integer"
                        }
                    ]
                },
                {
                    "name": "Collaboration",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isClosed",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "choreographyRef",
                            "type": "Choreography",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "isMany": true
                        },
                        {
                            "name": "participantAssociations",
                            "type": "ParticipantAssociation",
                            "isMany": true
                        },
                        {
                            "name": "messageFlowAssociations",
                            "type": "MessageFlowAssociation",
                            "isMany": true
                        },
                        {
                            "name": "conversationAssociations",
                            "type": "ConversationAssociation"
                        },
                        {
                            "name": "participants",
                            "type": "Participant",
                            "isMany": true
                        },
                        {
                            "name": "messageFlows",
                            "type": "MessageFlow",
                            "isMany": true
                        },
                        {
                            "name": "correlationKeys",
                            "type": "CorrelationKey",
                            "isMany": true
                        },
                        {
                            "name": "conversations",
                            "type": "ConversationNode",
                            "isMany": true
                        },
                        {
                            "name": "conversationLinks",
                            "type": "ConversationLink",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ChoreographyActivity",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode"
                    ],
                    "properties": [
                        {
                            "name": "participantRefs",
                            "type": "Participant",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "initiatingParticipantRef",
                            "type": "Participant",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "correlationKeys",
                            "type": "CorrelationKey",
                            "isMany": true
                        },
                        {
                            "name": "loopType",
                            "type": "ChoreographyLoopType",
                            "default": "None",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "CallChoreography",
                    "superClass": [
                        "ChoreographyActivity"
                    ],
                    "properties": [
                        {
                            "name": "calledChoreographyRef",
                            "type": "Choreography",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "participantAssociations",
                            "type": "ParticipantAssociation",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "SubChoreography",
                    "superClass": [
                        "ChoreographyActivity",
                        "FlowElementsContainer"
                    ],
                    "properties": [
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ChoreographyTask",
                    "superClass": [
                        "ChoreographyActivity"
                    ],
                    "properties": [
                        {
                            "name": "messageFlowRef",
                            "type": "MessageFlow",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Choreography",
                    "superClass": [
                        "FlowElementsContainer",
                        "Collaboration"
                    ]
                },
                {
                    "name": "GlobalChoreographyTask",
                    "superClass": [
                        "Choreography"
                    ],
                    "properties": [
                        {
                            "name": "initiatingParticipantRef",
                            "type": "Participant",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "TextAnnotation",
                    "superClass": [
                        "Artifact"
                    ],
                    "properties": [
                        {
                            "name": "text",
                            "type": "String"
                        },
                        {
                            "name": "textFormat",
                            "default": "text/plain",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Group",
                    "superClass": [
                        "Artifact"
                    ],
                    "properties": [
                        {
                            "name": "categoryValueRef",
                            "type": "CategoryValue",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Association",
                    "superClass": [
                        "Artifact"
                    ],
                    "properties": [
                        {
                            "name": "associationDirection",
                            "type": "AssociationDirection",
                            "isAttr": true
                        },
                        {
                            "name": "sourceRef",
                            "type": "BaseElement",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "BaseElement",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Category",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "categoryValue",
                            "type": "CategoryValue",
                            "isMany": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Artifact",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "CategoryValue",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "categorizedFlowElements",
                            "type": "FlowElement",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "value",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Activity",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode"
                    ],
                    "properties": [
                        {
                            "name": "isForCompensation",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "loopCharacteristics",
                            "type": "LoopCharacteristics"
                        },
                        {
                            "name": "resources",
                            "type": "ResourceRole",
                            "isMany": true
                        },
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "properties",
                            "type": "Property",
                            "isMany": true
                        },
                        {
                            "name": "ioSpecification",
                            "type": "InputOutputSpecification"
                        },
                        {
                            "name": "boundaryEventRefs",
                            "type": "BoundaryEvent",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "dataInputAssociations",
                            "type": "DataInputAssociation",
                            "isMany": true
                        },
                        {
                            "name": "dataOutputAssociations",
                            "type": "DataOutputAssociation",
                            "isMany": true
                        },
                        {
                            "name": "startQuantity",
                            "default": 1,
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "completionQuantity",
                            "default": 1,
                            "isAttr": true,
                            "type": "Integer"
                        }
                    ]
                },
                {
                    "name": "ServiceTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "SubProcess",
                    "superClass": [
                        "Activity",
                        "FlowElementsContainer",
                        "InteractionNode"
                    ],
                    "properties": [
                        {
                            "name": "triggeredByEvent",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LoopCharacteristics",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "MultiInstanceLoopCharacteristics",
                    "superClass": [
                        "LoopCharacteristics"
                    ],
                    "properties": [
                        {
                            "name": "isSequential",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "behavior",
                            "type": "MultiInstanceBehavior",
                            "default": "All",
                            "isAttr": true
                        },
                        {
                            "name": "loopCardinality",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "loopDataInputRef",
                            "type": "ItemAwareElement",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "loopDataOutputRef",
                            "type": "ItemAwareElement",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "inputDataItem",
                            "type": "DataInput"
                        },
                        {
                            "name": "outputDataItem",
                            "type": "DataOutput"
                        },
                        {
                            "name": "completionCondition",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "complexBehaviorDefinition",
                            "type": "ComplexBehaviorDefinition",
                            "isMany": true
                        },
                        {
                            "name": "oneBehaviorEventRef",
                            "type": "EventDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "noneBehaviorEventRef",
                            "type": "EventDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "StandardLoopCharacteristics",
                    "superClass": [
                        "LoopCharacteristics"
                    ],
                    "properties": [
                        {
                            "name": "testBefore",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "loopCondition",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "loopMaximum",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        }
                    ]
                },
                {
                    "name": "CallActivity",
                    "superClass": [
                        "Activity"
                    ],
                    "properties": [
                        {
                            "name": "calledElement",
                            "type": "String",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Task",
                    "superClass": [
                        "Activity",
                        "InteractionNode"
                    ]
                },
                {
                    "name": "SendTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ReceiveTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "instantiate",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ScriptTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "scriptFormat",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "script",
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "BusinessRuleTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "AdHocSubProcess",
                    "superClass": [
                        "SubProcess"
                    ],
                    "properties": [
                        {
                            "name": "completionCondition",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "ordering",
                            "type": "AdHocOrdering",
                            "isAttr": true
                        },
                        {
                            "name": "cancelRemainingInstances",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "Transaction",
                    "superClass": [
                        "SubProcess"
                    ],
                    "properties": [
                        {
                            "name": "protocol",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "method",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "GlobalScriptTask",
                    "superClass": [
                        "GlobalTask"
                    ],
                    "properties": [
                        {
                            "name": "scriptLanguage",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "script",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "GlobalBusinessRuleTask",
                    "superClass": [
                        "GlobalTask"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ComplexBehaviorDefinition",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "condition",
                            "type": "FormalExpression"
                        },
                        {
                            "name": "event",
                            "type": "ImplicitThrowEvent"
                        }
                    ]
                },
                {
                    "name": "ResourceRole",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "resourceRef",
                            "type": "Resource",
                            "isReference": true
                        },
                        {
                            "name": "resourceParameterBindings",
                            "type": "ResourceParameterBinding",
                            "isMany": true
                        },
                        {
                            "name": "resourceAssignmentExpression",
                            "type": "ResourceAssignmentExpression"
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ResourceParameterBinding",
                    "properties": [
                        {
                            "name": "expression",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        },
                        {
                            "name": "parameterRef",
                            "type": "ResourceParameter",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ResourceAssignmentExpression",
                    "properties": [
                        {
                            "name": "expression",
                            "type": "Expression",
                            "serialize": "xsi:type"
                        }
                    ]
                },
                {
                    "name": "Import",
                    "properties": [
                        {
                            "name": "importType",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "location",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "namespace",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Definitions",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "targetNamespace",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "expressionLanguage",
                            "default": "http://www.w3.org/1999/XPath",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "typeLanguage",
                            "default": "http://www.w3.org/2001/XMLSchema",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "imports",
                            "type": "Import",
                            "isMany": true
                        },
                        {
                            "name": "extensions",
                            "type": "Extension",
                            "isMany": true
                        },
                        {
                            "name": "rootElements",
                            "type": "RootElement",
                            "isMany": true
                        },
                        {
                            "name": "diagrams",
                            "isMany": true,
                            "type": "bpmndi:BPMNDiagram"
                        },
                        {
                            "name": "exporter",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "relationships",
                            "type": "Relationship",
                            "isMany": true
                        },
                        {
                            "name": "exporterVersion",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                }
            ],
            "emumerations": [
                {
                    "name": "ProcessType",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "Public"
                        },
                        {
                            "name": "Private"
                        }
                    ]
                },
                {
                    "name": "GatewayDirection",
                    "literalValues": [
                        {
                            "name": "Unspecified"
                        },
                        {
                            "name": "Converging"
                        },
                        {
                            "name": "Diverging"
                        },
                        {
                            "name": "Mixed"
                        }
                    ]
                },
                {
                    "name": "EventBasedGatewayType",
                    "literalValues": [
                        {
                            "name": "Parallel"
                        },
                        {
                            "name": "Exclusive"
                        }
                    ]
                },
                {
                    "name": "RelationshipDirection",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "Forward"
                        },
                        {
                            "name": "Backward"
                        },
                        {
                            "name": "Both"
                        }
                    ]
                },
                {
                    "name": "ItemKind",
                    "literalValues": [
                        {
                            "name": "Physical"
                        },
                        {
                            "name": "Information"
                        }
                    ]
                },
                {
                    "name": "ChoreographyLoopType",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "Standard"
                        },
                        {
                            "name": "MultiInstanceSequential"
                        },
                        {
                            "name": "MultiInstanceParallel"
                        }
                    ]
                },
                {
                    "name": "AssociationDirection",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "One"
                        },
                        {
                            "name": "Both"
                        }
                    ]
                },
                {
                    "name": "MultiInstanceBehavior",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "One"
                        },
                        {
                            "name": "All"
                        },
                        {
                            "name": "Complex"
                        }
                    ]
                },
                {
                    "name": "AdHocOrdering",
                    "literalValues": [
                        {
                            "name": "Parallel"
                        },
                        {
                            "name": "Sequential"
                        }
                    ]
                }
            ],
            "prefix": "bpmn",
            "xml": {
                "tagAlias": "lowerCase",
                "typePrefix": "t"
            }
        }
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/resources/bpmn/json/bpmndi.json": [function (require, module, exports) {
        module.exports = {
            "name": "BPMNDI",
            "uri": "http://www.omg.org/spec/BPMN/20100524/DI",
            "types": [
                {
                    "name": "BPMNDiagram",
                    "properties": [
                        {
                            "name": "plane",
                            "type": "BPMNPlane",
                            "redefines": "di:Diagram#rootElement"
                        },
                        {
                            "name": "labelStyle",
                            "type": "BPMNLabelStyle",
                            "isMany": true
                        }
                    ],
                    "superClass": [
                        "di:Diagram"
                    ]
                },
                {
                    "name": "BPMNPlane",
                    "properties": [
                        {
                            "name": "bpmnElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "bpmn:BaseElement",
                            "redefines": "di:DiagramElement#modelElement"
                        }
                    ],
                    "superClass": [
                        "di:Plane"
                    ]
                },
                {
                    "name": "BPMNShape",
                    "properties": [
                        {
                            "name": "bpmnElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "bpmn:BaseElement",
                            "redefines": "di:DiagramElement#modelElement"
                        },
                        {
                            "name": "isHorizontal",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "isExpanded",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "isMarkerVisible",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "label",
                            "type": "BPMNLabel"
                        },
                        {
                            "name": "isMessageVisible",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "participantBandKind",
                            "type": "ParticipantBandKind",
                            "isAttr": true
                        },
                        {
                            "name": "choreographyActivityShape",
                            "type": "BPMNShape",
                            "isAttr": true,
                            "isReference": true
                        }
                    ],
                    "superClass": [
                        "di:LabeledShape"
                    ]
                },
                {
                    "name": "BPMNEdge",
                    "properties": [
                        {
                            "name": "label",
                            "type": "BPMNLabel"
                        },
                        {
                            "name": "bpmnElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "bpmn:BaseElement",
                            "redefines": "di:DiagramElement#modelElement"
                        },
                        {
                            "name": "sourceElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "di:DiagramElement",
                            "redefines": "di:Edge#source"
                        },
                        {
                            "name": "targetElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "di:DiagramElement",
                            "redefines": "di:Edge#target"
                        },
                        {
                            "name": "messageVisibleKind",
                            "type": "MessageVisibleKind",
                            "isAttr": true,
                            "default": "initiating"
                        }
                    ],
                    "superClass": [
                        "di:LabeledEdge"
                    ]
                },
                {
                    "name": "BPMNLabel",
                    "properties": [
                        {
                            "name": "labelStyle",
                            "type": "BPMNLabelStyle",
                            "isAttr": true,
                            "isReference": true,
                            "redefines": "di:DiagramElement#style"
                        }
                    ],
                    "superClass": [
                        "di:Label"
                    ]
                },
                {
                    "name": "BPMNLabelStyle",
                    "properties": [
                        {
                            "name": "font",
                            "type": "dc:Font"
                        }
                    ],
                    "superClass": [
                        "di:Style"
                    ]
                }
            ],
            "emumerations": [
                {
                    "name": "ParticipantBandKind",
                    "literalValues": [
                        {
                            "name": "top_initiating"
                        },
                        {
                            "name": "middle_initiating"
                        },
                        {
                            "name": "bottom_initiating"
                        },
                        {
                            "name": "top_non_initiating"
                        },
                        {
                            "name": "middle_non_initiating"
                        },
                        {
                            "name": "bottom_non_initiating"
                        }
                    ]
                },
                {
                    "name": "MessageVisibleKind",
                    "literalValues": [
                        {
                            "name": "initiating"
                        },
                        {
                            "name": "non_initiating"
                        }
                    ]
                }
            ],
            "associations": [],
            "prefix": "bpmndi"
        }
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/resources/bpmn/json/dc.json": [function (require, module, exports) {
        module.exports = {
            "name": "DC",
            "uri": "http://www.omg.org/spec/DD/20100524/DC",
            "types": [
                {
                    "name": "Boolean"
                },
                {
                    "name": "Integer"
                },
                {
                    "name": "Real"
                },
                {
                    "name": "String"
                },
                {
                    "name": "Font",
                    "properties": [
                        {
                            "name": "name",
                            "type": "String",
                            "isAttr": true
                        },
                        {
                            "name": "size",
                            "type": "Real",
                            "isAttr": true
                        },
                        {
                            "name": "isBold",
                            "type": "Boolean",
                            "isAttr": true
                        },
                        {
                            "name": "isItalic",
                            "type": "Boolean",
                            "isAttr": true
                        },
                        {
                            "name": "isUnderline",
                            "type": "Boolean",
                            "isAttr": true
                        },
                        {
                            "name": "isStrikeThrough",
                            "type": "Boolean",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Point",
                    "properties": [
                        {
                            "name": "x",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        },
                        {
                            "name": "y",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Bounds",
                    "properties": [
                        {
                            "name": "x",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        },
                        {
                            "name": "y",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        },
                        {
                            "name": "width",
                            "type": "Real",
                            "isAttr": true
                        },
                        {
                            "name": "height",
                            "type": "Real",
                            "isAttr": true
                        }
                    ]
                }
            ],
            "prefix": "dc",
            "associations": []
        }
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/bpmn-moddle/resources/bpmn/json/di.json": [function (require, module, exports) {
        module.exports = {
            "name": "DI",
            "uri": "http://www.omg.org/spec/DD/20100524/DI",
            "types": [
                {
                    "name": "DiagramElement",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "extension",
                            "type": "Extension"
                        },
                        {
                            "name": "owningDiagram",
                            "type": "Diagram",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "owningElement",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "modelElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true,
                            "type": "Element"
                        },
                        {
                            "name": "style",
                            "type": "Style",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "ownedElement",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Node",
                    "isAbstract": true,
                    "superClass": [
                        "DiagramElement"
                    ]
                },
                {
                    "name": "Edge",
                    "isAbstract": true,
                    "superClass": [
                        "DiagramElement"
                    ],
                    "properties": [
                        {
                            "name": "source",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "target",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "waypoint",
                            "isUnique": false,
                            "isMany": true,
                            "type": "dc:Point",
                            "serialize": "xsi:type"
                        }
                    ]
                },
                {
                    "name": "Diagram",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "rootElement",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "documentation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "resolution",
                            "isAttr": true,
                            "type": "Real"
                        },
                        {
                            "name": "ownedStyle",
                            "type": "Style",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Shape",
                    "isAbstract": true,
                    "superClass": [
                        "Node"
                    ],
                    "properties": [
                        {
                            "name": "bounds",
                            "type": "dc:Bounds"
                        }
                    ]
                },
                {
                    "name": "Plane",
                    "isAbstract": true,
                    "superClass": [
                        "Node"
                    ],
                    "properties": [
                        {
                            "name": "planeElement",
                            "type": "DiagramElement",
                            "subsettedProperty": "DiagramElement-ownedElement",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LabeledEdge",
                    "isAbstract": true,
                    "superClass": [
                        "Edge"
                    ],
                    "properties": [
                        {
                            "name": "ownedLabel",
                            "type": "Label",
                            "isReadOnly": true,
                            "subsettedProperty": "DiagramElement-ownedElement",
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LabeledShape",
                    "isAbstract": true,
                    "superClass": [
                        "Shape"
                    ],
                    "properties": [
                        {
                            "name": "ownedLabel",
                            "type": "Label",
                            "isReadOnly": true,
                            "subsettedProperty": "DiagramElement-ownedElement",
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Label",
                    "isAbstract": true,
                    "superClass": [
                        "Node"
                    ],
                    "properties": [
                        {
                            "name": "bounds",
                            "type": "dc:Bounds"
                        }
                    ]
                },
                {
                    "name": "Style",
                    "isAbstract": true
                },
                {
                    "name": "Extension",
                    "properties": [
                        {
                            "name": "values",
                            "type": "Element",
                            "isMany": true
                        }
                    ]
                }
            ],
            "associations": [],
            "prefix": "di",
            "xml": {
                "tagAlias": "lowerCase"
            }
        }
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/diagram-js-direct-editing/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [require('diagram-js/lib/features/interaction-events')],
            __init__: ['directEditing'],
            directEditing: ['type', require('./lib/DirectEditing')]
        };
    }, {
        "./lib/DirectEditing": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/diagram-js-direct-editing/lib/DirectEditing.js",
        "diagram-js/lib/features/interaction-events": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/interaction-events/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/diagram-js-direct-editing/lib/DirectEditing.js": [function (require, module, exports) {
        'use strict';

        var bind = require('lodash/function/bind'),
            find = require('lodash/collection/find');

        var TextBox = require('./TextBox');


        /**
         * A direct editing component that allows users
         * to edit an elements text directly in the diagram
         *
         * @param {EventBus} eventBus the event bus
         */
        function DirectEditing(eventBus, canvas) {

            this._eventBus = eventBus;

            this._providers = [];
            this._textbox = new TextBox({
                container: canvas.getContainer(),
                keyHandler: bind(this._handleKey, this)
            });
        }

        DirectEditing.$inject = ['eventBus', 'canvas'];


        /**
         * Register a direct editing provider

         * @param {Object} provider the provider, must expose an #activate(element) method that returns
         *                          an activation context ({ bounds: {x, y, width, height }, text }) if
         *                          direct editing is available for the given element.
         *                          Additionally the provider must expose a #update(element, value) method
         *                          to receive direct editing updates.
         */
        DirectEditing.prototype.registerProvider = function (provider) {
            this._providers.push(provider);
        };


        /**
         * Returns true if direct editing is currently active
         *
         * @return {Boolean}
         */
        DirectEditing.prototype.isActive = function () {
            return !!this._active;
        };


        /**
         * Cancel direct editing, if it is currently active
         */
        DirectEditing.prototype.cancel = function () {
            if (!this._active) {
                return;
            }

            this._fire('cancel');
            this.close();
        };


        DirectEditing.prototype._fire = function (event) {
            this._eventBus.fire('directEditing.' + event, {active: this._active});
        };

        DirectEditing.prototype.close = function () {
            this._textbox.destroy();

            this._fire('deactivate');

            this._active = null;
        };


        DirectEditing.prototype.complete = function () {

            var active = this._active;

            if (!active) {
                return;
            }

            var text = this.getValue();

            if (text !== active.context.text) {
                active.provider.update(active.element, text, active.context.text);
            }

            this._fire('complete');

            this.close();
        };


        DirectEditing.prototype.getValue = function () {
            return this._textbox.getValue();
        };


        DirectEditing.prototype._handleKey = function (e) {

            // stop bubble
            e.stopPropagation();

            var key = e.keyCode || e.charCode;

            // ESC
            if (key === 27) {
                e.preventDefault();
                return this.cancel();
            }

            // Enter
            if (key === 13 && !e.shiftKey) {
                e.preventDefault();
                return this.complete();
            }
        };


        /**
         * Activate direct editing on the given element
         *
         * @param {Object} ElementDescriptor the descriptor for a shape or connection
         * @return {Boolean} true if the activation was possible
         */
        DirectEditing.prototype.activate = function (element) {

            if (this.isActive()) {
                this.cancel();
            }

            // the direct editing context
            var context;

            var provider = find(this._providers, function (p) {
                return !!(context = p.activate(element)) ? p : null;
            });

            // check if activation took place
            if (context) {
                this._textbox.create(context.bounds, context.style, context.text);

                this._active = {
                    element: element,
                    context: context,
                    provider: provider
                };

                this._fire('activate');
            }

            return !!context;
        };


        module.exports = DirectEditing;
    }, {
        "./TextBox": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/diagram-js-direct-editing/lib/TextBox.js",
        "lodash/collection/find": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/find.js",
        "lodash/function/bind": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/bind.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/diagram-js-direct-editing/lib/TextBox.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            domEvent = require('min-dom/lib/event'),
            domRemove = require('min-dom/lib/remove');

        function stopPropagation(event) {
            event.stopPropagation();
        }

        function TextBox(options) {

            this.container = options.container;
            this.textarea = document.createElement('textarea');

            this.keyHandler = options.keyHandler || function () {
            };
        }

        module.exports = TextBox;


        TextBox.prototype.create = function (bounds, style, value) {

            var textarea = this.textarea,
                container = this.container;

            assign(textarea.style, {
                width: bounds.width + 'px',
                height: bounds.height + 'px',
                left: bounds.x + 'px',
                top: bounds.y + 'px',
                position: 'absolute',
                textAlign: 'center',
                boxSizing: 'border-box'
            }, style || {});

            textarea.value = value;
            textarea.title = 'Press SHIFT+Enter for line feed';

            domEvent.bind(textarea, 'keydown', this.keyHandler);
            domEvent.bind(textarea, 'mousedown', stopPropagation);

            container.appendChild(textarea);

            setTimeout(function () {
                if (textarea.parent) {
                    textarea.select();
                }
                textarea.focus();
            }, 100);
        };

        TextBox.prototype.destroy = function () {
            var textarea = this.textarea;

            textarea.value = '';

            domEvent.unbind(textarea, 'keydown', this.keyHandler);
            domEvent.unbind(textarea, 'mousedown', stopPropagation);

            domRemove(textarea);
        };

        TextBox.prototype.getValue = function () {
            return this.textarea.value;
        };

    }, {
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/event.js",
        "min-dom/lib/remove": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/remove.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/ids/index.js": [function (require, module, exports) {
        'use strict';

        var hat = require('hat');


        /**
         * Create a new id generator / cache instance.
         *
         * You may optionally provide a seed that is used internally.
         *
         * @param {Seed} seed
         */
        function Ids(seed) {
            seed = seed || [128, 36, 1];
            this._seed = seed.length ? hat.rack(seed[0], seed[1], seed[2]) : seed;
        }

        module.exports = Ids;

        /**
         * Generate a next id.
         *
         * @param {Object} [element] element to bind the id to
         *
         * @return {String} id
         */
        Ids.prototype.next = function (element) {
            return this._seed(element || true);
        };

        /**
         * Generate a next id with a given prefix.
         *
         * @param {Object} [element] element to bind the id to
         *
         * @return {String} id
         */
        Ids.prototype.nextPrefixed = function (prefix, element) {
            var id;

            do {
                id = prefix + this.next(true);
            } while (this.assigned(id));

            // claim {prefix}{random}
            this.claim(id, element);

            // return
            return id;
        };

        /**
         * Manually claim an existing id.
         *
         * @param {String} id
         * @param {String} [element] element the id is claimed by
         */
        Ids.prototype.claim = function (id, element) {
            this._seed.set(id, element || true);
        };

        /**
         * Returns true if the given id has already been assigned.
         *
         * @param  {String} id
         * @return {Boolean}
         */
        Ids.prototype.assigned = function (id) {
            return this._seed.get(id) || false;
        };
    }, {"hat": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/ids/node_modules/hat/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/ids/node_modules/hat/index.js": [function (require, module, exports) {
        var hat = module.exports = function (bits, base) {
            if (!base) base = 16;
            if (bits === undefined) bits = 128;
            if (bits <= 0) return '0';

            var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
            for (var i = 2; digits === Infinity; i *= 2) {
                digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
            }

            var rem = digits - Math.floor(digits);

            var res = '';

            for (var i = 0; i < Math.floor(digits); i++) {
                var x = Math.floor(Math.random() * base).toString(base);
                res = x + res;
            }

            if (rem) {
                var b = Math.pow(base, rem);
                var x = Math.floor(Math.random() * b).toString(base);
                res = x + res;
            }

            var parsed = parseInt(res, base);
            if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
                return hat(bits, base)
            }
            else return res;
        };

        hat.rack = function (bits, base, expandBy) {
            var fn = function (data) {
                var iters = 0;
                do {
                    if (iters++ > 10) {
                        if (expandBy) bits += expandBy;
                        else throw new Error('too many ID collisions, use more bits')
                    }

                    var id = hat(bits, base);
                } while (Object.hasOwnProperty.call(hats, id));

                hats[id] = data;
                return id;
            };
            var hats = fn.hats = {};

            fn.get = function (id) {
                return fn.hats[id];
            };

            fn.set = function (id, value) {
                fn.hats[id] = value;
                return fn;
            };

            fn.bits = bits || 128;
            fn.base = base || 16;
            return fn;
        };

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js": [function (require, module, exports) {
        if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };
        } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                var TempCtor = function () {
                }
                TempCtor.prototype = superCtor.prototype
                ctor.prototype = new TempCtor()
                ctor.prototype.constructor = ctor
            }
        }

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/domify.js": [function (require, module, exports) {
        module.exports = require('domify');
    }, {"domify": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/node_modules/domify/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/event.js": [function (require, module, exports) {
        module.exports = require('component-event');
    }, {"component-event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/node_modules/component-event/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/query.js": [function (require, module, exports) {
        module.exports = require('component-query');
    }, {"component-query": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/node_modules/component-query/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/remove.js": [function (require, module, exports) {
        module.exports = function (el) {
            el.parentNode && el.parentNode.removeChild(el);
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/node_modules/component-event/index.js": [function (require, module, exports) {
        var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
            unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
            prefix = bind !== 'addEventListener' ? 'on' : '';

        /**
         * Bind `el` event `type` to `fn`.
         *
         * @param {Element} el
         * @param {String} type
         * @param {Function} fn
         * @param {Boolean} capture
         * @return {Function}
         * @api public
         */

        exports.bind = function (el, type, fn, capture) {
            el[bind](prefix + type, fn, capture || false);
            return fn;
        };

        /**
         * Unbind `el` event `type`'s callback `fn`.
         *
         * @param {Element} el
         * @param {String} type
         * @param {Function} fn
         * @param {Boolean} capture
         * @return {Function}
         * @api public
         */

        exports.unbind = function (el, type, fn, capture) {
            el[unbind](prefix + type, fn, capture || false);
            return fn;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/node_modules/component-query/index.js": [function (require, module, exports) {
        function one(selector, el) {
            return el.querySelector(selector);
        }

        exports = module.exports = function (selector, el) {
            el = el || document;
            return one(selector, el);
        };

        exports.all = function (selector, el) {
            el = el || document;
            return el.querySelectorAll(selector);
        };

        exports.engine = function (obj) {
            if (!obj.one) throw new Error('.one callback required');
            if (!obj.all) throw new Error('.all callback required');
            one = obj.one;
            exports.all = obj.all;
            return exports;
        };

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/node_modules/domify/index.js": [function (require, module, exports) {

        /**
         * Expose `parse`.
         */

        module.exports = parse;

        /**
         * Tests for browser support.
         */

        var div = document.createElement('div');
// Setup
        div.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
// Make sure that link elements get serialized correctly by innerHTML
// This requires a wrapper element in IE
        var innerHTMLBug = !div.getElementsByTagName('link').length;
        div = undefined;

        /**
         * Wrap map from jquery.
         */

        var map = {
            legend: [1, '<fieldset>', '</fieldset>'],
            tr: [2, '<table><tbody>', '</tbody></table>'],
            col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
            // for script/link/style tags to work in IE6-8, you have to wrap
            // in a div with a non-whitespace character in front, ha!
            _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
        };

        map.td =
            map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

        map.option =
            map.optgroup = [1, '<select multiple="multiple">', '</select>'];

        map.thead =
            map.tbody =
                map.colgroup =
                    map.caption =
                        map.tfoot = [1, '<table>', '</table>'];

        map.polyline =
            map.ellipse =
                map.polygon =
                    map.circle =
                        map.text =
                            map.line =
                                map.path =
                                    map.rect =
                                        map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>'];

        /**
         * Parse `html` and return a DOM Node instance, which could be a TextNode,
         * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
         * instance, depending on the contents of the `html` string.
         *
         * @param {String} html - HTML string to "domify"
         * @param {Document} doc - The `document` instance to create the Node for
         * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
         * @api private
         */

        function parse(html, doc) {
            if ('string' != typeof html) throw new TypeError('String expected');

            // default to the global `document` object
            if (!doc) doc = document;

            // tag name
            var m = /<([\w:]+)/.exec(html);
            if (!m) return doc.createTextNode(html);

            html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

            var tag = m[1];

            // body support
            if (tag == 'body') {
                var el = doc.createElement('html');
                el.innerHTML = html;
                return el.removeChild(el.lastChild);
            }

            // wrap map
            var wrap = map[tag] || map._default;
            var depth = wrap[0];
            var prefix = wrap[1];
            var suffix = wrap[2];
            var el = doc.createElement('div');
            el.innerHTML = prefix + html + suffix;
            while (depth--) el = el.lastChild;

            // one element
            if (el.firstChild == el.lastChild) {
                return el.removeChild(el.firstChild);
            }

            // several elements
            var fragment = doc.createDocumentFragment();
            while (el.firstChild) {
                fragment.appendChild(el.removeChild(el.firstChild));
            }

            return fragment;
        }

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/index.js": [function (require, module, exports) {
        module.exports = require('./lib/refs');

        module.exports.Collection = require('./lib/collection');
    }, {
        "./lib/collection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/lib/collection.js",
        "./lib/refs": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/lib/refs.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/lib/collection.js": [function (require, module, exports) {
        'use strict';

        /**
         * An empty collection stub. Use {@link RefsCollection.extend} to extend a
         * collection with ref semantics.
         *
         * @classdesc A change and inverse-reference aware collection with set semantics.
         *
         * @class RefsCollection
         */
        function RefsCollection() {
        }

        /**
         * Extends a collection with {@link Refs} aware methods
         *
         * @memberof RefsCollection
         * @static
         *
         * @param  {Array<Object>} collection
         * @param  {Refs} refs instance
         * @param  {Object} property represented by the collection
         * @param  {Object} target object the collection is attached to
         *
         * @return {RefsCollection<Object>} the extended array
         */
        function extend(collection, refs, property, target) {

            var inverseProperty = property.inverse;

            /**
             * Removes the given element from the array and returns it.
             *
             * @method RefsCollection#remove
             *
             * @param {Object} element the element to remove
             */
            collection.remove = function (element) {
                var idx = this.indexOf(element);
                if (idx !== -1) {
                    this.splice(idx, 1);

                    // unset inverse
                    refs.unset(element, inverseProperty, target);
                }

                return element;
            };

            /**
             * Returns true if the collection contains the given element
             *
             * @method RefsCollection#contains
             *
             * @param {Object} element the element to check for
             */
            collection.contains = function (element) {
                return this.indexOf(element) !== -1;
            };

            /**
             * Adds an element to the array, unless it exists already (set semantics).
             *
             * @method RefsCollection#add
             *
             * @param {Object} element the element to add
             */
            collection.add = function (element) {

                if (!this.contains(element)) {
                    this.push(element);

                    // set inverse
                    refs.set(element, inverseProperty, target);
                }
            };

            return collection;
        }


        module.exports.extend = extend;
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/lib/refs.js": [function (require, module, exports) {
        'use strict';

        var Collection = require('./collection');

        function hasOwnProperty(e, property) {
            return Object.prototype.hasOwnProperty.call(e, property.name || property);
        }


        function defineCollectionProperty(ref, property, target) {
            Object.defineProperty(target, property.name, {
                enumerable: property.enumerable,
                value: Collection.extend(target[property.name] || [], ref, property, target)
            });
        }


        function defineProperty(ref, property, target) {

            var inverseProperty = property.inverse;

            var _value = target[property.name];

            Object.defineProperty(target, property.name, {
                enumerable: property.enumerable,

                get: function () {
                    return _value;
                },

                set: function (value) {

                    // return if we already performed all changes
                    if (value === _value) {
                        return;
                    }

                    var old = _value;

                    // temporary set null
                    _value = null;

                    if (old) {
                        ref.unset(old, inverseProperty, target);
                    }

                    // set new value
                    _value = value;

                    // set inverse value
                    ref.set(_value, inverseProperty, target);
                }
            });

        }

        /**
         * Creates a new references object defining two inversly related
         * attribute descriptors a and b.
         *
         * <p>
         *   When bound to an object using {@link Refs#bind} the references
         *   get activated and ensure that add and remove operations are applied
         *   reversely, too.
         * </p>
         *
         * <p>
         *   For attributes represented as collections {@link Refs} provides the
         *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions
         *   that must be used to properly hook into the inverse change mechanism.
         * </p>
         *
         * @class Refs
         *
         * @classdesc A bi-directional reference between two attributes.
         *
         * @param {Refs.AttributeDescriptor} a property descriptor
         * @param {Refs.AttributeDescriptor} b property descriptor
         *
         * @example
         *
         * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });
         *
         * var car = { name: 'toyota' };
         * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];
         *
         * refs.bind(car, 'wheels');
         *
         * car.wheels // []
         * car.wheels.add(wheels[0]);
         * car.wheels.add(wheels[1]);
         *
         * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]
         *
         * wheels[0].car // { name: 'toyota' };
         * car.wheels.remove(wheels[0]);
         *
         * wheels[0].car // undefined
         */
        function Refs(a, b) {

            if (!(this instanceof Refs)) {
                return new Refs(a, b);
            }

            // link
            a.inverse = b;
            b.inverse = a;

            this.props = {};
            this.props[a.name] = a;
            this.props[b.name] = b;
        }

        /**
         * Binds one side of a bi-directional reference to a
         * target object.
         *
         * @memberOf Refs
         *
         * @param  {Object} target
         * @param  {String} property
         */
        Refs.prototype.bind = function (target, property) {
            if (typeof property === 'string') {
                if (!this.props[property]) {
                    throw new Error('no property <' + property + '> in ref');
                }
                property = this.props[property];
            }

            if (property.collection) {
                defineCollectionProperty(this, property, target);
            } else {
                defineProperty(this, property, target);
            }
        };

        Refs.prototype.ensureBound = function (target, property) {
            if (!hasOwnProperty(target, property)) {
                this.bind(target, property);
            }
        };

        Refs.prototype.unset = function (target, property, value) {

            if (target) {
                this.ensureBound(target, property);

                if (property.collection) {
                    target[property.name].remove(value);
                } else {
                    target[property.name] = undefined;
                }
            }
        };

        Refs.prototype.set = function (target, property, value) {

            if (target) {
                this.ensureBound(target, property);

                if (property.collection) {
                    target[property.name].add(value);
                } else {
                    target[property.name] = value;
                }
            }
        };

        module.exports = Refs;


        /**
         * An attribute descriptor to be used specify an attribute in a {@link Refs} instance
         *
         * @typedef {Object} Refs.AttributeDescriptor
         * @property {String} name
         * @property {boolean} [collection=false]
         * @property {boolean} [enumerable=false]
         */
    }, {"./collection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/lib/collection.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/index.js": [function (require, module, exports) {
        module.exports = require('./lib/Diagram');
    }, {"./lib/Diagram": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/Diagram.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/Diagram.js": [function (require, module, exports) {
        'use strict';

        var di = require('didi');


        /**
         * Bootstrap an injector from a list of modules, instantiating a number of default components
         *
         * @ignore
         * @param {Array<didi.Module>} bootstrapModules
         *
         * @return {didi.Injector} a injector to use to access the components
         */
        function bootstrap(bootstrapModules) {

            var modules = [],
                components = [];

            function hasModule(m) {
                return modules.indexOf(m) >= 0;
            }

            function addModule(m) {
                modules.push(m);
            }

            function visit(m) {
                if (hasModule(m)) {
                    return;
                }

                (m.__depends__ || []).forEach(visit);

                if (hasModule(m)) {
                    return;
                }

                addModule(m);

                (m.__init__ || []).forEach(function (c) {
                    components.push(c);
                });
            }

            bootstrapModules.forEach(visit);

            var injector = new di.Injector(modules);

            components.forEach(function (c) {

                try {
                    // eagerly resolve component (fn or string)
                    injector[typeof c === 'string' ? 'get' : 'invoke'](c);
                } catch (e) {
                    console.error('Failed to instantiate component');
                    console.error(e.stack);

                    throw e;
                }
            });

            return injector;
        }

        /**
         * Creates an injector from passed options.
         *
         * @ignore
         * @param  {Object} options
         * @return {didi.Injector}
         */
        function createInjector(options) {

            options = options || {};

            var configModule = {
                'config': ['value', options]
            };

            var coreModule = require('./core');

            var modules = [configModule, coreModule].concat(options.modules || []);

            return bootstrap(modules);
        }


        /**
         * The main diagram-js entry point that bootstraps the diagram with the given
         * configuration.
         *
         * To register extensions with the diagram, pass them as Array<didi.Module> to the constructor.
         *
         * @class djs.Diagram
         * @memberOf djs
         * @constructor
         *
         * @example
         *
         * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>
         *
         * // plug-in implemenentation
         * function MyLoggingPlugin(eventBus) {
 *   eventBus.on('shape.added', function(event) {
 *     console.log('shape ', event.shape, ' was added to the diagram');
 *   });
 * }
         *
         * // export as module
         * module.exports = {
 *   __init__: [ 'myLoggingPlugin' ],
 *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]
 * };
         *
         *
         * // instantiate the diagram with the new plug-in
         *
         * var diagram = new Diagram({ modules: [ require('path-to-my-logging-plugin') ] });
         *
         * diagram.invoke([ 'canvas', function(canvas) {
 *   // add shape to drawing canvas
 *   canvas.addShape({ x: 10, y: 10 });
 * });
         *
         * // 'shape ... was added to the diagram' logged to console
         *
         * @param {Object} options
         * @param {Array<didi.Module>} [options.modules] external modules to instantiate with the diagram
         * @param {didi.Injector} [injector] an (optional) injector to bootstrap the diagram with
         */
        function Diagram(options, injector) {

            // create injector unless explicitly specified
            this.injector = injector = injector || createInjector(options);

            // API

            /**
             * Resolves a diagram service
             *
             * @method Diagram#get
             *
             * @param {String} name the name of the diagram service to be retrieved
             * @param {Object} [locals] a number of locals to use to resolve certain dependencies
             */
            this.get = injector.get;

            /**
             * Executes a function into which diagram services are injected
             *
             * @method Diagram#invoke
             *
             * @param {Function|Object[]} fn the function to resolve
             * @param {Object} locals a number of locals to use to resolve certain dependencies
             */
            this.invoke = injector.invoke;

            // init

            // indicate via event


            /**
             * An event indicating that all plug-ins are loaded.
             *
             * Use this event to fire other events to interested plug-ins
             *
             * @memberOf Diagram
             *
             * @event diagram.init
             *
             * @example
             *
             * eventBus.on('diagram.init', function() {
   *   eventBus.fire('my-custom-event', { foo: 'BAR' });
   * });
             *
             * @type {Object}
             */
            this.get('eventBus').fire('diagram.init');
        }

        module.exports = Diagram;


        /**
         * Destroys the diagram
         *
         * @method  Diagram#destroy
         */
        Diagram.prototype.destroy = function () {
            this.get('eventBus').fire('diagram.destroy');
        };
    }, {
        "./core": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/index.js",
        "didi": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/CommandInterceptor.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            isFunction = require('lodash/lang/isFunction'),
            isArray = require('lodash/lang/isArray');


        /**
         * A utility that can be used to plug-in into the command execution for
         * extension and/or validation.
         *
         * @param {EventBus} eventBus
         *
         * @example
         *
         * var inherits = require('inherits');
         *
         * var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');
         *
         * function CommandLogger(eventBus) {
 *   CommandInterceptor.call(this, eventBus);
 *
 *   this.preExecute(function(event) {
 *     console.log('command pre-execute', event);
 *   });
 * }
         *
         * inherits(CommandLogger, CommandInterceptor);
         *
         */
        function CommandInterceptor(eventBus) {
            this._eventBus = eventBus;
        }

        CommandInterceptor.$inject = ['eventBus'];

        module.exports = CommandInterceptor;

        function unwrapEvent(fn) {
            return function (event) {
                return fn(event.context, event.command, event);
            };
        }

        /**
         * Register an interceptor for a command execution
         *
         * @param  {String|Array<String>} [events] list of commands to register on
         * @param  {String} [hook] command hook, i.e. preExecute, executed to listen on
         * @param  {Function} handlerFn interceptor to be invoked with (event)
         * @param  {Boolean} unwrap if true, unwrap the event and pass (context, command, event) to the
         *                          listener instead
         */
        CommandInterceptor.prototype.on = function (events, hook, handlerFn, unwrap) {

            if (isFunction(hook)) {
                unwrap = handlerFn;
                handlerFn = hook;
                hook = null;
            }

            if (!isFunction(handlerFn)) {
                throw new Error('handlerFn must be a function');
            }

            if (!isArray(events)) {
                events = [events];
            }

            var eventBus = this._eventBus;

            forEach(events, function (event) {
                // concat commandStack(.event)?(.hook)?
                var fullEvent = ['commandStack', event, hook].filter(function (e) {
                    return e;
                }).join('.');

                eventBus.on(fullEvent, unwrap ? unwrapEvent(handlerFn) : handlerFn);
            });
        };


        var hooks = [
            'canExecute',
            'preExecute',
            'execute',
            'executed',
            'postExecute',
            'revert',
            'reverted'
        ];

        /*
         * Install hook shortcuts
         *
         * This will generate the CommandInterceptor#(preExecute|...|reverted) methods
         * which will in term forward to CommandInterceptor#on.
         */
        forEach(hooks, function (hook) {
            CommandInterceptor.prototype[hook] = function (events, fn, unwrap) {
                if (isFunction(events)) {
                    unwrap = fn;
                    fn = events;
                    events = null;
                }

                this.on(events, hook, fn, unwrap);
            };
        });
    }, {
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "lodash/lang/isFunction": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isFunction.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/CommandStack.js": [function (require, module, exports) {
        'use strict';

        var unique = require('lodash/array/unique'),
            isArray = require('lodash/lang/isArray'),
            assign = require('lodash/object/assign');

        var InternalEvent = require('../core/EventBus').Event;


        /**
         * A service that offers un- and redoable execution of commands.
         *
         * The command stack is responsible for executing modeling actions
         * in a un- and redoable manner. To do this it delegates the actual
         * command execution to {@link CommandHandler}s.
         *
         * Command handlers provide {@link CommandHandler#execute(ctx)} and
         * {@link CommandHandler#revert(ctx)} methods to un- and redo a command
         * identified by a command context.
         *
         *
         * ## Life-Cycle events
         *
         * In the process the command stack fires a number of life-cycle events
         * that other components to participate in the command execution.
         *
         *    * preExecute
         *    * execute
         *    * executed
         *    * postExecute
         *    * revert
         *    * reverted
         *
         * A special event is used for validating, whether a command can be
         * performed prior to its execution.
         *
         *    * canExecute
         *
         * Each of the events is fired as `commandStack.{eventName}` and
         * `commandStack.{commandName}.{eventName}`, respectively. This gives
         * components fine grained control on where to hook into.
         *
         * The event object fired transports `command`, the name of the
         * command and `context`, the command context.
         *
         *
         * ## Creating Command Handlers
         *
         * Command handlers should provide the {@link CommandHandler#execute(ctx)}
         * and {@link CommandHandler#revert(ctx)} methods to implement
         * redoing and undoing of a command. They must ensure undo is performed
         * properly in order not to break the undo chain.
         *
         * Command handlers may execute other modeling operations (and thus
         * commands) in their `preExecute` and `postExecute` phases. The command
         * stack will properly group all commands together into a logical unit
         * that may be re- and undone atomically.
         *
         * Command handlers must not execute other commands from within their
         * core implementation (`execute`, `revert`).
         *
         *
         * ## Change Tracking
         *
         * During the execution of the CommandStack it will keep track of all
         * elements that have been touched during the command's execution.
         *
         * At the end of the CommandStack execution it will notify interested
         * components via an 'elements.changed' event with all the dirty
         * elements.
         *
         * The event can be picked up by components that are interested in the fact
         * that elements have been changed. One use case for this is updating
         * their graphical representation after moving / resizing or deletion.
         *
         *
         * @param {EventBus} eventBus
         * @param {Injector} injector
         */
        function CommandStack(eventBus, injector) {

            /**
             * A map of all registered command handlers.
             *
             * @type {Object}
             */
            this._handlerMap = {};

            /**
             * A stack containing all re/undoable actions on the diagram
             *
             * @type {Array<Object>}
             */
            this._stack = [];

            /**
             * The current index on the stack
             *
             * @type {Number}
             */
            this._stackIdx = -1;

            /**
             * Current active commandStack execution
             *
             * @type {Object}
             */
            this._currentExecution = {
                actions: [],
                dirty: []
            };


            this._injector = injector;
            this._eventBus = eventBus;

            this._uid = 1;
        }

        CommandStack.$inject = ['eventBus', 'injector'];

        module.exports = CommandStack;


        /**
         * Execute a command
         *
         * @param {String} command the command to execute
         * @param {Object} context the environment to execute the command in
         */
        CommandStack.prototype.execute = function (command, context) {
            if (!command) {
                throw new Error('command required');
            }

            var action = {command: command, context: context};

            this._pushAction(action);
            this._internalExecute(action);
            this._popAction(action);
        };


        /**
         * Ask whether a given command can be executed.
         *
         * Implementors may hook into the mechanism on two ways:
         *
         *   * in event listeners:
         *
         *     Users may prevent the execution via an event listener.
         *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.
         *
         *   * in command handlers:
         *
         *     If the method {@link CommandHandler#canExecute} is implemented in a handler
         *     it will be called to figure out whether the execution is allowed.
         *
         * @param  {String} command the command to execute
         * @param  {Object} context the environment to execute the command in
         *
         * @return {Boolean} true if the command can be executed
         */
        CommandStack.prototype.canExecute = function (command, context) {

            var action = {command: command, context: context};

            var handler = this._getHandler(command);

            if (!handler) {
                return false;
            }

            var result = this._fire(command, 'canExecute', action);

            // handler#canExecute will only be called if no listener
            // decided on a result already
            if (result === undefined && handler.canExecute) {
                result = handler.canExecute(context);
            }

            return result;
        };


        /**
         * Clear the command stack, erasing all undo / redo history
         */
        CommandStack.prototype.clear = function () {
            this._stack.length = 0;
            this._stackIdx = -1;

            this._fire('changed');
        };


        /**
         * Undo last command(s)
         */
        CommandStack.prototype.undo = function () {
            var action = this._getUndoAction(),
                next;

            if (action) {
                this._pushAction(action);

                while (action) {
                    this._internalUndo(action);
                    next = this._getUndoAction();

                    if (!next || next.id !== action.id) {
                        break;
                    }

                    action = next;
                }

                this._popAction();
            }
        };


        /**
         * Redo last command(s)
         */
        CommandStack.prototype.redo = function () {
            var action = this._getRedoAction(),
                next;

            if (action) {
                this._pushAction(action);

                while (action) {
                    this._internalExecute(action, true);
                    next = this._getRedoAction();

                    if (!next || next.id !== action.id) {
                        break;
                    }

                    action = next;
                }

                this._popAction();
            }
        };


        /**
         * Register a handler instance with the command stack
         *
         * @param {String} command
         * @param {CommandHandler} handler
         */
        CommandStack.prototype.register = function (command, handler) {
            this._setHandler(command, handler);
        };


        /**
         * Register a handler type with the command stack
         * by instantiating it and injecting its dependencies.
         *
         * @param {String} command
         * @param {Function} a constructor for a {@link CommandHandler}
         */
        CommandStack.prototype.registerHandler = function (command, handlerCls) {

            if (!command || !handlerCls) {
                throw new Error('command and handlerCls must be defined');
            }

            var handler = this._injector.instantiate(handlerCls);
            this.register(command, handler);
        };

        CommandStack.prototype.canUndo = function () {
            return !!this._getUndoAction();
        };

        CommandStack.prototype.canRedo = function () {
            return !!this._getRedoAction();
        };

////// stack access  //////////////////////////////////////

        CommandStack.prototype._getRedoAction = function () {
            return this._stack[this._stackIdx + 1];
        };


        CommandStack.prototype._getUndoAction = function () {
            return this._stack[this._stackIdx];
        };


////// internal functionality /////////////////////////////

        CommandStack.prototype._internalUndo = function (action) {
            var command = action.command,
                context = action.context;

            var handler = this._getHandler(command);

            this._fire(command, 'revert', action);

            this._markDirty(handler.revert(context));

            this._revertedAction(action);

            this._fire(command, 'reverted', action);
        };


        CommandStack.prototype._fire = function (command, qualifier, event) {
            if (arguments.length < 3) {
                event = qualifier;
                qualifier = null;
            }

            var names = qualifier ? [command + '.' + qualifier, qualifier] : [command],
                i, name, result;

            event = assign(new InternalEvent(), event);

            for (i = 0; !!(name = names[i]); i++) {
                result = this._eventBus.fire('commandStack.' + name, event);

                if (event.cancelBubble) {
                    break;
                }
            }

            return result;
        };

        CommandStack.prototype._createId = function () {
            return this._uid++;
        };


        CommandStack.prototype._internalExecute = function (action, redo) {
            var command = action.command,
                context = action.context;

            var handler = this._getHandler(command);

            if (!handler) {
                throw new Error('no command handler registered for <' + command + '>');
            }

            this._pushAction(action);

            if (!redo) {
                this._fire(command, 'preExecute', action);

                if (handler.preExecute) {
                    handler.preExecute(context);
                }
            }

            this._fire(command, 'execute', action);

            // execute
            this._markDirty(handler.execute(context));

            // log to stack
            this._executedAction(action, redo);

            this._fire(command, 'executed', action);

            if (!redo) {
                if (handler.postExecute) {
                    handler.postExecute(context);
                }

                this._fire(command, 'postExecute', action);
            }

            this._popAction(action);
        };


        CommandStack.prototype._pushAction = function (action) {

            var execution = this._currentExecution,
                actions = execution.actions;

            var baseAction = actions[0];

            if (!action.id) {
                action.id = (baseAction && baseAction.id) || this._createId();
            }

            actions.push(action);
        };


        CommandStack.prototype._popAction = function () {
            var execution = this._currentExecution,
                actions = execution.actions,
                dirty = execution.dirty;

            actions.pop();

            if (!actions.length) {
                this._eventBus.fire('elements.changed', {elements: unique(dirty)});

                dirty.length = 0;

                this._fire('changed');
            }
        };


        CommandStack.prototype._markDirty = function (elements) {
            var execution = this._currentExecution;

            if (!elements) {
                return;
            }

            elements = isArray(elements) ? elements : [elements];

            execution.dirty = execution.dirty.concat(elements);
        };


        CommandStack.prototype._executedAction = function (action, redo) {
            var stackIdx = ++this._stackIdx;

            if (!redo) {
                this._stack.splice(stackIdx, this._stack.length, action);
            }
        };


        CommandStack.prototype._revertedAction = function (action) {
            this._stackIdx--;
        };


        CommandStack.prototype._getHandler = function (command) {
            return this._handlerMap[command];
        };

        CommandStack.prototype._setHandler = function (command, handler) {
            if (!command || !handler) {
                throw new Error('command and handler required');
            }

            if (this._handlerMap[command]) {
                throw new Error('overriding handler for command <' + command + '>');
            }

            this._handlerMap[command] = handler;
        };

    }, {
        "../core/EventBus": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/EventBus.js",
        "lodash/array/unique": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/array/unique.js",
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../core')],
            commandStack: ['type', require('./CommandStack')]
        };
    }, {
        "../core": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/index.js",
        "./CommandStack": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/CommandStack.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/Canvas.js": [function (require, module, exports) {
        'use strict';

        var isNumber = require('lodash/lang/isNumber'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var Collections = require('../util/Collections');

        var Snap = require('../../vendor/snapsvg');

        function round(number, resolution) {
            return Math.round(number * resolution) / resolution;
        }

        function ensurePx(number) {
            return isNumber(number) ? number + 'px' : number;
        }

        /**
         * Creates a HTML container element for a SVG element with
         * the given configuration
         *
         * @param  {Object} options
         * @return {HTMLElement} the container element
         */
        function createContainer(options) {

            options = assign({}, {width: '100%', height: '100%'}, options);

            var container = options.container || document.body;

            // create a <div> around the svg element with the respective size
            // this way we can always get the correct container size
            // (this is impossible for <svg> elements at the moment)
            var parent = document.createElement('div');
            parent.setAttribute('class', 'djs-container');

            assign(parent.style, {
                position: 'relative',
                overflow: 'hidden',
                width: ensurePx(options.width),
                height: ensurePx(options.height)
            });

            container.appendChild(parent);

            return parent;
        }

        function createGroup(parent, cls) {
            return parent.group().attr({'class': cls});
        }

        var BASE_LAYER = 'base';


        /**
         * The main drawing canvas.
         *
         * @class
         * @constructor
         *
         * @emits Canvas#canvas.init
         *
         * @param {Object} config
         * @param {EventBus} eventBus
         * @param {GraphicsFactory} graphicsFactory
         * @param {ElementRegistry} elementRegistry
         */
        function Canvas(config, eventBus, graphicsFactory, elementRegistry) {
            this._eventBus = eventBus;
            this._elementRegistry = elementRegistry;
            this._graphicsFactory = graphicsFactory;

            this._init(config || {});
        }

        Canvas.$inject = ['config.canvas', 'eventBus', 'graphicsFactory', 'elementRegistry'];

        module.exports = Canvas;


        Canvas.prototype._init = function (config) {

            // Creates a <svg> element that is wrapped into a <div>.
            // This way we are always able to correctly figure out the size of the svg element
            // by querying the parent node.
            //
            // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)
            //
            // <div class="djs-container" style="width: {desired-width}, height: {desired-height}">
            //   <svg width="100%" height="100%">
            //    ...
            //   </svg>
            // </div>

            // html container
            var eventBus = this._eventBus,

                container = createContainer(config),
                svg = Snap.createSnapAt('100%', '100%', container),
                viewport = createGroup(svg, 'viewport'),

                self = this;

            this._container = container;
            this._svg = svg;
            this._viewport = viewport;
            this._layers = {};

            eventBus.on('diagram.init', function (event) {

                /**
                 * An event indicating that the canvas is ready to be drawn on.
                 *
                 * @memberOf Canvas
                 *
                 * @event canvas.init
                 *
                 * @type {Object}
                 * @property {Snap<SVGSVGElement>} svg the created svg element
                 * @property {Snap<SVGGroup>} viewport the direct parent of diagram elements and shapes
                 */
                eventBus.fire('canvas.init', {svg: svg, viewport: viewport});
            });

            eventBus.on('diagram.destroy', function () {

                var parent = self._container.parentNode;

                if (parent) {
                    parent.removeChild(container);
                }

                eventBus.fire('canvas.destroy', {svg: self._svg, viewport: self._viewport});

                self._svg.remove();

                self._svg = self._container = self._layers = self._viewport = null;
            });

        };

        /**
         * Returns the default layer on which
         * all elements are drawn.
         *
         * @returns {Snap<SVGGroup>}
         */
        Canvas.prototype.getDefaultLayer = function () {
            return this.getLayer(BASE_LAYER);
        };

        /**
         * Returns a layer that is used to draw elements
         * or annotations on it.
         *
         * @param  {String} name
         *
         * @returns {Snap<SVGGroup>}
         */
        Canvas.prototype.getLayer = function (name) {

            if (!name) {
                throw new Error('must specify a name');
            }

            var layer = this._layers[name];
            if (!layer) {
                layer = this._layers[name] = createGroup(this._viewport, 'layer-' + name);
            }

            return layer;
        };


        /**
         * Returns the html element that encloses the
         * drawing canvas.
         *
         * @return {DOMNode}
         */
        Canvas.prototype.getContainer = function () {
            return this._container;
        };


/////////////// markers ///////////////////////////////////

        Canvas.prototype._updateMarker = function (element, marker, add) {
            var container;

            if (!element.id) {
                element = this._elementRegistry.get(element);
            }

            // we need to access all
            container = this._elementRegistry._elements[element.id];

            if (!container) {
                return;
            }

            forEach([container.gfx, container.secondaryGfx], function (gfx) {
                if (gfx) {
                    // invoke either addClass or removeClass based on mode
                    gfx[add ? 'addClass' : 'removeClass'](marker);
                }
            });

            /**
             * An event indicating that a marker has been updated for an element
             *
             * @event element.marker.update
             * @type {Object}
             * @property {djs.model.Element} element the shape
             * @property {Object} gfx the graphical representation of the shape
             * @property {String} marker
             * @property {Boolean} add true if the marker was added, false if it got removed
             */
            this._eventBus.fire('element.marker.update', {
                element: element,
                gfx: container.gfx,
                marker: marker,
                add: !!add
            });
        };


        /**
         * Adds a marker to an element (basically a css class).
         *
         * Fires the element.marker.update event, making it possible to
         * integrate extension into the marker life-cycle, too.
         *
         * @example
         * canvas.addMarker('foo', 'some-marker');
         *
         * var fooGfx = canvas.getGraphics('foo');
         *
         * fooGfx; // <g class="... some-marker"> ... </g>
         *
         * @param {String|djs.model.Base} element
         * @param {String} marker
         */
        Canvas.prototype.addMarker = function (element, marker) {
            this._updateMarker(element, marker, true);
        };


        /**
         * Remove a marker from an element.
         *
         * Fires the element.marker.update event, making it possible to
         * integrate extension into the marker life-cycle, too.
         *
         * @param  {String|djs.model.Base} element
         * @param  {String} marker
         */
        Canvas.prototype.removeMarker = function (element, marker) {
            this._updateMarker(element, marker, false);
        };

        /**
         * Check the existence of a marker on element.
         *
         * @param  {String|djs.model.Base} element
         * @param  {String} marker
         */
        Canvas.prototype.hasMarker = function (element, marker) {
            if (!element.id) {
                element = this._elementRegistry.get(element);
            }

            var gfx = this.getGraphics(element);

            return gfx && gfx.hasClass(marker);
        };

        /**
         * Toggles a marker on an element.
         *
         * Fires the element.marker.update event, making it possible to
         * integrate extension into the marker life-cycle, too.
         *
         * @param  {String|djs.model.Base} element
         * @param  {String} marker
         */
        Canvas.prototype.toggleMarker = function (element, marker) {
            if (this.hasMarker(element, marker)) {
                this.removeMarker(element, marker);
            } else {
                this.addMarker(element, marker);
            }
        };

        Canvas.prototype.getRootElement = function () {
            if (!this._rootElement) {
                this.setRootElement({id: '__implicitroot'});
            }

            return this._rootElement;
        };


//////////////// root element handling ///////////////////////////

        /**
         * Sets a given element as the new root element for the canvas
         * and returns the new root element.
         *
         * @param {Object|djs.model.Root} element
         * @param {Boolean} [override] whether to override the current root element, if any
         *
         * @return {Object|djs.model.Root} new root element
         */
        Canvas.prototype.setRootElement = function (element, override) {

            this._ensureValidId(element);

            var oldRoot = this._rootElement,
                elementRegistry = this._elementRegistry,
                eventBus = this._eventBus;

            if (oldRoot) {
                if (!override) {
                    throw new Error('rootElement already set, need to specify override');
                }

                // simulate element remove event sequence
                eventBus.fire('root.remove', {element: oldRoot});
                eventBus.fire('root.removed', {element: oldRoot});

                elementRegistry.remove(oldRoot);
            }

            var gfx = this.getDefaultLayer();

            // resemble element add event sequence
            eventBus.fire('root.add', {element: element});

            elementRegistry.add(element, gfx, this._svg);

            eventBus.fire('root.added', {element: element, gfx: gfx});

            this._rootElement = element;

            return element;
        };


///////////// add functionality ///////////////////////////////

        Canvas.prototype._ensureValidId = function (element) {
            if (!element.id) {
                throw new Error('element must have an id');
            }

            if (this._elementRegistry.get(element.id)) {
                throw new Error('element with id ' + element.id + ' already exists');
            }
        };

        Canvas.prototype._setParent = function (element, parent) {
            Collections.add(parent.children, element);
            element.parent = parent;
        };

        /**
         * Adds an element to the canvas.
         *
         * This wires the parent <-> child relationship between the element and
         * a explicitly specified parent or an implicit root element.
         *
         * During add it emits the events
         *
         *  * <{type}.add> (element, parent)
         *  * <{type}.added> (element, gfx)
         *
         * Extensions may hook into these events to perform their magic.
         *
         * @param {String} type
         * @param {Object|djs.model.Base} element
         * @param {Object|djs.model.Base} [parent]
         *
         * @return {Object|djs.model.Base} the added element
         */
        Canvas.prototype._addElement = function (type, element, parent) {

            parent = parent || this.getRootElement();

            var eventBus = this._eventBus,
                graphicsFactory = this._graphicsFactory;

            this._ensureValidId(element);

            eventBus.fire(type + '.add', {element: element, parent: parent});

            this._setParent(element, parent);

            // create graphics
            var gfx = graphicsFactory.create(type, element);

            this._elementRegistry.add(element, gfx);

            // update its visual
            graphicsFactory.update(type, element, gfx);

            eventBus.fire(type + '.added', {element: element, gfx: gfx});

            return element;
        };

        /**
         * Adds a shape to the canvas
         *
         * @param {Object|djs.model.Shape} shape to add to the diagram
         * @param {djs.model.Base} [parent]
         *
         * @return {djs.model.Shape} the added shape
         */
        Canvas.prototype.addShape = function (shape, parent) {
            return this._addElement('shape', shape, parent);
        };

        /**
         * Adds a connection to the canvas
         *
         * @param {Object|djs.model.Connection} connection to add to the diagram
         * @param {djs.model.Base} [parent]
         *
         * @return {djs.model.Connection} the added connection
         */
        Canvas.prototype.addConnection = function (connection, parent) {
            return this._addElement('connection', connection, parent);
        };


        /**
         * Internal remove element
         */
        Canvas.prototype._removeElement = function (element, type) {

            var elementRegistry = this._elementRegistry,
                graphicsFactory = this._graphicsFactory,
                eventBus = this._eventBus;

            element = elementRegistry.get(element.id || element);

            if (!element) {
                // element was removed already
                return;
            }

            eventBus.fire(type + '.remove', {element: element});

            graphicsFactory.remove(element);

            // unset parent <-> child relationship
            Collections.remove(element.parent && element.parent.children, element);
            element.parent = null;

            eventBus.fire(type + '.removed', {element: element});

            elementRegistry.remove(element);

            return element;
        };


        /**
         * Removes a shape from the canvas
         *
         * @param {String|djs.model.Shape} shape or shape id to be removed
         *
         * @return {djs.model.Shape} the removed shape
         */
        Canvas.prototype.removeShape = function (shape) {

            /**
             * An event indicating that a shape is about to be removed from the canvas.
             *
             * @memberOf Canvas
             *
             * @event shape.remove
             * @type {Object}
             * @property {djs.model.Shape} element the shape descriptor
             * @property {Object} gfx the graphical representation of the shape
             */

            /**
             * An event indicating that a shape has been removed from the canvas.
             *
             * @memberOf Canvas
             *
             * @event shape.removed
             * @type {Object}
             * @property {djs.model.Shape} element the shape descriptor
             * @property {Object} gfx the graphical representation of the shape
             */
            return this._removeElement(shape, 'shape');
        };


        /**
         * Removes a connection from the canvas
         *
         * @param {String|djs.model.Connection} connection or connection id to be removed
         *
         * @return {djs.model.Connection} the removed connection
         */
        Canvas.prototype.removeConnection = function (connection) {

            /**
             * An event indicating that a connection is about to be removed from the canvas.
             *
             * @memberOf Canvas
             *
             * @event connection.remove
             * @type {Object}
             * @property {djs.model.Connection} element the connection descriptor
             * @property {Object} gfx the graphical representation of the connection
             */

            /**
             * An event indicating that a connection has been removed from the canvas.
             *
             * @memberOf Canvas
             *
             * @event connection.removed
             * @type {Object}
             * @property {djs.model.Connection} element the connection descriptor
             * @property {Object} gfx the graphical representation of the connection
             */
            return this._removeElement(connection, 'connection');
        };


        /**
         * Sends a shape to the front.
         *
         * This method takes parent / child relationships between shapes into account
         * and makes sure that children are properly handled, too.
         *
         * @param {djs.model.Shape} shape descriptor of the shape to be sent to front
         * @param {boolean} [bubble=true] whether to send parent shapes to front, too
         */
        Canvas.prototype.sendToFront = function (shape, bubble) {

            if (bubble !== false) {
                bubble = true;
            }

            if (bubble && shape.parent) {
                this.sendToFront(shape.parent);
            }

            forEach(shape.children, function (child) {
                this.sendToFront(child, false);
            }, this);

            var gfx = this.getGraphics(shape),
                gfxParent = gfx.parent();

            gfx.remove().appendTo(gfxParent);
        };


        /**
         * Return the graphical object underlaying a certain diagram element
         *
         * @param {String|djs.model.Base} element descriptor of the element
         * @param {Boolean} [secondary=false] whether to return the secondary connected element
         *
         * @return {SVGElement}
         */
        Canvas.prototype.getGraphics = function (element, secondary) {
            return this._elementRegistry.getGraphics(element, secondary);
        };


        Canvas.prototype._fireViewboxChange = function () {
            this._eventBus.fire('canvas.viewbox.changed', {viewbox: this.viewbox(false)});
        };


        /**
         * Gets or sets the view box of the canvas, i.e. the area that is currently displayed
         *
         * @param  {Object} [box] the new view box to set
         * @param  {Number} box.x the top left X coordinate of the canvas visible in view box
         * @param  {Number} box.y the top left Y coordinate of the canvas visible in view box
         * @param  {Number} box.width the visible width
         * @param  {Number} box.height
         *
         * @example
         *
         * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })
         *
         * // sets the visible area of the diagram to (100|100) -> (600|100)
         * // and and scales it according to the diagram width
         *
         * @return {Object} the current view box
         */
        Canvas.prototype.viewbox = function (box) {

            if (box === undefined && this._cachedViewbox) {
                return this._cachedViewbox;
            }

            var viewport = this._viewport,
                innerBox,
                outerBox = this.getSize(),
                matrix,
                scale,
                x, y;

            if (!box) {
                // compute the inner box based on the
                // diagrams default layer. This allows us to exclude
                // external components, such as overlays
                innerBox = this.getDefaultLayer().getBBox(true);

                matrix = viewport.transform().localMatrix;
                scale = round(matrix.a, 1000);

                x = round(-matrix.e || 0, 1000);
                y = round(-matrix.f || 0, 1000);

                box = this._cachedViewbox = {
                    x: x ? x / scale : 0,
                    y: y ? y / scale : 0,
                    width: outerBox.width / scale,
                    height: outerBox.height / scale,
                    scale: scale,
                    inner: {
                        width: innerBox.width,
                        height: innerBox.height,
                        x: innerBox.x,
                        y: innerBox.y
                    },
                    outer: outerBox
                };

                return box;
            } else {
                scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);

                matrix = new Snap.Matrix().scale(scale).translate(-box.x, -box.y);
                viewport.transform(matrix);

                this._fireViewboxChange();
            }

            return box;
        };


        /**
         * Gets or sets the scroll of the canvas.
         *
         * @param {Object} [delta] the new scroll to apply.
         *
         * @param {Number} [delta.dx]
         * @param {Number} [delta.dy]
         */
        Canvas.prototype.scroll = function (delta) {

            var node = this._viewport.node;
            var matrix = node.getCTM();

            if (delta) {
                delta = assign({dx: 0, dy: 0}, delta || {});

                matrix = this._svg.node.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);

                setCTM(node, matrix);

                this._fireViewboxChange();
            }

            return {x: matrix.e, y: matrix.f};
        };


        /**
         * Gets or sets the current zoom of the canvas, optionally zooming to the specified position.
         *
         * @param {String|Number} [newScale] the new zoom level, either a number, i.e. 0.9,
         *                                   or `fit-viewport` to adjust the size to fit the current viewport
         * @param {String|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null
         *
         * @return {Number} the current scale
         */
        Canvas.prototype.zoom = function (newScale, center) {

            if (newScale === 'fit-viewport') {
                return this._fitViewport(center);
            }

            var vbox = this.viewbox();

            if (newScale === undefined) {
                return vbox.scale;
            }

            var outer = vbox.outer;

            if (center === 'auto') {
                center = {
                    x: outer.width / 2,
                    y: outer.height / 2
                };
            }

            var matrix = this._setZoom(newScale, center);

            this._fireViewboxChange();

            return round(matrix.a, 1000);
        };

        function setCTM(node, m) {
            var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';
            node.setAttribute('transform', mstr);
        }

        Canvas.prototype._fitViewport = function (center) {

            var vbox = this.viewbox(),
                outer = vbox.outer,
                inner = vbox.inner,
                newScale,
                newViewbox;

            // display the complete diagram without zooming in.
            // instead of relying on internal zoom, we perform a
            // hard reset on the canvas viewbox to realize this
            //
            // if diagram does not need to be zoomed in, we focus it around
            // the diagram origin instead

            if (inner.x >= 0 &&
                inner.y >= 0 &&
                inner.x + inner.width <= outer.width &&
                inner.y + inner.height <= outer.height && !center) {

                newViewbox = {
                    x: 0,
                    y: 0,
                    width: Math.max(inner.width + inner.x, outer.width),
                    height: Math.max(inner.height + inner.y, outer.height)
                };
            } else {

                newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
                newViewbox = {
                    x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),
                    y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),
                    width: outer.width / newScale,
                    height: outer.height / newScale
                };
            }

            this.viewbox(newViewbox);

            return this.viewbox().scale;
        };


        Canvas.prototype._setZoom = function (scale, center) {

            var svg = this._svg.node,
                viewport = this._viewport.node;

            var matrix = svg.createSVGMatrix();
            var point = svg.createSVGPoint();

            var centerPoint,
                originalPoint,
                currentMatrix,
                scaleMatrix,
                newMatrix;

            currentMatrix = viewport.getCTM();


            var currentScale = currentMatrix.a;

            if (center) {
                centerPoint = assign(point, center);

                // revert applied viewport transformations
                originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());

                // create scale matrix
                scaleMatrix = matrix
                    .translate(originalPoint.x, originalPoint.y)
                    .scale(1 / currentScale * scale)
                    .translate(-originalPoint.x, -originalPoint.y);

                newMatrix = currentMatrix.multiply(scaleMatrix);
            } else {
                newMatrix = matrix.scale(scale);
            }

            setCTM(this._viewport.node, newMatrix);

            return newMatrix;
        };


        /**
         * Returns the size of the canvas
         *
         * @return {Dimensions}
         */
        Canvas.prototype.getSize = function () {
            return {
                width: this._container.clientWidth,
                height: this._container.clientHeight
            };
        };


        /**
         * Return the absolute bounding box for the given element
         *
         * The absolute bounding box may be used to display overlays in the
         * callers (browser) coordinate system rather than the zoomed in/out
         * canvas coordinates.
         *
         * @param  {ElementDescriptor} element
         * @return {Bounds} the absolute bounding box
         */
        Canvas.prototype.getAbsoluteBBox = function (element) {
            var vbox = this.viewbox();
            var bbox;

            // connection
            // use svg bbox
            if (element.waypoints) {
                var gfx = this.getGraphics(element);

                var transformBBox = gfx.getBBox(true);
                bbox = gfx.getBBox();

                bbox.x -= transformBBox.x;
                bbox.y -= transformBBox.y;

                bbox.width += 2 * transformBBox.x;
                bbox.height += 2 * transformBBox.y;
            }
            // shapes
            // use data
            else {
                bbox = element;
            }

            var x = bbox.x * vbox.scale - vbox.x * vbox.scale;
            var y = bbox.y * vbox.scale - vbox.y * vbox.scale;

            var width = bbox.width * vbox.scale;
            var height = bbox.height * vbox.scale;

            return {
                x: x,
                y: y,
                width: width,
                height: height
            };
        };

    }, {
        "../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "../util/Collections": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Collections.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/lang/isNumber": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isNumber.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/ElementFactory.js": [function (require, module, exports) {
        'use strict';

        var Model = require('../model');


        /**
         * A factory for diagram-js shapes
         */
        function ElementFactory() {
            this._uid = 12;
        }

        module.exports = ElementFactory;


        ElementFactory.prototype.createRoot = function (attrs) {
            return this.create('root', attrs);
        };

        ElementFactory.prototype.createLabel = function (attrs) {
            return this.create('label', attrs);
        };

        ElementFactory.prototype.createShape = function (attrs) {
            return this.create('shape', attrs);
        };

        ElementFactory.prototype.createConnection = function (attrs) {
            return this.create('connection', attrs);
        };

        /**
         * Create a model element with the given type and
         * a number of pre-set attributes.
         *
         * @param  {String} type
         * @param  {Object} attrs
         * @return {djs.model.Base} the newly created model instance
         */
        ElementFactory.prototype.create = function (type, attrs) {

            attrs = attrs || {};

            if (!attrs.id) {
                attrs.id = type + '_' + (this._uid++);
            }

            return Model.create(type, attrs);
        };
    }, {"../model": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/model/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/ElementRegistry.js": [function (require, module, exports) {
        'use strict';

        var ELEMENT_ID = 'data-element-id';


        /**
         * @class
         *
         * A registry that keeps track of all shapes in the diagram.
         */
        function ElementRegistry() {
            this._elements = {};
        }

        module.exports = ElementRegistry;

        /**
         * Register a pair of (element, gfx, (secondaryGfx)).
         *
         * @param {djs.model.Base} element
         * @param {Snap<SVGElement>} gfx
         * @param {Snap<SVGElement>} [secondaryGfx] optional other element to register, too
         */
        ElementRegistry.prototype.add = function (element, gfx, secondaryGfx) {

            var id = element.id;

            this._validateId(id);

            // associate dom node with element
            gfx.attr(ELEMENT_ID, id);

            if (secondaryGfx) {
                secondaryGfx.attr(ELEMENT_ID, id);
            }

            this._elements[id] = {element: element, gfx: gfx, secondaryGfx: secondaryGfx};
        };

        /**
         * Removes an element from the registry.
         *
         * @param {djs.model.Base} element
         */
        ElementRegistry.prototype.remove = function (element) {
            var elements = this._elements,
                id = element.id || element,
                container = id && elements[id];

            if (container) {

                // unset element id on gfx
                container.gfx.attr(ELEMENT_ID, null);

                if (container.secondaryGfx) {
                    container.secondaryGfx.attr(ELEMENT_ID, null);
                }

                delete elements[id];
            }
        };

        /**
         * Update the id of an element
         *
         * @param {djs.model.Base} element
         * @param {String} newId
         */
        ElementRegistry.prototype.updateId = function (element, newId) {

            this._validateId(newId);

            if (typeof element === 'string') {
                element = this.get(element);
            }

            var gfx = this.getGraphics(element),
                secondaryGfx = this.getGraphics(element, true);

            this.remove(element);

            element.id = newId;

            this.add(element, gfx, secondaryGfx);
        };

        /**
         * Return the model element for a given id or graphics.
         *
         * @example
         *
         * elementRegistry.get('SomeElementId_1');
         * elementRegistry.get(gfx);
         *
         *
         * @param {String|SVGElement} filter for selecting the element
         *
         * @return {djs.model.Base}
         */
        ElementRegistry.prototype.get = function (filter) {
            var id;

            if (typeof filter === 'string') {
                id = filter;
            } else {
                id = filter && filter.attr(ELEMENT_ID);
            }

            var container = this._elements[id];
            return container && container.element;
        };

        /**
         * Return all elements that match a given filter function.
         *
         * @param {Function} fn
         *
         * @return {Array<djs.model.Base>}
         */
        ElementRegistry.prototype.filter = function (fn) {

            var filtered = [];

            this.forEach(function (element, gfx) {
                if (fn(element, gfx)) {
                    filtered.push(element);
                }
            });

            return filtered;
        };

        /**
         * Iterate over all diagram elements.
         *
         * @param {Function} fn
         */
        ElementRegistry.prototype.forEach = function (fn) {

            var map = this._elements;

            Object.keys(map).forEach(function (id) {
                var container = map[id],
                    element = container.element,
                    gfx = container.gfx;

                return fn(element, gfx);
            });
        };

        /**
         * Return the graphical representation of an element or its id.
         *
         * @example
         * elementRegistry.getGraphics('SomeElementId_1');
         * elementRegistry.getGraphics(rootElement); // <g ...>
         *
         * elementRegistry.getGraphics(rootElement, true); // <svg ...>
         *
         *
         * @param {String|djs.model.Base} filter
         * @param {Boolean} [secondary=false] whether to return the secondary connected element
         *
         * @return {SVGElement}
         */
        ElementRegistry.prototype.getGraphics = function (filter, secondary) {
            var id = filter.id || filter;

            var container = this._elements[id];
            return container && (secondary ? container.secondaryGfx : container.gfx);
        };

        /**
         * Validate the suitability of the given id and signals a problem
         * with an exception.
         *
         * @param {String} id
         *
         * @throws {Error} if id is empty or already assigned
         */
        ElementRegistry.prototype._validateId = function (id) {
            if (!id) {
                throw new Error('element must have an id');
            }

            if (this._elements[id]) {
                throw new Error('element with id ' + id + ' already added');
            }
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/EventBus.js": [function (require, module, exports) {
        'use strict';

        var isFunction = require('lodash/lang/isFunction'),
            isArray = require('lodash/lang/isArray'),
            isNumber = require('lodash/lang/isNumber'),
            assign = require('lodash/object/assign');

        var DEFAULT_PRIORITY = 1000;


        /**
         * A general purpose event bus.
         *
         * This component is used to communicate across a diagram instance.
         * Other parts of a diagram can use it to listen to and broadcast events.
         *
         *
         * ## Registering for Events
         *
         * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
         * methods to register for events. {@link EventBus#off} can be used to
         * remove event registrations. Listeners receive an instance of {@link Event}
         * as the first argument. It allows them to hook into the event execution.
         *
         * ```javascript
         *
         * // listen for event
         * eventBus.on('foo', function(event) {
 *
 *   // access event type
 *   event.type; // 'foo'
 *
 *   // stop propagation to other listeners
 *   event.stopPropagation();
 *
 *   // prevent event default
 *   event.preventDefault();
 * });
         *
         * // listen for event with custom payload
         * eventBus.on('bar', function(event, payload) {
 *   console.log(payload);
 * });
         *
         * // listen for event returning value
         * eventBus.on('foobar', function(event) {
 *
 *   // stop event propagation + prevent default
 *   return false;
 *
 *   // stop event propagation + return custom result
 *   return {
 *     complex: 'listening result'
 *   };
 * });
         *
         *
         * // listen with custom priority (default=1000, higher is better)
         * eventBus.on('priorityfoo', 1500, function(event) {
 *   console.log('invoked first!');
 * });
         * ```
         *
         *
         * ## Emitting Events
         *
         * Events can be emitted via the event bus using {@link EventBus#fire}.
         *
         * ```javascript
         *
         * // false indicates that the default action
         * // was prevented by listeners
         * if (eventBus.fire('foo') === false) {
 *   console.log('default has been prevented!');
 * };
         *
         *
         * // custom args + return value listener
         * eventBus.on('sum', function(event, a, b) {
 *   return a + b;
 * });
         *
         * // you can pass custom arguments + retrieve result values.
         * var sum = eventBus.fire('sum', 1, 2);
         * console.log(sum); // 3
         * ```
         */
        function EventBus() {
            this._listeners = {};

            // cleanup on destroy

            var self = this;

            // destroy on lowest priority to allow
            // message passing until the bitter end
            this.on('diagram.destroy', 1, function () {
                self._listeners = null;
            });
        }

        module.exports = EventBus;


        /**
         * Register an event listener for events with the given name.
         *
         * The callback will be invoked with `event, ...additionalArguments`
         * that have been passed to {@link EventBus#fire}.
         *
         * Returning false from a listener will prevent the events default action
         * (if any is specified). To stop an event from being processed further in
         * other listeners execute {@link Event#stopPropagation}.
         *
         * Returning anything but `undefined` from a listener will stop the listener propagation.
         *
         * @param {String|Array<String>} events
         * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher
         * @param {Function} callback
         */
        EventBus.prototype.on = function (events, priority, callback) {

            events = isArray(events) ? events : [events];

            if (isFunction(priority)) {
                callback = priority;
                priority = DEFAULT_PRIORITY;
            }

            if (!isNumber(priority)) {
                throw new Error('priority must be a number');
            }

            var self = this,
                listener = {priority: priority, callback: callback};

            events.forEach(function (e) {
                self._addListener(e, listener);
            });
        };


        /**
         * Register an event listener that is executed only once.
         *
         * @param {String} event the event name to register for
         * @param {Function} callback the callback to execute
         */
        EventBus.prototype.once = function (event, callback) {

            var self = this;

            function wrappedCallback() {
                callback.apply(self, arguments);
                self.off(event, wrappedCallback);
            }

            this.on(event, wrappedCallback);
        };


        /**
         * Removes event listeners by event and callback.
         *
         * If no callback is given, all listeners for a given event name are being removed.
         *
         * @param {String} event
         * @param {Function} [callback]
         */
        EventBus.prototype.off = function (event, callback) {
            var listeners = this._getListeners(event),
                listener, idx;

            if (callback) {

                // move through listeners from back to front
                // and remove matching listeners
                for (idx = listeners.length - 1; !!(listener = listeners[idx]); idx--) {
                    if (listener.callback === callback) {
                        listeners.splice(idx, 1);
                    }
                }
            } else {
                // clear listeners
                listeners.length = 0;
            }
        };


        /**
         * Fires a named event.
         *
         * @example
         *
         * // fire event by name
         * events.fire('foo');
         *
         * // fire event object with nested type
         * var event = { type: 'foo' };
         * events.fire(event);
         *
         * // fire event with explicit type
         * var event = { x: 10, y: 20 };
         * events.fire('element.moved', event);
         *
         * // pass additional arguments to the event
         * events.on('foo', function(event, bar) {
 *   alert(bar);
 * });
         *
         * events.fire({ type: 'foo' }, 'I am bar!');
         *
         * @param {String} [name] the optional event name
         * @param {Object} [event] the event object
         * @param {...Object} additional arguments to be passed to the callback functions
         *
         * @return {Boolean} the events return value, if specified or false if the
         *                   default action was prevented by listeners
         */
        EventBus.prototype.fire = function (type, data) {

            var event,
                originalType,
                listeners, idx, listener,
                returnValue,
                args;

            args = Array.prototype.slice.call(arguments);

            if (typeof type === 'object') {
                event = type;
                type = event.type;
            }

            if (!type) {
                throw new Error('no event type specified');
            }

            listeners = this._listeners[type];

            if (!listeners) {
                return;
            }

            // we make sure we fire instances of our home made
            // events here. We wrap them only once, though
            if (data instanceof Event) {
                // we are fine, we alread have an event
                event = data;
            } else {
                event = new Event();
                event.init(data);
            }

            // ensure we pass the event as the first parameter
            args[0] = event;

            // original event type (in case we delegate)
            originalType = event.type;

            try {

                // update event type before delegation
                if (type !== originalType) {
                    event.type = type;
                }

                for (idx = 0; !!(listener = listeners[idx]); idx++) {

                    // handle stopped propagation
                    if (event.cancelBubble) {
                        break;
                    }

                    try {
                        // returning false prevents the default action
                        returnValue = event.returnValue = listener.callback.apply(null, args);

                        // stop propagation on return value
                        if (returnValue !== undefined) {
                            event.stopPropagation();
                        }

                        // prevent default on return false
                        if (returnValue === false) {
                            event.preventDefault();
                        }
                    } catch (e) {
                        if (!this.handleError(e)) {
                            console.error('unhandled error in event listener');
                            console.error(e.stack);

                            throw e;
                        }
                    }
                }
            } finally {
                // reset event type after delegation
                if (type !== originalType) {
                    event.type = originalType;
                }
            }

            // set the return value to false if the event default
            // got prevented and no other return value exists
            if (returnValue === undefined && event.defaultPrevented) {
                returnValue = false;
            }

            return returnValue;
        };


        EventBus.prototype.handleError = function (error) {
            return this.fire('error', {error: error}) === false;
        };


        /*
         * Add new listener with a certain priority to the list
         * of listeners (for the given event).
         *
         * The semantics of listener registration / listener execution are
         * first register, first serve: New listeners will always be inserted
         * after existing listeners with the same priority.
         *
         * Example: Inserting two listeners with priority 1000 and 1300
         *
         *    * before: [ 1500, 1500, 1000, 1000 ]
         *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
         *
         * @param {String} event
         * @param {Object} listener { priority, callback }
         */
        EventBus.prototype._addListener = function (event, newListener) {

            var listeners = this._getListeners(event),
                existingListener,
                idx;

            // ensure we order listeners by priority from
            // 0 (high) to n > 0 (low)
            for (idx = 0; !!(existingListener = listeners[idx]); idx++) {
                if (existingListener.priority < newListener.priority) {

                    // prepend newListener at before existingListener
                    listeners.splice(idx, 0, newListener);
                    return;
                }
            }

            listeners.push(newListener);
        };


        EventBus.prototype._getListeners = function (name) {
            var listeners = this._listeners[name];

            if (!listeners) {
                this._listeners[name] = listeners = [];
            }

            return listeners;
        };


        /**
         * A event that is emitted via the event bus.
         */
        function Event() {
        }

        module.exports.Event = Event;

        Event.prototype.stopPropagation = function () {
            this.cancelBubble = true;
        };

        Event.prototype.preventDefault = function () {
            this.defaultPrevented = true;
        };

        Event.prototype.init = function (data) {
            assign(this, data || {});
        };

    }, {
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "lodash/lang/isFunction": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isFunction.js",
        "lodash/lang/isNumber": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isNumber.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/GraphicsFactory.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            reduce = require('lodash/collection/reduce');

        var GraphicsUtil = require('../util/GraphicsUtil'),
            domClear = require('min-dom/lib/clear');

        /**
         * A factory that creates graphical elements
         *
         * @param {Renderer} renderer
         */
        function GraphicsFactory(renderer, elementRegistry) {
            this._renderer = renderer;
            this._elementRegistry = elementRegistry;
        }

        GraphicsFactory.$inject = ['renderer', 'elementRegistry'];

        module.exports = GraphicsFactory;


        GraphicsFactory.prototype._getChildren = function (element) {

            var gfx = this._elementRegistry.getGraphics(element);

            var childrenGfx;

            // root element
            if (!element.parent) {
                childrenGfx = gfx;
            } else {
                childrenGfx = GraphicsUtil.getChildren(gfx);
                if (!childrenGfx) {
                    childrenGfx = gfx.parent().group().attr('class', 'djs-children');
                }
            }

            return childrenGfx;
        };

        /**
         * Clears the graphical representation of the element and returns the
         * cleared visual (the <g class="djs-visual" /> element).
         */
        GraphicsFactory.prototype._clear = function (gfx) {
            var visual = GraphicsUtil.getVisual(gfx);

            domClear(visual.node);

            return visual;
        };

        /**
         * Creates a gfx container for shapes and connections
         *
         * The layout is as follows:
         *
         * <g class="djs-group">
         *
         *   <!-- the gfx -->
         *   <g class="djs-element djs-(shape|connection)">
         *     <g class="djs-visual">
         *       <!-- the renderer draws in here -->
         *     </g>
         *
         *     <!-- extensions (overlays, click box, ...) goes here
         *   </g>
         *
         *   <!-- the gfx child nodes -->
         *   <g class="djs-children"></g>
         * </g>
         *
         * @param {Object} parent
         * @param {String} type the type of the element, i.e. shape | connection
         */
        GraphicsFactory.prototype._createContainer = function (type, parentGfx) {
            var outerGfx = parentGfx.group().attr('class', 'djs-group'),
                gfx = outerGfx.group().attr('class', 'djs-element djs-' + type);

            // create visual
            gfx.group().attr('class', 'djs-visual');

            return gfx;
        };

        GraphicsFactory.prototype.create = function (type, element) {
            var childrenGfx = this._getChildren(element.parent);
            return this._createContainer(type, childrenGfx);
        };


        GraphicsFactory.prototype.updateContainments = function (elements) {

            var self = this,
                elementRegistry = this._elementRegistry,
                parents;


            parents = reduce(elements, function (map, e) {

                if (e.parent) {
                    map[e.parent.id] = e.parent;
                }

                return map;
            }, {});

            // update all parents of changed and reorganized their children
            // in the correct order (as indicated in our model)
            forEach(parents, function (parent) {

                var childGfx = self._getChildren(parent),
                    children = parent.children;

                if (!children) {
                    return;
                }

                forEach(children.slice().reverse(), function (c) {
                    var gfx = elementRegistry.getGraphics(c);
                    gfx.parent().prependTo(childGfx);
                });
            });

        };

        GraphicsFactory.prototype.update = function (type, element, gfx) {

            // Do not update root element
            if (!element.parent) {
                return;
            }

            var visual = this._clear(gfx);

            // redraw
            if (type === 'shape') {
                this._renderer.drawShape(visual, element);

                // update positioning
                gfx.translate(element.x, element.y);
            } else if (type === 'connection') {
                this._renderer.drawConnection(visual, element);
            } else {
                throw new Error('unknown type: ' + type);
            }

            gfx.attr('display', element.hidden ? 'none' : 'block');
        };


        GraphicsFactory.prototype.remove = function (element) {
            var gfx = this._elementRegistry.getGraphics(element);

            // remove
            gfx.parent().remove();
        };

    }, {
        "../util/GraphicsUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/GraphicsUtil.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/collection/reduce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/reduce.js",
        "min-dom/lib/clear": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/clear.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../draw')],
            __init__: ['canvas'],
            canvas: ['type', require('./Canvas')],
            elementRegistry: ['type', require('./ElementRegistry')],
            elementFactory: ['type', require('./ElementFactory')],
            eventBus: ['type', require('./EventBus')],
            graphicsFactory: ['type', require('./GraphicsFactory')]
        };
    }, {
        "../draw": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/draw/index.js",
        "./Canvas": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/Canvas.js",
        "./ElementFactory": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/ElementFactory.js",
        "./ElementRegistry": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/ElementRegistry.js",
        "./EventBus": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/EventBus.js",
        "./GraphicsFactory": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/GraphicsFactory.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/draw/Renderer.js": [function (require, module, exports) {
        'use strict';

        var Snap = require('../../vendor/snapsvg');


        /**
         * The default renderer used for shapes and connections.
         *
         * @param {Styles} styles
         */
        function Renderer(styles) {
            this.CONNECTION_STYLE = styles.style(['no-fill'], {strokeWidth: 5, stroke: 'fuchsia'});
            this.SHAPE_STYLE = styles.style({fill: 'white', stroke: 'fuchsia', strokeWidth: 2});
        }

        module.exports = Renderer;

        Renderer.$inject = ['styles'];


        Renderer.prototype.drawShape = function drawShape(gfxGroup, data) {
            return gfxGroup.rect(0, 0, data.width || 0, data.height || 0).attr(this.SHAPE_STYLE);
        };

        Renderer.prototype.drawConnection = function drawConnection(gfxGroup, data) {
            return createLine(data.waypoints, this.CONNECTION_STYLE).appendTo(gfxGroup);
        };

        function componentsToPath(components) {
            return components.join(',').replace(/,?([A-z]),?/g, '$1');
        }

        /**
         * Gets the default SVG path of a shape that represents it's visual bounds.
         *
         * @param {djs.model.Shape} shape
         * @return {string} svg path
         */
        Renderer.prototype.getShapePath = function getShapePath(shape) {

            var x = shape.x,
                y = shape.y,
                width = shape.width,
                height = shape.height;

            var shapePath = [
                ['M', x, y],
                ['l', width, 0],
                ['l', 0, height],
                ['l', -width, 0],
                ['z']
            ];

            return componentsToPath(shapePath);
        };

        /**
         * Gets the default SVG path of a connection that represents it's visual bounds.
         *
         * @param {djs.model.Connection} connection
         * @return {string} svg path
         */
        Renderer.prototype.getConnectionPath = function getConnectionPath(connection) {
            var waypoints = connection.waypoints;

            var idx, point, connectionPath = [];

            for (idx = 0; !!(point = waypoints[idx]); idx++) {

                // take invisible docking into account
                // when creating the path
                point = point.original || point;

                connectionPath.push([idx === 0 ? 'M' : 'L', point.x, point.y]);
            }

            return componentsToPath(connectionPath);
        };


        function toSVGPoints(points) {
            var result = '';

            for (var i = 0, p; !!(p = points[i]); i++) {
                result += p.x + ',' + p.y + ' ';
            }

            return result;
        }

        function createLine(points, attrs) {
            return Snap.create('polyline', {points: toSVGPoints(points)}).attr(attrs || {});
        }

        function updateLine(gfx, points) {
            return gfx.attr({points: toSVGPoints(points)});
        }

        module.exports.createLine = createLine;
        module.exports.updateLine = updateLine;
    }, {"../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/draw/Styles.js": [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            assign = require('lodash/object/assign'),
            reduce = require('lodash/collection/reduce');


        /**
         * A component that manages shape styles
         */
        function Styles() {

            var defaultTraits = {

                'no-fill': {
                    fill: 'none'
                },
                'no-border': {
                    strokeOpacity: 0.0
                },
                'no-events': {
                    pointerEvents: 'none'
                }
            };

            /**
             * Builds a style definition from a className, a list of traits and an object of additional attributes.
             *
             * @param  {String} className
             * @param  {Array<String>} traits
             * @param  {Object} additionalAttrs
             *
             * @return {Object} the style defintion
             */
            this.cls = function (className, traits, additionalAttrs) {
                var attrs = this.style(traits, additionalAttrs);

                return assign(attrs, {'class': className});
            };

            /**
             * Builds a style definition from a list of traits and an object of additional attributes.
             *
             * @param  {Array<String>} traits
             * @param  {Object} additionalAttrs
             *
             * @return {Object} the style defintion
             */
            this.style = function (traits, additionalAttrs) {

                if (!isArray(traits) && !additionalAttrs) {
                    additionalAttrs = traits;
                    traits = [];
                }

                var attrs = reduce(traits, function (attrs, t) {
                    return assign(attrs, defaultTraits[t] || {});
                }, {});

                return additionalAttrs ? assign(attrs, additionalAttrs) : attrs;
            };
        }

        module.exports = Styles;
    }, {
        "lodash/collection/reduce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/reduce.js",
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/draw/index.js": [function (require, module, exports) {
        module.exports = {
            renderer: ['type', require('./Renderer')],
            styles: ['type', require('./Styles')]
        };
    }, {
        "./Renderer": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/draw/Renderer.js",
        "./Styles": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/draw/Styles.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js": [function (require, module, exports) {
        'use strict';

        var Geometry = require('../../util/Geometry'),
            Util = require('./Util');

        var MARKER_OK = 'connect-ok',
            MARKER_NOT_OK = 'connect-not-ok',
            MARKER_CONNECT_HOVER = 'connect-hover',
            MARKER_CONNECT_UPDATING = 'djs-updating';

        var COMMAND_BENDPOINT_UPDATE = 'connection.updateWaypoints',
            COMMAND_RECONNECT_START = 'connection.reconnectStart',
            COMMAND_RECONNECT_END = 'connection.reconnectEnd';

        var round = Math.round;


        /**
         * A component that implements moving of bendpoints
         */
        function BendpointMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {

            var connectionDocking;

            // optional connection docking integration
            try {
                connectionDocking = injector.get('connectionDocking');
            } catch (e) {
            }


            // API

            this.start = function (event, connection, bendpointIndex, insert) {

                var type,
                    context,
                    waypoints = connection.waypoints,
                    gfx = canvas.getGraphics(connection);

                if (!insert && bendpointIndex === 0) {
                    type = COMMAND_RECONNECT_START;
                } else if (!insert && bendpointIndex === waypoints.length - 1) {
                    type = COMMAND_RECONNECT_END;
                } else {
                    type = COMMAND_BENDPOINT_UPDATE;
                }

                context = {
                    connection: connection,
                    bendpointIndex: bendpointIndex,
                    insert: insert,
                    type: type
                };

                dragging.activate(event, 'bendpoint.move', {
                    data: {
                        connection: connection,
                        connectionGfx: gfx,
                        context: context
                    }
                });
            };


            // DRAGGING IMPLEMENTATION


            function redrawConnection(data) {
                graphicsFactory.update('connection', data.connection, data.connectionGfx);
            }

            function filterRedundantWaypoints(waypoints) {
                return waypoints.filter(function (r, idx) {
                    return !Geometry.pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r);
                });
            }

            eventBus.on('bendpoint.move.start', function (e) {

                var context = e.context,
                    connection = context.connection,
                    originalWaypoints = connection.waypoints,
                    waypoints = originalWaypoints.slice(),
                    insert = context.insert,
                    idx = context.bendpointIndex;

                context.originalWaypoints = originalWaypoints;

                if (insert) {
                    // insert placeholder for bendpoint to-be-added
                    waypoints.splice(idx, 0, null);
                }

                connection.waypoints = waypoints;

                // add dragger gfx
                context.draggerGfx = Util.addBendpoint(canvas.getLayer('overlays'));
                context.draggerGfx.addClass('djs-dragging');

                canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
            });

            eventBus.on('bendpoint.move.hover', function (e) {
                e.context.hover = e.hover;

                canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);
            });

            eventBus.on([
                'bendpoint.move.out',
                'bendpoint.move.cleanup'
            ], function (e) {

                // remove connect marker
                // if it was added
                var hover = e.context.hover;

                if (hover) {
                    canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
                    canvas.removeMarker(hover, e.context.target ? MARKER_OK : MARKER_NOT_OK);
                }
            });

            eventBus.on('bendpoint.move.move', function (e) {

                var context = e.context,
                    moveType = context.type,
                    connection = e.connection,
                    source, target;

                connection.waypoints[context.bendpointIndex] = {x: e.x, y: e.y};

                if (connectionDocking) {

                    if (context.hover) {
                        if (moveType === COMMAND_RECONNECT_START) {
                            source = context.hover;
                        }

                        if (moveType === COMMAND_RECONNECT_END) {
                            target = context.hover;
                        }
                    }

                    connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, target);
                }

                // asks whether reconnect / bendpoint move / bendpoint add
                // is allowed at the given position
                var allowed = context.allowed = rules.allowed(context.type, context);

                if (allowed) {

                    if (context.hover) {
                        canvas.removeMarker(context.hover, MARKER_NOT_OK);
                        canvas.addMarker(context.hover, MARKER_OK);

                        context.target = context.hover;
                    }
                } else if (allowed === false) {
                    if (context.hover) {
                        canvas.removeMarker(context.hover, MARKER_OK);
                        canvas.addMarker(context.hover, MARKER_NOT_OK);

                        context.target = null;
                    }
                }

                // add dragger gfx
                context.draggerGfx.translate(e.x, e.y);

                redrawConnection(e);
            });

            eventBus.on([
                'bendpoint.move.end',
                'bendpoint.move.cancel'
            ], function (e) {

                var context = e.context,
                    connection = context.connection;

                // remove dragger gfx
                context.draggerGfx.remove();

                context.newWaypoints = connection.waypoints.slice();

                connection.waypoints = context.originalWaypoints;

                canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
            });

            eventBus.on('bendpoint.move.end', function (e) {

                var context = e.context,
                    waypoints = context.newWaypoints,
                    bendpointIndex = context.bendpointIndex,
                    bendpoint = waypoints[bendpointIndex],
                    allowed = context.allowed;

                // ensure we have actual pixel values bendpoint
                // coordinates (important when zoom level was > 1 during move)
                bendpoint.x = round(bendpoint.x);
                bendpoint.y = round(bendpoint.y);

                if (allowed === true && context.type === COMMAND_RECONNECT_START) {
                    modeling.reconnectStart(context.connection, context.target, bendpoint);
                } else if (allowed === true && context.type === COMMAND_RECONNECT_END) {
                    modeling.reconnectEnd(context.connection, context.target, bendpoint);
                } else if (allowed !== false && context.type === COMMAND_BENDPOINT_UPDATE) {
                    modeling.updateWaypoints(context.connection, filterRedundantWaypoints(waypoints));
                } else {
                    redrawConnection(e);

                    return false;
                }
            });

            eventBus.on('bendpoint.move.cancel', function (e) {
                redrawConnection(e);
            });
        }

        BendpointMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'rules', 'modeling'];

        module.exports = BendpointMove;
    }, {
        "../../util/Geometry": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Geometry.js",
        "./Util": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/Util.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            pick = require('lodash/object/pick'),
            forEach = require('lodash/collection/forEach');

        var Snap = require('../../../vendor/snapsvg');

        var round = Math.round;


        function BendpointSnapping(eventBus) {

            function snapTo(candidates, point) {
                return Snap.snapTo(candidates, point);
            }

            function toPoint(e) {
                return pick(e, ['x', 'y']);
            }

            function mid(element) {
                if (element.width) {
                    return {
                        x: round(element.width / 2 + element.x),
                        y: round(element.height / 2 + element.y)
                    };
                }
            }

            function getSnapPoints(context) {

                var snapPoints = context.snapPoints,
                    waypoints = context.connection.waypoints,
                    bendpointIndex = context.bendpointIndex,
                    referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];

                if (!snapPoints) {
                    context.snapPoints = snapPoints = {horizontal: [], vertical: []};

                    forEach(referenceWaypoints, function (p) {
                        // we snap on existing bendpoints only,
                        // not placeholders that are inserted during add
                        if (p) {
                            p = p.original || p;

                            snapPoints.horizontal.push(p.y);
                            snapPoints.vertical.push(p.x);
                        }
                    });
                }

                return snapPoints;
            }

            eventBus.on('bendpoint.move.start', function (event) {
                event.context.snapStart = toPoint(event);
            });

            eventBus.on('bendpoint.move.move', 1500, function (event) {

                var context = event.context,
                    snapPoints = getSnapPoints(context),
                    start = context.snapStart,
                    target = context.target,
                    targetMid = target && mid(target),
                    x = start.x + event.dx,
                    y = start.y + event.dy,
                    sx, sy;

                if (!snapPoints) {
                    return;
                }

                // snap
                sx = snapTo(targetMid ? snapPoints.vertical.concat([targetMid.x]) : snapPoints.vertical, x);
                sy = snapTo(targetMid ? snapPoints.horizontal.concat([targetMid.y]) : snapPoints.horizontal, y);


                // correction x/y
                var cx = (x - sx),
                    cy = (y - sy);

                // update delta
                assign(event, {
                    dx: event.dx - cx,
                    dy: event.dy - cy,
                    x: event.x - cx,
                    y: event.y - cy
                });
            });
        }


        BendpointSnapping.$inject = ['eventBus'];

        module.exports = BendpointSnapping;
    }, {
        "../../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "lodash/object/pick": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/pick.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js": [function (require, module, exports) {
        'use strict';

        var domEvent = require('min-dom/lib/event'),
            Util = require('./Util');

        var BENDPOINT_CLS = Util.BENDPOINT_CLS;


        /**
         * A service that adds editable bendpoints to connections.
         */
        function Bendpoints(injector, eventBus, canvas, interactionEvents, bendpointMove) {

            function getConnectionIntersection(waypoints, event) {
                var localPosition = Util.toCanvasCoordinates(canvas, event);
                return Util.getApproxIntersection(waypoints, localPosition);
            }

            function activateBendpointMove(event, connection) {
                var waypoints = connection.waypoints,
                    intersection = getConnectionIntersection(waypoints, event);

                if (!intersection) {
                    return;
                }

                bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);
            }

            function getBendpointsContainer(element, create) {

                var layer = canvas.getLayer('overlays'),
                    gfx = layer.select('.djs-bendpoints[data-element-id=' + element.id + ']');

                if (!gfx && create) {
                    gfx = layer.group().addClass('djs-bendpoints').attr('data-element-id', element.id);

                    domEvent.bind(gfx.node, 'mousedown', function (event) {
                        activateBendpointMove(event, element);
                    });
                }

                return gfx;
            }

            function createBendpoints(gfx, connection) {
                connection.waypoints.forEach(function (p, idx) {
                    Util.addBendpoint(gfx).translate(p.x, p.y);
                });

                // add floating bendpoint
                Util.addBendpoint(gfx).addClass('floating');
            }

            function clearBendpoints(gfx) {
                gfx.selectAll('.' + BENDPOINT_CLS).forEach(function (s) {
                    s.remove();
                });
            }

            function addBendpoints(connection) {
                var gfx = getBendpointsContainer(connection);

                if (!gfx) {
                    gfx = getBendpointsContainer(connection, true);
                    createBendpoints(gfx, connection);
                }

                return gfx;
            }

            function updateBendpoints(connection) {

                var gfx = getBendpointsContainer(connection);

                if (gfx) {
                    clearBendpoints(gfx);
                    createBendpoints(gfx, connection);
                }
            }

            eventBus.on('connection.changed', function (event) {
                updateBendpoints(event.element);
            });

            eventBus.on('connection.remove', function (event) {
                var gfx = getBendpointsContainer(event.element);
                if (gfx) {
                    gfx.remove();
                }
            });

            eventBus.on('element.marker.update', function (event) {

                var element = event.element,
                    bendpointsGfx;

                if (!element.waypoints) {
                    return;
                }

                bendpointsGfx = addBendpoints(element);
                bendpointsGfx[event.add ? 'addClass' : 'removeClass'](event.marker);
            });

            eventBus.on('element.mousemove', function (event) {

                var element = event.element,
                    waypoints = element.waypoints,
                    bendpointsGfx,
                    floating,
                    intersection;

                if (waypoints) {

                    bendpointsGfx = getBendpointsContainer(element, true);
                    floating = bendpointsGfx.select('.floating');

                    if (!floating) {
                        return;
                    }

                    intersection = getConnectionIntersection(waypoints, event.originalEvent);

                    if (intersection) {
                        floating.translate(intersection.point.x, intersection.point.y);
                    }
                }
            });

            eventBus.on('element.mousedown', function (event) {

                var originalEvent = event.originalEvent,
                    element = event.element,
                    waypoints = element.waypoints;

                if (!waypoints) {
                    return;
                }

                activateBendpointMove(originalEvent, element, waypoints);
            });

            eventBus.on('selection.changed', function (event) {
                var newSelection = event.newSelection,
                    primary = newSelection[0];

                if (primary && primary.waypoints) {
                    addBendpoints(primary);
                }
            });

            eventBus.on('element.hover', function (event) {
                var element = event.element;

                if (element.waypoints) {
                    addBendpoints(element);

                    interactionEvents.registerEvent(event.gfx.node, 'mousemove', 'element.mousemove');
                }
            });

            eventBus.on('element.out', function (event) {
                interactionEvents.unregisterEvent(event.gfx.node, 'mousemove', 'element.mousemove');
            });
        }

        Bendpoints.$inject = ['injector', 'eventBus', 'canvas', 'interactionEvents', 'bendpointMove'];

        module.exports = Bendpoints;
    }, {
        "./Util": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/Util.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/Util.js": [function (require, module, exports) {
        'use strict';

        var Snap = require('../../../vendor/snapsvg');

        var Events = require('../../util/Event'),
            Geometry = require('../../util/Geometry');

        var BENDPOINT_CLS = module.exports.BENDPOINT_CLS = 'djs-bendpoint';

        module.exports.toCanvasCoordinates = function (canvas, event) {

            var position = Events.toPoint(event),
                clientRect = canvas._container.getBoundingClientRect(),
                offset;

            // canvas relative position

            offset = {
                x: clientRect.left,
                y: clientRect.top
            };

            // update actual event payload with canvas relative measures

            var viewbox = canvas.viewbox();

            return {
                x: viewbox.x + (position.x - offset.x) / viewbox.scale,
                y: viewbox.y + (position.y - offset.y) / viewbox.scale
            };
        };

        module.exports.addBendpoint = function (parentGfx) {
            var groupGfx = parentGfx.group().addClass(BENDPOINT_CLS);

            groupGfx.circle(0, 0, 4).addClass('djs-visual');
            groupGfx.circle(0, 0, 10).addClass('djs-hit');

            return groupGfx;
        };


        function circlePath(center, r) {
            var x = center.x,
                y = center.y;

            return [
                ['M', x, y],
                ['m', 0, -r],
                ['a', r, r, 0, 1, 1, 0, 2 * r],
                ['a', r, r, 0, 1, 1, 0, -2 * r],
                ['z']
            ];
        }

        function linePath(points) {
            var segments = [];

            points.forEach(function (p, idx) {
                segments.push([idx === 0 ? 'M' : 'L', p.x, p.y]);
            });

            return segments;
        }


        var INTERSECTION_THRESHOLD = 10;

        function getBendpointIntersection(waypoints, reference) {

            var i, w;

            for (i = 0; !!(w = waypoints[i]); i++) {

                if (Geometry.distance(w, reference) <= INTERSECTION_THRESHOLD) {
                    return {
                        point: waypoints[i],
                        bendpoint: true,
                        index: i
                    };
                }
            }

            return null;
        }

        function getPathIntersection(waypoints, reference) {

            var intersections = Snap.path.intersection(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));

            var a = intersections[0],
                b = intersections[intersections.length - 1],
                idx;

            if (!a) {
                // no intersection
                return null;
            }

            if (a !== b) {

                if (a.segment2 !== b.segment2) {
                    // we use the bendpoint in between both segments
                    // as the intersection point

                    idx = Math.max(a.segment2, b.segment2) - 1;

                    return {
                        point: waypoints[idx],
                        bendpoint: true,
                        index: idx
                    };
                }

                return {
                    point: {
                        x: (Math.round(a.x + b.x) / 2),
                        y: (Math.round(a.y + b.y) / 2)
                    },
                    index: a.segment2
                };
            }

            return {
                point: {
                    x: Math.round(a.x),
                    y: Math.round(a.y)
                },
                index: a.segment2
            };
        }

        /**
         * Returns the closest point on the connection towards a given reference point.
         *
         * @param  {Array<Point>} waypoints
         * @param  {Point} reference
         *
         * @return {Object} intersection data (segment, point)
         */
        module.exports.getApproxIntersection = function (waypoints, reference) {
            return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
        };
    }, {
        "../../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "../../util/Event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Event.js",
        "../../util/Geometry": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Geometry.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../dragging'), require('../rules')],
            __init__: ['bendpoints', 'bendpointSnapping'],
            bendpoints: ['type', require('./Bendpoints')],
            bendpointMove: ['type', require('./BendpointMove')],
            bendpointSnapping: ['type', require('./BendpointSnapping')]
        };
    }, {
        "../dragging": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/dragging/index.js",
        "../rules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/index.js",
        "./BendpointMove": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js",
        "./BendpointSnapping": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js",
        "./Bendpoints": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/change-support/ChangeSupport.js": [function (require, module, exports) {
        'use strict';

        /**
         * Adds change support to the diagram, including
         *
         * <ul>
         *   <li>redrawing shapes and connections on change</li>
         * </ul>
         *
         * @param {EventBus} eventBus
         * @param {ElementRegistry} elementRegistry
         * @param {GraphicsFactory} graphicsFactory
         */
        function ChangeSupport(eventBus, elementRegistry, graphicsFactory) {

            // redraw shapes / connections on change

            eventBus.on('element.changed', function (event) {

                var element = event.element;

                if (!event.gfx) {
                    event.gfx = elementRegistry.getGraphics(element);
                }

                // shape + gfx may have been deleted
                if (!event.gfx) {
                    return;
                }

                if (element.waypoints) {
                    eventBus.fire('connection.changed', event);
                } else {
                    eventBus.fire('shape.changed', event);
                }
            });

            eventBus.on('elements.changed', function (event) {

                var elements = event.elements;

                elements.forEach(function (e) {
                    eventBus.fire('element.changed', {element: e});
                });

                graphicsFactory.updateContainments(elements);
            });

            eventBus.on('shape.changed', function (event) {
                graphicsFactory.update('shape', event.element, event.gfx);
            });

            eventBus.on('connection.changed', function (event) {
                graphicsFactory.update('connection', event.element, event.gfx);
            });
        }

        ChangeSupport.$inject = ['eventBus', 'elementRegistry', 'graphicsFactory'];

        module.exports = ChangeSupport;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/change-support/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['changeSupport'],
            changeSupport: ['type', require('./ChangeSupport')]
        };
    }, {"./ChangeSupport": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/change-support/ChangeSupport.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/connect/Connect.js": [function (require, module, exports) {
        'use strict';

        var LayoutUtil = require('../../layout/LayoutUtil');

        var MARKER_OK = 'connect-ok',
            MARKER_NOT_OK = 'connect-not-ok';


        function Connect(eventBus, dragging, modeling, rules, canvas, renderer) {

            // TODO(nre): separate UI and events

            // rules

            function canConnect(source, target) {
                return rules.allowed('connection.create', {
                    source: source,
                    target: target
                });
            }


            // layouting

            function crop(start, end, source, target) {

                var sourcePath = renderer.getShapePath(source),
                    targetPath = target && renderer.getShapePath(target),
                    connectionPath = renderer.getConnectionPath({waypoints: [start, end]});

                start = LayoutUtil.getElementLineIntersection(sourcePath, connectionPath, true) || start;
                end = (target && LayoutUtil.getElementLineIntersection(targetPath, connectionPath, false)) || end;

                return [start, end];
            }


            // event handlers

            eventBus.on('connect.move', function (event) {

                var context = event.context,
                    source = context.source,
                    target = context.target,
                    visual = context.visual,
                    start, end, waypoints;

                // update connection visuals during drag

                start = LayoutUtil.getMidPoint(source);

                end = {
                    x: event.x,
                    y: event.y
                };

                waypoints = crop(start, end, source, target);

                visual.attr('points', [waypoints[0].x, waypoints[0].y, waypoints[1].x, waypoints[1].y]);
            });

            eventBus.on('connect.hover', function (event) {
                var context = event.context,
                    source = context.source,
                    hover = event.hover,
                    canExecute;

                canExecute = context.canExecute = canConnect(source, hover);

                // simply ignore hover
                if (canExecute === null) {
                    return;
                }

                context.target = hover;

                canvas.addMarker(hover, canExecute ? MARKER_OK : MARKER_NOT_OK);
            });

            eventBus.on(['connect.out', 'connect.cleanup'], function (event) {
                var context = event.context;

                if (context.target) {
                    canvas.removeMarker(context.target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
                }

                context.target = null;
            });

            eventBus.on('connect.cleanup', function (event) {
                var context = event.context;

                if (context.visual) {
                    context.visual.remove();
                }
            });

            eventBus.on('connect.start', function (event) {
                var context = event.context,
                    visual;

                visual = canvas.getDefaultLayer().polyline().attr({
                    'stroke': '#333',
                    'strokeDasharray': [1],
                    'strokeWidth': 2,
                    'pointer-events': 'none'
                });

                context.visual = visual;
            });

            eventBus.on('connect.end', function (event) {

                var context = event.context,
                    source = context.source,
                    target = context.target,
                    canExecute = context.canExecute || canConnect(source, target);

                if (!canExecute) {
                    return false;
                }

                modeling.connect(source, target);
            });


            // API

            this.start = function (event, source, autoActivate) {

                dragging.activate(event, 'connect', {
                    autoActivate: autoActivate,
                    data: {
                        shape: source,
                        context: {
                            source: source
                        }
                    }
                });
            };
        }

        Connect.$inject = ['eventBus', 'dragging', 'modeling', 'rules', 'canvas', 'renderer'];

        module.exports = Connect;
    }, {"../../layout/LayoutUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/LayoutUtil.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/connect/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../selection'),
                require('../rules'),
                require('../dragging')
            ],
            connect: ['type', require('./Connect')]
        };

    }, {
        "../dragging": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/dragging/index.js",
        "../rules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/index.js",
        "../selection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/index.js",
        "./Connect": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/connect/Connect.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/context-pad/ContextPad.js": [function (require, module, exports) {
        'use strict';

        var isFunction = require('lodash/lang/isFunction'),
            forEach = require('lodash/collection/forEach'),

            domDelegate = require('min-dom/lib/delegate'),
            domClear = require('min-dom/lib/clear'),
            domEvent = require('min-dom/lib/event'),
            domAttr = require('min-dom/lib/attr'),
            domQuery = require('min-dom/lib/query'),
            domClasses = require('min-dom/lib/classes'),
            domify = require('min-dom/lib/domify');


        var entrySelector = '.entry';


        /**
         * A context pad that displays element specific, contextual actions next
         * to a diagram element.
         *
         * @param {EventBus} eventBus
         * @param {Overlays} overlays
         */
        function ContextPad(eventBus, overlays) {

            this._providers = [];

            this._eventBus = eventBus;
            this._overlays = overlays;

            this._current = null;

            this._init();
        }

        ContextPad.$inject = ['eventBus', 'overlays'];

        /**
         * Registers events needed for interaction with other components
         */
        ContextPad.prototype._init = function () {

            var eventBus = this._eventBus;

            var self = this;

            eventBus.on('selection.changed', function (e) {

                var selection = e.newSelection;

                if (selection.length === 1) {
                    self.open(selection[0]);
                } else {
                    self.close();
                }
            });
        };


        /**
         * Register a provider with the context pad
         *
         * @param  {ContextPadProvider} provider
         */
        ContextPad.prototype.registerProvider = function (provider) {
            this._providers.push(provider);
        };


        /**
         * Returns the context pad entries for a given element
         *
         * @param {djs.element.Base} element
         *
         * @return {Array<ContextPadEntryDescriptor>} list of entries
         */
        ContextPad.prototype.getEntries = function (element) {
            var entries = {};

            // loop through all providers and their entries.
            // group entries by id so that overriding an entry is possible
            forEach(this._providers, function (provider) {
                var e = provider.getContextPadEntries(element);

                forEach(e, function (entry, id) {
                    entries[id] = entry;
                });
            });

            return entries;
        };


        /**
         * Trigger an action available on the opened context pad
         *
         * @param  {String} action
         * @param  {Event} event
         */
        ContextPad.prototype.trigger = function (action, event, autoActivate) {

            var current = this._current,
                element = current.element,
                entries = current.entries,
                entry,
                handler,
                originalEvent,
                button = event.delegateTarget || event.target;

            if (!button) {
                return event.preventDefault();
            }

            entry = entries[domAttr(button, 'data-action')];
            handler = entry.action;

            originalEvent = event.originalEvent || event;

            // simple action (via callback function)
            if (isFunction(handler)) {
                if (action === 'click') {
                    return handler(originalEvent, element, autoActivate);
                }
            } else {
                if (handler[action]) {
                    return handler[action](originalEvent, element, autoActivate);
                }
            }

            // silence other actions
            event.preventDefault();
        };


        /**
         * Open the context pad for the given element
         *
         * @param {djs.model.Base} element
         */
        ContextPad.prototype.open = function (element) {

            if (this._current && this._current.open) {

                if (this._current.element === element) {
                    // no change needed
                    return;
                }

                this.close();
            }

            this._updateAndOpen(element);
        };


        ContextPad.prototype._updateAndOpen = function (element) {

            var entries = this.getEntries(element),
                pad = this.getPad(element),
                html = pad.html;

            domClear(html);

            forEach(entries, function (entry, id) {
                var grouping = entry.group || 'default',
                    control = domify(entry.html || '<div class="entry" draggable="true"></div>'),
                    container;

                domAttr(control, 'data-action', id);

                container = domQuery('[data-group=' + grouping + ']', html);
                if (!container) {
                    container = domify('<div class="group" data-group="' + grouping + '"></div>');
                    html.appendChild(container);
                }

                container.appendChild(control);

                if (entry.className) {
                    domClasses(control).add(entry.className);
                }

                if (entry.title) {
                    domAttr(control, 'title', entry.title);
                }

                if (entry.imageUrl) {
                    control.appendChild(domify('<img src="' + entry.imageUrl + '">'));
                }
            });

            domClasses(html).add('open');

            this._current = {
                element: element,
                pad: pad,
                entries: entries,
                open: true
            };

            this._eventBus.fire('contextPad.open', {current: this._current});
        };

        ContextPad.prototype.getPad = function (element) {

            var self = this;

            var overlays = this._overlays,
                pads = overlays.get({element: element, type: 'context-pad'});

            // create context pad on demand if needed
            if (!pads.length) {

                var html = domify('<div class="djs-context-pad"></div>');

                domDelegate.bind(html, entrySelector, 'click', function (event) {
                    self.trigger('click', event);
                });

                domDelegate.bind(html, entrySelector, 'dragstart', function (event) {
                    self.trigger('dragstart', event);
                });

                // stop propagation of mouse events
                domEvent.bind(html, 'mousedown', function (event) {
                    event.stopPropagation();
                });

                overlays.add(element, 'context-pad', {
                    position: {
                        right: -9,
                        top: -6
                    },
                    html: html
                });

                pads = overlays.get({element: element, type: 'context-pad'});

                this._eventBus.fire('contextPad.create', {element: element, pad: pads[0]});
            }

            return pads[0];
        };


        /**
         * Close the context pad
         */
        ContextPad.prototype.close = function () {

            var html;

            if (this._current) {
                if (this._current.open) {
                    html = this._current.pad.html;
                    domClasses(html).remove('open');
                }

                this._current.open = false;

                this._eventBus.fire('contextPad.close', {current: this._current});
            }
        };


        /**
         * Return the element the context pad is currently opened for,
         * if it is opened.
         *
         * @example
         *
         * contextPad.open(shape1);
         *
         * if (contextPad.isOpen()) {
 *   // yes, we are open
 * }
         *
         * @return {djs.model.Base} element
         */
        ContextPad.prototype.isOpen = function () {
            return this._current && this._current.open;
        };

        module.exports = ContextPad;

    }, {
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/lang/isFunction": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isFunction.js",
        "min-dom/lib/attr": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/attr.js",
        "min-dom/lib/classes": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/classes.js",
        "min-dom/lib/clear": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/clear.js",
        "min-dom/lib/delegate": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/delegate.js",
        "min-dom/lib/domify": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/domify.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js",
        "min-dom/lib/query": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/query.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/context-pad/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../interaction-events'),
                require('../overlays')
            ],
            contextPad: ['type', require('./ContextPad')]
        };
    }, {
        "../interaction-events": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/interaction-events/index.js",
        "../overlays": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/overlays/index.js",
        "./ContextPad": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/context-pad/ContextPad.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/create/Create.js": [function (require, module, exports) {
        'use strict';

        var MARKER_OK = 'drop-ok',
            MARKER_NOT_OK = 'drop-not-ok';


        function Create(eventBus, dragging, rules, modeling, canvas, elementFactory, renderer, styles) {

            // rules

            function canCreate(shape, target, source) {

                if (source) {
                    return rules.allowed('shape.append', {
                        source: source,
                        shape: shape,
                        parent: target
                    });
                } else {
                    return rules.allowed('shape.create', {
                        shape: shape,
                        parent: target
                    });
                }
            }


            // visual helpers

            function createVisual(shape) {
                var group, preview, visual;

                group = canvas.getDefaultLayer().group().attr(styles.cls('djs-drag-group', ['no-events']));

                preview = group.group().addClass('djs-dragger');

                preview.translate(shape.width / -2, shape.height / -2);

                visual = preview.group().addClass('djs-visual');

                // hijack renderer to draw preview
                renderer.drawShape(visual, shape);

                return group;
            }


            // event handlers

            eventBus.on('create.move', function (event) {

                var context = event.context,
                    shape = context.shape,
                    visual = context.visual;

                // lazy init drag visual once we received the first real
                // drag move event (this allows us to get the proper canvas local coordinates)
                if (!visual) {
                    visual = context.visual = createVisual(shape);
                }

                visual.translate(event.x, event.y);

                var hover = event.hover,
                    canExecute;

                canExecute = context.canExecute = hover && canCreate(context.shape, hover, context.source);

                // ignore hover visually if canExecute is null
                if (hover && canExecute !== null) {
                    context.target = hover;
                    canvas.addMarker(hover, canExecute ? MARKER_OK : MARKER_NOT_OK);
                }
            });

            eventBus.on(['create.end', 'create.out', 'create.cleanup'], function (event) {
                var context = event.context;

                if (context.target) {
                    canvas.removeMarker(context.target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
                }
            });

            eventBus.on('create.end', function (event) {
                var context = event.context,
                    source = context.source,
                    shape = context.shape,
                    target = context.target,
                    canExecute = context.canExecute,
                    position = {
                        x: event.x,
                        y: event.y
                    };

                if (!canExecute) {
                    return false;
                }

                if (source) {
                    modeling.appendShape(source, shape, position, target);
                } else {
                    modeling.createShape(shape, position, target);
                }
            });


            eventBus.on('create.cleanup', function (event) {
                var context = event.context;

                if (context.visual) {
                    context.visual.remove();
                }
            });

            // API

            this.start = function (event, shape, source) {

                dragging.activate(event, 'create', {
                    cursor: 'grabbing',
                    autoActivate: true,
                    data: {
                        shape: shape,
                        context: {
                            shape: shape,
                            source: source
                        }
                    }
                });
            };
        }

        Create.$inject = ['eventBus', 'dragging', 'rules', 'modeling', 'canvas', 'elementFactory', 'renderer', 'styles'];

        module.exports = Create;
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/create/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../dragging'),
                require('../selection')
            ],
            create: ['type', require('./Create')]
        };
    }, {
        "../dragging": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/dragging/index.js",
        "../selection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/index.js",
        "./Create": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/create/Create.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/dragging/Dragging.js": [function (require, module, exports) {
        'use strict';

        /* global TouchEvent */

        var assign = require('lodash/object/assign');

        var domEvent = require('min-dom/lib/event'),
            Event = require('../../util/Event'),
            ClickTrap = require('../../util/ClickTrap'),
            Cursor = require('../../util/Cursor');

        function suppressEvent(event) {
            if (event instanceof MouseEvent) {
                Event.stopEvent(event, true);
            } else {
                Event.preventDefault(event);
            }
        }

        function getLength(point) {
            return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        }

        function substract(p1, p2) {
            return {
                x: p1.x - p2.x,
                y: p1.y - p2.y
            };
        }

        /**
         * A helper that fires canvas localized drag events and realizes
         * the general "drag-and-drop" look and feel.
         *
         * Calling {@link Dragging#activate} activates dragging on a canvas.
         *
         * It provides the following:
         *
         *   * emits the events `start`, `move`, `end`, `cancel` and `cleanup` via the {@link EventBus}.
         *     Each of the events is prefixed with a prefix that is assigned during activate.
         *   * sets and restores the cursor
         *   * sets and restores the selection
         *   * ensures there can be only one drag operation active at a time
         *
         * Dragging may be canceled manually by calling {@link Dragging#cancel} or by pressing ESC.
         *
         * @example
         *
         * function MyDragComponent(eventBus, dragging) {
 *
 *   eventBus.on('mydrag.start', function(event) {
 *     console.log('yes, we start dragging');
 *   });
 *
 *   eventBus.on('mydrag.move', function(event) {
 *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);
 *
 *     // local drag data is passed with the event
 *     event.context.foo; // "BAR"
 *
 *     // the original mouse event, too
 *     event.originalEvent; // MouseEvent(...)
 *   });
 *
 *   eventBus.on('element.click', function(event) {
 *     dragging.activate(event, 'mydrag', {
 *       cursor: 'grabbing',
 *       data: {
 *         context: {
 *           foo: "BAR"
 *         }
 *       }
 *     });
 *   });
 * }
         */
        function Dragging(eventBus, canvas, selection) {

            var defaultOptions = {
                threshold: 5
            };

            // the currently active drag operation
            // dragging is active as soon as this context exists.
            //
            // it is visually _active_ only when a context.active flag is set to true.
            var context;


            // helpers

            function fire(type) {

                var ActualEvent = require('../../core/EventBus').Event;

                var event = assign(new ActualEvent(), context.payload, context.data);

                // default integration
                if (eventBus.fire('drag.' + type, event) === false) {
                    return false;
                }

                return eventBus.fire(context.prefix + '.' + type, event);
            }

            // event listeners

            function move(event, activate) {

                var payload = context.payload,
                    start = context.start,
                    position = Event.toPoint(event),
                    delta = substract(position, start),
                    clientRect = canvas._container.getBoundingClientRect(),
                    offset;

                // canvas relative position

                offset = {
                    x: clientRect.left,
                    y: clientRect.top
                };

                // update actual event payload with canvas relative measures

                var viewbox = canvas.viewbox();

                var movement = {
                    x: viewbox.x + (position.x - offset.x) / viewbox.scale,
                    y: viewbox.y + (position.y - offset.y) / viewbox.scale,
                    dx: delta.x / viewbox.scale,
                    dy: delta.y / viewbox.scale
                };

                // activate context explicitly or once threshold is reached

                if (!context.active && (activate || getLength(delta) > context.threshold)) {

                    // fire start event with original
                    // starting coordinates

                    assign(payload, {
                        x: movement.x - movement.dx,
                        y: movement.y - movement.dy,
                        dx: 0,
                        dy: 0
                    }, {originalEvent: event});

                    if (false === fire('start')) {
                        return cancel();
                    }

                    context.active = true;

                    // unset selection
                    if (!context.keepSelection) {
                        context.previousSelection = selection.get();
                        selection.select(null);
                    }

                    // allow custom cursor
                    if (context.cursor) {
                        Cursor.set(context.cursor);
                    }
                }

                suppressEvent(event);

                if (context.active) {

                    // fire move event with actual coordinates
                    assign(payload, movement, {originalEvent: event});

                    fire('move');
                }
            }

            function end(event) {

                var returnValue = true;

                if (context.active) {

                    if (event) {
                        context.payload.originalEvent = event;

                        // suppress original event (click, ...)
                        // because we just ended a drag operation
                        suppressEvent(event);
                    }

                    // implementations may stop restoring the
                    // original state (selections, ...) by preventing the
                    // end events default action
                    returnValue = fire('end');
                }

                if (returnValue === false) {
                    fire('rejected');
                }

                cleanup(returnValue !== true);
            }


            // cancel active drag operation if the user presses
            // the ESC key on the keyboard

            function checkCancel(event) {

                if (event.which === 27) {
                    event.preventDefault();

                    cancel();
                }
            }


            // prevent ghost click that might occur after a finished
            // drag and drop session

            function trapClickAndEnd(event) {

                var untrap;

                // trap the click in case we are part of an active
                // drag operation. This will effectively prevent
                // the ghost click that cannot be canceled otherwise.
                if (context.active) {
                    untrap = ClickTrap.install();
                    setTimeout(untrap, 400);
                }

                end(event);
            }

            function trapTouch(event) {
                move(event);
            }

            // update the drag events hover (djs.model.Base) and hoverGfx (Snap<SVGElement>)
            // properties during hover and out and fire {prefix}.hover and {prefix}.out properties
            // respectively

            function hover(event) {
                var payload = context.payload;

                payload.hoverGfx = event.gfx;
                payload.hover = event.element;

                fire('hover');
            }

            function out(event) {
                fire('out');

                var payload = context.payload;

                payload.hoverGfx = null;
                payload.hover = null;
            }


            // life-cycle methods

            function cancel(restore) {

                if (!context) {
                    return;
                }

                if (context.active) {
                    fire('cancel');
                }

                cleanup(restore);
            }

            function cleanup(restore) {

                fire('cleanup');

                // reset cursor
                Cursor.unset();

                // reset dom listeners
                domEvent.unbind(document, 'mousemove', move);

                domEvent.unbind(document, 'mousedown', trapClickAndEnd, true);
                domEvent.unbind(document, 'mouseup', trapClickAndEnd, true);

                domEvent.unbind(document, 'keyup', checkCancel);

                domEvent.unbind(document, 'touchstart', trapTouch, true);
                domEvent.unbind(document, 'touchcancel', cancel, true);
                domEvent.unbind(document, 'touchmove', move, true);
                domEvent.unbind(document, 'touchend', end, true);

                eventBus.off('element.hover', hover);
                eventBus.off('element.out', out);

                // restore selection, unless it has changed
                if (restore !== false && context.previousSelection && !selection.get().length) {
                    selection.select(context.previousSelection);
                }

                context = null;
            }

            /**
             * Activate a drag operation
             *
             * @param  {MouseEvent|TouchEvent} [event]
             * @param  {String} prefix
             * @param  {Object} [options]
             */
            function activate(event, prefix, options) {

                // only one drag operation may be active, at a time
                if (context) {
                    cancel(false);
                }

                options = assign({}, defaultOptions, options || {});

                var data = options.data || {},
                    originalEvent,
                    start;

                if (event) {
                    originalEvent = Event.getOriginal(event) || event;
                    start = Event.toPoint(event);

                    suppressEvent(event);
                } else {
                    originalEvent = null;
                    start = {x: 0, y: 0};
                }

                context = assign({
                    prefix: prefix,
                    data: data,
                    payload: {},
                    start: start
                }, options);

                // skip dom registration if trigger
                // is set to manual (during testing)
                if (!options.manual) {

                    // add dom listeners

                    // fixes TouchEvent not being available on desktop Firefox
                    if (typeof TouchEvent !== 'undefined' && originalEvent instanceof TouchEvent) {
                        domEvent.bind(document, 'touchstart', trapTouch, true);
                        domEvent.bind(document, 'touchcancel', cancel, true);
                        domEvent.bind(document, 'touchmove', move, true);
                        domEvent.bind(document, 'touchend', end, true);
                    } else {
                        // assume we use the mouse to interact per default
                        domEvent.bind(document, 'mousemove', move);

                        domEvent.bind(document, 'mousedown', trapClickAndEnd, true);
                        domEvent.bind(document, 'mouseup', trapClickAndEnd, true);
                    }

                    domEvent.bind(document, 'keyup', checkCancel);

                    eventBus.on('element.hover', hover);
                    eventBus.on('element.out', out);
                }

                fire('activate');

                if (options.autoActivate) {
                    move(event, true);
                }
            }

            // cancel on diagram destruction
            eventBus.on('diagram.destroy', cancel);


            // API

            this.activate = activate;
            this.move = move;
            this.hover = hover;
            this.out = out;
            this.end = end;

            this.cancel = cancel;

            // for introspection

            this.active = function () {
                return context;
            };

            this.setOptions = function (options) {
                assign(defaultOptions, options);
            };
        }

        Dragging.$inject = ['eventBus', 'canvas', 'selection'];

        module.exports = Dragging;
    }, {
        "../../core/EventBus": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/core/EventBus.js",
        "../../util/ClickTrap": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/ClickTrap.js",
        "../../util/Cursor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Cursor.js",
        "../../util/Event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Event.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/dragging/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../selection')
            ],
            dragging: ['type', require('./Dragging')]
        };
    }, {
        "../selection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/index.js",
        "./Dragging": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/dragging/Dragging.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            domDelegate = require('min-dom/lib/delegate'),
            Renderer = require('../../draw/Renderer'),
            createLine = Renderer.createLine,
            updateLine = Renderer.updateLine;


        var isPrimaryButton = require('../../util/Mouse').isPrimaryButton;

        var Snap = require('../../../vendor/snapsvg');

        /**
         * A plugin that provides interaction events for diagram elements.
         *
         * It emits the following events:
         *
         *   * element.hover
         *   * element.out
         *   * element.click
         *   * element.dblclick
         *   * element.mousedown
         *
         * Each event is a tuple { element, gfx, originalEvent }.
         *
         * Canceling the event via Event#preventDefault() prevents the original DOM operation.
         *
         * @param {EventBus} eventBus
         */
        function InteractionEvents(eventBus, elementRegistry, styles) {

            var HIT_STYLE = styles.cls('djs-hit', ['no-fill', 'no-border'], {
                stroke: 'white',
                strokeWidth: 15
            });

            function fire(type, event) {
                var target = event.delegateTarget || event.target,
                    gfx = target && new Snap(target),
                    element = elementRegistry.get(gfx),
                    returnValue;

                if (!gfx || !element) {
                    return;
                }

                returnValue = eventBus.fire(type, {element: element, gfx: gfx, originalEvent: event});

                if (returnValue === false) {
                    event.stopPropagation();
                    event.preventDefault();
                }
            }

            var handlers = {};

            function mouseHandler(type) {

                var fn = handlers[type];

                if (!fn) {
                    fn = handlers[type] = function (event) {
                        // only indicate left mouse button interactions
                        if (isPrimaryButton(event)) {
                            fire(type, event);
                        }
                    };
                }

                return fn;
            }

            var bindings = {
                mouseover: 'element.hover',
                mouseout: 'element.out',
                click: 'element.click',
                dblclick: 'element.dblclick',
                mousedown: 'element.mousedown',
                mouseup: 'element.mouseup'
            };

            var elementSelector = 'svg, .djs-element';

            ///// event registration

            function registerEvent(node, event, localEvent) {
                var handler = mouseHandler(localEvent);
                handler.$delegate = domDelegate.bind(node, elementSelector, event, handler);
            }

            function unregisterEvent(node, event, localEvent) {
                domDelegate.unbind(node, event, mouseHandler(localEvent).$delegate);
            }

            function registerEvents(svg) {
                forEach(bindings, function (val, key) {
                    registerEvent(svg.node, key, val);
                });
            }

            function unregisterEvents(svg) {
                forEach(bindings, function (val, key) {
                    unregisterEvent(svg.node, key, val);
                });
            }

            eventBus.on('canvas.destroy', function (event) {
                unregisterEvents(event.svg);
            });

            eventBus.on('canvas.init', function (event) {
                registerEvents(event.svg);
            });


            eventBus.on(['shape.added', 'connection.added'], function (event) {
                var element = event.element,
                    gfx = event.gfx,
                    hit,
                    type;

                if (element.waypoints) {
                    hit = createLine(element.waypoints);
                    type = 'connection';
                } else {
                    hit = Snap.create('rect', {x: 0, y: 0, width: element.width, height: element.height});
                    type = 'shape';
                }

                hit.attr(HIT_STYLE).appendTo(gfx.node);
            });

            // update djs-hit on change

            eventBus.on('shape.changed', function (event) {

                var element = event.element,
                    gfx = event.gfx,
                    hit = gfx.select('.djs-hit');

                hit.attr({
                    width: element.width,
                    height: element.height
                });
            });

            eventBus.on('connection.changed', function (event) {

                var element = event.element,
                    gfx = event.gfx,
                    hit = gfx.select('.djs-hit');

                updateLine(hit, element.waypoints);
            });


            // API

            this.fire = fire;

            this.mouseHandler = mouseHandler;

            this.registerEvent = registerEvent;
            this.unregisterEvent = unregisterEvent;
        }


        InteractionEvents.$inject = ['eventBus', 'elementRegistry', 'styles'];

        module.exports = InteractionEvents;


        /**
         * An event indicating that the mouse hovered over an element
         *
         * @event element.hover
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {Snap<Element>} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has left an element
         *
         * @event element.out
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {Snap<Element>} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has clicked an element
         *
         * @event element.click
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {Snap<Element>} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has double clicked an element
         *
         * @event element.dblclick
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {Snap<Element>} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has gone down on an element.
         *
         * @event element.mousedown
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {Snap<Element>} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has gone up on an element.
         *
         * @event element.mouseup
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {Snap<Element>} gfx
         * @property {Event} originalEvent
         */
    }, {
        "../../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "../../draw/Renderer": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/draw/Renderer.js",
        "../../util/Mouse": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Mouse.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "min-dom/lib/delegate": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/delegate.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/interaction-events/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['interactionEvents'],
            interactionEvents: ['type', require('./InteractionEvents')]
        };
    }, {"./InteractionEvents": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/keyboard/Keyboard.js": [function (require, module, exports) {
        'use strict';

        var domEvent = require('min-dom/lib/event'),
            domMatches = require('min-dom/lib/matches');

        /**
         * A keyboard abstraction that may be activated and
         * deactivated by users at will, consuming key events
         * and triggering diagram actions.
         *
         * The implementation fires the following key events that allow
         * other components to hook into key handling:
         *
         *  - keyboard.bind
         *  - keyboard.unbind
         *  - keyboard.init
         *  - keyboard.destroy
         *
         * All events contain the fields (node, listeners).
         *
         * A default binding for the keyboard may be specified via the
         * `keyboard.bindTo` configuration option.
         *
         * @param {EventBus} eventBus
         * @param {CommandStack} commandStack
         * @param {Modeling} modeling
         * @param {Selection} selection
         */
        function Keyboard(config, eventBus, commandStack, modeling, selection) {

            var self = this;

            this._commandStack = commandStack;
            this._modeling = modeling;
            this._selection = selection;
            this._eventBus = eventBus;

            this._listeners = [];

            // our key handler is a singleton that passes
            // (keycode, modifiers) to each listener.
            //
            // listeners must indicate that they handled a key event
            // by returning true. This stops the event propagation.
            //
            this._keyHandler = function (event) {

                var i, l,
                    target = event.target,
                    listeners = self._listeners,
                    code = event.keyCode || event.charCode || -1;

                if (domMatches(target, 'input, textarea')) {
                    return;
                }

                for (i = 0; !!(l = listeners[i]); i++) {
                    if (l(code, event)) {
                        event.stopPropagation();
                    }
                }
            };

            // properly clean dom registrations
            eventBus.on('diagram.destroy', function () {
                self._fire('destroy');

                self.unbind();
                self._listeners = null;
            });

            eventBus.on('diagram.init', function () {
                self._fire('init');

                if (config && config.bindTo) {
                    self.bind(config.bindTo);
                }
            });

            this._init();
        }

        Keyboard.$inject = ['config.keyboard', 'eventBus', 'commandStack', 'modeling', 'selection'];

        module.exports = Keyboard;


        Keyboard.prototype.bind = function (node) {
            this._node = node;

            // bind key events
            domEvent.bind(node, 'keydown', this._keyHandler, true);

            this._fire('bind');
        };

        Keyboard.prototype.getBinding = function () {
            return this._node;
        };

        Keyboard.prototype.unbind = function () {
            var node = this._node;

            if (node) {
                this._fire('unbind');

                // unbind key events
                domEvent.unbind(node, 'keydown', this._keyHandler, true);
            }

            this._node = null;
        };


        Keyboard.prototype._fire = function (event) {
            this._eventBus.fire('keyboard.' + event, {node: this._node, listeners: this._listeners});
        };

        Keyboard.prototype._init = function () {

            var listeners = this._listeners,
                commandStack = this._commandStack,
                modeling = this._modeling,
                selection = this._selection;


            // init default listeners

            // undo
            // (CTRL|CMD) + Z
            function undo(key, modifiers) {

                if (isCmd(modifiers) && !isShift(modifiers) && key === 90) {
                    commandStack.undo();

                    return true;
                }
            }

            // redo
            // CTRL + Y
            // CMD + SHIFT + Z
            function redo(key, modifiers) {

                if (isCmd(modifiers) && (key === 89 || (key === 90 && isShift(modifiers)))) {
                    commandStack.redo();

                    return true;
                }
            }


            // delete selected element
            // DEL
            function remove(key, modifiers) {

                if (key === 46) {

                    var selectedElements = selection.get();

                    if (selectedElements.length) {
                        modeling.removeElements(selectedElements.slice());
                    }

                    return true;
                }
            }

            listeners.push(undo);
            listeners.push(redo);
            listeners.push(remove);
        };


        /**
         * Add a listener function that is notified with (key, modifiers) whenever
         * the keyboard is bound and the user presses a key.
         *
         * @param {Function} listenerFn
         */
        Keyboard.prototype.addListener = function (listenerFn) {
            this._listeners.push(listenerFn);
        };

        Keyboard.prototype.hasModifier = hasModifier;
        Keyboard.prototype.isCmd = isCmd;
        Keyboard.prototype.isShift = isShift;


        function hasModifier(modifiers) {
            return (modifiers.ctrlKey || modifiers.metaKey || modifiers.shiftKey || modifiers.altKey);
        }

        function isCmd(modifiers) {
            return modifiers.ctrlKey || modifiers.metaKey;
        }

        function isShift(modifiers) {
            return modifiers.shiftKey;
        }

    }, {
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js",
        "min-dom/lib/matches": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/matches.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/keyboard/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['keyboard'],
            keyboard: ['type', require('./Keyboard')]
        };

    }, {"./Keyboard": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/keyboard/Keyboard.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js": [function (require, module, exports) {
        'use strict';

        var values = require('lodash/object/values');

        var getEnclosedElements = require('../../util/Elements').getEnclosedElements;

        var hasPrimaryModifier = require('../../util/Mouse').hasPrimaryModifier;

        var Snap = require('../../../vendor/snapsvg');


        function LassoTool(eventBus, canvas, dragging, elementRegistry, selection) {

            this._selection = selection;
            this._dragging = dragging;

            var self = this;

            // lasso visuals implementation

            /**
             * A helper that realizes the selection box visual
             */
            var visuals = {

                create: function (context) {
                    var container = canvas.getDefaultLayer(),
                        frame;

                    frame = context.frame = Snap.create('rect', {
                        class: 'djs-lasso-overlay',
                        width: 1,
                        height: 1,
                        x: 0,
                        y: 0
                    });

                    frame.appendTo(container);
                },

                update: function (context) {
                    var frame = context.frame,
                        bbox = context.bbox;

                    frame.attr({
                        x: bbox.x,
                        y: bbox.y,
                        width: bbox.width,
                        height: bbox.height
                    });
                },

                remove: function (context) {

                    if (context.frame) {
                        context.frame.remove();
                    }
                }
            };


            eventBus.on('lasso.selection.end', function (event) {

                setTimeout(function () {
                    self.activateLasso(event.originalEvent, true);
                });
            });

            // lasso interaction implementation

            eventBus.on('lasso.end', function (event) {

                var bbox = toBBox(event);

                var elements = elementRegistry.filter(function (element) {
                    return element;
                });

                self.select(elements, bbox);
            });

            eventBus.on('lasso.start', function (event) {

                var context = event.context;

                context.bbox = toBBox(event);
                visuals.create(context);
            });

            eventBus.on('lasso.move', function (event) {

                var context = event.context;

                context.bbox = toBBox(event);
                visuals.update(context);
            });

            eventBus.on('lasso.end', function (event) {

                var context = event.context;

                visuals.remove(context);
            });

            eventBus.on('lasso.cleanup', function (event) {

                var context = event.context;

                visuals.remove(context);
            });


            // event integration

            eventBus.on('element.mousedown', 1500, function (event) {

                if (hasPrimaryModifier(event)) {
                    self.activateLasso(event.originalEvent);

                    event.stopPropagation();
                }
            });
        }

        LassoTool.$inject = [
            'eventBus',
            'canvas',
            'dragging',
            'elementRegistry',
            'selection'
        ];

        module.exports = LassoTool;


        LassoTool.prototype.activateLasso = function (event, autoActivate) {

            this._dragging.activate(event, 'lasso', {
                autoActivate: autoActivate,
                cursor: 'crosshair',
                data: {
                    context: {}
                }
            });
        };

        LassoTool.prototype.activateSelection = function (event) {

            this._dragging.activate(event, 'lasso.selection', {
                cursor: 'crosshair'
            });
        };

        LassoTool.prototype.select = function (elements, bbox) {
            var selectedElements = getEnclosedElements(elements, bbox);

            this._selection.select(values(selectedElements));
        };


        function toBBox(event) {

            var start = {

                x: event.x - event.dx,
                y: event.y - event.dy
            };

            var end = {
                x: event.x,
                y: event.y
            };

            var bbox;

            if ((start.x <= end.x && start.y < end.y) ||
                (start.x < end.x && start.y <= end.y)) {

                bbox = {
                    x: start.x,
                    y: start.y,
                    width: end.x - start.x,
                    height: end.y - start.y
                };
            } else if ((start.x >= end.x && start.y < end.y) ||
                (start.x > end.x && start.y <= end.y)) {

                bbox = {
                    x: end.x,
                    y: start.y,
                    width: start.x - end.x,
                    height: end.y - start.y
                };
            } else if ((start.x <= end.x && start.y > end.y) ||
                (start.x < end.x && start.y >= end.y)) {

                bbox = {
                    x: start.x,
                    y: end.y,
                    width: end.x - start.x,
                    height: start.y - end.y
                };
            } else if ((start.x >= end.x && start.y > end.y) ||
                (start.x > end.x && start.y >= end.y)) {

                bbox = {
                    x: end.x,
                    y: end.y,
                    width: start.x - end.x,
                    height: start.y - end.y
                };
            } else {

                bbox = {
                    x: end.x,
                    y: end.y,
                    width: 0,
                    height: 0
                };
            }
            return bbox;
        }
    }, {
        "../../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "../../util/Elements": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Elements.js",
        "../../util/Mouse": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Mouse.js",
        "lodash/object/values": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/values.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/lasso-tool/index.js": [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['lassoTool'],
            lassoTool: ['type', require('./LassoTool')]
        };

    }, {"./LassoTool": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/Modeling.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var model = require('../../model');


        /**
         * The basic modeling entry point.
         *
         * @param {EventBus} eventBus
         * @param {ElementFactory} elementFactory
         * @param {CommandStack} commandStack
         */
        function Modeling(eventBus, elementFactory, commandStack) {
            this._eventBus = eventBus;
            this._elementFactory = elementFactory;
            this._commandStack = commandStack;

            var self = this;

            eventBus.on('diagram.init', function () {
                // register modeling handlers
                self.registerHandlers(commandStack);
            });
        }

        Modeling.$inject = ['eventBus', 'elementFactory', 'commandStack'];

        module.exports = Modeling;


        Modeling.prototype.getHandlers = function () {
            return {
                'shape.append': require('./cmd/AppendShapeHandler'),
                'shape.create': require('./cmd/CreateShapeHandler'),
                'shape.delete': require('./cmd/DeleteShapeHandler'),
                'shape.move': require('./cmd/MoveShapeHandler'),
                'shapes.move': require('./cmd/MoveShapesHandler'),
                'shape.resize': require('./cmd/ResizeShapeHandler'),
                'shape.replace': require('./cmd/ReplaceShapeHandler'),

                'spaceTool': require('./cmd/SpaceToolHandler'),

                'label.create': require('./cmd/CreateLabelHandler'),

                'connection.create': require('./cmd/CreateConnectionHandler'),
                'connection.delete': require('./cmd/DeleteConnectionHandler'),
                'connection.move': require('./cmd/MoveConnectionHandler'),
                'connection.layout': require('./cmd/LayoutConnectionHandler'),

                'connection.updateWaypoints': require('./cmd/UpdateWaypointsHandler'),

                'connection.reconnectStart': require('./cmd/ReconnectConnectionHandler'),
                'connection.reconnectEnd': require('./cmd/ReconnectConnectionHandler'),

                'elements.delete': require('./cmd/DeleteElementsHandler'),
                'element.updateAnchors': require('./cmd/UpdateAnchorsHandler')
            };
        };

        /**
         * Register handlers with the command stack
         *
         * @param {CommandStack} commandStack
         */
        Modeling.prototype.registerHandlers = function (commandStack) {
            forEach(this.getHandlers(), function (handler, id) {
                commandStack.registerHandler(id, handler);
            });
        };


///// modeling helpers /////////////////////////////////////////


        Modeling.prototype.moveShape = function (shape, delta, newParent, hints) {

            var context = {
                shape: shape,
                delta: delta,
                newParent: newParent,
                hints: hints || {}
            };

            this._commandStack.execute('shape.move', context);
        };


        Modeling.prototype.moveShapes = function (shapes, delta, newParent, hints) {

            var context = {
                shapes: shapes,
                delta: delta,
                newParent: newParent,
                hints: hints || {}
            };

            this._commandStack.execute('shapes.move', context);
        };

        /**
         * Update the anchors on the element with the given delta movement
         * @param  {djs.model.Element} element
         * @param  {Point} delta
         */
        Modeling.prototype.updateAnchors = function (element, delta) {
            var context = {
                element: element,
                delta: delta
            };

            this._commandStack.execute('element.updateAnchors', context);
        };

        Modeling.prototype.moveConnection = function (connection, delta, newParent, hints) {

            var context = {
                connection: connection,
                delta: delta,
                newParent: newParent,
                hints: hints || {}
            };

            this._commandStack.execute('connection.move', context);
        };


        Modeling.prototype.layoutConnection = function (connection, hints) {

            var context = {
                connection: connection,
                hints: hints || {}
            };

            this._commandStack.execute('connection.layout', context);
        };


        Modeling.prototype.createConnection = function (source, target, connection, parent) {

            connection = this._create('connection', connection);

            var context = {
                source: source,
                target: target,
                parent: parent,
                connection: connection
            };

            this._commandStack.execute('connection.create', context);

            return context.connection;
        };

        Modeling.prototype.createShape = function (shape, position, parent) {

            shape = this._create('shape', shape);

            var context = {
                position: position,
                parent: parent,
                shape: shape
            };

            this._commandStack.execute('shape.create', context);

            return context.shape;
        };


        Modeling.prototype.createLabel = function (labelTarget, position, label, parent) {

            label = this._create('label', label);

            var context = {
                labelTarget: labelTarget,
                position: position,
                parent: parent,
                shape: label
            };

            this._commandStack.execute('label.create', context);

            return context.shape;
        };


        Modeling.prototype.appendShape = function (source, shape, position, parent, connection, connectionParent) {

            shape = this._create('shape', shape);

            var context = {
                source: source,
                position: position,
                parent: parent,
                shape: shape,
                connection: connection,
                connectionParent: connectionParent
            };

            this._commandStack.execute('shape.append', context);

            return context.shape;
        };


        Modeling.prototype.removeElements = function (elements) {
            var context = {
                elements: elements
            };

            this._commandStack.execute('elements.delete', context);
        };


        Modeling.prototype.removeShape = function (shape) {
            var context = {
                shape: shape
            };

            this._commandStack.execute('shape.delete', context);
        };


        Modeling.prototype.removeConnection = function (connection) {
            var context = {
                connection: connection
            };

            this._commandStack.execute('connection.delete', context);
        };

        Modeling.prototype.replaceShape = function (oldShape, newShape, options) {
            var context = {
                oldShape: oldShape,
                newData: newShape,
                options: options
            };

            this._commandStack.execute('shape.replace', context);

            return context.newShape;
        };

        Modeling.prototype.resizeShape = function (shape, newBounds) {
            var context = {
                shape: shape,
                newBounds: newBounds
            };

            this._commandStack.execute('shape.resize', context);
        };

        Modeling.prototype.createSpace = function (movingShapes, resizingShapes, delta, direction) {
            var context = {
                movingShapes: movingShapes,
                resizingShapes: resizingShapes,
                delta: delta,
                direction: direction
            };

            this._commandStack.execute('spaceTool', context);
        };

        Modeling.prototype.updateWaypoints = function (connection, newWaypoints) {
            var context = {
                connection: connection,
                newWaypoints: newWaypoints
            };

            this._commandStack.execute('connection.updateWaypoints', context);
        };

        Modeling.prototype.reconnectStart = function (connection, newSource, dockingPoint) {
            var context = {
                connection: connection,
                newSource: newSource,
                dockingPoint: dockingPoint
            };

            this._commandStack.execute('connection.reconnectStart', context);
        };

        Modeling.prototype.reconnectEnd = function (connection, newTarget, dockingPoint) {
            var context = {
                connection: connection,
                newTarget: newTarget,
                dockingPoint: dockingPoint
            };

            this._commandStack.execute('connection.reconnectEnd', context);
        };

        Modeling.prototype.connect = function (source, target, attrs) {
            return this.createConnection(source, target, attrs || {}, source.parent);
        };


        Modeling.prototype._create = function (type, attrs) {
            if (attrs instanceof model.Base) {
                return attrs;
            } else {
                return this._elementFactory.create(type, attrs);
            }
        };

    }, {
        "../../model": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/model/index.js",
        "./cmd/AppendShapeHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js",
        "./cmd/CreateConnectionHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js",
        "./cmd/CreateLabelHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js",
        "./cmd/CreateShapeHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js",
        "./cmd/DeleteConnectionHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js",
        "./cmd/DeleteElementsHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js",
        "./cmd/DeleteShapeHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js",
        "./cmd/LayoutConnectionHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js",
        "./cmd/MoveConnectionHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js",
        "./cmd/MoveShapeHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js",
        "./cmd/MoveShapesHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/MoveShapesHandler.js",
        "./cmd/ReconnectConnectionHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js",
        "./cmd/ReplaceShapeHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js",
        "./cmd/ResizeShapeHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js",
        "./cmd/SpaceToolHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js",
        "./cmd/UpdateAnchorsHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/UpdateAnchorsHandler.js",
        "./cmd/UpdateWaypointsHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');


        /**
         * A handler that implements reversible appending of shapes
         * to a source shape.
         *
         * @param {canvas} Canvas
         * @param {elementFactory} ElementFactory
         * @param {modeling} Modeling
         */
        function AppendShapeHandler(modeling) {
            this._modeling = modeling;
        }

        inherits(AppendShapeHandler, require('./NoopHandler'));


        AppendShapeHandler.$inject = ['modeling'];

        module.exports = AppendShapeHandler;


////// api /////////////////////////////////////////////

        /**
         * Creates a new shape
         *
         * @param {Object} context
         * @param {ElementDescriptor} context.shape the new shape
         * @param {ElementDescriptor} context.source the source object
         * @param {ElementDescriptor} context.parent the parent object
         * @param {Point} context.position position of the new element
         */
        AppendShapeHandler.prototype.preExecute = function (context) {

            if (!context.source) {
                throw new Error('source required');
            }

            var parent = context.parent || context.source.parent,
                shape = this._modeling.createShape(context.shape, context.position, parent);

            context.shape = shape;
        };

        AppendShapeHandler.prototype.postExecute = function (context) {
            var parent = context.connectionParent || context.shape.parent;

            // create connection
            this._modeling.connect(context.source, context.shape, context.connection, parent);
        };
    }, {
        "./NoopHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/NoopHandler.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/inherits/inherits_browser.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js": [function (require, module, exports) {
        'use strict';


        function CreateConnectionHandler(canvas, layouter) {
            this._canvas = canvas;
            this._layouter = layouter;
        }

        CreateConnectionHandler.$inject = ['canvas', 'layouter'];

        module.exports = CreateConnectionHandler;


////// api /////////////////////////////////////////

        /**
         * Appends a shape to a target shape
         *
         * @param {Object} context
         * @param {djs.element.Base} context.source the source object
         * @param {djs.element.Base} context.target the parent object
         * @param {Point} context.position position of the new element
         */
        CreateConnectionHandler.prototype.execute = function (context) {

            var source = context.source,
                target = context.target,
                parent = context.parent;

            if (!source || !target) {
                throw new Error('source and target required');
            }

            if (!parent) {
                throw new Error('parent required');
            }

            var connection = context.connection;

            connection.source = source;
            connection.target = target;

            if (!connection.waypoints) {
                connection.waypoints = this._layouter.layoutConnection(connection);
            }

            // add connection
            this._canvas.addConnection(connection, parent);

            return connection;
        };

        CreateConnectionHandler.prototype.revert = function (context) {
            var connection = context.connection;

            this._canvas.removeConnection(connection);

            connection.source = null;
            connection.target = null;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CreateShapeHandler = require('./CreateShapeHandler');


        /**
         * A handler that attaches a label to a given target shape.
         *
         * @param {canvas} Canvas
         */
        function CreateLabelHandler(canvas) {
            CreateShapeHandler.call(this, canvas);
        }

        inherits(CreateLabelHandler, CreateShapeHandler);

        CreateLabelHandler.$inject = ['canvas'];

        module.exports = CreateLabelHandler;


////// api /////////////////////////////////////////


        /**
         * Appends a label to a target shape.
         *
         * @method CreateLabelHandler#execute
         *
         * @param {Object} context
         * @param {ElementDescriptor} context.target the element the label is attached to
         * @param {ElementDescriptor} context.parent the parent object
         * @param {Point} context.position position of the new element
         */

        /**
         * Undo append by removing the shape
         */
        CreateLabelHandler.prototype.revert = function (context) {
            context.shape.labelTarget = null;
            this._canvas.removeShape(context.shape);
        };


////// helpers /////////////////////////////////////////

        CreateLabelHandler.prototype.getParent = function (context) {
            return context.parent || context.labelTarget && context.labelTarget.parent;
        };

        CreateLabelHandler.prototype.addElement = function (shape, parent, context) {
            shape.labelTarget = context.labelTarget;
            this._canvas.addShape(shape, parent, true);
        };
    }, {
        "./CreateShapeHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/inherits/inherits_browser.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');


        /**
         * A handler that implements reversible addition of shapes.
         *
         * @param {canvas} Canvas
         */
        function CreateShapeHandler(canvas) {
            this._canvas = canvas;
        }

        CreateShapeHandler.$inject = ['canvas'];

        module.exports = CreateShapeHandler;


////// api /////////////////////////////////////////


        /**
         * Appends a shape to a target shape
         *
         * @param {Object} context
         * @param {djs.model.Base} context.parent the parent object
         * @param {Point} context.position position of the new element
         */
        CreateShapeHandler.prototype.execute = function (context) {

            var parent = this.getParent(context);

            var shape = context.shape;

            this.setPosition(shape, context);

            this.addElement(shape, parent, context);

            return shape;
        };


        /**
         * Undo append by removing the shape
         */
        CreateShapeHandler.prototype.revert = function (context) {
            this._canvas.removeShape(context.shape);
        };


////// helpers /////////////////////////////////////////

        CreateShapeHandler.prototype.getParent = function (context) {
            var parent = context.parent;

            if (!parent) {
                throw new Error('parent required');
            }

            return parent;
        };

        CreateShapeHandler.prototype.getPosition = function (context) {
            if (!context.position) {
                throw new Error('no position given');
            }

            return context.position;
        };

        CreateShapeHandler.prototype.addElement = function (shape, parent) {
            this._canvas.addShape(shape, parent);
        };

        CreateShapeHandler.prototype.setPosition = function (shape, context) {
            var position = this.getPosition(context);

            // update to center position
            // specified in create context
            assign(shape, {
                x: position.x - shape.width / 2,
                y: position.y - shape.height / 2
            });
        };
    }, {"lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js": [function (require, module, exports) {
        'use strict';

        var Collections = require('../../../util/Collections');


        /**
         * A handler that implements reversible deletion of Connections.
         *
         */
        function DeleteConnectionHandler(canvas, modeling) {
            this._canvas = canvas;
            this._modeling = modeling;
        }

        DeleteConnectionHandler.$inject = ['canvas', 'modeling'];

        module.exports = DeleteConnectionHandler;


        /**
         * - Remove attached label
         */
        DeleteConnectionHandler.prototype.preExecute = function (context) {

            var connection = context.connection;

            // Remove label
            if (connection.label) {
                this._modeling.removeShape(connection.label);
            }
        };

        DeleteConnectionHandler.prototype.execute = function (context) {

            var connection = context.connection,
                parent = connection.parent;

            context.parent = parent;
            context.parentIndex = Collections.indexOf(parent.children, connection);

            context.source = connection.source;
            context.target = connection.target;

            this._canvas.removeConnection(connection);

            connection.source = null;
            connection.target = null;
            connection.label = null;
        };

        /**
         * Command revert implementation.
         */
        DeleteConnectionHandler.prototype.revert = function (context) {

            var connection = context.connection,
                parent = context.parent,
                parentIndex = context.parentIndex;

            connection.source = context.source;
            connection.target = context.target;

            // restore previous location in old parent
            Collections.add(parent.children, connection, parentIndex);

            this._canvas.addConnection(connection, parent);
        };

    }, {"../../../util/Collections": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Collections.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            inherits = require('inherits');


        function DeleteElementsHandler(modeling, elementRegistry) {
            this._modeling = modeling;
            this._elementRegistry = elementRegistry;
        }

        inherits(DeleteElementsHandler, require('./NoopHandler'));

        DeleteElementsHandler.$inject = ['modeling', 'elementRegistry'];

        module.exports = DeleteElementsHandler;


        DeleteElementsHandler.prototype.postExecute = function (context) {

            var modeling = this._modeling,
                elementRegistry = this._elementRegistry,
                elements = context.elements;

            forEach(elements, function (element) {

                // element may have been removed with previous
                // remove operations already (e.g. in case of nesting)
                if (!elementRegistry.get(element.id)) {
                    return;
                }

                if (element.waypoints) {
                    modeling.removeConnection(element);
                } else {
                    modeling.removeShape(element);
                }
            });
        };
    }, {
        "./NoopHandler": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/NoopHandler.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/inherits/inherits_browser.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js": [function (require, module, exports) {
        'use strict';

        var Collections = require('../../../util/Collections');


        /**
         * A handler that implements reversible deletion of shapes.
         *
         */
        function DeleteShapeHandler(canvas, modeling) {
            this._canvas = canvas;
            this._modeling = modeling;
        }

        DeleteShapeHandler.$inject = ['canvas', 'modeling'];

        module.exports = DeleteShapeHandler;


        /**
         * - Remove connections
         * - Remove all direct children
         */
        DeleteShapeHandler.prototype.preExecute = function (context) {

            var shape = context.shape,
                label = shape.label,
                modeling = this._modeling;

            // Clean up on removeShape(label)
            if (shape.labelTarget) {
                context.labelTarget = shape.labelTarget;
                shape.labelTarget = null;
            }

            // Remove label
            if (label) {
                this._modeling.removeShape(label);
            }

            // remove connections
            this._saveClear(shape.incoming, function (connection) {
                // To make sure that the connection isn't removed twice
                // For example if a container is removed
                modeling.removeConnection(connection);
            });

            this._saveClear(shape.outgoing, function (connection) {
                modeling.removeConnection(connection);
            });


            // remove children
            this._saveClear(shape.children, function (e) {
                modeling.removeShape(e);
            });
        };


        DeleteShapeHandler.prototype._saveClear = function (collection, remove) {

            var e;

            while (!!(e = collection[0])) {
                remove(e);
            }
        };


        /**
         * Remove shape and remember the parent
         */
        DeleteShapeHandler.prototype.execute = function (context) {

            var shape = context.shape,
                parent = shape.parent;

            context.parent = parent;
            context.parentIndex = Collections.indexOf(parent.children, shape);

            shape.label = null;

            this._canvas.removeShape(shape);
        };


        /**
         * Command revert implementation
         */
        DeleteShapeHandler.prototype.revert = function (context) {

            var shape = context.shape,
                parent = context.parent,
                parentIndex = context.parentIndex,
                labelTarget = context.labelTarget;

            // restore previous location in old parent
            Collections.add(parent.children, shape, parentIndex);

            if (labelTarget) {
                labelTarget.label = shape;
            }

            this._canvas.addShape(shape, parent);
        };

    }, {"../../../util/Collections": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Collections.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');


        /**
         * A handler that implements reversible moving of shapes.
         */
        function LayoutConnectionHandler(layouter, canvas) {
            this._layouter = layouter;
            this._canvas = canvas;
        }

        LayoutConnectionHandler.$inject = ['layouter', 'canvas'];

        module.exports = LayoutConnectionHandler;

        LayoutConnectionHandler.prototype.execute = function (context) {

            var connection = context.connection,
                parent = connection.parent,
                connectionSiblings = parent.children;

            var oldIndex = connectionSiblings.indexOf(connection);

            assign(context, {
                oldWaypoints: connection.waypoints,
                oldIndex: oldIndex
            });

            sendToFront(connection);

            connection.waypoints = this._layouter.layoutConnection(connection, context.hints);

            return connection;
        };

        LayoutConnectionHandler.prototype.revert = function (context) {

            var connection = context.connection,
                parent = connection.parent,
                connectionSiblings = parent.children,
                currentIndex = connectionSiblings.indexOf(connection),
                oldIndex = context.oldIndex;

            connection.waypoints = context.oldWaypoints;

            if (oldIndex !== currentIndex) {

                // change position of connection in shape
                connectionSiblings.splice(currentIndex, 1);
                connectionSiblings.splice(oldIndex, 0, connection);
            }

            return connection;
        };

// connections should have a higher z-order as there source and targets
        function sendToFront(connection) {

            var connectionSiblings = connection.parent.children;

            var connectionIdx = connectionSiblings.indexOf(connection),
                sourceIdx = findIndex(connectionSiblings, connection.source),
                targetIdx = findIndex(connectionSiblings, connection.target),

            // ensure we do not send the connection back
            // if it is already in front
                insertIndex = Math.max(sourceIdx + 1, targetIdx + 1, connectionIdx);

            if (connectionIdx < insertIndex) {
                connectionSiblings.splice(insertIndex, 0, connection); // add to new position
                connectionSiblings.splice(connectionIdx, 1); // remove from old position
            }

            function findIndex(array, obj) {

                var index = array.indexOf(obj);
                if (index < 0 && obj) {
                    var parent = obj.parent;
                    index = findIndex(array, parent);
                }
                return index;
            }

            return insertIndex;
        }

    }, {"lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var Collections = require('../../../util/Collections');


        /**
         * A handler that implements reversible moving of connections.
         *
         * The handler differs from the layout connection handler in a sense
         * that it preserves the connection layout.
         */
        function MoveConnectionHandler() {
        }

        module.exports = MoveConnectionHandler;


        MoveConnectionHandler.prototype.execute = function (context) {

            var updateAnchors = (context.hints.updateAnchors !== false);

            var connection = context.connection,
                delta = context.delta;

            var newParent = this.getNewParent(connection, context),
                oldParent = connection.parent;

            // save old position + parent in context
            context.oldParent = oldParent;
            context.oldParentIndex = Collections.indexOf(oldParent.children, connection);

            // update waypoint positions
            forEach(connection.waypoints, function (p) {
                p.x += delta.x;
                p.y += delta.y;

                if (updateAnchors && p.original) {
                    p.original.x += delta.x;
                    p.original.y += delta.y;
                }
            });

            // update parent
            connection.parent = newParent;

            return connection;
        };

        MoveConnectionHandler.prototype.revert = function (context) {

            var updateAnchors = (context.hints.updateAnchors !== false);

            var connection = context.connection,
                oldParent = context.oldParent,
                oldParentIndex = context.oldParentIndex,
                delta = context.delta;

            // restore previous location in old parent
            Collections.add(oldParent.children, connection, oldParentIndex);

            // restore parent
            connection.parent = oldParent;

            // revert to old waypoint positions
            forEach(connection.waypoints, function (p) {
                p.x -= delta.x;
                p.y -= delta.y;

                if (updateAnchors && p.original) {
                    p.original.x -= delta.x;
                    p.original.y -= delta.y;
                }
            });

            return connection;
        };


        MoveConnectionHandler.prototype.getNewParent = function (connection, context) {
            return context.newParent || connection.parent;
        };

    }, {
        "../../../util/Collections": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Collections.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var MoveHelper = require('./helper/MoveHelper'),
            Collections = require('../../../util/Collections');


        /**
         * A handler that implements reversible moving of shapes.
         */
        function MoveShapeHandler(modeling) {
            this._modeling = modeling;

            this._helper = new MoveHelper(modeling);
        }

        MoveShapeHandler.$inject = ['modeling'];

        module.exports = MoveShapeHandler;


        MoveShapeHandler.prototype.execute = function (context) {

            var shape = context.shape,
                delta = context.delta,
                newParent = this.getNewParent(context),
                oldParent = shape.parent;

            // save old parent in context
            context.oldParent = oldParent;
            context.oldParentIndex = Collections.indexOf(oldParent.children, shape);

            // update shape parent + position
            assign(shape, {
                parent: newParent,
                x: shape.x + delta.x,
                y: shape.y + delta.y
            });

            return shape;
        };

        MoveShapeHandler.prototype.postExecute = function (context) {

            var shape = context.shape,
                delta = context.delta;

            var modeling = this._modeling;

            if (context.hints.updateAnchors !== false) {
                modeling.updateAnchors(shape, delta);
            }

            if (context.hints.layout !== false) {
                forEach(shape.incoming, function (c) {
                    modeling.layoutConnection(c, {endChanged: true});
                });

                forEach(shape.outgoing, function (c) {
                    modeling.layoutConnection(c, {startChanged: true});
                });
            }

            if (context.hints.recurse !== false) {
                this.moveChildren(context);
            }
        };

        MoveShapeHandler.prototype.revert = function (context) {

            var shape = context.shape,
                oldParent = context.oldParent,
                oldParentIndex = context.oldParentIndex,
                delta = context.delta;

            // restore previous location in old parent
            Collections.add(oldParent.children, shape, oldParentIndex);

            // revert to old position and parent
            assign(shape, {
                parent: oldParent,
                x: shape.x - delta.x,
                y: shape.y - delta.y
            });

            return shape;
        };

        MoveShapeHandler.prototype.moveChildren = function (context) {

            var delta = context.delta,
                shape = context.shape;

            this._helper.moveRecursive(shape.children, delta, null);
        };

        MoveShapeHandler.prototype.getNewParent = function (context) {
            return context.newParent || context.shape.parent;
        };
    }, {
        "../../../util/Collections": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Collections.js",
        "./helper/MoveHelper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/MoveShapesHandler.js": [function (require, module, exports) {
        'use strict';

        var MoveHelper = require('./helper/MoveHelper');


        /**
         * A handler that implements reversible moving of shapes.
         */
        function MoveShapesHandler(modeling) {
            this._helper = new MoveHelper(modeling);
        }

        MoveShapesHandler.$inject = ['modeling'];

        module.exports = MoveShapesHandler;

        MoveShapesHandler.prototype.preExecute = function (context) {
            context.closure = this._helper.getClosure(context.shapes);
        };

        MoveShapesHandler.prototype.postExecute = function (context) {
            this._helper.moveClosure(context.closure, context.delta, context.newParent);
        };


        MoveShapesHandler.prototype.execute = function (context) {
        };
        MoveShapesHandler.prototype.revert = function (context) {
        };

    }, {"./helper/MoveHelper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/NoopHandler.js": [function (require, module, exports) {
        'use strict';

        function NoopHandler() {
        }

        module.exports = NoopHandler;

        NoopHandler.prototype.execute = function () {
        };
        NoopHandler.prototype.revert = function () {
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js": [function (require, module, exports) {
        'use strict';


        function ReconnectConnectionHandler(layouter) {
        }

        ReconnectConnectionHandler.$inject = ['layouter'];

        module.exports = ReconnectConnectionHandler;

        ReconnectConnectionHandler.prototype.execute = function (context) {

            var newSource = context.newSource,
                newTarget = context.newTarget,
                connection = context.connection;

            if (!newSource && !newTarget) {
                throw new Error('newSource or newTarget are required');
            }

            if (newSource && newTarget) {
                throw new Error('must specify either newSource or newTarget');
            }

            if (newSource) {
                context.oldSource = connection.source;
                connection.source = newSource;

                context.oldDockingPoint = connection.waypoints[0];
                connection.waypoints[0] = context.dockingPoint;
            }

            if (newTarget) {
                context.oldTarget = connection.target;
                connection.target = newTarget;

                context.oldDockingPoint = connection.waypoints[connection.waypoints.length - 1];
                connection.waypoints[connection.waypoints.length - 1] = context.dockingPoint;
            }

            return connection;
        };

        ReconnectConnectionHandler.prototype.revert = function (context) {

            var newSource = context.newSource,
                newTarget = context.newTarget,
                connection = context.connection;

            if (newSource) {
                connection.source = context.oldSource;
                connection.waypoints[0] = context.oldDockingPoint;
            }

            if (newTarget) {
                connection.target = context.oldTarget;
                connection.waypoints[connection.waypoints.length - 1] = context.oldDockingPoint;
            }

            return connection;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');


        /**
         * A handler that implements reversible replacing of shapes.
         * Internally the old shape will be removed and the new shape will be added.
         *
         *
         * @class
         * @constructor
         *
         * @param {canvas} Canvas
         */
        function ReplaceShapeHandler(modeling, rules) {
            this._modeling = modeling;
            this._rules = rules;
        }

        ReplaceShapeHandler.$inject = ['modeling', 'rules'];

        module.exports = ReplaceShapeHandler;


////// api /////////////////////////////////////////


        /**
         * Replaces a shape with an replacement Element.
         *
         * The newData object should contain type, x, y.
         *
         * If possible also the incoming/outgoing connection
         * will be restored.
         *
         * @param {Object} context
         */
        ReplaceShapeHandler.prototype.preExecute = function (context) {

            var modeling = this._modeling,
                rules = this._rules;

            var oldShape = context.oldShape,
                newData = context.newData,
                newShape;


            // (1) place a new shape at the given position

            var position = {
                x: newData.x,
                y: newData.y
            };

            newShape = context.newShape = context.newShape || modeling.createShape(newData, position, oldShape.parent);


            // (2) reconnect connections to the new shape (where allowed)

            var incoming = oldShape.incoming.slice(),
                outgoing = oldShape.outgoing.slice();

            forEach(incoming, function (connection) {
                var waypoints = connection.waypoints,
                    docking = waypoints[waypoints.length - 1],
                    allowed = rules.allowed('connection.reconnectEnd', {
                        source: connection.source,
                        target: newShape,
                        connection: connection
                    });

                if (allowed) {
                    modeling.reconnectEnd(connection, newShape, docking);
                }
            });

            forEach(outgoing, function (connection) {
                var waypoints = connection.waypoints,
                    docking = waypoints[0],
                    allowed = rules.allowed('connection.reconnectStart', {
                        source: newShape,
                        target: connection.target,
                        connection: connection
                    });

                if (allowed) {
                    modeling.reconnectStart(connection, newShape, docking);
                }
            });
        };


        ReplaceShapeHandler.prototype.postExecute = function (context) {
            var modeling = this._modeling;

            var oldShape = context.oldShape;

            modeling.removeShape(oldShape);
        };


        ReplaceShapeHandler.prototype.execute = function (context) {
        };

        ReplaceShapeHandler.prototype.revert = function (context) {
        };

    }, {"lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');


        /**
         * A handler that implements reversible resizing of shapes.
         *
         */
        function ResizeShapeHandler(modeling) {
            this._modeling = modeling;
        }

        ResizeShapeHandler.$inject = ['modeling'];

        module.exports = ResizeShapeHandler;

        /**
         * {
 *   shape: {....}
 *   newBounds: {
 *     width:  20,
 *     height: 40,
 *     x:       5,
 *     y:      10
 *   }
 *
 * }
         */
        ResizeShapeHandler.prototype.execute = function (context) {

            var shape = context.shape,
                newBounds = context.newBounds;

            if (newBounds.x === undefined || newBounds.y === undefined ||
                newBounds.width === undefined || newBounds.height === undefined) {
                throw new Error('newBounds must have {x, y, width, height} properties');
            }

            if (newBounds.width < 10 || newBounds.height < 10) {
                throw new Error('width and height cannot be less than 10px');
            }

            // save old bbox in context
            context.oldBounds = {
                width: shape.width,
                height: shape.height,
                x: shape.x,
                y: shape.y
            };

            // update shape
            assign(shape, {
                width: newBounds.width,
                height: newBounds.height,
                x: newBounds.x,
                y: newBounds.y
            });

            return shape;
        };

        ResizeShapeHandler.prototype.postExecute = function (context) {

            var shape = context.shape;

            var modeling = this._modeling;

            forEach(shape.incoming, function (c) {
                modeling.layoutConnection(c, {endChanged: true});
            });

            forEach(shape.outgoing, function (c) {
                modeling.layoutConnection(c, {startChanged: true});
            });

        };

        ResizeShapeHandler.prototype.revert = function (context) {

            var shape = context.shape,
                oldBounds = context.oldBounds;

            // restore previous bbox
            assign(shape, {
                width: oldBounds.width,
                height: oldBounds.height,
                x: oldBounds.x,
                y: oldBounds.y
            });

            return shape;
        };

    }, {
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var SpaceUtil = require('../../space-tool/SpaceUtil');

        /**
         * A handler that implements reversible creating and removing of space.
         *
         * It executes in two phases:
         *
         *  (1) resize all affected resizeShapes
         *  (2) move all affected moveShapes
         */
        function SpaceToolHandler(modeling) {
            this._modeling = modeling;
        }

        SpaceToolHandler.$inject = ['modeling'];

        module.exports = SpaceToolHandler;


        SpaceToolHandler.prototype.preExecute = function (context) {

            // resize
            var modeling = this._modeling,
                resizingShapes = context.resizingShapes,
                delta = context.delta,
                direction = context.direction;

            forEach(resizingShapes, function (shape) {
                var newBounds = SpaceUtil.resizeBounds(shape, direction, delta);

                modeling.resizeShape(shape, newBounds);
            });
        };

        SpaceToolHandler.prototype.postExecute = function (context) {
            // move
            var modeling = this._modeling,
                movingShapes = context.movingShapes,
                delta = context.delta;

            modeling.moveShapes(movingShapes, delta);
        };

        SpaceToolHandler.prototype.execute = function (context) {
        };
        SpaceToolHandler.prototype.revert = function (context) {
        };

    }, {
        "../../space-tool/SpaceUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/UpdateAnchorsHandler.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            assign = require('lodash/object/assign');


        /**
         * Update the anchors of
         */
        function UpdateAnchorsHandler() {
        }

        module.exports = UpdateAnchorsHandler;


        UpdateAnchorsHandler.prototype.execute = function (context) {

            // update connection anchors
            return this.updateAnchors(context.element, context.delta);
        };

        UpdateAnchorsHandler.prototype.revert = function (context) {

            var delta = context.delta,
                revertedDelta = {x: -1 * delta.x, y: -1 * delta.y};

            // revert update connection anchors
            return this.updateAnchors(context.element, revertedDelta);
        };

        /**
         * Update anchors on the element according to the delta movement.
         *
         * @param {djs.model.Element} element
         * @param {Point} delta
         *
         * @return Array<djs.model.Connection>
         */
        UpdateAnchorsHandler.prototype.updateAnchors = function (element, delta) {

            function add(point, delta) {
                return {
                    x: point.x + delta.x,
                    y: point.y + delta.y
                };
            }

            function updateAnchor(waypoint) {
                var original = waypoint.original;

                waypoint.original = assign(original || {}, add(original || waypoint, delta));
            }

            var changed = [];

            forEach(element.incoming, function (c) {
                var waypoints = c.waypoints;
                updateAnchor(waypoints[waypoints.length - 1]);

                changed.push(c);
            });

            forEach(element.outgoing, function (c) {
                var waypoints = c.waypoints;
                updateAnchor(waypoints[0]);

                changed.push(c);
            });

            return changed;
        };
    }, {
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js": [function (require, module, exports) {
        'use strict';

        function UpdateWaypointsHandler() {
        }

        module.exports = UpdateWaypointsHandler;

        UpdateWaypointsHandler.prototype.execute = function (context) {

            var connection = context.connection,
                newWaypoints = context.newWaypoints;

            context.oldWaypoints = connection.waypoints;

            connection.waypoints = newWaypoints;

            return connection;
        };

        UpdateWaypointsHandler.prototype.revert = function (context) {

            var connection = context.connection,
                oldWaypoints = context.oldWaypoints;

            connection.waypoints = oldWaypoints;

            return connection;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var Elements = require('../../../../util/Elements');


        /**
         * A helper that is able to carry out serialized move operations on multiple elements.
         *
         * @param {Modeling} modeling
         */
        function MoveHelper(modeling) {
            this._modeling = modeling;
        }

        module.exports = MoveHelper;

        /**
         * Move the specified elements and all children by the given delta.
         *
         * This moves all enclosed connections, too and layouts all affected
         * external connections.
         *
         * @param  {Array<djs.model.Base>} elements
         * @param  {Point} delta
         * @param  {djs.model.Base} newParent applied to the first level of shapes
         *
         * @return {Array<djs.model.Base>} list of touched elements
         */
        MoveHelper.prototype.moveRecursive = function (elements, delta, newParent) {
            return this.moveClosure(this.getClosure(elements), delta, newParent);
        };

        /**
         * Move the given closure of elmements
         */
        MoveHelper.prototype.moveClosure = function (closure, delta, newParent) {

            var modeling = this._modeling;

            var allShapes = closure.allShapes,
                allConnections = closure.allConnections,
                enclosedConnections = closure.enclosedConnections,
                topLevel = closure.topLevel;

            // move all shapes
            forEach(allShapes, function (s) {

                modeling.moveShape(s, delta, topLevel[s.id] && newParent, {
                    recurse: false,
                    layout: false
                });
            });

            // move all child connections / layout external connections
            forEach(allConnections, function (c) {

                var startMoved = !!allShapes[c.source.id],
                    endMoved = !!allShapes[c.target.id];

                if (enclosedConnections[c.id] &&
                    startMoved && endMoved) {
                    modeling.moveConnection(c, delta, topLevel[c.id] && newParent, {updateAnchors: false});
                } else {
                    modeling.layoutConnection(c, {
                        startChanged: startMoved,
                        endChanged: endMoved
                    });
                }
            });
        };

        /**
         * Returns the closure for the selected elements
         *
         * @param  {Array<djs.model.Base>} elements
         * @return {Object} closure
         */
        MoveHelper.prototype.getClosure = function (elements) {
            return Elements.getClosure(elements);
        };

    }, {
        "../../../../util/Elements": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Elements.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../../command'),
                require('../change-support'),
                require('../rules')
            ],
            __init__: ['modeling'],
            modeling: ['type', require('./Modeling')],
            layouter: ['type', require('../../layout/BaseLayouter')]
        };

    }, {
        "../../command": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/index.js",
        "../../layout/BaseLayouter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/BaseLayouter.js",
        "../change-support": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/change-support/index.js",
        "../rules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/index.js",
        "./Modeling": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/Modeling.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/move/Move.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            filter = require('lodash/collection/filter'),
            groupBy = require('lodash/collection/groupBy');


        var LOW_PRIORITY = 500,
            HIGH_PRIORITY = 1500;

        var getOriginalEvent = require('../../util/Event').getOriginal;

        var round = Math.round;


        /**
         * Return a filtered list of elements that do not contain
         * those nested into others.
         *
         * @param  {Array<djs.model.Base>} elements
         *
         * @return {Array<djs.model.Base>} filtered
         */
        function removeNested(elements) {

            var ids = groupBy(elements, 'id');

            return filter(elements, function (element) {
                while (!!(element = element.parent)) {
                    if (ids[element.id]) {
                        return false;
                    }
                }

                return true;
            });
        }


        /**
         * A plugin that makes shapes draggable / droppable.
         *
         * @param {EventBus} eventBus
         * @param {Dragging} dragging
         * @param {Modeling} modeling
         * @param {Selection} selection
         * @param {Rules} rules
         */
        function MoveEvents(eventBus, dragging, modeling, selection, rules) {

            // rules

            function canMove(shapes, delta, target) {

                return rules.allowed('shapes.move', {
                    shapes: shapes,
                    delta: delta,
                    newParent: target
                });
            }


            // move events

            // assign a high priority to this handler to setup the environment
            // others may hook up later, e.g. at default priority and modify
            // the move environment
            //
            eventBus.on('shape.move.start', HIGH_PRIORITY, function (event) {

                var context = event.context,
                    shape = event.shape,
                    shapes = selection.get().slice();

                // move only single shape shape if the dragged element
                // is not part of the current selection
                if (shapes.indexOf(shape) === -1) {
                    shapes = [shape];
                }

                // ensure we remove nested elements in the collection
                shapes = removeNested(shapes);

                // attach shapes to drag context
                assign(context, {
                    shapes: shapes,
                    shape: shape
                });

                // check if we can move the elements
                if (!canMove(shapes)) {
                    // suppress move operation
                    event.stopPropagation();

                    return false;
                }
            });

            // assign a low priority to this handler
            // to let others modify the move event before we update
            // the context
            //
            eventBus.on('shape.move.move', LOW_PRIORITY, function (event) {

                var context = event.context,
                    shapes = context.shapes,
                    hover = event.hover,
                    delta = {x: event.dx, y: event.dy},
                    canExecute;

                // check if we can move the elements
                canExecute = canMove(shapes, delta, hover);

                context.delta = delta;
                context.canExecute = canExecute;

                // simply ignore move over
                if (canExecute === null) {
                    context.target = null;

                    return;
                }

                context.target = hover;
            });

            eventBus.on('shape.move.end', function (event) {

                var context = event.context;

                var delta = context.delta,
                    canExecute = context.canExecute;

                if (!canExecute) {
                    return false;
                }

                // ensure we have actual pixel values deltas
                // (important when zoom level was > 1 during move)
                delta.x = round(delta.x);
                delta.y = round(delta.y);

                modeling.moveShapes(context.shapes, delta, context.target);
            });


            // move activation

            eventBus.on('element.mousedown', function (event) {

                var originalEvent = getOriginalEvent(event);

                if (!originalEvent) {
                    throw new Error('must supply DOM mousedown event');
                }

                start(originalEvent, event.element);
            });


            function start(event, element, activate) {

                // do not move connections or the root element
                if (element.waypoints || !element.parent) {
                    return;
                }

                dragging.activate(event, 'shape.move', {
                    cursor: 'grabbing',
                    autoActivate: activate,
                    data: {
                        shape: element,
                        context: {}
                    }
                });
            }

            // API

            this.start = start;
        }

        MoveEvents.$inject = ['eventBus', 'dragging', 'modeling', 'selection', 'rules'];

        module.exports = MoveEvents;

    }, {
        "../../util/Event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Event.js",
        "lodash/collection/filter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/filter.js",
        "lodash/collection/groupBy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/groupBy.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/move/MoveVisuals.js": [function (require, module, exports) {
        'use strict';

        var flatten = require('lodash/array/flatten'),
            forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter'),
            find = require('lodash/collection/find'),
            map = require('lodash/collection/map');

        var Elements = require('../../util/Elements');

        var LOW_PRIORITY = 500;

        var MARKER_DRAGGING = 'djs-dragging',
            MARKER_OK = 'drop-ok',
            MARKER_NOT_OK = 'drop-not-ok';


        /**
         * A plugin that makes shapes draggable / droppable.
         *
         * @param {EventBus} eventBus
         * @param {ElementRegistry} elementRegistry
         * @param {Canvas} canvas
         * @param {Styles} styles
         */
        function MoveVisuals(eventBus, elementRegistry, canvas, styles) {

            function getGfx(e) {
                return elementRegistry.getGraphics(e);
            }

            function getVisualDragShapes(shapes) {

                var elements = Elements.selfAndDirectChildren(shapes, true);
                var filteredElements = removeEdges(elements);

                return filteredElements;
            }

            function getAllDraggedElements(shapes) {
                var allShapes = Elements.selfAndAllChildren(shapes, true);

                var allConnections = map(allShapes, function (shape) {
                    return (shape.incoming || []).concat(shape.outgoing || []);
                });

                return flatten(allShapes.concat(allConnections), true);
            }

            function addDragger(shape, dragGroup) {
                var gfx = getGfx(shape);
                var dragger = gfx.clone();
                var bbox = gfx.getBBox();

                dragger.attr(styles.cls('djs-dragger', [], {
                    x: bbox.x,
                    y: bbox.y
                }));

                dragGroup.add(dragger);
            }

            // assign a low priority to this handler
            // to let others modify the move context before
            // we draw things
            //
            eventBus.on('shape.move.start', LOW_PRIORITY, function (event) {

                var context = event.context,
                    dragShapes = context.shapes;

                var dragGroup = canvas.getDefaultLayer().group().attr(styles.cls('djs-drag-group', ['no-events']));

                var visuallyDraggedShapes = getVisualDragShapes(dragShapes);

                visuallyDraggedShapes.forEach(function (shape) {
                    addDragger(shape, dragGroup);
                });


                // cache all dragged elements / gfx
                // so that we can quickly undo their state changes later
                var allDraggedElements = context.allDraggedElements = getAllDraggedElements(dragShapes);

                // add dragging marker
                forEach(allDraggedElements, function (e) {
                    canvas.addMarker(e, MARKER_DRAGGING);
                });

                context.dragGroup = dragGroup;
            });

            // assign a low priority to this handler
            // to let others modify the move context before
            // we draw things
            //
            eventBus.on('shape.move.move', LOW_PRIORITY, function (event) {

                var context = event.context,
                    dragGroup = context.dragGroup,
                    target = context.target;

                if (target) {
                    canvas.addMarker(target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
                }

                dragGroup.translate(event.dx, event.dy);
            });

            eventBus.on(['shape.move.out', 'shape.move.cleanup'], function (event) {
                var context = event.context;

                if (context.target) {
                    canvas.removeMarker(context.target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
                }
            });

            eventBus.on('shape.move.cleanup', function (event) {

                var context = event.context,
                    allDraggedElements = context.allDraggedElements,
                    dragGroup = context.dragGroup;


                // remove dragging marker
                forEach(allDraggedElements, function (e) {
                    canvas.removeMarker(e, MARKER_DRAGGING);
                });

                if (dragGroup) {
                    dragGroup.remove();
                }
            });
        }

// returns elements minus all connections
// where source or target is not elements
        function removeEdges(elements) {

            var filteredElements = filter(elements, function (element) {

                if (!element.waypoints) { // shapes
                    return true;
                } else {                  // connections
                    var srcFound = find(elements, element.source);
                    var targetFound = find(elements, element.target);

                    return srcFound && targetFound;
                }
            });

            return filteredElements;
        }

        MoveVisuals.$inject = ['eventBus', 'elementRegistry', 'canvas', 'styles'];

        module.exports = MoveVisuals;

    }, {
        "../../util/Elements": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Elements.js",
        "lodash/array/flatten": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/array/flatten.js",
        "lodash/collection/filter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/filter.js",
        "lodash/collection/find": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/find.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/collection/map": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/map.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/move/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../interaction-events'),
                require('../selection'),
                require('../outline'),
                require('../rules'),
                require('../dragging')
            ],
            __init__: ['move', 'moveVisuals'],
            move: ['type', require('./Move')],
            moveVisuals: ['type', require('./MoveVisuals')]
        };

    }, {
        "../dragging": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/dragging/index.js",
        "../interaction-events": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/interaction-events/index.js",
        "../outline": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/outline/index.js",
        "../rules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/index.js",
        "../selection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/index.js",
        "./Move": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/move/Move.js",
        "./MoveVisuals": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/move/MoveVisuals.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/outline/Outline.js": [function (require, module, exports) {
        'use strict';

        var Snap = require('../../../vendor/snapsvg');
        var getBBox = require('../../util/Elements').getBBox;


        /**
         * @class
         *
         * A plugin that adds an outline to shapes and connections that may be activated and styled
         * via CSS classes.
         *
         * @param {EventBus} events the event bus
         */
        function Outline(eventBus, styles, elementRegistry) {

            var OUTLINE_OFFSET = 6;

            var OUTLINE_STYLE = styles.cls('djs-outline', ['no-fill']);

            function createOutline(gfx, bounds) {
                return Snap.create('rect', OUTLINE_STYLE).prependTo(gfx);
            }

            function updateShapeOutline(outline, bounds) {

                outline.attr({
                    x: -OUTLINE_OFFSET,
                    y: -OUTLINE_OFFSET,
                    width: bounds.width + OUTLINE_OFFSET * 2,
                    height: bounds.height + OUTLINE_OFFSET * 2
                });
            }

            function updateConnectionOutline(outline, connection) {

                var bbox = getBBox(connection);

                outline.attr({
                    x: bbox.x - OUTLINE_OFFSET,
                    y: bbox.y - OUTLINE_OFFSET,
                    width: bbox.width + OUTLINE_OFFSET * 2,
                    height: bbox.height + OUTLINE_OFFSET * 2
                });
            }

            eventBus.on(['shape.added', 'shape.changed'], function (event) {
                var element = event.element,
                    gfx = event.gfx;

                var outline = gfx.select('.djs-outline');

                if (!outline) {
                    outline = createOutline(gfx, element);
                }

                updateShapeOutline(outline, element);
            });

            eventBus.on(['connection.added', 'connection.changed'], function (event) {
                var element = event.element,
                    gfx = event.gfx;

                var outline = gfx.select('.djs-outline');

                if (!outline) {
                    outline = createOutline(gfx, element);
                }

                updateConnectionOutline(outline, element);
            });


        }


        Outline.$inject = ['eventBus', 'styles', 'elementRegistry'];

        module.exports = Outline;

    }, {
        "../../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "../../util/Elements": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Elements.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/outline/index.js": [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['outline'],
            outline: ['type', require('./Outline')]
        };
    }, {"./Outline": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/outline/Outline.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/overlays/Overlays.js": [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            isString = require('lodash/lang/isString'),
            isObject = require('lodash/lang/isObject'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter'),
            debounce = require('lodash/function/debounce');

        var domify = require('min-dom/lib/domify'),
            domClasses = require('min-dom/lib/classes'),
            domRemove = require('min-dom/lib/remove');

        var getBBox = require('../../util/Elements').getBBox;

// document wide unique overlay ids
        var ids = new (require('../../util/IdGenerator'))('ov');


        function createRoot(parent) {
            var root = domify('<div class="djs-overlay-container" style="position: absolute; width: 0; height: 0;" />');
            parent.insertBefore(root, parent.firstChild);

            return root;
        }


        function setPosition(el, x, y) {
            assign(el.style, {left: x + 'px', top: y + 'px'});
        }

        function setVisible(el, visible) {
            el.style.display = visible === false ? 'none' : '';
        }

        /**
         * A service that allows users to attach overlays to diagram elements.
         *
         * The overlay service will take care of overlay positioning during updates.
         *
         * @example
         *
         * // add a pink badge on the top left of the shape
         * overlays.add(someShape, {
 *   position: {
 *     top: -5,
 *     left: -5
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
         *
         * // or add via shape id
         *
         * overlays.add('some-element-id', {
 *   position: {
 *     top: -5,
 *     left: -5
 *   }
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
         *
         * // or add with optional type
         *
         * overlays.add(someShape, 'badge', {
 *   position: {
 *     top: -5,
 *     left: -5
 *   }
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
         *
         *
         * // remove an overlay
         *
         * var id = overlays.add(...);
         * overlays.remove(id);
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         * @param {ElementRegistry} elementRegistry
         */
        function Overlays(config, eventBus, canvas, elementRegistry) {

            this._eventBus = eventBus;
            this._canvas = canvas;
            this._elementRegistry = elementRegistry;

            this._ids = ids;

            this._overlayDefaults = {
                show: {
                    minZoom: 0.7,
                    maxZoom: 5.0
                }
            };

            /**
             * Mapping overlayId -> overlay
             */
            this._overlays = {};

            /**
             * Mapping elementId -> overlay container
             */
            this._overlayContainers = {};

            // root html element for all overlays
            this._overlayRoot = createRoot(canvas.getContainer());

            this._init(config);
        }


        Overlays.$inject = ['config.overlays', 'eventBus', 'canvas', 'elementRegistry'];

        module.exports = Overlays;


        /**
         * Returns the overlay with the specified id or a list of overlays
         * for an element with a given type.
         *
         * @example
         *
         * // return the single overlay with the given id
         * overlays.get('some-id');
         *
         * // return all overlays for the shape
         * overlays.get({ element: someShape });
         *
         * // return all overlays on shape with type 'badge'
         * overlays.get({ element: someShape, type: 'badge' });
         *
         * // shape can also be specified as id
         * overlays.get({ element: 'element-id', type: 'badge' });
         *
         *
         * @param {Object} search
         * @param {String} [search.id]
         * @param {String|djs.model.Base} [search.element]
         * @param {String} [search.type]
         *
         * @return {Object|Array<Object>} the overlay(s)
         */
        Overlays.prototype.get = function (search) {

            if (isString(search)) {
                search = {id: search};
            }

            if (search.element) {
                var container = this._getOverlayContainer(search.element, true);

                // return a list of overlays when searching by element (+type)
                if (container) {
                    return search.type ? filter(container.overlays, {type: search.type}) : container.overlays.slice();
                } else {
                    return [];
                }
            } else if (search.type) {
                return filter(this._overlays, {type: search.type});
            } else {
                // return single element when searching by id
                return search.id ? this._overlays[search.id] : null;
            }
        };

        /**
         * Adds a HTML overlay to an element.
         *
         * @param {String|djs.model.Base}   element   attach overlay to this shape
         * @param {String}                  [type]    optional type to assign to the overlay
         * @param {Object}                  overlay   the overlay configuration
         *
         * @param {String|DOMElement}       overlay.html                 html element to use as an overlay
         * @param {Object}                  [overlay.show]               show configuration
         * @param {Number}                  [overlay.show.minZoom]       minimal zoom level to show the overlay
         * @param {Number}                  [overlay.show.maxZoom]       maximum zoom level to show the overlay
         * @param {Object}                  overlay.position             where to attach the overlay
         * @param {Number}                  [overlay.position.left]      relative to element bbox left attachment
         * @param {Number}                  [overlay.position.top]       relative to element bbox top attachment
         * @param {Number}                  [overlay.position.bottom]    relative to element bbox bottom attachment
         * @param {Number}                  [overlay.position.right]     relative to element bbox right attachment
         *
         * @return {String}                 id that may be used to reference the overlay for update or removal
         */
        Overlays.prototype.add = function (element, type, overlay) {

            if (isObject(type)) {
                overlay = type;
                type = null;
            }

            if (!element.id) {
                element = this._elementRegistry.get(element);
            }

            if (!overlay.position) {
                throw new Error('must specifiy overlay position');
            }

            if (!overlay.html) {
                throw new Error('must specifiy overlay html');
            }

            if (!element) {
                throw new Error('invalid element specified');
            }

            var id = this._ids.next();

            overlay = assign({}, this._overlayDefaults, overlay, {
                id: id,
                type: type,
                element: element,
                html: overlay.html
            });

            this._addOverlay(overlay);

            return id;
        };


        /**
         * Remove an overlay with the given id or all overlays matching the given filter.
         *
         * @see Overlays#get for filter options.
         *
         * @param {String} [id]
         * @param {Object} [filter]
         */
        Overlays.prototype.remove = function (filter) {

            var overlays = this.get(filter) || [];

            if (!isArray(overlays)) {
                overlays = [overlays];
            }

            var self = this;

            forEach(overlays, function (overlay) {

                var container = self._getOverlayContainer(overlay.element, true);

                if (overlay) {
                    domRemove(overlay.html);
                    domRemove(overlay.htmlContainer);

                    delete overlay.htmlContainer;
                    delete overlay.element;

                    delete self._overlays[overlay.id];
                }

                if (container) {
                    var idx = container.overlays.indexOf(overlay);
                    if (idx !== -1) {
                        container.overlays.splice(idx, 1);
                    }
                }
            });

        };


        Overlays.prototype.show = function () {
            setVisible(this._overlayRoot);
        };


        Overlays.prototype.hide = function () {
            setVisible(this._overlayRoot, false);
        };


        Overlays.prototype._updateOverlayContainer = function (container) {
            var element = container.element,
                html = container.html;

            // update container left,top according to the elements x,y coordinates
            // this ensures we can attach child elements relative to this container

            var x = element.x,
                y = element.y;

            if (element.waypoints) {
                var bbox = getBBox(element);
                x = bbox.x;
                y = bbox.y;
            }

            setPosition(html, x, y);
        };


        Overlays.prototype._updateOverlay = function (overlay) {

            var position = overlay.position,
                htmlContainer = overlay.htmlContainer,
                element = overlay.element;

            // update overlay html relative to shape because
            // it is already positioned on the element

            // update relative
            var left = position.left,
                top = position.top;

            if (position.right !== undefined) {

                var width;

                if (element.waypoints) {
                    width = getBBox(element).width;
                } else {
                    width = element.width;
                }

                left = position.right * -1 + width;
            }

            if (position.bottom !== undefined) {

                var height;

                if (element.waypoints) {
                    height = getBBox(element).height;
                } else {
                    height = element.height;
                }

                top = position.bottom * -1 + height;
            }

            setPosition(htmlContainer, left || 0, top || 0);
        };


        Overlays.prototype._createOverlayContainer = function (element) {
            var html = domify('<div class="djs-overlays djs-overlays-' + element.id + '" style="position: absolute" />');

            this._overlayRoot.appendChild(html);

            var container = {
                html: html,
                element: element,
                overlays: []
            };

            this._updateOverlayContainer(container);

            return container;
        };


        Overlays.prototype._updateRoot = function (viewbox) {
            var a = viewbox.scale || 1;
            var d = viewbox.scale || 1;

            var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';

            this._overlayRoot.style.transform = matrix;
            this._overlayRoot.style['-ms-transform'] = matrix;
        };


        Overlays.prototype._getOverlayContainer = function (element, raw) {
            var id = (element && element.id) || element;

            var container = this._overlayContainers[id];
            if (!container && !raw) {
                container = this._overlayContainers[id] = this._createOverlayContainer(element);
            }

            return container;
        };


        Overlays.prototype._addOverlay = function (overlay) {

            var id = overlay.id,
                element = overlay.element,
                html = overlay.html,
                htmlContainer,
                overlayContainer;

            // unwrap jquery (for those who need it)
            if (html.get) {
                html = html.get(0);
            }

            // create proper html elements from
            // overlay HTML strings
            if (isString(html)) {
                html = domify(html);
            }

            overlayContainer = this._getOverlayContainer(element);

            htmlContainer = domify('<div class="djs-overlay" data-overlay-id="' + id + '" style="position: absolute">');

            htmlContainer.appendChild(html);

            if (overlay.type) {
                domClasses(htmlContainer).add('djs-overlay-' + overlay.type);
            }

            overlay.htmlContainer = htmlContainer;

            overlayContainer.overlays.push(overlay);
            overlayContainer.html.appendChild(htmlContainer);

            this._overlays[id] = overlay;

            this._updateOverlay(overlay);
        };

        Overlays.prototype._updateOverlayVisibilty = function (viewbox) {

            forEach(this._overlays, function (overlay) {
                var show = overlay.show,
                    htmlContainer = overlay.htmlContainer,
                    visible = true;

                if (show) {
                    if (show.minZoom > viewbox.scale ||
                        show.maxZoom < viewbox.scale) {
                        visible = false;
                    }

                    setVisible(htmlContainer, visible);
                }
            });
        };

        Overlays.prototype._init = function (config) {

            var eventBus = this._eventBus;

            var self = this;


            // scroll/zoom integration

            var updateViewbox = function (viewbox) {
                self._updateRoot(viewbox);
                self._updateOverlayVisibilty(viewbox);

                self.show();
            };

            if (!config || config.deferUpdate !== false) {
                updateViewbox = debounce(updateViewbox, 300);
            }

            eventBus.on('canvas.viewbox.changed', function (event) {
                self.hide();
                updateViewbox(event.viewbox);
            });


            // remove integration

            eventBus.on(['shape.remove', 'connection.remove'], function (e) {
                var overlays = self.get({element: e.element});

                forEach(overlays, function (o) {
                    self.remove(o.id);
                });
            });


            // move integration

            eventBus.on([
                'element.changed'
            ], function (e) {
                var element = e.element;

                var container = self._getOverlayContainer(element, true);

                if (container) {
                    forEach(container.overlays, function (overlay) {
                        self._updateOverlay(overlay);
                    });

                    self._updateOverlayContainer(container);
                }
            });


            // marker integration, simply add them on the overlays as classes, too.

            eventBus.on('element.marker.update', function (e) {
                var container = self._getOverlayContainer(e.element, true);
                if (container) {
                    domClasses(container.html)[e.add ? 'add' : 'remove'](e.marker);
                }
            });
        };

    }, {
        "../../util/Elements": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Elements.js",
        "../../util/IdGenerator": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/IdGenerator.js",
        "lodash/collection/filter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/filter.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/function/debounce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/debounce.js",
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "lodash/lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js",
        "lodash/lang/isString": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isString.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "min-dom/lib/classes": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/classes.js",
        "min-dom/lib/domify": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/domify.js",
        "min-dom/lib/remove": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/remove.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/overlays/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['overlays'],
            overlays: ['type', require('./Overlays')]
        };
    }, {"./Overlays": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/overlays/Overlays.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/palette/Palette.js": [function (require, module, exports) {
        'use strict';

        var isFunction = require('lodash/lang/isFunction'),
            forEach = require('lodash/collection/forEach');

        var domify = require('min-dom/lib/domify'),
            domQuery = require('min-dom/lib/query'),
            domAttr = require('min-dom/lib/attr'),
            domClear = require('min-dom/lib/clear'),
            domClasses = require('min-dom/lib/classes'),
            domMatches = require('min-dom/lib/matches'),
            domDelegate = require('min-dom/lib/delegate'),
            domEvent = require('min-dom/lib/event');


        var toggleSelector = '.djs-palette-toggle',
            entrySelector = '.entry',
            elementSelector = toggleSelector + ', ' + entrySelector;


        /**
         * A palette containing modeling elements.
         */
        function Palette(eventBus, canvas) {

            this._eventBus = eventBus;
            this._canvas = canvas;

            this._providers = [];
        }

        Palette.$inject = ['eventBus', 'canvas'];

        module.exports = Palette;


        /**
         * Register a provider with the palette
         *
         * @param  {PaletteProvider} provider
         */
        Palette.prototype.registerProvider = function (provider) {
            this._providers.push(provider);

            if (!this._container) {
                this._init();
            }

            this._update();
        };


        /**
         * Returns the palette entries for a given element
         *
         * @return {Array<PaletteEntryDescriptor>} list of entries
         */
        Palette.prototype.getEntries = function () {

            var entries = {};

            // loop through all providers and their entries.
            // group entries by id so that overriding an entry is possible
            forEach(this._providers, function (provider) {
                var e = provider.getPaletteEntries();

                forEach(e, function (entry, id) {
                    entries[id] = entry;
                });
            });

            return entries;
        };


        /**
         * Initialize
         */
        Palette.prototype._init = function () {
            var parent = this._canvas.getContainer(),
                container = this._container = domify(Palette.HTML_MARKUP),
                self = this;

            parent.appendChild(container);

            domDelegate.bind(container, elementSelector, 'click', function (event) {

                var target = event.delegateTarget;

                if (domMatches(target, toggleSelector)) {
                    return self.toggle();
                }

                self.trigger('click', event);
            });

            // prevent drag propagation
            domEvent.bind(container, 'mousedown', function (event) {
                event.stopPropagation();
            });

            // prevent drag propagation
            domDelegate.bind(container, entrySelector, 'dragstart', function (event) {
                self.trigger('dragstart', event);
            });

            this._eventBus.fire('palette.create', {
                html: container
            });
        };


        Palette.prototype._update = function () {

            var entriesContainer = domQuery('.djs-palette-entries', this._container),
                entries = this._entries = this.getEntries();

            domClear(entriesContainer);

            forEach(entries, function (entry, id) {

                var grouping = entry.group || 'default';

                var container = domQuery('[data-group=' + grouping + ']', entriesContainer);
                if (!container) {
                    container = domify('<div class="group" data-group="' + grouping + '"></div>');
                    entriesContainer.appendChild(container);
                }

                var html = entry.html || (
                        entry.separator ?
                            '<hr class="separator" />' :
                            '<div class="entry" draggable="true"></div>');


                var control = domify(html);
                container.appendChild(control);

                if (!entry.separator) {
                    domAttr(control, 'data-action', id);

                    if (entry.title) {
                        domAttr(control, 'title', entry.title);
                    }

                    if (entry.className) {
                        domClasses(control).add(entry.className);
                    }

                    if (entry.imageUrl) {
                        control.appendChild(domify('<img src="' + entry.imageUrl + '">'));
                    }
                }
            });

            // open after update
            this.open(true);
        };


        /**
         * Trigger an action available on the palette
         *
         * @param  {String} action
         * @param  {Event} event
         */
        Palette.prototype.trigger = function (action, event, autoActivate) {

            var entries = this._entries,
                entry,
                handler,
                originalEvent,
                button = event.delegateTarget || event.target;

            if (!button) {
                return event.preventDefault();
            }


            entry = entries[domAttr(button, 'data-action')];
            handler = entry.action;

            originalEvent = event.originalEvent || event;

            // simple action (via callback function)
            if (isFunction(handler)) {
                if (action === 'click') {
                    return handler(originalEvent, autoActivate);
                }
            } else {
                if (handler[action]) {
                    return handler[action](originalEvent, autoActivate);
                }
            }

            // silence other actions
            event.preventDefault();
        };


        /**
         * Close the palette
         */
        Palette.prototype.close = function () {
            domClasses(this._container).remove('open');
        };


        /**
         * Open the palette
         */
        Palette.prototype.open = function () {
            domClasses(this._container).add('open');
        };


        Palette.prototype.toggle = function (open) {
            if (this.isOpen()) {
                this.close();
            } else {
                this.open();
            }
        };


        /**
         * Return true if the palette is opened.
         *
         * @example
         *
         * palette.open();
         *
         * if (palette.isOpen()) {
 *   // yes, we are open
 * }
         *
         * @return {boolean} true if palette is opened
         */
        Palette.prototype.isOpen = function () {
            return this._container && domClasses(this._container).has('open');
        };


        /* markup definition */

        Palette.HTML_MARKUP =
            '<div class="djs-palette">' +
            '<div class="djs-palette-entries"></div>' +
            '<div class="djs-palette-toggle"></div>' +
            '</div>';
    }, {
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/lang/isFunction": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isFunction.js",
        "min-dom/lib/attr": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/attr.js",
        "min-dom/lib/classes": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/classes.js",
        "min-dom/lib/clear": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/clear.js",
        "min-dom/lib/delegate": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/delegate.js",
        "min-dom/lib/domify": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/domify.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js",
        "min-dom/lib/matches": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/matches.js",
        "min-dom/lib/query": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/query.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/palette/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['palette'],
            palette: ['type', require('./Palette')]
        };

    }, {"./Palette": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/palette/Palette.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            assign = require('lodash/object/assign'),
            domEvent = require('min-dom/lib/event'),
            domify = require('min-dom/lib/domify'),
            domClasses = require('min-dom/lib/classes'),
            domAttr = require('min-dom/lib/attr'),
            domRemove = require('min-dom/lib/remove');


        function PopupMenu(eventBus, canvas) {

            this._eventBus = eventBus;
            this._canvas = canvas;
            this._instances = {};
        }

        PopupMenu.$inject = ['eventBus', 'canvas'];

        module.exports = PopupMenu;

        PopupMenu.prototype.open = function (name, position, entries, options) {

            var outer = this,
                canvas = this._canvas,
                instances = outer._instances;

            // return existing instance
            if (instances[name]) {
                return instances[name];
            }

            var parent = canvas.getContainer();

            //------------------------
            function PopupMenuInstance() {

                var self = this;

                self._actions = {};
                self.name = name || 'popup-menu';

                var _options = {
                    entryClassName: 'entry'
                };
                assign(_options, options);

                // Container setup
                var container = this._container = domify('<div class="djs-popup">');

                assign(container.style, {
                    position: 'absolute',
                    left: position.x + 'px',
                    top: position.y + 'px'
                });
                domClasses(container).add(name);

                // Add entries
                forEach(entries, function (entry) {

                    var entryContainer = domify('<div>');
                    domClasses(entryContainer).add(entry.className || _options.entryClassName);
                    domClasses(entryContainer).add('djs-popup-entry');

                    if (entry.style) {
                        domAttr(entryContainer, 'style', entry.style);
                    }

                    if (entry.action) {
                        domAttr(entryContainer, 'data-action', entry.action.name);
                        self._actions[entry.action.name] = entry.action.handler;
                    }

                    var title = domify('<span>');
                    title.textContent = entry.label;
                    entryContainer.appendChild(title);

                    container.appendChild(entryContainer);
                });

                // Event handler
                domEvent.bind(container, 'click', function (event) {
                    self.trigger(event);
                });

                // apply canvas zoom level
                var zoom = canvas.zoom();

                container.style.transformOrigin = 'top left';
                container.style.transform = 'scale(' + zoom + ')';

                // Attach to DOM
                parent.appendChild(container);

                // Add Handler
                this.bindHandlers();
            }

            PopupMenuInstance.prototype.close = function () {
                this.unbindHandlers();
                domRemove(this._container);
                delete outer._instances[this.name];
            };

            PopupMenuInstance.prototype.bindHandlers = function () {

                var self = this,
                    eventBus = outer._eventBus;

                this._closeHandler = function () {
                    self.close();
                };

                eventBus.once('contextPad.close', this._closeHandler);
                eventBus.once('canvas.viewbox.changed', this._closeHandler);
            };

            PopupMenuInstance.prototype.unbindHandlers = function () {

                var eventBus = outer._eventBus;

                eventBus.off('contextPad.close', this._closeHandler);
                eventBus.off('canvas.viewbox.changed', this._closeHandler);
            };

            PopupMenuInstance.prototype.trigger = function (event) {

                var element = event.target,
                    actionName = element.getAttribute('data-action') ||
                        element.parentNode.getAttribute('data-action');

                var action = this._actions[actionName];


                if (action) {
                    action();
                }

                // silence other actions
                event.preventDefault();
            };

            var instance = outer._instances[name] = new PopupMenuInstance(position, entries, parent, options);

            return instance;
        };

    }, {
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "min-dom/lib/attr": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/attr.js",
        "min-dom/lib/classes": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/classes.js",
        "min-dom/lib/domify": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/domify.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js",
        "min-dom/lib/remove": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/remove.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/popup-menu/index.js": [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['popupMenu'],
            popupMenu: ['type', require('./PopupMenu')]
        };

    }, {"./PopupMenu": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/replace/Replace.js": [function (require, module, exports) {
        'use strict';


        /**
         * Service that allow replacing of elements.
         *
         *
         * @class
         * @constructor
         */
        function Replace(modeling) {

            this._modeling = modeling;
        }

        module.exports = Replace;

        Replace.$inject = ['modeling'];

        /**
         * @param {Element} oldElement - Element to be replaced
         * @param {Object}  newElementData - Containing information about the new Element, for example height, width, type.
         * @param {Object}  options - Custom options that will be attached to the context. It can be used to inject data
         *                            that is needed in the command chain. For example it could be used in
         *                            eventbus.on('commandStack.shape.replace.postExecute') to change shape attributes after
         *                            shape creation.
         */
        Replace.prototype.replaceElement = function (oldElement, newElementData, options) {

            var modeling = this._modeling;

            var newElement = null;

            if (oldElement.waypoints) {
                // TODO
                // modeling.replaceConnection
            } else {
                // set center of element for modeling API
                // if no new width / height is given use old elements size
                newElementData.x = oldElement.x + (newElementData.width || oldElement.width) / 2;
                newElementData.y = oldElement.y + (newElementData.height || oldElement.height) / 2;

                newElement = modeling.replaceShape(oldElement, newElementData, options);
            }

            return newElement;
        };

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/replace/index.js": [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['replace'],
            replace: ['type', require('./Replace')]
        };

    }, {"./Replace": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/replace/Replace.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/resize/Resize.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter'),
            pick = require('lodash/object/pick');

        var ResizeUtil = require('./ResizeUtil'),
            domEvent = require('min-dom/lib/event'),
            Elements = require('../../util/Elements');

        var isPrimaryButton = require('../../util/Mouse').isPrimaryButton;

        var round = Math.round;

        var Snap = require('../../../vendor/snapsvg');

        var HANDLE_OFFSET = -2,
            HANDLE_SIZE = 5,
            HANDLE_HIT_SIZE = 20;

        var MARKER_RESIZING = 'djs-resizing',
            MARKER_RESIZE_NOT_OK = 'resize-not-ok',
            CLS_RESIZER = 'djs-resizer';


        /**
         * Implements resize on shapes by
         *
         *   * adding resize handles,
         *   * creating a visual during resize
         *   * checking resize rules
         *   * committing a change once finished
         *
         *
         *  ## Customizing
         *
         *  It's possible to customize the resizing behaviour by intercepting 'resize.start'
         *  and providing the following parameters through the 'context':
         *
         *    * minDimensions ({ width, height }) - Minimum shape dimensions
         *    * childrenBoxPadding (number) - Gap between the minimum bounding box and the container
         *
         *  f.ex:
         *
         *  eventBus.on('resize.start', 1500, function(event) {
 *    var context = event.context,
 *
 *   context.minDimensions = { width: 140, height: 120 };
 *   context.childrenBoxPadding = 30;
 *  });
         */

        function Resize(eventBus, elementRegistry, rules, modeling, canvas, selection, dragging) {

            function canResize(context) {
                var ctx = pick(context, ['newBounds', 'shape', 'delta', 'direction']);
                return rules.allowed('shape.resize', ctx);
            }


            // resizing implementation //////////////////////////////////

            /**
             * A helper that realizes the resize visuals
             */
            var visuals = {
                create: function (context) {
                    var container = canvas.getDefaultLayer(),
                        shape = context.shape,
                        frame;

                    frame = context.frame = Snap.create('rect', {
                        class: 'djs-resize-overlay',
                        width: shape.width + 10,
                        height: shape.height + 10,
                        x: shape.x - 5,
                        y: shape.y - 5
                    });

                    frame.appendTo(container);
                },

                update: function (context) {
                    var frame = context.frame,
                        bounds = context.newBounds;

                    if (bounds.width > 5) {
                        frame.attr({
                            x: bounds.x,
                            width: bounds.width
                        });
                    }

                    if (bounds.height > 5) {
                        frame.attr({
                            y: bounds.y,
                            height: bounds.height
                        });
                    }

                    frame[context.canExecute ? 'removeClass' : 'addClass'](MARKER_RESIZE_NOT_OK);
                },

                remove: function (context) {
                    if (context.frame) {
                        context.frame.remove();
                    }
                }
            };

            function computeMinBoundaryBox(context) {

                var shape = context.shape,
                    direction = context.direction,
                    minDimensions = context.minDimensions || {},
                    childrenBoxPadding = context.childrenBoxPadding || 20,
                    children,
                    minBoundaryBox;

                // grab all the shapes that are NOT labels or connections
                children = filter(shape.children, function (child) {
                    // connections
                    if (child.waypoints) {
                        return false;
                    }

                    // labels
                    if (child.type === 'label') {
                        return false;
                    }

                    return true;
                });

                // compute a minimum bounding box
                // around the existing children
                if (children.length) {
                    minBoundaryBox = Elements.getBBox(children);

                    // add a gap between the minBoundaryBox and the resizable container
                    minBoundaryBox.width += childrenBoxPadding * 2;
                    minBoundaryBox.height += childrenBoxPadding * 2;
                    minBoundaryBox.x -= childrenBoxPadding;
                    minBoundaryBox.y -= childrenBoxPadding;
                } else {
                    minBoundaryBox = ResizeUtil.getMinResizeBounds(direction, shape, {
                        width: minDimensions.width || 10,
                        height: minDimensions.height || 10
                    });
                }

                return minBoundaryBox;
            }

            eventBus.on('resize.start', function (event) {

                var context = event.context,
                    shape = context.shape,
                    minBoundaryBox = context.minBoundaryBox;

                if (minBoundaryBox === undefined) {
                    context.minBoundaryBox = computeMinBoundaryBox(context);
                }

                // add resizable indicator
                canvas.addMarker(shape, MARKER_RESIZING);

                visuals.create(context);
            });

            eventBus.on('resize.move', function (event) {

                var context = event.context,
                    shape = context.shape,
                    direction = context.direction,
                    minBoundaryBox = context.minBoundaryBox,
                    delta;

                delta = {
                    x: event.dx,
                    y: event.dy
                };

                context.delta = delta;

                context.newBounds = ResizeUtil.resizeBounds(shape, direction, delta);

                if (minBoundaryBox) {
                    context.newBounds = ResizeUtil.ensureMinBounds(context.newBounds, minBoundaryBox);
                }

                // update + cache executable state
                context.canExecute = canResize(context);

                // update resize frame visuals
                visuals.update(context);
            });

            eventBus.on('resize.end', function (event) {
                var context = event.context,
                    shape = context.shape;

                var newBounds = context.newBounds;


                // ensure we have actual pixel values for new bounds
                // (important when zoom level was > 1 during move)
                newBounds.x = round(newBounds.x);
                newBounds.y = round(newBounds.y);
                newBounds.width = round(newBounds.width);
                newBounds.height = round(newBounds.height);

                // perform the actual resize
                if (context.canExecute) {
                    modeling.resizeShape(shape, context.newBounds);
                }
            });

            eventBus.on('resize.cleanup', function (event) {

                var context = event.context,
                    shape = context.shape;

                // remove resizable indicator
                canvas.removeMarker(shape, MARKER_RESIZING);

                // remove frame + destroy context
                visuals.remove(context);
            });


            function activate(event, shape, direction) {

                dragging.activate(event, 'resize', {
                    autoActivate: true,
                    cursor: 'resize-' + (/nw|se/.test(direction) ? 'nwse' : 'nesw'),
                    data: {
                        shape: shape,
                        context: {
                            direction: direction,
                            shape: shape
                        }
                    }
                });
            }

            function makeDraggable(element, gfx, direction) {

                function listener(event) {
                    // only trigger on left mouse button
                    if (isPrimaryButton(event)) {
                        activate(event, element, direction);
                    }
                }

                domEvent.bind(gfx.node, 'mousedown', listener);
                domEvent.bind(gfx.node, 'touchstart', listener);
            }

            function __createResizer(gfx, x, y, rotation, direction) {

                var group = gfx.group().addClass(CLS_RESIZER).addClass(CLS_RESIZER + '-' + direction);

                var origin = -HANDLE_SIZE + HANDLE_OFFSET;

                // Create four drag indicators on the outline
                group.rect(origin, origin, HANDLE_SIZE, HANDLE_SIZE).addClass(CLS_RESIZER + '-visual');
                group.rect(origin, origin, HANDLE_HIT_SIZE, HANDLE_HIT_SIZE).addClass(CLS_RESIZER + '-hit');

                var matrix = new Snap.Matrix().translate(x, y).rotate(rotation, 0, 0);
                group.transform(matrix);

                return group;
            }

            function createResizer(element, gfx, direction) {

                var resizer;

                if (direction === 'nw') {
                    resizer = __createResizer(gfx, 0, 0, 0, direction);
                } else if (direction === 'ne') {
                    resizer = __createResizer(gfx, element.width, 0, 90, direction);
                } else if (direction === 'se') {
                    resizer = __createResizer(gfx, element.width, element.height, 180, direction);
                } else {
                    resizer = __createResizer(gfx, 0, element.height, 270, direction);
                }

                makeDraggable(element, resizer, direction);
            }

            // resize handles implementation ///////////////////////////////

            function addResize(shape) {

                if (!canResize({shape: shape})) {
                    return;
                }

                var gfx = elementRegistry.getGraphics(shape);

                createResizer(shape, gfx, 'nw');
                createResizer(shape, gfx, 'ne');
                createResizer(shape, gfx, 'se');
                createResizer(shape, gfx, 'sw');
            }

            function removeResize(shape) {

                var gfx = elementRegistry.getGraphics(shape);
                var resizers = gfx.selectAll('.' + CLS_RESIZER);

                forEach(resizers, function (resizer) {
                    resizer.remove();
                });
            }

            eventBus.on('selection.changed', function (e) {

                var oldSelection = e.oldSelection,
                    newSelection = e.newSelection;

                // remove old selection markers
                forEach(oldSelection, removeResize);

                // add new selection markers ONLY if single selection
                if (newSelection.length === 1) {
                    forEach(newSelection, addResize);
                }
            });

            eventBus.on('shape.changed', function (e) {
                var shape = e.element;

                removeResize(shape);

                if (selection.isSelected(shape)) {
                    addResize(shape);
                }
            });


            // API

            this.activate = activate;
        }

        Resize.$inject = ['eventBus', 'elementRegistry', 'rules', 'modeling', 'canvas', 'selection', 'dragging'];

        module.exports = Resize;

    }, {
        "../../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "../../util/Elements": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Elements.js",
        "../../util/Mouse": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Mouse.js",
        "./ResizeUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/resize/ResizeUtil.js",
        "lodash/collection/filter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/filter.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/object/pick": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/pick.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/resize/ResizeUtil.js": [function (require, module, exports) {
        'use strict';

        /**
         * Resize the given bounds by the specified delta from a given anchor point.
         *
         * @param {Bounds} bounds the bounding box that should be resized
         * @param {String} direction in which the element is resized (nw, ne, se, sw)
         * @param {Point} delta of the resize operation
         *
         * @return {Bounds} resized bounding box
         */
        module.exports.resizeBounds = function (bounds, direction, delta) {

            var dx = delta.x,
                dy = delta.y;

            switch (direction) {

                case 'nw':
                    return {
                        x: bounds.x + dx,
                        y: bounds.y + dy,
                        width: bounds.width - dx,
                        height: bounds.height - dy
                    };

                case 'sw':
                    return {
                        x: bounds.x + dx,
                        y: bounds.y,
                        width: bounds.width - dx,
                        height: bounds.height + dy
                    };

                case 'ne':
                    return {
                        x: bounds.x,
                        y: bounds.y + dy,
                        width: bounds.width + dx,
                        height: bounds.height - dy
                    };

                case 'se':
                    return {
                        x: bounds.x,
                        y: bounds.y,
                        width: bounds.width + dx,
                        height: bounds.height + dy
                    };

                default:
                    throw new Error('unrecognized direction: ' + direction);
            }
        };

        module.exports.reattachPoint = function (bounds, newBounds, point) {

            var sx = bounds.width / newBounds.width,
                sy = bounds.height / newBounds.height;

            return {
                x: Math.round((newBounds.x + newBounds.width / 2)) - Math.floor(((bounds.x + bounds.width / 2) - point.x) / sx),
                y: Math.round((newBounds.y + newBounds.height / 2)) - Math.floor(((bounds.y + bounds.height / 2) - point.y) / sy)
            };
        };


        module.exports.ensureMinBounds = function (currentBounds, minBounds) {
            var topLeft = {
                x: Math.min(currentBounds.x, minBounds.x),
                y: Math.min(currentBounds.y, minBounds.y)
            };

            var bottomRight = {
                x: Math.max(currentBounds.x + currentBounds.width, minBounds.x + minBounds.width),
                y: Math.max(currentBounds.y + currentBounds.height, minBounds.y + minBounds.height)
            };

            return {
                x: topLeft.x,
                y: topLeft.y,
                width: bottomRight.x - topLeft.x,
                height: bottomRight.y - topLeft.y
            };
        };


        module.exports.getMinResizeBounds = function (direction, currentBounds, minDimensions) {

            switch (direction) {
                case 'nw':
                    return {
                        x: currentBounds.x + currentBounds.width - minDimensions.width,
                        y: currentBounds.y + currentBounds.height - minDimensions.height,
                        width: minDimensions.width,
                        height: minDimensions.height
                    };
                case 'sw':
                    return {
                        x: currentBounds.x + currentBounds.width - minDimensions.width,
                        y: currentBounds.y,
                        width: minDimensions.width,
                        height: minDimensions.height
                    };
                case 'ne':
                    return {
                        x: currentBounds.x,
                        y: currentBounds.y + currentBounds.height - minDimensions.height,
                        width: minDimensions.width,
                        height: minDimensions.height
                    };
                case 'se':
                    return {
                        x: currentBounds.x,
                        y: currentBounds.y,
                        width: minDimensions.width,
                        height: minDimensions.height
                    };
                default:
                    throw new Error('unrecognized direction: ' + direction);
            }
        };


    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/resize/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../modeling'),
                require('../rules'),
                require('../dragging')
            ],
            __init__: ['resize'],
            resize: ['type', require('./Resize')]
        };

    }, {
        "../dragging": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/dragging/index.js",
        "../modeling": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/index.js",
        "../rules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/index.js",
        "./Resize": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/resize/Resize.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/RuleProvider.js": [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('../../command/CommandInterceptor');

        /**
         * A basic provider that may be extended to implement modeling rules.
         *
         * Extensions should implement the init method to actually add their custom
         * modeling checks. Checks may be added via the #addRule(action, fn) method.
         *
         * @param {EventBus} eventBus
         */
        function RuleProvider(eventBus) {
            CommandInterceptor.call(this, eventBus);

            this.init();
        }

        RuleProvider.$inject = ['eventBus'];

        inherits(RuleProvider, CommandInterceptor);

        module.exports = RuleProvider;


        /**
         * Adds a modeling rule for the given action, implemented through a callback function.
         *
         * The function will receive the modeling specific action context to perform its check.
         * It must return false or null to disallow the action from happening.
         *
         * Returning <code>null</code> may encode simply ignoring the action.
         *
         * @example
         *
         * ResizableRules.prototype.init = function() {
 *
 *   this.addRule('shape.resize', function(context) {
 *
 *     var shape = context.shape;
 *
 *     if (!context.newBounds) {
 *       // check general resizability
 *       if (!shape.resizable) {
 *         return false;
 *       }
 *     } else {
 *       // element must have minimum size of 10*10 points
 *       return context.newBounds.width > 10 && context.newBounds.height > 10;
 *     }
 *   });
 * };
         *
         * @param {String|Array<String>} actions the identifier for the modeling action to check
         * @param {Function} fn the callback function that performs the actual check
         */
        RuleProvider.prototype.addRule = function (actions, fn) {

            var self = this;

            if (typeof actions === 'string') {
                actions = [actions];
            }

            actions.forEach(function (action) {

                self.canExecute(action, function (context, action, event) {
                    return fn(context);
                }, true);
            });
        };
    }, {
        "../../command/CommandInterceptor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/CommandInterceptor.js",
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/inherits/inherits_browser.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/Rules.js": [function (require, module, exports) {
        'use strict';

        /**
         * A service that provides rules for certain diagram actions.
         *
         * @param {CommandStack} commandStack
         */
        function Rules(commandStack) {
            this._commandStack = commandStack;
        }

        Rules.$inject = ['commandStack'];

        module.exports = Rules;


        /**
         * This method can be queried to ask whether certain modeling actions
         * are allowed or not.
         *
         * @param  {String} action the action to be checked
         * @param  {Object} [context] the context to check the action in
         *
         * @return {Boolean} returns true, false or null depending on whether the
         *                   operation is allowed, not allowed or should be ignored.
         */
        Rules.prototype.allowed = function (action, context) {
            var allowed = this._commandStack.canExecute(action, context);

            // map undefined to true, i.e. no rules
            return allowed === undefined ? true : allowed;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../../command')],
            __init__: ['rules'],
            rules: ['type', require('./Rules')]
        };

    }, {
        "../../command": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/command/index.js",
        "./Rules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/Rules.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/Selection.js": [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            forEach = require('lodash/collection/forEach');


        /**
         * A service that offers the current selection in a diagram.
         * Offers the api to control the selection, too.
         *
         * @class
         *
         * @param {EventBus} eventBus the event bus
         */
        function Selection(eventBus) {

            this._eventBus = eventBus;

            this._selectedElements = [];

            var self = this;

            eventBus.on(['shape.remove', 'connection.remove'], function (e) {
                var element = e.element;
                self.deselect(element);
            });
        }

        Selection.$inject = ['eventBus'];

        module.exports = Selection;


        Selection.prototype.deselect = function (element) {
            var selectedElements = this._selectedElements;

            var idx = selectedElements.indexOf(element);

            if (idx !== -1) {
                var oldSelection = selectedElements.slice();

                selectedElements.splice(idx, 1);

                this._eventBus.fire('selection.changed', {oldSelection: oldSelection, newSelection: selectedElements});
            }
        };


        Selection.prototype.get = function () {
            return this._selectedElements;
        };

        Selection.prototype.isSelected = function (element) {
            return this._selectedElements.indexOf(element) !== -1;
        };


        /**
         * This method selects one or more elements on the diagram.
         *
         * By passing an additional add parameter you can decide whether or not the element(s)
         * should be added to the already existing selection or not.
         *
         * @method Selection#select
         *
         * @param  {Object|Object[]} elements element or array of elements to be selected
         * @param  {boolean} [add] whether the element(s) should be appended to the current selection, defaults to false
         */
        Selection.prototype.select = function (elements, add) {
            var selectedElements = this._selectedElements,
                oldSelection = selectedElements.slice();

            if (!isArray(elements)) {
                elements = elements ? [elements] : [];
            }

            // selection may be cleared by passing an empty array or null
            // to the method
            if (add) {
                forEach(elements, function (element) {
                    if (selectedElements.indexOf(element) !== -1) {
                        // already selected
                        return;
                    } else {
                        selectedElements.push(element);
                    }
                });
            } else {
                this._selectedElements = selectedElements = elements.slice();
            }
            this._eventBus.fire('selection.changed', {oldSelection: oldSelection, newSelection: selectedElements});
        };

    }, {
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/SelectionBehavior.js": [function (require, module, exports) {
        'use strict';

        var hasPrimaryModifier = require('../../util/Mouse').hasPrimaryModifier;


        function SelectionBehavior(eventBus, selection, canvas) {

            eventBus.on('create.end', 500, function (e) {
                if (e.context.canExecute) {
                    selection.select(e.shape);
                }
            });

            eventBus.on('connect.end', 500, function (e) {
                if (e.context.canExecute && e.context.target) {
                    selection.select(e.context.target);
                }
            });

            eventBus.on('shape.move.end', 500, function (e) {
                selection.select(e.context.shapes);
            });


            // Shift + click selection
            eventBus.on('element.click', function (event) {

                var element = event.element;

                // do not select the root element
                // or connections
                if (element === canvas.getRootElement()) {
                    element = null;
                }

                var isSelected = selection.isSelected(element),
                    isMultiSelect = selection.get().length > 1;

                // mouse-event: SELECTION_KEY
                var add = hasPrimaryModifier(event);

                // select OR deselect element in multi selection
                if (isSelected && isMultiSelect) {
                    if (add) {
                        return selection.deselect(element);
                    } else {
                        return selection.select(element);
                    }
                } else if (!isSelected) {
                    selection.select(element, add);
                } else {
                    selection.deselect(element);
                }
            });
        }

        SelectionBehavior.$inject = ['eventBus', 'selection', 'canvas'];

        module.exports = SelectionBehavior;

    }, {"../../util/Mouse": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Mouse.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/SelectionVisuals.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var MARKER_HOVER = 'hover',
            MARKER_SELECTED = 'selected';


        /**
         * A plugin that adds a visible selection UI to shapes and connections
         * by appending the <code>hover</code> and <code>selected</code> classes to them.
         *
         * @class
         *
         * Makes elements selectable, too.
         *
         * @param {EventBus} events
         * @param {SelectionService} selection
         * @param {Canvas} canvas
         */
        function SelectionVisuals(events, canvas, selection, graphicsFactory, styles) {

            this._multiSelectionBox = null;

            function addMarker(e, cls) {
                canvas.addMarker(e, cls);
            }

            function removeMarker(e, cls) {
                canvas.removeMarker(e, cls);
            }

            events.on('element.hover', function (event) {
                addMarker(event.element, MARKER_HOVER);
            });

            events.on('element.out', function (event) {
                removeMarker(event.element, MARKER_HOVER);
            });

            events.on('selection.changed', function (event) {

                function deselect(s) {
                    removeMarker(s, MARKER_SELECTED);
                }

                function select(s) {
                    addMarker(s, MARKER_SELECTED);
                }

                var oldSelection = event.oldSelection,
                    newSelection = event.newSelection;

                forEach(oldSelection, function (e) {
                    if (newSelection.indexOf(e) === -1) {
                        deselect(e);
                    }
                });

                forEach(newSelection, function (e) {
                    if (oldSelection.indexOf(e) === -1) {
                        select(e);
                    }
                });
            });
        }

        SelectionVisuals.$inject = [
            'eventBus',
            'canvas',
            'selection',
            'graphicsFactory',
            'styles'
        ];

        module.exports = SelectionVisuals;

    }, {"lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['selectionVisuals', 'selectionBehavior'],
            __depends__: [
                require('../interaction-events'),
                require('../outline')
            ],
            selection: ['type', require('./Selection')],
            selectionVisuals: ['type', require('./SelectionVisuals')],
            selectionBehavior: ['type', require('./SelectionBehavior')]
        };

    }, {
        "../interaction-events": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/interaction-events/index.js",
        "../outline": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/outline/index.js",
        "./Selection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/Selection.js",
        "./SelectionBehavior": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/SelectionBehavior.js",
        "./SelectionVisuals": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/selection/SelectionVisuals.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/snapping/SnapContext.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var snapTo = require('./SnapUtil').snapTo;


        /**
         * A snap context, containing the (possibly incomplete)
         * mappings of drop targets (to identify the snapping)
         * to computed snap points.
         */
        function SnapContext() {

            /**
             * Map<String, SnapPoints> mapping drop targets to
             * a list of possible snappings.
             *
             * @type {Object}
             */
            this._targets = {};

            /**
             * Map<String, Point> initial positioning of element
             * regarding various snap directions.
             *
             * @type {Object}
             */
            this._snapOrigins = {};

            /**
             * List of snap locations
             *
             * @type {Array<String>}
             */
            this._snapLocations = [];

            /**
             * Map<String, Array<Point>> of default snapping locations
             *
             * @type {Object}
             */
            this._defaultSnaps = {};
        }


        SnapContext.prototype.getSnapOrigin = function (snapLocation) {
            return this._snapOrigins[snapLocation];
        };


        SnapContext.prototype.setSnapOrigin = function (snapLocation, initialValue) {
            this._snapOrigins[snapLocation] = initialValue;

            if (this._snapLocations.indexOf(snapLocation) === -1) {
                this._snapLocations.push(snapLocation);
            }
        };


        SnapContext.prototype.addDefaultSnap = function (type, point) {

            var snapValues = this._defaultSnaps[type];

            if (!snapValues) {
                snapValues = this._defaultSnaps[type] = [];
            }

            snapValues.push(point);
        };

        /**
         * Return a number of initialized snaps, i.e. snap locations such as
         * top-left, mid, bottom-right and so forth.
         *
         * @return {Array<String>} snapLocations
         */
        SnapContext.prototype.getSnapLocations = function () {
            return this._snapLocations;
        };

        /**
         * Set the snap locations for this context.
         *
         * The order of locations determines precedence.
         *
         * @param {Array<String>} snapLocations
         */
        SnapContext.prototype.setSnapLocations = function (snapLocations) {
            this._snapLocations = snapLocations;
        };

        /**
         * Get snap points for a given target
         *
         * @param {Element|String} target
         */
        SnapContext.prototype.pointsForTarget = function (target) {

            var targetId = target.id || target;

            var snapPoints = this._targets[targetId];

            if (!snapPoints) {
                snapPoints = this._targets[targetId] = new SnapPoints();
                snapPoints.initDefaults(this._defaultSnaps);
            }

            return snapPoints;
        };

        module.exports = SnapContext;


        /**
         * Creates the snap points and initializes them with the
         * given default values.
         *
         * @param {Object<String, Array<Point>>} [defaultPoints]
         */
        function SnapPoints(defaultSnaps) {

            /**
             * Map<String, Map<(x|y), Array<Number>>> mapping snap locations,
             * i.e. top-left, bottom-right, center to actual snap values.
             *
             * @type {Object}
             */
            this._snapValues = {};
        }

        SnapPoints.prototype.add = function (snapLocation, point) {

            var snapValues = this._snapValues[snapLocation];

            if (!snapValues) {
                snapValues = this._snapValues[snapLocation] = {x: [], y: []};
            }

            if (snapValues.x.indexOf(point.x) === -1) {
                snapValues.x.push(point.x);
            }

            if (snapValues.y.indexOf(point.y) === -1) {
                snapValues.y.push(point.y);
            }
        };


        SnapPoints.prototype.snap = function (point, snapLocation, axis, tolerance) {
            var snappingValues = this._snapValues[snapLocation];

            return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);
        };

        /**
         * Initialize a number of default snapping points.
         *
         * @param  {Object} defaultSnaps
         */
        SnapPoints.prototype.initDefaults = function (defaultSnaps) {

            var self = this;

            forEach(defaultSnaps || {}, function (snapPoints, snapLocation) {
                forEach(snapPoints, function (point) {
                    self.add(snapLocation, point);
                });
            });
        };
    }, {
        "./SnapUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/snapping/SnapUtil.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/snapping/SnapUtil.js": [function (require, module, exports) {
        'use strict';

        var abs = Math.abs,
            round = Math.round;


        /**
         * Snap value to a collection of reference values.
         *
         * @param  {Number} value
         * @param  {Array<Number>} values
         * @param  {Number} [tolerance=10]
         *
         * @return {Number} the value we snapped to or null, if none snapped
         */
        function snapTo(value, values, tolerance) {
            tolerance = tolerance === undefined ? 10 : tolerance;

            var idx, snapValue;

            for (idx = 0; idx < values.length; idx++) {
                snapValue = values[idx];

                if (abs(snapValue - value) <= tolerance) {
                    return snapValue;
                }
            }
        }


        module.exports.snapTo = snapTo;


        function topLeft(bounds) {
            return {
                x: bounds.x,
                y: bounds.y
            };
        }

        module.exports.topLeft = topLeft;


        function mid(bounds, defaultValue) {

            if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
                return defaultValue;
            }

            return {
                x: round(bounds.x + bounds.width / 2),
                y: round(bounds.y + bounds.height / 2)
            };
        }

        module.exports.mid = mid;


        function bottomRight(bounds) {
            return {
                x: bounds.x + bounds.width,
                y: bounds.y + bounds.height
            };
        }

        module.exports.bottomRight = bottomRight;
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/snapping/Snapping.js": [function (require, module, exports) {
        'use strict';

        var filter = require('lodash/collection/filter'),
            forEach = require('lodash/collection/forEach'),
            debounce = require('lodash/function/debounce');


        var mid = require('./SnapUtil').mid;

        var SnapContext = require('./SnapContext');

        /**
         * A general purpose snapping component for diagram elements.
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         */
        function Snapping(eventBus, canvas) {

            this._canvas = canvas;

            var self = this;

            eventBus.on(['shape.move.start', 'create.start'], function (event) {
                self.initSnap(event);
            });

            eventBus.on(['shape.move.move', 'shape.move.end', 'create.move', 'create.end'], function (event) {
                if (event.snapped) {
                    return;
                }

                self.snap(event);
            });

            eventBus.on(['shape.move.cleanup', 'create.cleanup'], function (event) {
                self.hide();
            });

            // delay hide by 1000 seconds since last match
            this._asyncHide = debounce(this.hide, 1000);
        }

        Snapping.$inject = ['eventBus', 'canvas'];

        module.exports = Snapping;


        Snapping.prototype.initSnap = function (event) {

            var context = event.context,
                shape = context.shape,
                snapContext = context.snapContext;

            if (!snapContext) {
                snapContext = context.snapContext = new SnapContext();
            }

            var snapMid = mid(shape, event);

            snapContext.setSnapOrigin('mid', {
                x: snapMid.x - event.x,
                y: snapMid.y - event.y
            });

            return snapContext;
        };


        Snapping.prototype.snap = function (event) {

            var context = event.context,
                snapContext = context.snapContext,
                shape = context.shape,
                target = context.target,
                snapLocations = snapContext.getSnapLocations();

            if (!target) {
                return;
            }

            var snapPoints = snapContext.pointsForTarget(target);

            if (!snapPoints.initialized) {
                this.addTargetSnaps(snapPoints, shape, target);

                snapPoints.initialized = true;
            }


            var snapping = {};

            forEach(snapLocations, function (location) {

                var snapOrigin = snapContext.getSnapOrigin(location);

                var snapCurrent = {
                    x: event.x + snapOrigin.x,
                    y: event.y + snapOrigin.y
                };

                // snap on both axis, if not snapped already
                forEach(['x', 'y'], function (axis) {
                    var locationSnapping;

                    if (!snapping[axis]) {
                        locationSnapping = snapPoints.snap(snapCurrent, location, axis, 7);

                        if (locationSnapping !== undefined) {
                            snapping[axis] = {
                                value: locationSnapping,
                                originValue: locationSnapping - snapOrigin[axis]
                            };
                        }
                    }
                });

                // no more need to snap, drop out of interation
                if (snapping.x && snapping.y) {
                    return false;
                }
            });


            // show snap visuals

            this.showSnapLine('vertical', snapping.x && snapping.x.value);
            this.showSnapLine('horizontal', snapping.y && snapping.y.value);


            // adjust event { x, y, dx, dy } and mark as snapping
            var cx, cy;

            if (snapping.x) {

                cx = event.x - snapping.x.originValue;

                event.x = snapping.x.originValue;
                event.dx = event.dx - cx;

                event.snapped = true;
            }

            if (snapping.y) {
                cy = event.y - snapping.y.originValue;

                event.y = snapping.y.originValue;
                event.dy = event.dy - cy;

                event.snapped = true;
            }
        };


        Snapping.prototype._createLine = function (orientation) {

            var root = this._canvas.getLayer('snap');

            var line = root.path('M0,0 L0,0').addClass('djs-snap-line');

            return {
                update: function (position) {

                    if (position === undefined) {
                        line.attr({display: 'none'});
                    } else {
                        if (orientation === 'horizontal') {
                            line.attr({
                                path: 'M-100000,' + position + ' L+100000,' + position,
                                display: ''
                            });
                        } else {
                            line.attr({
                                path: 'M ' + position + ',-100000 L ' + position + ', +100000',
                                display: ''
                            });
                        }
                    }
                }
            };
        };


        Snapping.prototype._createSnapLines = function () {

            this._snapLines = {
                horizontal: this._createLine('horizontal'),
                vertical: this._createLine('vertical')
            };
        };

        Snapping.prototype.showSnapLine = function (orientation, position) {

            var line = this.getSnapLine(orientation);

            if (line) {
                line.update(position);
            }

            this._asyncHide();
        };

        Snapping.prototype.getSnapLine = function (orientation) {
            if (!this._snapLines) {
                this._createSnapLines();
            }

            return this._snapLines[orientation];
        };

        Snapping.prototype.hide = function () {
            forEach(this._snapLines, function (l) {
                l.update();
            });
        };

        Snapping.prototype.addTargetSnaps = function (snapPoints, shape, target) {

            var siblings = this.getSiblings(shape, target);

            forEach(siblings, function (s) {
                snapPoints.add('mid', mid(s));
            });

        };

        Snapping.prototype.getSiblings = function (element, target) {

            // snap to all non connection siblings
            return target && filter(target.children, function (e) {
                    return !e.hidden && !e.labelTarget && !e.waypoints && e !== element;
                });
        };
    }, {
        "./SnapContext": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/snapping/SnapContext.js",
        "./SnapUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/snapping/SnapUtil.js",
        "lodash/collection/filter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/filter.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/function/debounce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/debounce.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/space-tool/SpaceTool.js": [function (require, module, exports) {
        'use strict';

        var SpaceUtil = require('./SpaceUtil');

        var Cursor = require('../../util/Cursor');

        var hasPrimaryModifier = require('../../util/Mouse').hasPrimaryModifier;

        var abs = Math.abs,
            round = Math.round;

        var HIGH_PRIORITY = 1500;

        /**
         * A tool that allows users to create and remove space in a diagram.
         *
         * The tool needs to be activated manually via {@link SpaceTool#activate(MouseEvent)}.
         */
        function SpaceTool(eventBus, dragging, elementRegistry, modeling, rules) {

            function canResize(shape) {
                var ctx = {shape: shape};
                return rules.allowed('shape.resize', ctx);
            }

            function activateSelection(event, autoActivate) {
                dragging.activate(event, 'spaceTool.selection', {
                    cursor: 'crosshair',
                    autoActivate: autoActivate,
                    data: {
                        context: {
                            crosshair: {}
                        }
                    }
                });
            }

            function activateMakeSpace(event) {
                dragging.activate(event, 'spaceTool', {
                    autoActivate: true,
                    cursor: 'crosshair',
                    data: {
                        context: {}
                    }
                });
            }


            eventBus.on('spaceTool.selection.end', function (event) {
                setTimeout(function () {
                    activateMakeSpace(event.originalEvent);
                });
            });


            var AXIS_TO_DIMENSION = {x: 'width', y: 'height'},
                AXIS_INVERTED = {x: 'y', y: 'x'};


            function initializeMakeSpace(event, context) {

                var axis = abs(event.dx) > abs(event.dy) ? 'x' : 'y',
                    offset = event['d' + axis],
                // start point of create space operation
                    spacePos = event[axis] - offset,
                // list of moving shapes
                    movingShapes = [],
                // list of resizing shapes
                    resizingShapes = [];

                if (abs(offset) < 5) {
                    return false;
                }

                // inverts the offset to choose the shapes
                // on the opposite side of the resizer if
                // a key modifier is pressed
                if (hasPrimaryModifier(event)) {
                    offset *= -1;
                }

                // collect all elements that need to be moved _AND_
                // resized given on the initial create space position
                elementRegistry.forEach(function (shape) {
                    var shapeStart = shape[[axis]],
                        shapeEnd = shapeStart + shape[AXIS_TO_DIMENSION[axis]];

                    // checking if it's root
                    if (!shape.parent) {
                        return;
                    }

                    // checking if it's a shape
                    if (shape.waypoints) {
                        return;
                    }

                    // shape after spacePos
                    if (offset > 0 && shapeStart > spacePos) {
                        return movingShapes.push(shape);
                    }

                    // shape before spacePos
                    if (offset < 0 && shapeEnd < spacePos) {
                        return movingShapes.push(shape);
                    }

                    // shape on top of spacePos, resize only if allowed
                    if (shapeStart < spacePos && shapeEnd > spacePos && canResize(shape)) {
                        return resizingShapes.push(shape);
                    }
                });

                // store data in context
                context.axis = axis;
                context.direction = SpaceUtil.getDirection(axis, offset);
                context.movingShapes = movingShapes;
                context.resizingShapes = resizingShapes;

                Cursor.set('resize-' + (axis === 'x' ? 'ew' : 'ns'));

                return true;
            }


            eventBus.on('spaceTool.move', HIGH_PRIORITY, function (event) {

                var context = event.context;

                if (!context.initialized) {
                    context.initialized = initializeMakeSpace(event, context);
                }
            });


            eventBus.on('spaceTool.end', function (event) {

                var context = event.context,
                    axis = context.axis,
                    direction = context.direction,
                    movingShapes = context.movingShapes,
                    resizingShapes = context.resizingShapes;

                // skip if create space has not been initialized yet
                if (!context.initialized) {
                    return;
                }

                var delta = {x: round(event.dx), y: round(event.dy)};
                delta[AXIS_INVERTED[axis]] = 0;

                return modeling.createSpace(movingShapes, resizingShapes, delta, direction);
            });

            // API
            this.activateSelection = activateSelection;
            this.activateMakeSpace = activateMakeSpace;
        }

        SpaceTool.$inject = ['eventBus', 'dragging', 'elementRegistry', 'modeling', 'rules'];

        module.exports = SpaceTool;

    }, {
        "../../util/Cursor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Cursor.js",
        "../../util/Mouse": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Mouse.js",
        "./SpaceUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/space-tool/SpaceToolVisuals.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');


        var MARKER_DRAGGING = 'djs-dragging';


        /**
         * A plugin that makes shapes draggable / droppable.
         *
         * @param {EventBus} eventBus
         * @param {ElementRegistry} elementRegistry
         * @param {Canvas} canvas
         * @param {Styles} styles
         */

        function SpaceToolVisuals(eventBus, elementRegistry, canvas, styles) {

            function getGfx(e) {
                return elementRegistry.getGraphics(e);
            }

            function addDragger(shape, dragGroup) {
                var gfx = getGfx(shape);
                var dragger = gfx.clone();
                var bbox = gfx.getBBox();

                dragger.attr(styles.cls('djs-dragger', [], {
                    x: bbox.x,
                    y: bbox.y
                }));

                dragGroup.add(dragger);
            }

            eventBus.on('spaceTool.selection.start', function (event) {
                var space = canvas.getLayer('space'),
                    context = event.context;

                var orientation = {
                    x: 'M 0,-10000 L 0,10000',
                    y: 'M -10000,0 L 10000,0'
                };

                var crosshairGroup = space.group().attr(styles.cls('djs-crosshair-group', ['no-events']));

                crosshairGroup.path(orientation.x).addClass('djs-crosshair');
                crosshairGroup.path(orientation.y).addClass('djs-crosshair');

                context.crosshairGroup = crosshairGroup;
            });

            eventBus.on('spaceTool.selection.move', function (event) {
                var crosshairGroup = event.context.crosshairGroup;

                crosshairGroup.translate(event.x, event.y);
            });

            eventBus.on('spaceTool.selection.cleanup', function (event) {
                var context = event.context,
                    crosshairGroup = context.crosshairGroup;

                if (crosshairGroup) {
                    crosshairGroup.remove();
                }
            });


            // assign a low priority to this handler
            // to let others modify the move context before
            // we draw things
            eventBus.on('spaceTool.move', function (event) {
                /*
                 TODO (Ricardo): extend connections while adding space
                 */

                var context = event.context,
                    line = context.line,
                    axis = context.axis,
                    dragShapes = context.movingShapes;

                if (!context.initialized) {
                    return;
                }

                if (!context.dragGroup) {
                    var spaceLayer = canvas.getLayer('space');
                    line = spaceLayer.path('M0,0 L0,0').addClass('djs-crosshair');

                    context.line = line;
                    var dragGroup = canvas.getDefaultLayer().group().attr(styles.cls('djs-drag-group', ['no-events']));


                    forEach(dragShapes, function (shape) {
                        addDragger(shape, dragGroup);
                        canvas.addMarker(shape, MARKER_DRAGGING);
                    });

                    context.dragGroup = dragGroup;
                }

                var orientation = {
                    x: 'M' + event.x + ', -10000 L' + event.x + ', 10000',
                    y: 'M -10000, ' + event.y + ' L 10000, ' + event.y
                };

                line.attr({
                    path: orientation[axis],
                    display: ''
                });

                var opposite = {x: 'y', y: 'x'};
                var delta = {x: event.dx, y: event.dy};
                delta[opposite[context.axis]] = 0;

                context.dragGroup.translate(delta.x, delta.y);
            });

            eventBus.on('spaceTool.cleanup', function (event) {

                var context = event.context,
                    shapes = context.movingShapes,
                    line = context.line,
                    dragGroup = context.dragGroup;

                // remove dragging marker
                forEach(shapes, function (e) {
                    canvas.removeMarker(e, MARKER_DRAGGING);
                });

                if (dragGroup) {
                    line.remove();
                    dragGroup.remove();
                }
            });
        }

        SpaceToolVisuals.$inject = ['eventBus', 'elementRegistry', 'canvas', 'styles'];

        module.exports = SpaceToolVisuals;

    }, {"lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js": [function (require, module, exports) {
        'use strict';

        /**
         * Get Resize direction given axis + offset
         *
         * @param {String} axis (x|y)
         * @param {Number} offset
         *
         * @return {String} (e|w|n|s)
         */
        function getDirection(axis, offset) {

            if (axis === 'x') {
                if (offset > 0) {
                    return 'e';
                }

                if (offset < 0) {
                    return 'w';
                }
            }

            if (axis === 'y') {
                if (offset > 0) {
                    return 's';
                }

                if (offset < 0) {
                    return 'n';
                }
            }

            return null;
        }

        module.exports.getDirection = getDirection;

        /**
         * Resize the given bounds by the specified delta from a given anchor point.
         *
         * @param {Bounds} bounds the bounding box that should be resized
         * @param {String} direction in which the element is resized (n, s, e, w)
         * @param {Point} delta of the resize operation
         *
         * @return {Bounds} resized bounding box
         */
        module.exports.resizeBounds = function (bounds, direction, delta) {

            var dx = delta.x,
                dy = delta.y;

            switch (direction) {

                case 'n':
                    return {
                        x: bounds.x,
                        y: bounds.y + dy,
                        width: bounds.width,
                        height: bounds.height - dy
                    };

                case 's':
                    return {
                        x: bounds.x,
                        y: bounds.y,
                        width: bounds.width,
                        height: bounds.height + dy
                    };

                case 'w':
                    return {
                        x: bounds.x + dx,
                        y: bounds.y,
                        width: bounds.width - dx,
                        height: bounds.height
                    };

                case 'e':
                    return {
                        x: bounds.x,
                        y: bounds.y,
                        width: bounds.width + dx,
                        height: bounds.height
                    };

                default:
                    throw new Error('unrecognized direction: ' + direction);
            }
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/space-tool/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['spaceToolVisuals'],
            __depends__: [require('../dragging'), require('../modeling'), require('../rules')],
            spaceTool: ['type', require('./SpaceTool')],
            spaceToolVisuals: ['type', require('./SpaceToolVisuals')]
        };

    }, {
        "../dragging": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/dragging/index.js",
        "../modeling": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/modeling/index.js",
        "../rules": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/rules/index.js",
        "./SpaceTool": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/space-tool/SpaceTool.js",
        "./SpaceToolVisuals": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/space-tool/SpaceToolVisuals.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/tooltips/Tooltips.js": [function (require, module, exports) {
        'use strict';

        var isString = require('lodash/lang/isString'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            debounce = require('lodash/function/debounce');

        var domify = require('min-dom/lib/domify'),
            domAttr = require('min-dom/lib/attr'),
            domClasses = require('min-dom/lib/classes'),
            domRemove = require('min-dom/lib/remove'),
            domDelegate = require('min-dom/lib/delegate');


// document wide unique tooltip ids
        var ids = new (require('../../util/IdGenerator'))('tt');


        function createRoot(parent) {
            var root = domify('<div class="djs-tooltip-container" style="position: absolute; width: 0; height: 0;" />');
            parent.insertBefore(root, parent.firstChild);

            return root;
        }


        function setPosition(el, x, y) {
            assign(el.style, {left: x + 'px', top: y + 'px'});
        }

        function setVisible(el, visible) {
            el.style.display = visible === false ? 'none' : '';
        }


        var tooltipClass = 'djs-tooltip',
            tooltipSelector = '.' + tooltipClass;

        /**
         * A service that allows users to render tool tips on the diagram.
         *
         * The tooltip service will take care of updating the tooltip positioning
         * during navigation + zooming.
         *
         * @example
         *
         * ```javascript
         *
         * // add a pink badge on the top left of the shape
         * tooltips.add({
 *   position: {
 *     x: 50,
 *     y: 100
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
 * });
         *
         * // or with optional life span
         * tooltips.add({
 *   position: {
 *     top: -5,
 *     left: -5
 *   },
 *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>',
 *   ttl: 2000
 * });
         *
         * // remove a tool tip
         * var id = tooltips.add(...);
         * tooltips.remove(id);
         * ```
         *
         * @param {Object} config
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         */
        function Tooltips(config, eventBus, canvas) {

            this._eventBus = eventBus;
            this._canvas = canvas;

            this._ids = ids;

            this._tooltipDefaults = {
                show: {
                    minZoom: 0.7,
                    maxZoom: 5.0
                }
            };

            /**
             * Mapping tooltipId -> tooltip
             */
            this._tooltips = {};

            // root html element for all tooltips
            this._tooltipRoot = createRoot(canvas.getContainer());


            var self = this;

            domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mousedown', function (event) {
                event.stopPropagation();
            });

            domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mouseover', function (event) {
                self.trigger('mouseover', event);
            });

            domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mouseout', function (event) {
                self.trigger('mouseout', event);
            });

            this._init(config);
        }


        Tooltips.$inject = ['config.tooltips', 'eventBus', 'canvas'];

        module.exports = Tooltips;


        /**
         * Adds a HTML tooltip to the diagram
         *
         * @param {Object}               tooltip   the tooltip configuration
         *
         * @param {String|DOMElement}    tooltip.html                 html element to use as an tooltip
         * @param {Object}               [tooltip.show]               show configuration
         * @param {Number}               [tooltip.show.minZoom]       minimal zoom level to show the tooltip
         * @param {Number}               [tooltip.show.maxZoom]       maximum zoom level to show the tooltip
         * @param {Object}               tooltip.position             where to attach the tooltip
         * @param {Number}               [tooltip.position.left]      relative to element bbox left attachment
         * @param {Number}               [tooltip.position.top]       relative to element bbox top attachment
         * @param {Number}               [tooltip.position.bottom]    relative to element bbox bottom attachment
         * @param {Number}               [tooltip.position.right]     relative to element bbox right attachment
         * @param {Number}               [tooltip.timeout=-1]
         *
         * @return {String}              id that may be used to reference the tooltip for update or removal
         */
        Tooltips.prototype.add = function (tooltip) {

            if (!tooltip.position) {
                throw new Error('must specifiy tooltip position');
            }

            if (!tooltip.html) {
                throw new Error('must specifiy tooltip html');
            }

            var id = this._ids.next();

            tooltip = assign({}, this._tooltipDefaults, tooltip, {
                id: id
            });

            this._addTooltip(tooltip);

            if (tooltip.timeout) {
                this.setTimeout(tooltip);
            }

            return id;
        };

        Tooltips.prototype.trigger = function (action, event) {

            var node = event.delegateTarget || event.target;

            var tooltip = this.get(domAttr(node, 'data-tooltip-id'));

            if (!tooltip) {
                return;
            }

            if (action === 'mouseover' && tooltip.timeout) {
                this.clearTimeout(tooltip);
            }

            if (action === 'mouseout' && tooltip.timeout) {
                // cut timeout after mouse out
                tooltip.timeout = 1000;

                this.setTimeout(tooltip);
            }

            console.log('mouse leave', event);
        };

        /**
         * Get a tooltip with the given id
         *
         * @param {String} id
         */
        Tooltips.prototype.get = function (id) {

            if (typeof id !== 'string') {
                id = id.id;
            }

            return this._tooltips[id];
        };

        Tooltips.prototype.clearTimeout = function (tooltip) {

            tooltip = this.get(tooltip);

            if (!tooltip) {
                return;
            }

            var removeTimer = tooltip.removeTimer;

            if (removeTimer) {
                clearTimeout(removeTimer);
                tooltip.removeTimer = null;
            }
        };

        Tooltips.prototype.setTimeout = function (tooltip) {

            tooltip = this.get(tooltip);

            if (!tooltip) {
                return;
            }

            this.clearTimeout(tooltip);

            var self = this;

            tooltip.removeTimer = setTimeout(function () {
                self.remove(tooltip);
            }, tooltip.timeout);
        };

        /**
         * Remove an tooltip with the given id
         *
         * @param {String} id
         */
        Tooltips.prototype.remove = function (id) {

            var tooltip = this.get(id);

            if (tooltip) {
                domRemove(tooltip.html);
                domRemove(tooltip.htmlContainer);

                delete tooltip.htmlContainer;

                delete this._tooltips[tooltip.id];
            }
        };


        Tooltips.prototype.show = function () {
            setVisible(this._tooltipRoot);
        };


        Tooltips.prototype.hide = function () {
            setVisible(this._tooltipRoot, false);
        };


        Tooltips.prototype._updateRoot = function (viewbox) {
            var a = viewbox.scale || 1;
            var d = viewbox.scale || 1;

            var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';

            this._tooltipRoot.style.transform = matrix;
            this._tooltipRoot.style['-ms-transform'] = matrix;
        };


        Tooltips.prototype._addTooltip = function (tooltip) {

            var id = tooltip.id,
                html = tooltip.html,
                htmlContainer,
                tooltipRoot = this._tooltipRoot;

            // unwrap jquery (for those who need it)
            if (html.get) {
                html = html.get(0);
            }

            // create proper html elements from
            // tooltip HTML strings
            if (isString(html)) {
                html = domify(html);
            }

            htmlContainer = domify('<div data-tooltip-id="' + id + '" class="' + tooltipClass + '" style="position: absolute">');

            htmlContainer.appendChild(html);

            if (tooltip.type) {
                domClasses(htmlContainer).add('djs-tooltip-' + tooltip.type);
            }

            if (tooltip.className) {
                domClasses(htmlContainer).add(tooltip.className);
            }

            tooltip.htmlContainer = htmlContainer;

            tooltipRoot.appendChild(htmlContainer);

            this._tooltips[id] = tooltip;

            this._updateTooltip(tooltip);
        };


        Tooltips.prototype._updateTooltip = function (tooltip) {

            var position = tooltip.position,
                htmlContainer = tooltip.htmlContainer;

            // update overlay html based on tooltip x, y

            setPosition(htmlContainer, position.x, position.y);
        };


        Tooltips.prototype._updateTooltipVisibilty = function (viewbox) {

            forEach(this._tooltips, function (tooltip) {
                var show = tooltip.show,
                    htmlContainer = tooltip.htmlContainer,
                    visible = true;

                if (show) {
                    if (show.minZoom > viewbox.scale ||
                        show.maxZoom < viewbox.scale) {
                        visible = false;
                    }

                    setVisible(htmlContainer, visible);
                }
            });
        };

        Tooltips.prototype._init = function (config) {

            var self = this;


            // scroll/zoom integration

            var updateViewbox = function (viewbox) {
                self._updateRoot(viewbox);
                self._updateTooltipVisibilty(viewbox);

                self.show();
            };

            if (!config || config.deferUpdate !== false) {
                updateViewbox = debounce(updateViewbox, 300);
            }

            this._eventBus.on('canvas.viewbox.changed', function (event) {
                self.hide();
                updateViewbox(event.viewbox);
            });
        };

    }, {
        "../../util/IdGenerator": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/IdGenerator.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/function/debounce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/debounce.js",
        "lodash/lang/isString": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isString.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "min-dom/lib/attr": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/attr.js",
        "min-dom/lib/classes": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/classes.js",
        "min-dom/lib/delegate": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/delegate.js",
        "min-dom/lib/domify": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/domify.js",
        "min-dom/lib/remove": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/remove.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/tooltips/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['tooltips'],
            tooltips: ['type', require('./Tooltips')]
        };
    }, {"./Tooltips": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/tooltips/Tooltips.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/touch/TouchFix.js": [function (require, module, exports) {
        'use strict';

        function TouchFix(canvas, eventBus) {

            var self = this;

            eventBus.on('canvas.init', function (e) {
                self.addBBoxMarker(e.svg);
            });
        }

        TouchFix.$inject = ['canvas', 'eventBus'];

        module.exports = TouchFix;


        /**
         * Safari mobile (iOS 7) does not fire touchstart event in <SVG> element
         * if there is no shape between 0,0 and viewport elements origin.
         *
         * So touchstart event is only fired when the <g class="viewport"> element was hit.
         * Putting an element over and below the 'viewport' fixes that behavior.
         */
        TouchFix.prototype.addBBoxMarker = function (paper) {

            var markerStyle = {
                fill: 'none',
                class: 'outer-bound-marker'
            };

            paper.rect(-10000, -10000, 10, 10).attr(markerStyle);
            paper.rect(10000, 10000, 10, 10).attr(markerStyle);
        };

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js": [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            domEvent = require('min-dom/lib/event'),
            domClosest = require('min-dom/lib/closest'),
            Hammer = require('hammerjs'),
            Snap = require('../../../vendor/snapsvg'),
            Event = require('../../util/Event');

        var MIN_ZOOM = 0.2,
            MAX_ZOOM = 4;

        var mouseEvents = [
            'mousedown',
            'mouseup',
            'mouseover',
            'mouseout',
            'click',
            'dblclick'
        ];

        function log() {
            if (false) {
                console.log.apply(console, arguments);
            }
        }

        function get(service, injector) {
            try {
                return injector.get(service);
            } catch (e) {
                return null;
            }
        }

        function createTouchRecognizer(node) {

            function stopEvent(event) {
                Event.stopEvent(event, true);
            }

            function stopMouse(event) {

                forEach(mouseEvents, function (e) {
                    domEvent.bind(node, e, stopEvent, true);
                });
            }

            function allowMouse(event) {
                setTimeout(function () {
                    forEach(mouseEvents, function (e) {
                        domEvent.unbind(node, e, stopEvent, true);
                    });
                }, 500);
            }

            domEvent.bind(node, 'touchstart', stopMouse, true);
            domEvent.bind(node, 'touchend', allowMouse, true);
            domEvent.bind(node, 'touchcancel', allowMouse, true);

            // A touch event recognizer that handles
            // touch events only (we know, we can already handle
            // mouse events out of the box)

            var recognizer = new Hammer.Manager(node, {
                inputClass: Hammer.TouchInput,
                recognizers: []
            });


            var tap = new Hammer.Tap();
            var pan = new Hammer.Pan({threshold: 10});
            var press = new Hammer.Press();
            var pinch = new Hammer.Pinch();

            var doubleTap = new Hammer.Tap({event: 'doubletap', taps: 2});

            pinch.requireFailure(pan);
            pinch.requireFailure(press);

            recognizer.add([pan, press, pinch, doubleTap, tap]);

            recognizer.reset = function (force) {
                var recognizers = this.recognizers,
                    session = this.session;

                if (session.stopped) {
                    return;
                }

                log('recognizer', 'stop');

                recognizer.stop(force);

                setTimeout(function () {
                    var i, r;

                    log('recognizer', 'reset');
                    for (i = 0; !!(r = recognizers[i]); i++) {
                        r.reset();
                        r.state = 8; // FAILED STATE
                    }

                    session.curRecognizer = null;
                }, 0);
            };

            recognizer.on('hammer.input', function (event) {
                if (event.srcEvent.defaultPrevented) {
                    recognizer.reset(true);
                }
            });

            return recognizer;
        }

        /**
         * A plugin that provides touch events for elements.
         *
         * @param {EventBus} eventBus
         * @param {InteractionEvents} interactionEvents
         */
        function TouchInteractionEvents(injector, canvas, eventBus, elementRegistry, interactionEvents, snap) {

            // optional integrations
            var dragging = get('dragging', injector),
                move = get('move', injector),
                contextPad = get('contextPad', injector),
                palette = get('palette', injector);

            // the touch recognizer
            var recognizer;

            function handler(type) {

                return function (event) {
                    log('element', type, event);

                    interactionEvents.fire(type, event);
                };
            }

            function getGfx(target) {
                var node = domClosest(target, 'svg, .djs-element', true);
                return node && new Snap(node);
            }

            function initEvents(svg) {

                // touch recognizer
                recognizer = createTouchRecognizer(svg);

                recognizer.on('doubletap', handler('element.dblclick'));

                recognizer.on('tap', handler('element.click'));

                function startGrabCanvas(event) {

                    log('canvas', 'grab start');

                    var lx = 0, ly = 0;

                    function update(e) {

                        var dx = e.deltaX - lx,
                            dy = e.deltaY - ly;

                        canvas.scroll({dx: dx, dy: dy});

                        lx = e.deltaX;
                        ly = e.deltaY;
                    }

                    function end(e) {
                        recognizer.off('panmove', update);
                        recognizer.off('panend', end);
                        recognizer.off('pancancel', end);

                        log('canvas', 'grab end');
                    }

                    recognizer.on('panmove', update);
                    recognizer.on('panend', end);
                    recognizer.on('pancancel', end);
                }

                function startGrab(event) {

                    var gfx = getGfx(event.target),
                        element = gfx && elementRegistry.get(gfx);

                    // recognizer
                    if (move && canvas.getRootElement() !== element) {
                        log('element', 'move start', element, event, true);
                        return move.start(event, element, true);
                    } else {
                        startGrabCanvas(event);
                    }
                }

                function startZoom(e) {

                    log('canvas', 'zoom start');

                    var zoom = canvas.zoom(),
                        mid = e.center;

                    function update(e) {

                        var ratio = 1 - (1 - e.scale) / 1.50,
                            newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom));

                        canvas.zoom(newZoom, mid);

                        Event.stopEvent(e, true);
                    }

                    function end(e) {
                        recognizer.off('pinchmove', update);
                        recognizer.off('pinchend', end);
                        recognizer.off('pinchcancel', end);

                        recognizer.reset(true);

                        log('canvas', 'zoom end');
                    }

                    recognizer.on('pinchmove', update);
                    recognizer.on('pinchend', end);
                    recognizer.on('pinchcancel', end);
                }

                recognizer.on('panstart', startGrab);
                recognizer.on('press', startGrab);

                recognizer.on('pinchstart', startZoom);
            }

            if (dragging) {

                // simulate hover during dragging
                eventBus.on('drag.move', function (event) {

                    var position = Event.toPoint(event.originalEvent);

                    var node = document.elementFromPoint(position.x, position.y),
                        gfx = getGfx(node),
                        element = gfx && elementRegistry.get(gfx);

                    if (element !== event.hover) {
                        if (event.hover) {
                            dragging.out(event);
                        }

                        if (element) {
                            dragging.hover({element: element, gfx: gfx});

                            event.hover = element;
                            event.hoverGfx = gfx;
                        }
                    }
                });
            }

            if (contextPad) {

                eventBus.on('contextPad.create', function (event) {
                    var node = event.pad.html;

                    // touch recognizer
                    var padRecognizer = createTouchRecognizer(node);

                    padRecognizer.on('panstart', function (event) {
                        log('context-pad', 'panstart', event);
                        contextPad.trigger('dragstart', event, true);
                    });

                    padRecognizer.on('press', function (event) {
                        log('context-pad', 'press', event);
                        contextPad.trigger('dragstart', event, true);
                    });

                    padRecognizer.on('tap', function (event) {
                        log('context-pad', 'tap', event);
                        contextPad.trigger('click', event);
                    });
                });
            }

            if (palette) {
                eventBus.on('palette.create', function (event) {
                    var node = event.html;

                    // touch recognizer
                    var padRecognizer = createTouchRecognizer(node);

                    padRecognizer.on('panstart', function (event) {
                        log('palette', 'panstart', event);
                        palette.trigger('dragstart', event, true);
                    });

                    padRecognizer.on('press', function (event) {
                        log('palette', 'press', event);
                        palette.trigger('dragstart', event, true);
                    });

                    padRecognizer.on('tap', function (event) {
                        log('palette', 'tap', event);
                        palette.trigger('click', event);
                    });
                });
            }

            eventBus.on('canvas.init', function (event) {
                initEvents(event.svg.node);
            });
        }


        TouchInteractionEvents.$inject = [
            'injector',
            'canvas',
            'eventBus',
            'elementRegistry',
            'interactionEvents',
            'touchFix'
        ];

        module.exports = TouchInteractionEvents;
    }, {
        "../../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "../../util/Event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Event.js",
        "hammerjs": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/hammerjs/hammer.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "min-dom/lib/closest": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/closest.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/touch/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../interaction-events')],
            __init__: ['touchInteractionEvents'],
            touchInteractionEvents: ['type', require('./TouchInteractionEvents')],
            touchFix: ['type', require('./TouchFix')]
        };
    }, {
        "../interaction-events": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/interaction-events/index.js",
        "./TouchFix": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/touch/TouchFix.js",
        "./TouchInteractionEvents": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/BaseLayouter.js": [function (require, module, exports) {
        'use strict';

        var LayoutUtil = require('./LayoutUtil');


        /**
         * A base connection layouter implementation
         * that layouts the connection by directly connecting
         * mid(source) + mid(target).
         */
        function BaseLayouter() {
        }

        module.exports = BaseLayouter;


        /**
         * Return the new layouted waypoints for the given connection.
         *
         * @param {djs.model.Connection} connection
         * @param {Object} hints
         * @param {Boolean} [hints.movedStart=false]
         * @param {Boolean} [hints.movedEnd=false]
         *
         * @return {Array<Point>} the layouted connection waypoints
         */
        BaseLayouter.prototype.layoutConnection = function (connection, hints) {
            return [
                LayoutUtil.getMidPoint(connection.source),
                LayoutUtil.getMidPoint(connection.target)
            ];
        };

    }, {"./LayoutUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/LayoutUtil.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');

        var LayoutUtil = require('./LayoutUtil');


        function dockingToPoint(docking) {
            // use the dockings actual point and
            // retain the original docking
            return assign({original: docking.point.original || docking.point}, docking.actual);
        }


        /**
         * A {@link ConnectionDocking} that crops connection waypoints based on
         * the path(s) of the connection source and target.
         *
         * @param {djs.core.ElementRegistry} elementRegistry
         */
        function CroppingConnectionDocking(elementRegistry, renderer) {
            this._elementRegistry = elementRegistry;
            this._renderer = renderer;
        }

        CroppingConnectionDocking.$inject = ['elementRegistry', 'renderer'];

        module.exports = CroppingConnectionDocking;


        /**
         * @inheritDoc ConnectionDocking#getCroppedWaypoints
         */
        CroppingConnectionDocking.prototype.getCroppedWaypoints = function (connection, source, target) {

            source = source || connection.source;
            target = target || connection.target;

            var sourceDocking = this.getDockingPoint(connection, source, true),
                targetDocking = this.getDockingPoint(connection, target);

            var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);

            croppedWaypoints.unshift(dockingToPoint(sourceDocking));
            croppedWaypoints.push(dockingToPoint(targetDocking));

            return croppedWaypoints;
        };

        /**
         * Return the connection docking point on the specified shape
         *
         * @inheritDoc ConnectionDocking#getDockingPoint
         */
        CroppingConnectionDocking.prototype.getDockingPoint = function (connection, shape, dockStart) {

            var waypoints = connection.waypoints,
                dockingIdx,
                dockingPoint,
                croppedPoint;

            dockingIdx = dockStart ? 0 : waypoints.length - 1;
            dockingPoint = waypoints[dockingIdx];

            croppedPoint = this._getIntersection(shape, connection, dockStart);

            return {
                point: dockingPoint,
                actual: croppedPoint || dockingPoint,
                idx: dockingIdx
            };
        };


////// helper methods ///////////////////////////////////////////////////

        CroppingConnectionDocking.prototype._getIntersection = function (shape, connection, takeFirst) {

            var shapePath = this._getShapePath(shape),
                connectionPath = this._getConnectionPath(connection);

            return LayoutUtil.getElementLineIntersection(shapePath, connectionPath, takeFirst);
        };

        CroppingConnectionDocking.prototype._getConnectionPath = function (connection) {
            return this._renderer.getConnectionPath(connection);
        };

        CroppingConnectionDocking.prototype._getShapePath = function (shape) {
            return this._renderer.getShapePath(shape);
        };

        CroppingConnectionDocking.prototype._getGfx = function (element) {
            return this._elementRegistry.getGraphics(element);
        };
    }, {
        "./LayoutUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/LayoutUtil.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/LayoutUtil.js": [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            sortBy = require('lodash/collection/sortBy');

        var Snap = require('../../vendor/snapsvg');

        /**
         * Returns whether two points are in a horizontal or vertical line.
         *
         * @param {Point} a
         * @param {Point} b
         *
         * @return {String|Boolean} returns false if the points are not
         *                          aligned or 'h|v' if they are aligned
         *                          horizontally / vertically.
         */
        function pointsAligned(a, b) {
            switch (true) {
                case a.x === b.x:
                    return 'h';
                case a.y === b.y:
                    return 'v';
            }

            return false;
        }

        module.exports.pointsAligned = pointsAligned;


        function roundPoint(point) {

            return {
                x: Math.round(point.x),
                y: Math.round(point.y)
            };
        }

        module.exports.roundPoint = roundPoint;


        function pointsEqual(a, b) {
            return a.x === b.x && a.y === b.y;
        }

        module.exports.pointsEqual = pointsEqual;


        function pointDistance(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        module.exports.pointDistance = pointDistance;


        function asTRBL(bounds) {
            return {
                top: bounds.y,
                right: bounds.x + (bounds.width || 0),
                bottom: bounds.y + (bounds.height || 0),
                left: bounds.x
            };
        }

        module.exports.asTRBL = asTRBL;


        function getMidPoint(bounds) {
            return roundPoint({
                x: bounds.x + bounds.width / 2,
                y: bounds.y + bounds.height / 2
            });
        }

        module.exports.getMidPoint = getMidPoint;


////// orientation utils //////////////////////////////

        function getOrientation(rect, reference, pointDistance) {

            pointDistance = pointDistance || 0;

            var rectOrientation = asTRBL(rect),
                referenceOrientation = asTRBL(reference);

            var top = rectOrientation.bottom + pointDistance <= referenceOrientation.top,
                right = rectOrientation.left - pointDistance >= referenceOrientation.right,
                bottom = rectOrientation.top - pointDistance >= referenceOrientation.bottom,
                left = rectOrientation.right + pointDistance <= referenceOrientation.left;

            var vertical = top ? 'top' : (bottom ? 'bottom' : null),
                horizontal = left ? 'left' : (right ? 'right' : null);

            if (horizontal && vertical) {
                return vertical + '-' + horizontal;
            } else if (horizontal || vertical) {
                return horizontal || vertical;
            } else {
                return 'intersect';
            }
        }

        module.exports.getOrientation = getOrientation;


        function hasAnyOrientation(rect, reference, pointDistance, locations) {

            if (isArray(pointDistance)) {
                locations = pointDistance;
                pointDistance = 0;
            }

            var orientation = getOrientation(rect, reference, pointDistance);

            return locations.indexOf(orientation) !== -1;
        }

        module.exports.hasAnyOrientation = hasAnyOrientation;


////// intersection utils //////////////////////////////

        function getElementLineIntersection(elementPath, linePath, cropStart) {

            var intersections = getIntersections(elementPath, linePath);

            // recognize intersections
            // only one -> choose
            // two close together -> choose first
            // two or more distinct -> pull out appropriate one
            // none -> ok (fallback to point itself)
            if (intersections.length === 1) {
                return roundPoint(intersections[0]);
            } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {
                return roundPoint(intersections[0]);
            } else if (intersections.length > 1) {

                // sort by intersections based on connection segment +
                // distance from start
                intersections = sortBy(intersections, function (i) {
                    var distance = Math.floor(i.t2 * 100) || 1;

                    distance = 100 - distance;

                    distance = (distance < 10 ? '0' : '') + distance;

                    // create a sort string that makes sure we sort
                    // line segment ASC + line segment position DESC (for cropStart)
                    // line segment ASC + line segment position ASC (for cropEnd)
                    return i.segment2 + '#' + distance;
                });

                return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
            }

            return null;
        }

        module.exports.getElementLineIntersection = getElementLineIntersection;


        function getIntersections(a, b) {
            return Snap.path.intersection(a, b);
        }

        module.exports.getIntersections = getIntersections;
    }, {
        "../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "lodash/collection/sortBy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/sortBy.js",
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/ManhattanLayout.js": [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            find = require('lodash/collection/find');

        var LayoutUtil = require('./LayoutUtil'),
            Geometry = require('../util/Geometry');

        var MIN_DISTANCE = 20;


        /**
         * Returns the mid points for a manhattan connection between two points.
         *
         * @example
         *
         * [a]----[x]
         *         |
         *        [x]--->[b]
         *
         * @param  {Point} a
         * @param  {Point} b
         * @param  {String} directions
         *
         * @return {Array<Point>}
         */
        module.exports.getMidPoints = function (a, b, directions) {

            directions = directions || 'h:h';

            var xmid, ymid;

            // one point, next to a
            if (directions === 'h:v') {
                return [{x: b.x, y: a.y}];
            } else
            // one point, above a
            if (directions === 'v:h') {
                return [{x: a.x, y: b.y}];
            } else
            // vertical edge xmid
            if (directions === 'h:h') {
                xmid = Math.round((b.x - a.x) / 2 + a.x);

                return [
                    {x: xmid, y: a.y},
                    {x: xmid, y: b.y}
                ];
            } else
            // horizontal edge ymid
            if (directions === 'v:v') {
                ymid = Math.round((b.y - a.y) / 2 + a.y);

                return [
                    {x: a.x, y: ymid},
                    {x: b.x, y: ymid}
                ];
            } else {
                throw new Error(
                    'unknown directions: <' + directions + '>: ' +
                    'directions must be specified as {a direction}:{b direction} (direction in h|v)');
            }
        };


        /**
         * Create a connection between the two points according
         * to the manhattan layout (only horizontal and vertical) edges.
         *
         * @param {Point} a
         * @param {Point} b
         *
         * @param {String} [directions='h:h'] specifies manhattan directions for each point as {adirection}:{bdirection}.
         A directionfor a point is either `h` (horizontal) or `v` (vertical)
         *
         * @return {Array<Point>}
         */
        module.exports.connectPoints = function (a, b, directions) {

            var points = [];

            if (!LayoutUtil.pointsAligned(a, b)) {
                points = this.getMidPoints(a, b, directions);
            }

            points.unshift(a);
            points.push(b);

            return points;
        };


        /**
         * Connect two rectangles using a manhattan layouted connection.
         *
         * @param {Bounds} source source rectangle
         * @param {Bounds} target target rectangle
         * @param {Point} [start] source docking
         * @param {Point} [end] target docking
         *
         * @return {Array<Point>} connection points
         */
        module.exports.connectRectangles = function (source, target, start, end, options) {

            options = options || {};

            var orientation = LayoutUtil.getOrientation(source, target, MIN_DISTANCE);

            var directions = this.getDirections(source, target, options.preferVertical);

            start = start || LayoutUtil.getMidPoint(source);
            end = end || LayoutUtil.getMidPoint(target);

            // overlapping elements
            if (!directions) {
                return;
            }

            if (directions === 'h:h') {

                switch (orientation) {
                    case 'top-right':
                    case 'right':
                    case 'bottom-right':
                        start = {original: start, x: source.x, y: start.y};
                        end = {original: end, x: target.x + target.width, y: end.y};
                        break;
                    case 'top-left':
                    case 'left':
                    case 'bottom-left':
                        start = {original: start, x: source.x + source.width, y: start.y};
                        end = {original: end, x: target.x, y: end.y};
                        break;
                }
            }

            if (directions === 'v:v') {

                switch (orientation) {
                    case 'top-left':
                    case 'top':
                    case 'top-right':
                        start = {original: start, x: start.x, y: source.y + source.height};
                        end = {original: end, x: end.x, y: target.y};
                        break;
                    case 'bottom-left':
                    case 'bottom':
                    case 'bottom-right':
                        start = {original: start, x: start.x, y: source.y};
                        end = {original: end, x: end.x, y: target.y + target.height};
                        break;
                }
            }

            return this.connectPoints(start, end, directions);
        };

        /**
         * Repair the connection between two rectangles, of which one has been updated.
         *
         * @param {Bounds} source
         * @param {Bounds} target
         * @param {Point} [start]
         * @param {Point} [end]
         * @param {Array<Point>} waypoints
         * @param {Object} [hints]
         * @param {Boolean} hints.preferStraight
         * @param {Boolean} hints.preferVertical
         * @param {Boolean} hints.startChanged
         * @param {Boolean} hints.endChanged
         *
         * @return {Array<Point>} repaired waypoints
         */
        module.exports.repairConnection = function (source, target, start, end, waypoints, hints) {

            if (isArray(start)) {
                waypoints = start;
                hints = end;

                start = LayoutUtil.getMidPoint(source);
                end = LayoutUtil.getMidPoint(target);
            }

            hints = hints || {};


            var repairedWaypoints;

            // just layout non-existing or simple connections
            // attempt to render straight lines, if required
            if (!waypoints || waypoints.length < 3) {

                if (hints.preferStraight) {
                    // attempt to layout a straight line
                    repairedWaypoints = this.layoutStraight(source, target, start, end, hints);
                }
            } else {
                // check if we layout from start or end
                if (hints.endChanged) {
                    repairedWaypoints = this._repairConnectionSide(target, source, end, waypoints.slice().reverse());
                    repairedWaypoints = repairedWaypoints && repairedWaypoints.reverse();
                } else if (hints.startChanged) {
                    repairedWaypoints = this._repairConnectionSide(source, target, start, waypoints);
                }
                // or whether nothing seems to have changed
                else {
                    repairedWaypoints = waypoints;
                }
            }

            // simply reconnect if nothing else worked
            if (!repairedWaypoints) {
                return this.connectRectangles(source, target, start, end, hints);
            }

            return repairedWaypoints;
        };

        function max(a, b) {
            return Math.max(a, b);
        }

        function min(a, b) {
            return Math.min(a, b);
        }

        function inRange(a, start, end) {
            return a >= start && a <= end;
        }

        module.exports.layoutStraight = function (source, target, start, end, hints) {

            var startX, endX, x,
                startY, endY, y;

            startX = max(source.x + 10, target.x + 10);
            endX = min(source.x + source.width - 10, target.x + target.width - 10);

            if (startX < endX) {

                if (source.width === target.width) {

                    if (hints.endChanged && inRange(end.x, startX, endX)) {
                        x = end.x;
                    } else if (inRange(start.x, startX, endX)) {
                        x = start.x;
                    }
                }

                if (x === undefined) {
                    if (source.width < target.width && inRange(start.x, startX, endX)) {
                        x = start.x;
                    } else if (source.width > target.width && inRange(end.x, startX, endX)) {
                        x = end.x;
                    } else {
                        x = (startX + endX) / 2;
                    }
                }
            }

            startY = max(source.y + 10, target.y + 10);
            endY = min(source.y + source.height - 10, target.y + target.height - 10);

            if (startY < endY) {

                if (source.height === target.height) {
                    if (hints.endChanged && inRange(end.y, startY, endY)) {
                        y = end.y;
                    } else if (inRange(start.y, startY, endY)) {
                        y = start.y;
                    }
                }

                if (y === undefined) {
                    if (source.height <= target.height && inRange(start.y, startY, endY)) {
                        y = start.y;
                    } else if (target.height <= source.height && inRange(end.y, startY, endY)) {
                        y = end.y;
                    } else {
                        y = (startY + endY) / 2;
                    }
                }
            }

            // cannot layout straight
            if (x === undefined && y === undefined) {
                return null;
            }

            return [
                {
                    x: x !== undefined ? x : start.x,
                    y: y !== undefined ? y : start.y
                },
                {
                    x: x !== undefined ? x : end.x,
                    y: y !== undefined ? y : end.y
                }
            ];
        };


        /**
         * Repair a connection from one side that moved.
         *
         * @param  {Bounds} moved
         * @param  {Bounds} other
         * @param  {Point} newDocking
         * @param  {Array<Point>} points originalPoints from moved to other
         *
         * @return {Array<Point>} the repaired points between the two rectangles
         */
        module.exports._repairConnectionSide = function (moved, other, newDocking, points) {

            function needsRelayout(moved, other, points) {

                if (points.length < 3) {
                    return true;
                }

                if (points.length > 4) {
                    return false;
                }

                // relayout if two points overlap
                // this is most likely due to
                return !!find(points, function (p, idx) {
                    var q = points[idx - 1];

                    return q && Geometry.distance(p, q) < 3;
                });
            }

            function repairBendpoint(candidate, oldPeer, newPeer) {

                var alignment = LayoutUtil.pointsAligned(oldPeer, candidate);

                switch (alignment) {
                    case 'v':
                        // repair vertical alignment
                        return {x: candidate.x, y: newPeer.y};
                    case 'h':
                        // repair horizontal alignment
                        return {x: newPeer.x, y: candidate.y};
                }

                return {x: candidate.x, y: candidate.y};
            }

            function removeOverlapping(points, a, b) {
                var i;

                for (i = points.length - 2; i !== 0; i--) {

                    // intersects (?) break, remove all bendpoints up to this one and relayout
                    if (Geometry.pointInRect(points[i], a, MIN_DISTANCE) ||
                        Geometry.pointInRect(points[i], b, MIN_DISTANCE)) {

                        // return sliced old connection
                        return points.slice(i);
                    }
                }

                return points;
            }


            // (0) only repair what has layoutable bendpoints

            // (1) if only one bendpoint and on shape moved onto other shapes axis
            //     (horizontally / vertically), relayout

            if (needsRelayout(moved, other, points)) {
                return null;
            }

            var oldDocking = points[0],
                newPoints = points.slice(),
                slicedPoints;

            // (2) repair only last line segment and only if it was layouted before

            newPoints[0] = newDocking;
            newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);


            // (3) if shape intersects with any bendpoint after repair,
            //     remove all segments up to this bendpoint and repair from there

            slicedPoints = removeOverlapping(newPoints, moved, other);
            if (slicedPoints !== newPoints) {
                return this._repairConnectionSide(moved, other, newDocking, slicedPoints);
            }

            return newPoints;
        };

        /**
         * Returns the default manhattan directions connecting two rectangles.
         *
         * @param {Bounds} source
         * @param {Bounds} target
         * @param {Boolean} preferVertical
         *
         * @return {String}
         */
        module.exports.getDirections = function (source, target, preferVertical) {
            var orientation = LayoutUtil.getOrientation(source, target, MIN_DISTANCE);

            switch (orientation) {
                case 'intersect':
                    return null;

                case 'top':
                case 'bottom':
                    return 'v:v';

                case 'left':
                case 'right':
                    return 'h:h';

                default:
                    return preferVertical ? 'v:v' : 'h:h';
            }
        };
    }, {
        "../util/Geometry": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Geometry.js",
        "./LayoutUtil": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/layout/LayoutUtil.js",
        "lodash/collection/find": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/find.js",
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/model/index.js": [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            inherits = require('inherits');

        var Refs = require('object-refs');

        var parentRefs = new Refs({name: 'children', enumerable: true, collection: true}, {name: 'parent'}),
            labelRefs = new Refs({name: 'label', enumerable: true}, {name: 'labelTarget'}),
            outgoingRefs = new Refs({name: 'outgoing', collection: true}, {name: 'source'}),
            incomingRefs = new Refs({name: 'incoming', collection: true}, {name: 'target'});

        /**
         * @namespace djs.model
         */

        /**
         * @memberOf djs.model
         */

        /**
         * The basic graphical representation
         *
         * @class
         *
         * @abstract
         */
        function Base() {

            /**
             * The object that backs up the shape
             *
             * @name Base#businessObject
             * @type Object
             */
            Object.defineProperty(this, 'businessObject', {
                writable: true
            });

            /**
             * The parent shape
             *
             * @name Base#parent
             * @type Shape
             */
            parentRefs.bind(this, 'parent');

            /**
             * @name Base#label
             * @type Label
             */
            labelRefs.bind(this, 'label');

            /**
             * The list of outgoing connections
             *
             * @name Base#outgoing
             * @type Array<Connection>
             */
            outgoingRefs.bind(this, 'outgoing');

            /**
             * The list of outgoing connections
             *
             * @name Base#incoming
             * @type Array<Connection>
             */
            incomingRefs.bind(this, 'incoming');
        }


        /**
         * A graphical object
         *
         * @class
         * @constructor
         *
         * @extends Base
         */
        function Shape() {
            Base.call(this);

            /**
             * The list of children
             *
             * @name Shape#children
             * @type Array<Base>
             */
            parentRefs.bind(this, 'children');
        }

        inherits(Shape, Base);


        /**
         * A root graphical object
         *
         * @class
         * @constructor
         *
         * @extends Shape
         */
        function Root() {
            Shape.call(this);
        }

        inherits(Root, Shape);


        /**
         * A label for an element
         *
         * @class
         * @constructor
         *
         * @extends Shape
         */
        function Label() {
            Shape.call(this);

            /**
             * The labeled element
             *
             * @name Label#labelTarget
             * @type Base
             */
            labelRefs.bind(this, 'labelTarget');
        }

        inherits(Label, Shape);


        /**
         * A connection between two elements
         *
         * @class
         * @constructor
         *
         * @extends Base
         */
        function Connection() {
            Base.call(this);

            /**
             * The element this connection originates from
             *
             * @name Connection#source
             * @type Base
             */
            outgoingRefs.bind(this, 'source');

            /**
             * The element this connection points to
             *
             * @name Connection#target
             * @type Base
             */
            incomingRefs.bind(this, 'target');
        }

        inherits(Connection, Base);


        var types = {
            connection: Connection,
            shape: Shape,
            label: Label,
            root: Root
        };

        /**
         * Creates a new model element of the specified type
         *
         * @method create
         *
         * @example
         *
         * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });
         * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });
         *
         * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });
         *
         * @param  {String} type lower-cased model name
         * @param  {Object} attrs attributes to initialize the new model instance with
         *
         * @return {Base} the new model instance
         */
        module.exports.create = function (type, attrs) {
            var Type = types[type];
            if (!Type) {
                throw new Error('unknown type: <' + type + '>');
            }
            return assign(new Type(), attrs);
        };


        module.exports.Base = Base;
        module.exports.Root = Root;
        module.exports.Shape = Shape;
        module.exports.Connection = Connection;
        module.exports.Label = Label;
    }, {
        "inherits": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/inherits/inherits_browser.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "object-refs": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/object-refs/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js": [function (require, module, exports) {
        'use strict';

        var Cursor = require('../../util/Cursor'),
            ClickTrap = require('../../util/ClickTrap'),
            domEvent = require('min-dom/lib/event'),
            Event = require('../../util/Event');

        function substract(p1, p2) {
            return {
                x: p1.x - p2.x,
                y: p1.y - p2.y
            };
        }

        function length(point) {
            return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        }


        var THRESHOLD = 15;


        function MoveCanvas(eventBus, canvas) {

            var container = canvas._container,
                context;


            function handleMove(event) {

                var start = context.start,
                    position = Event.toPoint(event),
                    delta = substract(position, start);

                if (!context.dragging && length(delta) > THRESHOLD) {
                    context.dragging = true;

                    // prevent mouse click in this
                    // interaction sequence
                    ClickTrap.install();

                    Cursor.set('move');
                }

                if (context.dragging) {

                    var lastPosition = context.last || context.start;

                    delta = substract(position, lastPosition);

                    canvas.scroll({
                        dx: delta.x,
                        dy: delta.y
                    });

                    context.last = position;
                }

                // prevent select
                event.preventDefault();
            }


            function handleEnd(event) {
                domEvent.unbind(document, 'mousemove', handleMove);
                domEvent.unbind(document, 'mouseup', handleEnd);

                context = null;

                Cursor.unset();

                // prevent select
                Event.stopEvent(event);
            }

            function handleStart(event) {

                // reject non-left left mouse button or modifier key
                if (event.button || event.ctrlKey || event.shiftKey || event.altKey) {
                    return;
                }

                context = {
                    start: Event.toPoint(event)
                };

                domEvent.bind(document, 'mousemove', handleMove);
                domEvent.bind(document, 'mouseup', handleEnd);

                // prevent select
                Event.stopEvent(event);
            }

            domEvent.bind(container, 'mousedown', handleStart);
        }


        MoveCanvas.$inject = ['eventBus', 'canvas'];

        module.exports = MoveCanvas;

    }, {
        "../../util/ClickTrap": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/ClickTrap.js",
        "../../util/Cursor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Cursor.js",
        "../../util/Event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Event.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/movecanvas/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['moveCanvas'],
            moveCanvas: ['type', require('./MoveCanvas')]
        };
    }, {"./MoveCanvas": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/touch/index.js": [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../../features/touch')]
        };
    }, {"../../features/touch": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/features/touch/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js": [function (require, module, exports) {
        'use strict';

        var domEvent = require('min-dom/lib/event');

        var hasPrimaryModifier = require('../../util/Mouse').hasPrimaryModifier,
            hasSecondaryModifier = require('../../util/Mouse').hasSecondaryModifier;

        var isMac = require('../../util/Platform').isMac;


        function ZoomScroll(events, canvas) {

            var RANGE = {min: 0.2, max: 4};

            function cap(scale) {
                return Math.max(RANGE.min, Math.min(RANGE.max, scale));
            }

            function reset() {
                canvas.zoom('fit-viewport');
            }

            function zoom(direction, position) {

                var currentZoom = canvas.zoom();
                var factor = Math.pow(1 + Math.abs(direction), direction > 0 ? 1 : -1);

                canvas.zoom(cap(currentZoom * factor), position);
            }

            function scroll(delta) {
                canvas.scroll(delta);
            }

            function init(element) {

                domEvent.bind(element, 'wheel', function (event) {

                    event.preventDefault();

                    // mouse-event: SELECTION_KEY
                    // mouse-event: AND_KEY
                    var isVerticalScroll = hasPrimaryModifier(event),
                        isHorizontalScroll = hasSecondaryModifier(event);

                    var factor;

                    if (isVerticalScroll || isHorizontalScroll) {

                        if (isMac) {
                            factor = event.deltaMode === 0 ? 1.25 : 50;
                        } else {
                            factor = event.deltaMode === 0 ? 1 / 40 : 1 / 2;
                        }

                        var delta = {};

                        if (isHorizontalScroll) {
                            delta.dx = (factor * (event.deltaX || event.deltaY));
                        } else {
                            delta.dy = (factor * event.deltaY);
                        }

                        scroll(delta);
                    } else {
                        factor = (event.deltaMode === 0 ? 1 / 40 : 1 / 2);

                        var elementRect = element.getBoundingClientRect();

                        var offset = {
                            x: event.clientX - elementRect.left,
                            y: event.clientY - elementRect.top
                        };

                        // zoom in relative to diagram {x,y} coordinates
                        zoom(event.deltaY * factor / (-5), offset);
                    }
                });
            }

            events.on('canvas.init', function (e) {
                init(canvas._container);
            });

            // API
            this.zoom = zoom;
            this.reset = reset;
        }


        ZoomScroll.$inject = ['eventBus', 'canvas'];

        module.exports = ZoomScroll;


    }, {
        "../../util/Mouse": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Mouse.js",
        "../../util/Platform": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Platform.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/zoomscroll/index.js": [function (require, module, exports) {
        module.exports = {
            __init__: ['zoomScroll'],
            zoomScroll: ['type', require('./ZoomScroll')]
        };
    }, {"./ZoomScroll": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/ClickTrap.js": [function (require, module, exports) {
        'use strict';

        var domEvent = require('min-dom/lib/event'),
            stopEvent = require('./Event').stopEvent;

        function trap(event) {
            stopEvent(event);

            toggle(false);
        }

        function toggle(active) {
            domEvent[active ? 'bind' : 'unbind'](document.body, 'click', trap, true);
        }

        /**
         * Installs a click trap that prevents a ghost click following a dragging operation.
         *
         * @return {Function} a function to immediately remove the installed trap.
         */
        function install() {

            toggle(true);

            return function () {
                toggle(false);
            };
        }

        module.exports.install = install;
    }, {
        "./Event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Event.js",
        "min-dom/lib/event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Collections.js": [function (require, module, exports) {
        'use strict';

        /**
         * Failsafe remove an element from a collection
         *
         * @param  {Array<Object>} [collection]
         * @param  {Object} [element]
         *
         * @return {Object} the element that got removed or undefined
         */
        module.exports.remove = function (collection, element) {

            if (!collection || !element) {
                return;
            }

            var idx = collection.indexOf(element);
            if (idx === -1) {
                return;
            }

            collection.splice(idx, 1);

            return element;
        };

        /**
         * Fail save add an element to the given connection, ensuring
         * it does not yet exist.
         *
         * @param {Array<Object>} collection
         * @param {Object} element
         * @param {Number} idx
         */
        module.exports.add = function (collection, element, idx) {

            if (!collection || !element) {
                return;
            }

            if (isNaN(idx)) {
                idx = -1;
            }

            var currentIdx = collection.indexOf(element);

            if (currentIdx !== -1) {

                if (currentIdx === idx) {
                    // nothing to do, position has not changed
                    return;
                } else {

                    if (idx !== -1) {
                        // remove from current position
                        collection.splice(currentIdx, 1);
                    } else {
                        // already exists in collection
                        return;
                    }
                }
            }

            if (idx !== -1) {
                // insert at specified position
                collection.splice(idx, 0, element);
            } else {
                // push to end
                collection.push(element);
            }
        };


        /**
         * Fail get the index of an element in a collection.
         *
         * @param {Array<Object>} collection
         * @param {Object} element
         *
         * @return {Number} the index or -1 if collection or element do
         *                  not exist or the element is not contained.
         */
        module.exports.indexOf = function (collection, element) {

            if (!collection || !element) {
                return -1;
            }

            return collection.indexOf(element);
        };

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Cursor.js": [function (require, module, exports) {
        'use strict';

        var domClasses = require('min-dom/lib/classes');

        var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;


        module.exports.set = function (mode) {
            var classes = domClasses(document.body);

            classes.removeMatching(CURSOR_CLS_PATTERN);

            if (mode) {
                classes.add('djs-cursor-' + mode);
            }
        };

        module.exports.unset = function () {
            this.set(null);
        };
    }, {"min-dom/lib/classes": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/classes.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Elements.js": [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            isNumber = require('lodash/lang/isNumber'),
            groupBy = require('lodash/collection/groupBy'),
            forEach = require('lodash/collection/forEach');

        /**
         * Adds an element to a collection and returns true if the
         * element was added.
         *
         * @param {Array<Object>} elements
         * @param {Object} e
         * @param {Boolean} unique
         */
        function add(elements, e, unique) {
            var canAdd = !unique || elements.indexOf(e) === -1;

            if (canAdd) {
                elements.push(e);
            }

            return canAdd;
        }

        function eachElement(elements, fn, depth) {

            depth = depth || 0;

            forEach(elements, function (s, i) {
                var filter = fn(s, i, depth);

                if (isArray(filter) && filter.length) {
                    eachElement(filter, fn, depth + 1);
                }
            });
        }

        /**
         * Collects self + child elements up to a given depth from a list of elements.
         *
         * @param  {Array<djs.model.Base>} elements the elements to select the children from
         * @param  {Boolean} unique whether to return a unique result set (no duplicates)
         * @param  {Number} maxDepth the depth to search through or -1 for infinite
         *
         * @return {Array<djs.model.Base>} found elements
         */
        function selfAndChildren(elements, unique, maxDepth) {
            var result = [],
                processedChildren = [];

            eachElement(elements, function (element, i, depth) {
                add(result, element, unique);

                var children = element.children;

                // max traversal depth not reached yet
                if (maxDepth === -1 || depth < maxDepth) {

                    // children exist && children not yet processed
                    if (children && add(processedChildren, children, unique)) {
                        return children;
                    }
                }
            });

            return result;
        }

        /**
         * Return self + direct children for a number of elements
         *
         * @param  {Array<djs.model.Base>} elements to query
         * @param  {Boolean} allowDuplicates to allow duplicates in the result set
         *
         * @return {Array<djs.model.Base>} the collected elements
         */
        function selfAndDirectChildren(elements, allowDuplicates) {
            return selfAndChildren(elements, !allowDuplicates, 1);
        }

        /**
         * Return self + ALL children for a number of elements
         *
         * @param  {Array<djs.model.Base>} elements to query
         * @param  {Boolean} allowDuplicates to allow duplicates in the result set
         *
         * @return {Array<djs.model.Base>} the collected elements
         */
        function selfAndAllChildren(elements, allowDuplicates) {
            return selfAndChildren(elements, !allowDuplicates, -1);
        }

        /**
         * Gets the the closure fo all selected elements,
         * their connections and
         *
         * @param {Array<djs.model.Base>} elements
         * @return {Object} enclosure
         */
        function getClosure(elements) {

            // original elements passed to this function
            var topLevel = groupBy(elements, function (e) {
                return e.id;
            });

            var allShapes = {},
                allConnections = {},
                enclosedElements = {},
                enclosedConnections = {};

            function handleConnection(c) {
                if (topLevel[c.source.id] && topLevel[c.target.id]) {
                    topLevel[c.id] = c;
                }

                // not enclosed as a child, but maybe logically
                // (connecting two moved elements?)
                if (allShapes[c.source.id] && allShapes[c.target.id]) {
                    enclosedConnections[c.id] = enclosedElements[c.id] = c;
                }

                allConnections[c.id] = c;
            }

            function handleElement(element) {

                enclosedElements[element.id] = element;

                if (element.waypoints) {
                    // remember connection
                    enclosedConnections[element.id] = allConnections[element.id] = element;
                } else {
                    // remember shape
                    allShapes[element.id] = element;

                    // remember all connections
                    forEach(element.incoming, handleConnection);

                    forEach(element.outgoing, handleConnection);

                    // recurse into children
                    return element.children;
                }
            }

            eachElement(elements, handleElement);

            return {
                allShapes: allShapes,
                allConnections: allConnections,
                topLevel: topLevel,
                enclosedConnections: enclosedConnections,
                enclosedElements: enclosedElements
            };
        }

        /**
         * Returns the surrounding bbox for all elements in the array or the element primitive.
         */
        function getBBox(elements, stopRecursion) {

            stopRecursion = !!stopRecursion;
            if (!isArray(elements)) {
                elements = [elements];
            }

            var minX,
                minY,
                maxX,
                maxY;

            forEach(elements, function (element) {

                // If element is a connection the bbox must be computed first
                var bbox = element;
                if (element.waypoints && !stopRecursion) {
                    bbox = getBBox(element.waypoints, true);
                }

                var x = bbox.x,
                    y = bbox.y,
                    height = bbox.height || 0,
                    width = bbox.width || 0;

                if (x < minX || minX === undefined) {
                    minX = x;
                }
                if (y < minY || minY === undefined) {
                    minY = y;
                }

                if ((x + width) > maxX || maxX === undefined) {
                    maxX = x + width;
                }
                if ((y + height) > maxY || maxY === undefined) {
                    maxY = y + height;
                }
            });

            return {
                x: minX,
                y: minY,
                height: maxY - minY,
                width: maxX - minX
            };
        }


        /**
         * Returns all elements that are enclosed from the bounding box.
         *
         * @param {Array<Object>} elements List of Elements to search through
         * @param {Object} bbox the enclosing bbox.
         * <ul>
         *  <li>If bbox.(width|height) is not specified
         * the method returns all elements with element.x/y &gt; bbox.x/y
         * </li>
         *  <li>If only bbox.x or bbox.y is specified, method return all elements with
         *  e.x &gt; bbox.x or e.y &gt; bbox.y.</li>
         * </ul>
         *
         */
        function getEnclosedElements(elements, bbox) {

            var filteredElements = {};

            forEach(elements, function (element) {

                var e = element;

                if (e.waypoints) {
                    e = getBBox(e);
                }

                if (!isNumber(bbox.y) && (e.x > bbox.x)) {
                    filteredElements[element.id] = element;
                }
                if (!isNumber(bbox.x) && (e.y > bbox.y)) {
                    filteredElements[element.id] = element;
                }
                if (e.x > bbox.x && e.y > bbox.y) {
                    if (isNumber(bbox.width) && isNumber(bbox.height) &&
                        e.width + e.x < bbox.width + bbox.x &&
                        e.height + e.y < bbox.height + bbox.y) {

                        filteredElements[element.id] = element;
                    } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {
                        filteredElements[element.id] = element;
                    }
                }
            });

            return filteredElements;
        }


        module.exports.eachElement = eachElement;
        module.exports.selfAndDirectChildren = selfAndDirectChildren;
        module.exports.selfAndAllChildren = selfAndAllChildren;
        module.exports.getBBox = getBBox;
        module.exports.getEnclosedElements = getEnclosedElements;

        module.exports.getClosure = getClosure;

    }, {
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/collection/groupBy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/groupBy.js",
        "lodash/lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "lodash/lang/isNumber": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isNumber.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Event.js": [function (require, module, exports) {
        'use strict';

        function __preventDefault(event) {
            return event && event.preventDefault();
        }

        function __stopPropagation(event, immediate) {
            if (!event) {
                return;
            }

            if (event.stopPropagation) {
                event.stopPropagation();
            }

            if (immediate && event.stopImmediatePropagation) {
                event.stopImmediatePropagation();
            }
        }


        function getOriginal(event) {
            return event.originalEvent || event.srcEvent;
        }

        module.exports.getOriginal = getOriginal;


        function stopEvent(event, immediate) {
            stopPropagation(event, immediate);
            preventDefault(event);
        }

        module.exports.stopEvent = stopEvent;


        function preventDefault(event) {
            __preventDefault(event);
            __preventDefault(getOriginal(event));
        }

        module.exports.preventDefault = preventDefault;


        function stopPropagation(event, immediate) {
            __stopPropagation(event, immediate);
            __stopPropagation(getOriginal(event), immediate);
        }

        module.exports.stopPropagation = stopPropagation;


        function toPoint(event) {

            if (event.pointers && event.pointers.length) {
                event = event.pointers[0];
            }

            if (event.touches && event.touches.length) {
                event = event.touches[0];
            }

            return event ? {
                x: event.clientX,
                y: event.clientY
            } : null;
        }

        module.exports.toPoint = toPoint;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Geometry.js": [function (require, module, exports) {
        'use strict';

        /**
         * Computes the distance between two points
         *
         * @param  {Point}  p
         * @param  {Point}  q
         *
         * @return {Number}  distance
         */
        var distance = module.exports.distance = function (p, q) {
            return Math.sqrt(Math.pow(q.x - p.x, 2) + Math.pow(q.y - p.y, 2));
        };

        /**
         * Returns true if the point r is on the line between p and y
         *
         * @param  {Point}  p
         * @param  {Point}  q
         * @param  {Point}  r
         *
         * @return {Boolean}
         */
        module.exports.pointsOnLine = function (p, q, r) {

            if (!p || !q || !r) {
                return false;
            }

            var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),
                dist = distance(p, q);

            // @see http://stackoverflow.com/a/907491/412190
            return Math.abs(val / dist) < 5;
        };

        module.exports.pointInRect = function (p, rect, tolerance) {
            tolerance = tolerance || 0;

            return p.x > rect.x - tolerance &&
                p.y > rect.y - tolerance &&
                p.x < rect.x + rect.width + tolerance &&
                p.y < rect.y + rect.height + tolerance;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/GraphicsUtil.js": [function (require, module, exports) {
        'use strict';

        /**
         * SVGs for elements are generated by the {@link GraphicsFactory}.
         *
         * This utility gives quick access to the important semantic
         * parts of an element.
         */

        /**
         * Returns the visual part of a diagram element
         *
         * @param {Snap<SVGElement>} gfx
         *
         * @return {Snap<SVGElement>}
         */
        function getVisual(gfx) {
            return gfx.select('.djs-visual');
        }

        /**
         * Returns the children for a given diagram element.
         *
         * @param {Snap<SVGElement>} gfx
         * @return {Snap<SVGElement>}
         */
        function getChildren(gfx) {
            return gfx.parent().children()[1];
        }

        /**
         * Returns the visual bbox of an element
         *
         * @param {Snap<SVGElement>} gfx
         *
         * @return {Bounds}
         */
        function getBBox(gfx) {
            return getVisual(gfx).select('*').getBBox();
        }


        module.exports.getVisual = getVisual;
        module.exports.getChildren = getChildren;
        module.exports.getBBox = getBBox;
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/IdGenerator.js": [function (require, module, exports) {
        'use strict';

        /**
         * Util that provides unique IDs.
         *
         * @class djs.util.IdGenerator
         * @constructor
         * @memberOf djs.util
         *
         * The ids can be customized via a given prefix and contain a random value to avoid collisions.
         *
         * @param {String} prefix a prefix to prepend to generated ids (for better readability)
         */
        function IdGenerator(prefix) {

            this._counter = 0;
            this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';
        }

        module.exports = IdGenerator;

        /**
         * Returns a next unique ID.
         *
         * @method djs.util.IdGenerator#next
         *
         * @returns {String} the id
         */
        IdGenerator.prototype.next = function () {
            return this._prefix + (++this._counter);
        };

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Mouse.js": [function (require, module, exports) {
        'use strict';

        var getOriginalEvent = require('./Event').getOriginal;

        var isMac = require('./Platform').isMac;


        function isPrimaryButton(event) {
            // button === 0 -> left áka primary mouse button
            return !(getOriginalEvent(event) || event).button;
        }

        module.exports.isPrimaryButton = isPrimaryButton;

        module.exports.isMac = isMac;

        module.exports.hasPrimaryModifier = function (event) {
            var originalEvent = getOriginalEvent(event) || event;

            if (!isPrimaryButton(event)) {
                return false;
            }

            // Use alt as primary modifier key for mac OS
            if (isMac()) {
                return originalEvent.altKey;
            } else {
                return originalEvent.ctrlKey;
            }
        };


        module.exports.hasSecondaryModifier = function (event) {
            var originalEvent = getOriginalEvent(event) || event;

            return isPrimaryButton(event) && originalEvent.shiftKey;
        };

    }, {
        "./Event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Event.js",
        "./Platform": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Platform.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Platform.js": [function (require, module, exports) {
        'use strict';

        module.exports.isMac = function isMac() {
            return (/mac/i).test(navigator.platform);
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/lib/util/Text.js": [function (require, module, exports) {
        'use strict';

        var isObject = require('lodash/lang/isObject'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            reduce = require('lodash/collection/reduce'),
            merge = require('lodash/object/merge');

        var Snap = require('../../vendor/snapsvg');

        var DEFAULT_BOX_PADDING = 0;

        var DEFAULT_LABEL_SIZE = {
            width: 150,
            height: 50
        };


        function parseAlign(align) {

            var parts = align.split('-');

            return {
                horizontal: parts[0] || 'center',
                vertical: parts[1] || 'top'
            };
        }

        function parsePadding(padding) {

            if (isObject(padding)) {
                return assign({top: 0, left: 0, right: 0, bottom: 0}, padding);
            } else {
                return {
                    top: padding,
                    left: padding,
                    right: padding,
                    bottom: padding
                };
            }
        }

        function getTextBBox(text, fakeText) {
            fakeText.textContent = text;
            return fakeText.getBBox();
        }


        /**
         * Layout the next line and return the layouted element.
         *
         * Alters the lines passed.
         *
         * @param  {Array<String>} lines
         * @return {Object} the line descriptor, an object { width, height, text }
         */
        function layoutNext(lines, maxWidth, fakeText) {

            var originalLine = lines.shift(),
                fitLine = originalLine;

            var textBBox;

            while (true) {
                textBBox = getTextBBox(fitLine, fakeText);

                textBBox.width = fitLine ? textBBox.width : 0;

                // try to fit
                if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 4) {
                    return fit(lines, fitLine, originalLine, textBBox);
                }


                fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
            }
        }

        function fit(lines, fitLine, originalLine, textBBox) {
            if (fitLine.length < originalLine.length) {
                var nextLine = lines[0] || '',
                    remainder = originalLine.slice(fitLine.length).trim();

                if (/-\s*$/.test(remainder)) {
                    nextLine = remainder.replace(/-\s*$/, '') + nextLine.replace(/^\s+/, '');
                } else {
                    nextLine = remainder + ' ' + nextLine;
                }

                lines[0] = nextLine;
            }
            return {width: textBBox.width, height: textBBox.height, text: fitLine};
        }


        /**
         * Shortens a line based on spacing and hyphens.
         * Returns the shortened result on success.
         *
         * @param  {String} line
         * @param  {Number} maxLength the maximum characters of the string
         * @return {String} the shortened string
         */
        function semanticShorten(line, maxLength) {
            var parts = line.split(/(\s|-)/g),
                part,
                shortenedParts = [],
                length = 0;

            // try to shorten via spaces + hyphens
            if (parts.length > 1) {
                while ((part = parts.shift())) {
                    if (part.length + length < maxLength) {
                        shortenedParts.push(part);
                        length += part.length;
                    } else {
                        // remove previous part, too if hyphen does not fit anymore
                        if (part === '-') {
                            shortenedParts.pop();
                        }

                        break;
                    }
                }
            }

            return shortenedParts.join('');
        }


        function shortenLine(line, width, maxWidth) {
            var length = Math.max(line.length * (maxWidth / width), 1);

            // try to shorten semantically (i.e. based on spaces and hyphens)
            var shortenedLine = semanticShorten(line, length);

            if (!shortenedLine) {

                // force shorten by cutting the long word
                shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));
            }

            return shortenedLine;
        }


        /**
         * Creates a new label utility
         *
         * @param {Object} config
         * @param {Dimensions} config.size
         * @param {Number} config.padding
         * @param {Object} config.style
         * @param {String} config.align
         */
        function Text(config) {

            this._config = assign({}, {
                size: DEFAULT_LABEL_SIZE,
                padding: DEFAULT_BOX_PADDING,
                style: {},
                align: 'center-top'
            }, config || {});
        }


        /**
         * Create a label in the parent node.
         *
         * @method Text#createText
         *
         * @param {SVGElement} parent the parent to draw the label on
         * @param {String} text the text to render on the label
         * @param {Object} options
         * @param {String} options.align how to align in the bounding box.
         *                             Any of { 'center-middle', 'center-top' }, defaults to 'center-top'.
         * @param {String} options.style style to be applied to the text
         *
         * @return {SVGText} the text element created
         */
        Text.prototype.createText = function (parent, text, options) {

            var box = merge({}, this._config.size, options.box || {}),
                style = merge({}, this._config.style, options.style || {}),
                align = parseAlign(options.align || this._config.align),
                padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding);

            var lines = text.split(/\r?\n/g),
                layouted = [];

            var maxWidth = box.width - padding.left - padding.right;

            // FF regression: ensure text is shown during rendering
            // by attaching it directly to the body
            var fakeText = parent.paper.text(0, 0, '').attr(style).node;

            while (lines.length) {
                layouted.push(layoutNext(lines, maxWidth, fakeText));
            }

            var totalHeight = reduce(layouted, function (sum, line, idx) {
                return sum + line.height;
            }, 0);

            // the y position of the next line
            var y, x;

            switch (align.vertical) {
                case 'middle':
                    y = (box.height - totalHeight) / 2 - layouted[0].height / 4;
                    break;

                default:
                    y = padding.top;
            }

            var textElement = parent.text().attr(style);

            forEach(layouted, function (line) {
                y += line.height;

                switch (align.horizontal) {
                    case 'left':
                        x = padding.left;
                        break;

                    case 'right':
                        x = (maxWidth - padding.right - line.width);
                        break;

                    default:
                        // aka center
                        x = Math.max(((maxWidth - line.width) / 2 + padding.left), 0);
                }


                var tspan = Snap.create('tspan', {x: x, y: y}).node;
                tspan.textContent = line.text;

                textElement.append(tspan);
            });

            // remove fake text
            fakeText.parentNode.removeChild(fakeText);

            return textElement;
        };


        module.exports = Text;
    }, {
        "../../vendor/snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js",
        "lodash/collection/forEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js",
        "lodash/collection/reduce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/reduce.js",
        "lodash/lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js",
        "lodash/object/assign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js",
        "lodash/object/merge": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/merge.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/annotation.js": [function (require, module, exports) {

        var isArray = function (obj) {
            return Object.prototype.toString.call(obj) === '[object Array]';
        };

        var annotate = function () {
            var args = Array.prototype.slice.call(arguments);

            if (args.length === 1 && isArray(args[0])) {
                args = args[0];
            }

            var fn = args.pop();

            fn.$inject = args;

            return fn;
        };


// Current limitations:
// - can't put into "function arg" comments
// function /* (no parenthesis like this) */ (){}
// function abc( /* xx (no parenthesis like this) */ a, b) {}
//
// Just put the comment before function or inside:
// /* (((this is fine))) */ function(a, b) {}
// function abc(a) { /* (((this is fine))) */}

        var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
        var FN_ARG = /\/\*([^\*]*)\*\//m;

        var parse = function (fn) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot annotate "' + fn + '". Expected a function!');
            }

            var match = fn.toString().match(FN_ARGS);
            return match[1] && match[1].split(',').map(function (arg) {
                    match = arg.match(FN_ARG);
                    return match ? match[1].trim() : arg.trim();
                }) || [];
        };


        exports.annotate = annotate;
        exports.parse = parse;
        exports.isArray = isArray;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/index.js": [function (require, module, exports) {
        module.exports = {
            annotate: require('./annotation').annotate,
            Module: require('./module'),
            Injector: require('./injector')
        };

    }, {
        "./annotation": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/annotation.js",
        "./injector": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/injector.js",
        "./module": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/module.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/injector.js": [function (require, module, exports) {
        var Module = require('./module');
        var autoAnnotate = require('./annotation').parse;
        var annotate = require('./annotation').annotate;
        var isArray = require('./annotation').isArray;


        var Injector = function (modules, parent) {
            parent = parent || {
                get: function (name) {
                    currentlyResolving.push(name);
                    throw error('No provider for "' + name + '"!');
                }
            };

            var currentlyResolving = [];
            var providers = this._providers = Object.create(parent._providers || null);
            var instances = this._instances = Object.create(null);

            var self = instances.injector = this;

            var error = function (msg) {
                var stack = currentlyResolving.join(' -> ');
                currentlyResolving.length = 0;
                return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);
            };

            var get = function (name) {
                if (!providers[name] && name.indexOf('.') !== -1) {
                    var parts = name.split('.');
                    var pivot = get(parts.shift());

                    while (parts.length) {
                        pivot = pivot[parts.shift()];
                    }

                    return pivot;
                }

                if (Object.hasOwnProperty.call(instances, name)) {
                    return instances[name];
                }

                if (Object.hasOwnProperty.call(providers, name)) {
                    if (currentlyResolving.indexOf(name) !== -1) {
                        currentlyResolving.push(name);
                        throw error('Cannot resolve circular dependency!');
                    }

                    currentlyResolving.push(name);
                    instances[name] = providers[name][0](providers[name][1]);
                    currentlyResolving.pop();

                    return instances[name];
                }

                return parent.get(name);
            };

            var instantiate = function (Type) {
                var instance = Object.create(Type.prototype);
                var returned = invoke(Type, instance);

                return typeof returned === 'object' ? returned : instance;
            };

            var invoke = function (fn, context) {
                if (typeof fn !== 'function') {
                    if (isArray(fn)) {
                        fn = annotate(fn.slice());
                    } else {
                        throw new Error('Cannot invoke "' + fn + '". Expected a function!');
                    }
                }

                var inject = fn.$inject && fn.$inject || autoAnnotate(fn);
                var dependencies = inject.map(function (dep) {
                    return get(dep);
                });

                // TODO(vojta): optimize without apply
                return fn.apply(context, dependencies);
            };


            var createPrivateInjectorFactory = function (privateChildInjector) {
                return annotate(function (key) {
                    return privateChildInjector.get(key);
                });
            };

            var createChild = function (modules, forceNewInstances) {
                if (forceNewInstances && forceNewInstances.length) {
                    var fromParentModule = Object.create(null);
                    var matchedScopes = Object.create(null);

                    var privateInjectorsCache = [];
                    var privateChildInjectors = [];
                    var privateChildFactories = [];

                    var provider;
                    var cacheIdx;
                    var privateChildInjector;
                    var privateChildInjectorFactory;
                    for (var name in providers) {
                        provider = providers[name];

                        if (forceNewInstances.indexOf(name) !== -1) {
                            if (provider[2] === 'private') {
                                cacheIdx = privateInjectorsCache.indexOf(provider[3]);
                                if (cacheIdx === -1) {
                                    privateChildInjector = provider[3].createChild([], forceNewInstances);
                                    privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
                                    privateInjectorsCache.push(provider[3]);
                                    privateChildInjectors.push(privateChildInjector);
                                    privateChildFactories.push(privateChildInjectorFactory);
                                    fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];
                                } else {
                                    fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];
                                }
                            } else {
                                fromParentModule[name] = [provider[2], provider[1]];
                            }
                            matchedScopes[name] = true;
                        }

                        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {
                            forceNewInstances.forEach(function (scope) {
                                if (provider[1].$scope.indexOf(scope) !== -1) {
                                    fromParentModule[name] = [provider[2], provider[1]];
                                    matchedScopes[scope] = true;
                                }
                            });
                        }
                    }

                    forceNewInstances.forEach(function (scope) {
                        if (!matchedScopes[scope]) {
                            throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
                        }
                    });

                    modules.unshift(fromParentModule);
                }

                return new Injector(modules, self);
            };

            var factoryMap = {
                factory: invoke,
                type: instantiate,
                value: function (value) {
                    return value;
                }
            };

            modules.forEach(function (module) {

                function arrayUnwrap(type, value) {
                    if (type !== 'value' && isArray(value)) {
                        value = annotate(value.slice());
                    }

                    return value;
                }

                // TODO(vojta): handle wrong inputs (modules)
                if (module instanceof Module) {
                    module.forEach(function (provider) {
                        var name = provider[0];
                        var type = provider[1];
                        var value = provider[2];

                        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
                    });
                } else if (typeof module === 'object') {
                    if (module.__exports__) {
                        var clonedModule = Object.keys(module).reduce(function (m, key) {
                            if (key.substring(0, 2) !== '__') {
                                m[key] = module[key];
                            }
                            return m;
                        }, Object.create(null));

                        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);
                        var getFromPrivateInjector = annotate(function (key) {
                            return privateInjector.get(key);
                        });
                        module.__exports__.forEach(function (key) {
                            providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];
                        });
                    } else {
                        Object.keys(module).forEach(function (name) {
                            if (module[name][2] === 'private') {
                                providers[name] = module[name];
                                return;
                            }

                            var type = module[name][0];
                            var value = module[name][1];

                            providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
                        });
                    }
                }
            });

            // public API
            this.get = get;
            this.invoke = invoke;
            this.instantiate = instantiate;
            this.createChild = createChild;
        };

        module.exports = Injector;

    }, {
        "./annotation": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/annotation.js",
        "./module": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/module.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/didi/lib/module.js": [function (require, module, exports) {
        var Module = function () {
            var providers = [];

            this.factory = function (name, factory) {
                providers.push([name, 'factory', factory]);
                return this;
            };

            this.value = function (name, value) {
                providers.push([name, 'value', value]);
                return this;
            };

            this.type = function (name, type) {
                providers.push([name, 'type', type]);
                return this;
            };

            this.forEach = function (iterator) {
                providers.forEach(iterator);
            };
        };

        module.exports = Module;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/eve/eve.js": [function (require, module, exports) {
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\

        (function (glob) {
            var version = "0.4.2",
                has = "hasOwnProperty",
                separator = /[\.\/]/,
                comaseparator = /\s*,\s*/,
                wildcard = "*",
                fun = function () {
                },
                numsort = function (a, b) {
                    return a - b;
                },
                current_event,
                stop,
                events = {n: {}},
                firstDefined = function () {
                    for (var i = 0, ii = this.length; i < ii; i++) {
                        if (typeof this[i] != "undefined") {
                            return this[i];
                        }
                    }
                },
                lastDefined = function () {
                    var i = this.length;
                    while (--i) {
                        if (typeof this[i] != "undefined") {
                            return this[i];
                        }
                    }
                },
            /*\
             * eve
             [ method ]

             * Fires event with given `name`, given scope and other parameters.

             > Arguments

             - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
             - scope (object) context for the event handlers
             - varargs (...) the rest of arguments will be sent to event handlers

             = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
             \*/
                eve = function (name, scope) {
                    name = String(name);
                    var e = events,
                        oldstop = stop,
                        args = Array.prototype.slice.call(arguments, 2),
                        listeners = eve.listeners(name),
                        z = 0,
                        f = false,
                        l,
                        indexed = [],
                        queue = {},
                        out = [],
                        ce = current_event,
                        errors = [];
                    out.firstDefined = firstDefined;
                    out.lastDefined = lastDefined;
                    current_event = name;
                    stop = 0;
                    for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                        indexed.push(listeners[i].zIndex);
                        if (listeners[i].zIndex < 0) {
                            queue[listeners[i].zIndex] = listeners[i];
                        }
                    }
                    indexed.sort(numsort);
                    while (indexed[z] < 0) {
                        l = queue[indexed[z++]];
                        out.push(l.apply(scope, args));
                        if (stop) {
                            stop = oldstop;
                            return out;
                        }
                    }
                    for (i = 0; i < ii; i++) {
                        l = listeners[i];
                        if ("zIndex" in l) {
                            if (l.zIndex == indexed[z]) {
                                out.push(l.apply(scope, args));
                                if (stop) {
                                    break;
                                }
                                do {
                                    z++;
                                    l = queue[indexed[z]];
                                    l && out.push(l.apply(scope, args));
                                    if (stop) {
                                        break;
                                    }
                                } while (l)
                            } else {
                                queue[l.zIndex] = l;
                            }
                        } else {
                            out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        }
                    }
                    stop = oldstop;
                    current_event = ce;
                    return out;
                };
            // Undocumented. Debug only.
            eve._events = events;
            /*\
             * eve.listeners
             [ method ]

             * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

             > Arguments

             - name (string) name of the event, dot (`.`) or slash (`/`) separated

             = (array) array of event handlers
             \*/
            eve.listeners = function (name) {
                var names = name.split(separator),
                    e = events,
                    item,
                    items,
                    k,
                    i,
                    ii,
                    j,
                    jj,
                    nes,
                    es = [e],
                    out = [];
                for (i = 0, ii = names.length; i < ii; i++) {
                    nes = [];
                    for (j = 0, jj = es.length; j < jj; j++) {
                        e = es[j].n;
                        items = [e[names[i]], e[wildcard]];
                        k = 2;
                        while (k--) {
                            item = items[k];
                            if (item) {
                                nes.push(item);
                                out = out.concat(item.f || []);
                            }
                        }
                    }
                    es = nes;
                }
                return out;
            };

            /*\
             * eve.on
             [ method ]
             **
             * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
             | eve.on("*.under.*", f);
             | eve("mouse.under.floor"); // triggers f
             * Use @eve to trigger the listener.
             **
             > Arguments
             **
             - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
             - f (function) event handler function
             **
             = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
             > Example:
             | eve.on("mouse", eatIt)(2);
             | eve.on("mouse", scream);
             | eve.on("mouse", catchIt)(1);
             * This will ensure that `catchIt` function will be called before `eatIt`.
             *
             * If you want to put your handler before non-indexed handlers, specify a negative value.
             * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
             \*/
            eve.on = function (name, f) {
                name = String(name);
                if (typeof f != "function") {
                    return function () {
                    };
                }
                var names = name.split(comaseparator);
                for (var i = 0, ii = names.length; i < ii; i++) {
                    (function (name) {
                        var names = name.split(separator),
                            e = events,
                            exist;
                        for (var i = 0, ii = names.length; i < ii; i++) {
                            e = e.n;
                            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
                        }
                        e.f = e.f || [];
                        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
                            exist = true;
                            break;
                        }
                        !exist && e.f.push(f);
                    }(names[i]));
                }
                return function (zIndex) {
                    if (+zIndex == +zIndex) {
                        f.zIndex = +zIndex;
                    }
                };
            };
            /*\
             * eve.f
             [ method ]
             **
             * Returns function that will fire given event with optional arguments.
             * Arguments that will be passed to the result function will be also
             * concated to the list of final arguments.
             | el.onclick = eve.f("click", 1, 2);
             | eve.on("click", function (a, b, c) {
             |     console.log(a, b, c); // 1, 2, [event object]
             | });
             > Arguments
             - event (string) event name
             - varargs (…) and any other arguments
             = (function) possible event handler function
             \*/
            eve.f = function (event) {
                var attrs = [].slice.call(arguments, 1);
                return function () {
                    eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
                };
            };
            /*\
             * eve.stop
             [ method ]
             **
             * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
             \*/
            eve.stop = function () {
                stop = 1;
            };
            /*\
             * eve.nt
             [ method ]
             **
             * Could be used inside event handler to figure out actual name of the event.
             **
             > Arguments
             **
             - subname (string) #optional subname of the event
             **
             = (string) name of the event, if `subname` is not specified
             * or
             = (boolean) `true`, if current event’s name contains `subname`
             \*/
            eve.nt = function (subname) {
                if (subname) {
                    return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
                }
                return current_event;
            };
            /*\
             * eve.nts
             [ method ]
             **
             * Could be used inside event handler to figure out actual name of the event.
             **
             **
             = (array) names of the event
             \*/
            eve.nts = function () {
                return current_event.split(separator);
            };
            /*\
             * eve.off
             [ method ]
             **
             * Removes given function from the list of event listeners assigned to given name.
             * If no arguments specified all the events will be cleared.
             **
             > Arguments
             **
             - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
             - f (function) event handler function
             \*/
            /*\
             * eve.unbind
             [ method ]
             **
             * See @eve.off
             \*/
            eve.off = eve.unbind = function (name, f) {
                if (!name) {
                    eve._events = events = {n: {}};
                    return;
                }
                var names = name.split(comaseparator);
                if (names.length > 1) {
                    for (var i = 0, ii = names.length; i < ii; i++) {
                        eve.off(names[i], f);
                    }
                    return;
                }
                names = name.split(separator);
                var e,
                    key,
                    splice,
                    i, ii, j, jj,
                    cur = [events];
                for (i = 0, ii = names.length; i < ii; i++) {
                    for (j = 0; j < cur.length; j += splice.length - 2) {
                        splice = [j, 1];
                        e = cur[j].n;
                        if (names[i] != wildcard) {
                            if (e[names[i]]) {
                                splice.push(e[names[i]]);
                            }
                        } else {
                            for (key in e) if (e[has](key)) {
                                splice.push(e[key]);
                            }
                        }
                        cur.splice.apply(cur, splice);
                    }
                }
                for (i = 0, ii = cur.length; i < ii; i++) {
                    e = cur[i];
                    while (e.n) {
                        if (f) {
                            if (e.f) {
                                for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                                    e.f.splice(j, 1);
                                    break;
                                }
                                !e.f.length && delete e.f;
                            }
                            for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                                var funcs = e.n[key].f;
                                for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                                    funcs.splice(j, 1);
                                    break;
                                }
                                !funcs.length && delete e.n[key].f;
                            }
                        } else {
                            delete e.f;
                            for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                                delete e.n[key].f;
                            }
                        }
                        e = e.n;
                    }
                }
            };
            /*\
             * eve.once
             [ method ]
             **
             * Binds given event handler with a given name to only run once then unbind itself.
             | eve.once("login", f);
             | eve("login"); // triggers f
             | eve("login"); // no listeners
             * Use @eve to trigger the listener.
             **
             > Arguments
             **
             - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
             - f (function) event handler function
             **
             = (function) same return function as @eve.on
             \*/
            eve.once = function (name, f) {
                var f2 = function () {
                    eve.unbind(name, f2);
                    return f.apply(this, arguments);
                };
                return eve.on(name, f2);
            };
            /*\
             * eve.version
             [ property (string) ]
             **
             * Current version of the library.
             \*/
            eve.version = version;
            eve.toString = function () {
                return "You are running Eve " + version;
            };
            (typeof module != "undefined" && module.exports) ? (module.exports = eve) : (typeof define === "function" && define.amd ? (define("eve", [], function () {
                return eve;
            })) : (glob.eve = eve));
        })(this);

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/hammerjs/hammer.js": [function (require, module, exports) {
        /*! Hammer.JS - v2.0.4 - 2014-09-28
         * http://hammerjs.github.io/
         *
         * Copyright (c) 2014 Jorik Tangelder;
         * Licensed under the MIT license */
        (function (window, document, exportName, undefined) {
            'use strict';

            var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
            var TEST_ELEMENT = document.createElement('div');

            var TYPE_FUNCTION = 'function';

            var round = Math.round;
            var abs = Math.abs;
            var now = Date.now;

            /**
             * set a timeout with a given scope
             * @param {Function} fn
             * @param {Number} timeout
             * @param {Object} context
             * @returns {number}
             */
            function setTimeoutContext(fn, timeout, context) {
                return setTimeout(bindFn(fn, context), timeout);
            }

            /**
             * if the argument is an array, we want to execute the fn on each entry
             * if it aint an array we don't want to do a thing.
             * this is used by all the methods that accept a single and array argument.
             * @param {*|Array} arg
             * @param {String} fn
             * @param {Object} [context]
             * @returns {Boolean}
             */
            function invokeArrayArg(arg, fn, context) {
                if (Array.isArray(arg)) {
                    each(arg, context[fn], context);
                    return true;
                }
                return false;
            }

            /**
             * walk objects and arrays
             * @param {Object} obj
             * @param {Function} iterator
             * @param {Object} context
             */
            function each(obj, iterator, context) {
                var i;

                if (!obj) {
                    return;
                }

                if (obj.forEach) {
                    obj.forEach(iterator, context);
                } else if (obj.length !== undefined) {
                    i = 0;
                    while (i < obj.length) {
                        iterator.call(context, obj[i], i, obj);
                        i++;
                    }
                } else {
                    for (i in obj) {
                        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
                    }
                }
            }

            /**
             * extend object.
             * means that properties in dest will be overwritten by the ones in src.
             * @param {Object} dest
             * @param {Object} src
             * @param {Boolean} [merge]
             * @returns {Object} dest
             */
            function extend(dest, src, merge) {
                var keys = Object.keys(src);
                var i = 0;
                while (i < keys.length) {
                    if (!merge || (merge && dest[keys[i]] === undefined)) {
                        dest[keys[i]] = src[keys[i]];
                    }
                    i++;
                }
                return dest;
            }

            /**
             * merge the values from src in the dest.
             * means that properties that exist in dest will not be overwritten by src
             * @param {Object} dest
             * @param {Object} src
             * @returns {Object} dest
             */
            function merge(dest, src) {
                return extend(dest, src, true);
            }

            /**
             * simple class inheritance
             * @param {Function} child
             * @param {Function} base
             * @param {Object} [properties]
             */
            function inherit(child, base, properties) {
                var baseP = base.prototype,
                    childP;

                childP = child.prototype = Object.create(baseP);
                childP.constructor = child;
                childP._super = baseP;

                if (properties) {
                    extend(childP, properties);
                }
            }

            /**
             * simple function bind
             * @param {Function} fn
             * @param {Object} context
             * @returns {Function}
             */
            function bindFn(fn, context) {
                return function boundFn() {
                    return fn.apply(context, arguments);
                };
            }

            /**
             * let a boolean value also be a function that must return a boolean
             * this first item in args will be used as the context
             * @param {Boolean|Function} val
             * @param {Array} [args]
             * @returns {Boolean}
             */
            function boolOrFn(val, args) {
                if (typeof val == TYPE_FUNCTION) {
                    return val.apply(args ? args[0] || undefined : undefined, args);
                }
                return val;
            }

            /**
             * use the val2 when val1 is undefined
             * @param {*} val1
             * @param {*} val2
             * @returns {*}
             */
            function ifUndefined(val1, val2) {
                return (val1 === undefined) ? val2 : val1;
            }

            /**
             * addEventListener with multiple events at once
             * @param {EventTarget} target
             * @param {String} types
             * @param {Function} handler
             */
            function addEventListeners(target, types, handler) {
                each(splitStr(types), function (type) {
                    target.addEventListener(type, handler, false);
                });
            }

            /**
             * removeEventListener with multiple events at once
             * @param {EventTarget} target
             * @param {String} types
             * @param {Function} handler
             */
            function removeEventListeners(target, types, handler) {
                each(splitStr(types), function (type) {
                    target.removeEventListener(type, handler, false);
                });
            }

            /**
             * find if a node is in the given parent
             * @method hasParent
             * @param {HTMLElement} node
             * @param {HTMLElement} parent
             * @return {Boolean} found
             */
            function hasParent(node, parent) {
                while (node) {
                    if (node == parent) {
                        return true;
                    }
                    node = node.parentNode;
                }
                return false;
            }

            /**
             * small indexOf wrapper
             * @param {String} str
             * @param {String} find
             * @returns {Boolean} found
             */
            function inStr(str, find) {
                return str.indexOf(find) > -1;
            }

            /**
             * split string on whitespace
             * @param {String} str
             * @returns {Array} words
             */
            function splitStr(str) {
                return str.trim().split(/\s+/g);
            }

            /**
             * find if a array contains the object using indexOf or a simple polyFill
             * @param {Array} src
             * @param {String} find
             * @param {String} [findByKey]
             * @return {Boolean|Number} false when not found, or the index
             */
            function inArray(src, find, findByKey) {
                if (src.indexOf && !findByKey) {
                    return src.indexOf(find);
                } else {
                    var i = 0;
                    while (i < src.length) {
                        if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                            return i;
                        }
                        i++;
                    }
                    return -1;
                }
            }

            /**
             * convert array-like objects to real arrays
             * @param {Object} obj
             * @returns {Array}
             */
            function toArray(obj) {
                return Array.prototype.slice.call(obj, 0);
            }

            /**
             * unique array with objects based on a key (like 'id') or just by the array's value
             * @param {Array} src [{id:1},{id:2},{id:1}]
             * @param {String} [key]
             * @param {Boolean} [sort=False]
             * @returns {Array} [{id:1},{id:2}]
             */
            function uniqueArray(src, key, sort) {
                var results = [];
                var values = [];
                var i = 0;

                while (i < src.length) {
                    var val = key ? src[i][key] : src[i];
                    if (inArray(values, val) < 0) {
                        results.push(src[i]);
                    }
                    values[i] = val;
                    i++;
                }

                if (sort) {
                    if (!key) {
                        results = results.sort();
                    } else {
                        results = results.sort(function sortUniqueArray(a, b) {
                            return a[key] > b[key];
                        });
                    }
                }

                return results;
            }

            /**
             * get the prefixed property
             * @param {Object} obj
             * @param {String} property
             * @returns {String|Undefined} prefixed
             */
            function prefixed(obj, property) {
                var prefix, prop;
                var camelProp = property[0].toUpperCase() + property.slice(1);

                var i = 0;
                while (i < VENDOR_PREFIXES.length) {
                    prefix = VENDOR_PREFIXES[i];
                    prop = (prefix) ? prefix + camelProp : property;

                    if (prop in obj) {
                        return prop;
                    }
                    i++;
                }
                return undefined;
            }

            /**
             * get a unique id
             * @returns {number} uniqueId
             */
            var _uniqueId = 1;

            function uniqueId() {
                return _uniqueId++;
            }

            /**
             * get the window object of an element
             * @param {HTMLElement} element
             * @returns {DocumentView|Window}
             */
            function getWindowForElement(element) {
                var doc = element.ownerDocument;
                return (doc.defaultView || doc.parentWindow);
            }

            var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

            var SUPPORT_TOUCH = ('ontouchstart' in window);
            var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
            var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

            var INPUT_TYPE_TOUCH = 'touch';
            var INPUT_TYPE_PEN = 'pen';
            var INPUT_TYPE_MOUSE = 'mouse';
            var INPUT_TYPE_KINECT = 'kinect';

            var COMPUTE_INTERVAL = 25;

            var INPUT_START = 1;
            var INPUT_MOVE = 2;
            var INPUT_END = 4;
            var INPUT_CANCEL = 8;

            var DIRECTION_NONE = 1;
            var DIRECTION_LEFT = 2;
            var DIRECTION_RIGHT = 4;
            var DIRECTION_UP = 8;
            var DIRECTION_DOWN = 16;

            var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
            var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
            var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

            var PROPS_XY = ['x', 'y'];
            var PROPS_CLIENT_XY = ['clientX', 'clientY'];

            /**
             * create new input type manager
             * @param {Manager} manager
             * @param {Function} callback
             * @returns {Input}
             * @constructor
             */
            function Input(manager, callback) {
                var self = this;
                this.manager = manager;
                this.callback = callback;
                this.element = manager.element;
                this.target = manager.options.inputTarget;

                // smaller wrapper around the handler, for the scope and the enabled state of the manager,
                // so when disabled the input events are completely bypassed.
                this.domHandler = function (ev) {
                    if (boolOrFn(manager.options.enable, [manager])) {
                        self.handler(ev);
                    }
                };

                this.init();

            }

            Input.prototype = {
                /**
                 * should handle the inputEvent data and trigger the callback
                 * @virtual
                 */
                handler: function () {
                },

                /**
                 * bind the events
                 */
                init: function () {
                    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },

                /**
                 * unbind the events
                 */
                destroy: function () {
                    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
            };

            /**
             * create new input type manager
             * called by the Manager constructor
             * @param {Hammer} manager
             * @returns {Input}
             */
            function createInputInstance(manager) {
                var Type;
                var inputClass = manager.options.inputClass;

                if (inputClass) {
                    Type = inputClass;
                } else if (SUPPORT_POINTER_EVENTS) {
                    Type = PointerEventInput;
                } else if (SUPPORT_ONLY_TOUCH) {
                    Type = TouchInput;
                } else if (!SUPPORT_TOUCH) {
                    Type = MouseInput;
                } else {
                    Type = TouchMouseInput;
                }
                return new (Type)(manager, inputHandler);
            }

            /**
             * handle input events
             * @param {Manager} manager
             * @param {String} eventType
             * @param {Object} input
             */
            function inputHandler(manager, eventType, input) {
                var pointersLen = input.pointers.length;
                var changedPointersLen = input.changedPointers.length;
                var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
                var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

                input.isFirst = !!isFirst;
                input.isFinal = !!isFinal;

                if (isFirst) {
                    manager.session = {};
                }

                // source event is the normalized value of the domEvents
                // like 'touchstart, mouseup, pointerdown'
                input.eventType = eventType;

                // compute scale, rotation etc
                computeInputData(manager, input);

                // emit secret event
                manager.emit('hammer.input', input);

                manager.recognize(input);
                manager.session.prevInput = input;
            }

            /**
             * extend the data with some usable properties like scale, rotate, velocity etc
             * @param {Object} manager
             * @param {Object} input
             */
            function computeInputData(manager, input) {
                var session = manager.session;
                var pointers = input.pointers;
                var pointersLength = pointers.length;

                // store the first input to calculate the distance and direction
                if (!session.firstInput) {
                    session.firstInput = simpleCloneInputData(input);
                }

                // to compute scale and rotation we need to store the multiple touches
                if (pointersLength > 1 && !session.firstMultiple) {
                    session.firstMultiple = simpleCloneInputData(input);
                } else if (pointersLength === 1) {
                    session.firstMultiple = false;
                }

                var firstInput = session.firstInput;
                var firstMultiple = session.firstMultiple;
                var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

                var center = input.center = getCenter(pointers);
                input.timeStamp = now();
                input.deltaTime = input.timeStamp - firstInput.timeStamp;

                input.angle = getAngle(offsetCenter, center);
                input.distance = getDistance(offsetCenter, center);

                computeDeltaXY(session, input);
                input.offsetDirection = getDirection(input.deltaX, input.deltaY);

                input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
                input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

                computeIntervalInputData(session, input);

                // find the correct target
                var target = manager.element;
                if (hasParent(input.srcEvent.target, target)) {
                    target = input.srcEvent.target;
                }
                input.target = target;
            }

            function computeDeltaXY(session, input) {
                var center = input.center;
                var offset = session.offsetDelta || {};
                var prevDelta = session.prevDelta || {};
                var prevInput = session.prevInput || {};

                if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
                    prevDelta = session.prevDelta = {
                        x: prevInput.deltaX || 0,
                        y: prevInput.deltaY || 0
                    };

                    offset = session.offsetDelta = {
                        x: center.x,
                        y: center.y
                    };
                }

                input.deltaX = prevDelta.x + (center.x - offset.x);
                input.deltaY = prevDelta.y + (center.y - offset.y);
            }

            /**
             * velocity is calculated every x ms
             * @param {Object} session
             * @param {Object} input
             */
            function computeIntervalInputData(session, input) {
                var last = session.lastInterval || input,
                    deltaTime = input.timeStamp - last.timeStamp,
                    velocity, velocityX, velocityY, direction;

                if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
                    var deltaX = last.deltaX - input.deltaX;
                    var deltaY = last.deltaY - input.deltaY;

                    var v = getVelocity(deltaTime, deltaX, deltaY);
                    velocityX = v.x;
                    velocityY = v.y;
                    velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
                    direction = getDirection(deltaX, deltaY);

                    session.lastInterval = input;
                } else {
                    // use latest velocity info if it doesn't overtake a minimum period
                    velocity = last.velocity;
                    velocityX = last.velocityX;
                    velocityY = last.velocityY;
                    direction = last.direction;
                }

                input.velocity = velocity;
                input.velocityX = velocityX;
                input.velocityY = velocityY;
                input.direction = direction;
            }

            /**
             * create a simple clone from the input used for storage of firstInput and firstMultiple
             * @param {Object} input
             * @returns {Object} clonedInputData
             */
            function simpleCloneInputData(input) {
                // make a simple copy of the pointers because we will get a reference if we don't
                // we only need clientXY for the calculations
                var pointers = [];
                var i = 0;
                while (i < input.pointers.length) {
                    pointers[i] = {
                        clientX: round(input.pointers[i].clientX),
                        clientY: round(input.pointers[i].clientY)
                    };
                    i++;
                }

                return {
                    timeStamp: now(),
                    pointers: pointers,
                    center: getCenter(pointers),
                    deltaX: input.deltaX,
                    deltaY: input.deltaY
                };
            }

            /**
             * get the center of all the pointers
             * @param {Array} pointers
             * @return {Object} center contains `x` and `y` properties
             */
            function getCenter(pointers) {
                var pointersLength = pointers.length;

                // no need to loop when only one touch
                if (pointersLength === 1) {
                    return {
                        x: round(pointers[0].clientX),
                        y: round(pointers[0].clientY)
                    };
                }

                var x = 0, y = 0, i = 0;
                while (i < pointersLength) {
                    x += pointers[i].clientX;
                    y += pointers[i].clientY;
                    i++;
                }

                return {
                    x: round(x / pointersLength),
                    y: round(y / pointersLength)
                };
            }

            /**
             * calculate the velocity between two points. unit is in px per ms.
             * @param {Number} deltaTime
             * @param {Number} x
             * @param {Number} y
             * @return {Object} velocity `x` and `y`
             */
            function getVelocity(deltaTime, x, y) {
                return {
                    x: x / deltaTime || 0,
                    y: y / deltaTime || 0
                };
            }

            /**
             * get the direction between two points
             * @param {Number} x
             * @param {Number} y
             * @return {Number} direction
             */
            function getDirection(x, y) {
                if (x === y) {
                    return DIRECTION_NONE;
                }

                if (abs(x) >= abs(y)) {
                    return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                }
                return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
            }

            /**
             * calculate the absolute distance between two points
             * @param {Object} p1 {x, y}
             * @param {Object} p2 {x, y}
             * @param {Array} [props] containing x and y keys
             * @return {Number} distance
             */
            function getDistance(p1, p2, props) {
                if (!props) {
                    props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]],
                    y = p2[props[1]] - p1[props[1]];

                return Math.sqrt((x * x) + (y * y));
            }

            /**
             * calculate the angle between two coordinates
             * @param {Object} p1
             * @param {Object} p2
             * @param {Array} [props] containing x and y keys
             * @return {Number} angle
             */
            function getAngle(p1, p2, props) {
                if (!props) {
                    props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]],
                    y = p2[props[1]] - p1[props[1]];
                return Math.atan2(y, x) * 180 / Math.PI;
            }

            /**
             * calculate the rotation degrees between two pointersets
             * @param {Array} start array of pointers
             * @param {Array} end array of pointers
             * @return {Number} rotation
             */
            function getRotation(start, end) {
                return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
            }

            /**
             * calculate the scale factor between two pointersets
             * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
             * @param {Array} start array of pointers
             * @param {Array} end array of pointers
             * @return {Number} scale
             */
            function getScale(start, end) {
                return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
            }

            var MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
            };

            var MOUSE_ELEMENT_EVENTS = 'mousedown';
            var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

            /**
             * Mouse events input
             * @constructor
             * @extends Input
             */
            function MouseInput() {
                this.evEl = MOUSE_ELEMENT_EVENTS;
                this.evWin = MOUSE_WINDOW_EVENTS;

                this.allow = true; // used by Input.TouchMouse to disable mouse events
                this.pressed = false; // mousedown state

                Input.apply(this, arguments);
            }

            inherit(MouseInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function MEhandler(ev) {
                    var eventType = MOUSE_INPUT_MAP[ev.type];

                    // on start we want to have the left mouse button down
                    if (eventType & INPUT_START && ev.button === 0) {
                        this.pressed = true;
                    }

                    if (eventType & INPUT_MOVE && ev.which !== 1) {
                        eventType = INPUT_END;
                    }

                    // mouse must be down, and mouse events are allowed (see the TouchMouse input)
                    if (!this.pressed || !this.allow) {
                        return;
                    }

                    if (eventType & INPUT_END) {
                        this.pressed = false;
                    }

                    this.callback(this.manager, eventType, {
                        pointers: [ev],
                        changedPointers: [ev],
                        pointerType: INPUT_TYPE_MOUSE,
                        srcEvent: ev
                    });
                }
            });

            var POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
            };

// in IE10 the pointer types is defined as an enum
            var IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
            };

            var POINTER_ELEMENT_EVENTS = 'pointerdown';
            var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
            if (window.MSPointerEvent) {
                POINTER_ELEMENT_EVENTS = 'MSPointerDown';
                POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
            }

            /**
             * Pointer events input
             * @constructor
             * @extends Input
             */
            function PointerEventInput() {
                this.evEl = POINTER_ELEMENT_EVENTS;
                this.evWin = POINTER_WINDOW_EVENTS;

                Input.apply(this, arguments);

                this.store = (this.manager.session.pointerEvents = []);
            }

            inherit(PointerEventInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function PEhandler(ev) {
                    var store = this.store;
                    var removePointer = false;

                    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
                    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

                    var isTouch = (pointerType == INPUT_TYPE_TOUCH);

                    // get index of the event in the store
                    var storeIndex = inArray(store, ev.pointerId, 'pointerId');

                    // start and mouse must be down
                    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                        if (storeIndex < 0) {
                            store.push(ev);
                            storeIndex = store.length - 1;
                        }
                    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                        removePointer = true;
                    }

                    // it not found, so the pointer hasn't been down (so it's probably a hover)
                    if (storeIndex < 0) {
                        return;
                    }

                    // update the event in the store
                    store[storeIndex] = ev;

                    this.callback(this.manager, eventType, {
                        pointers: store,
                        changedPointers: [ev],
                        pointerType: pointerType,
                        srcEvent: ev
                    });

                    if (removePointer) {
                        // remove from the store
                        store.splice(storeIndex, 1);
                    }
                }
            });

            var SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };

            var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
            var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

            /**
             * Touch events input
             * @constructor
             * @extends Input
             */
            function SingleTouchInput() {
                this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
                this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
                this.started = false;

                Input.apply(this, arguments);
            }

            inherit(SingleTouchInput, Input, {
                handler: function TEhandler(ev) {
                    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

                    // should we handle the touch events?
                    if (type === INPUT_START) {
                        this.started = true;
                    }

                    if (!this.started) {
                        return;
                    }

                    var touches = normalizeSingleTouches.call(this, ev, type);

                    // when done, reset the started state
                    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                        this.started = false;
                    }

                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });

            /**
             * @this {TouchInput}
             * @param {Object} ev
             * @param {Number} type flag
             * @returns {undefined|Array} [all, changed]
             */
            function normalizeSingleTouches(ev, type) {
                var all = toArray(ev.touches);
                var changed = toArray(ev.changedTouches);

                if (type & (INPUT_END | INPUT_CANCEL)) {
                    all = uniqueArray(all.concat(changed), 'identifier', true);
                }

                return [all, changed];
            }

            var TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };

            var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

            /**
             * Multi-user touch events input
             * @constructor
             * @extends Input
             */
            function TouchInput() {
                this.evTarget = TOUCH_TARGET_EVENTS;
                this.targetIds = {};

                Input.apply(this, arguments);
            }

            inherit(TouchInput, Input, {
                handler: function MTEhandler(ev) {
                    var type = TOUCH_INPUT_MAP[ev.type];
                    var touches = getTouches.call(this, ev, type);
                    if (!touches) {
                        return;
                    }

                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });

            /**
             * @this {TouchInput}
             * @param {Object} ev
             * @param {Number} type flag
             * @returns {undefined|Array} [all, changed]
             */
            function getTouches(ev, type) {
                var allTouches = toArray(ev.touches);
                var targetIds = this.targetIds;

                // when there is only one touch, the process can be simplified
                if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
                    targetIds[allTouches[0].identifier] = true;
                    return [allTouches, allTouches];
                }

                var i,
                    targetTouches,
                    changedTouches = toArray(ev.changedTouches),
                    changedTargetTouches = [],
                    target = this.target;

                // get target touches from touches
                targetTouches = allTouches.filter(function (touch) {
                    return hasParent(touch.target, target);
                });

                // collect touches
                if (type === INPUT_START) {
                    i = 0;
                    while (i < targetTouches.length) {
                        targetIds[targetTouches[i].identifier] = true;
                        i++;
                    }
                }

                // filter changed touches to only contain touches that exist in the collected target ids
                i = 0;
                while (i < changedTouches.length) {
                    if (targetIds[changedTouches[i].identifier]) {
                        changedTargetTouches.push(changedTouches[i]);
                    }

                    // cleanup removed touches
                    if (type & (INPUT_END | INPUT_CANCEL)) {
                        delete targetIds[changedTouches[i].identifier];
                    }
                    i++;
                }

                if (!changedTargetTouches.length) {
                    return;
                }

                return [
                    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
                    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
                    changedTargetTouches
                ];
            }

            /**
             * Combined touch and mouse input
             *
             * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
             * This because touch devices also emit mouse events while doing a touch.
             *
             * @constructor
             * @extends Input
             */
            function TouchMouseInput() {
                Input.apply(this, arguments);

                var handler = bindFn(this.handler, this);
                this.touch = new TouchInput(this.manager, handler);
                this.mouse = new MouseInput(this.manager, handler);
            }

            inherit(TouchMouseInput, Input, {
                /**
                 * handle mouse and touch events
                 * @param {Hammer} manager
                 * @param {String} inputEvent
                 * @param {Object} inputData
                 */
                handler: function TMEhandler(manager, inputEvent, inputData) {
                    var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
                        isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

                    // when we're in a touch event, so  block all upcoming mouse events
                    // most mobile browser also emit mouseevents, right after touchstart
                    if (isTouch) {
                        this.mouse.allow = false;
                    } else if (isMouse && !this.mouse.allow) {
                        return;
                    }

                    // reset the allowMouse when we're done
                    if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                        this.mouse.allow = true;
                    }

                    this.callback(manager, inputEvent, inputData);
                },

                /**
                 * remove the event listeners
                 */
                destroy: function destroy() {
                    this.touch.destroy();
                    this.mouse.destroy();
                }
            });

            var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
            var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
            var TOUCH_ACTION_COMPUTE = 'compute';
            var TOUCH_ACTION_AUTO = 'auto';
            var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
            var TOUCH_ACTION_NONE = 'none';
            var TOUCH_ACTION_PAN_X = 'pan-x';
            var TOUCH_ACTION_PAN_Y = 'pan-y';

            /**
             * Touch Action
             * sets the touchAction property or uses the js alternative
             * @param {Manager} manager
             * @param {String} value
             * @constructor
             */
            function TouchAction(manager, value) {
                this.manager = manager;
                this.set(value);
            }

            TouchAction.prototype = {
                /**
                 * set the touchAction value on the element or enable the polyfill
                 * @param {String} value
                 */
                set: function (value) {
                    // find out the touch-action by the event handlers
                    if (value == TOUCH_ACTION_COMPUTE) {
                        value = this.compute();
                    }

                    if (NATIVE_TOUCH_ACTION) {
                        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                    }
                    this.actions = value.toLowerCase().trim();
                },

                /**
                 * just re-set the touchAction value
                 */
                update: function () {
                    this.set(this.manager.options.touchAction);
                },

                /**
                 * compute the value for the touchAction property based on the recognizer's settings
                 * @returns {String} value
                 */
                compute: function () {
                    var actions = [];
                    each(this.manager.recognizers, function (recognizer) {
                        if (boolOrFn(recognizer.options.enable, [recognizer])) {
                            actions = actions.concat(recognizer.getTouchAction());
                        }
                    });
                    return cleanTouchActions(actions.join(' '));
                },

                /**
                 * this method is called on each input cycle and provides the preventing of the browser behavior
                 * @param {Object} input
                 */
                preventDefaults: function (input) {
                    // not needed with native support for the touchAction property
                    if (NATIVE_TOUCH_ACTION) {
                        return;
                    }

                    var srcEvent = input.srcEvent;
                    var direction = input.offsetDirection;

                    // if the touch action did prevented once this session
                    if (this.manager.session.prevented) {
                        srcEvent.preventDefault();
                        return;
                    }

                    var actions = this.actions;
                    var hasNone = inStr(actions, TOUCH_ACTION_NONE);
                    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
                    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

                    if (hasNone ||
                        (hasPanY && direction & DIRECTION_HORIZONTAL) ||
                        (hasPanX && direction & DIRECTION_VERTICAL)) {
                        return this.preventSrc(srcEvent);
                    }
                },

                /**
                 * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
                 * @param {Object} srcEvent
                 */
                preventSrc: function (srcEvent) {
                    this.manager.session.prevented = true;
                    srcEvent.preventDefault();
                }
            };

            /**
             * when the touchActions are collected they are not a valid value, so we need to clean things up. *
             * @param {String} actions
             * @returns {*}
             */
            function cleanTouchActions(actions) {
                // none
                if (inStr(actions, TOUCH_ACTION_NONE)) {
                    return TOUCH_ACTION_NONE;
                }

                var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

                // pan-x and pan-y can be combined
                if (hasPanX && hasPanY) {
                    return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
                }

                // pan-x OR pan-y
                if (hasPanX || hasPanY) {
                    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
                }

                // manipulation
                if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
                    return TOUCH_ACTION_MANIPULATION;
                }

                return TOUCH_ACTION_AUTO;
            }

            /**
             * Recognizer flow explained; *
             * All recognizers have the initial state of POSSIBLE when a input session starts.
             * The definition of a input session is from the first input until the last input, with all it's movement in it. *
             * Example session for mouse-input: mousedown -> mousemove -> mouseup
             *
             * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
             * which determines with state it should be.
             *
             * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
             * POSSIBLE to give it another change on the next cycle.
             *
             *               Possible
             *                  |
             *            +-----+---------------+
             *            |                     |
             *      +-----+-----+               |
             *      |           |               |
             *   Failed      Cancelled          |
             *                          +-------+------+
             *                          |              |
             *                      Recognized       Began
             *                                         |
             *                                      Changed
             *                                         |
             *                                  Ended/Recognized
             */
            var STATE_POSSIBLE = 1;
            var STATE_BEGAN = 2;
            var STATE_CHANGED = 4;
            var STATE_ENDED = 8;
            var STATE_RECOGNIZED = STATE_ENDED;
            var STATE_CANCELLED = 16;
            var STATE_FAILED = 32;

            /**
             * Recognizer
             * Every recognizer needs to extend from this class.
             * @constructor
             * @param {Object} options
             */
            function Recognizer(options) {
                this.id = uniqueId();

                this.manager = null;
                this.options = merge(options || {}, this.defaults);

                // default is enable true
                this.options.enable = ifUndefined(this.options.enable, true);

                this.state = STATE_POSSIBLE;

                this.simultaneous = {};
                this.requireFail = [];
            }

            Recognizer.prototype = {
                /**
                 * @virtual
                 * @type {Object}
                 */
                defaults: {},

                /**
                 * set options
                 * @param {Object} options
                 * @return {Recognizer}
                 */
                set: function (options) {
                    extend(this.options, options);

                    // also update the touchAction, in case something changed about the directions/enabled state
                    this.manager && this.manager.touchAction.update();
                    return this;
                },

                /**
                 * recognize simultaneous with an other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                recognizeWith: function (otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                        return this;
                    }

                    var simultaneous = this.simultaneous;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (!simultaneous[otherRecognizer.id]) {
                        simultaneous[otherRecognizer.id] = otherRecognizer;
                        otherRecognizer.recognizeWith(this);
                    }
                    return this;
                },

                /**
                 * drop the simultaneous link. it doesnt remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRecognizeWith: function (otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                        return this;
                    }

                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    delete this.simultaneous[otherRecognizer.id];
                    return this;
                },

                /**
                 * recognizer can only run when an other is failing
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                requireFailure: function (otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                        return this;
                    }

                    var requireFail = this.requireFail;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (inArray(requireFail, otherRecognizer) === -1) {
                        requireFail.push(otherRecognizer);
                        otherRecognizer.requireFailure(this);
                    }
                    return this;
                },

                /**
                 * drop the requireFailure link. it does not remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRequireFailure: function (otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                        return this;
                    }

                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    var index = inArray(this.requireFail, otherRecognizer);
                    if (index > -1) {
                        this.requireFail.splice(index, 1);
                    }
                    return this;
                },

                /**
                 * has require failures boolean
                 * @returns {boolean}
                 */
                hasRequireFailures: function () {
                    return this.requireFail.length > 0;
                },

                /**
                 * if the recognizer can recognize simultaneous with an other recognizer
                 * @param {Recognizer} otherRecognizer
                 * @returns {Boolean}
                 */
                canRecognizeWith: function (otherRecognizer) {
                    return !!this.simultaneous[otherRecognizer.id];
                },

                /**
                 * You should use `tryEmit` instead of `emit` directly to check
                 * that all the needed recognizers has failed before emitting.
                 * @param {Object} input
                 */
                emit: function (input) {
                    var self = this;
                    var state = this.state;

                    function emit(withState) {
                        self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
                    }

                    // 'panstart' and 'panmove'
                    if (state < STATE_ENDED) {
                        emit(true);
                    }

                    emit(); // simple 'eventName' events

                    // panend and pancancel
                    if (state >= STATE_ENDED) {
                        emit(true);
                    }
                },

                /**
                 * Check that all the require failure recognizers has failed,
                 * if true, it emits a gesture event,
                 * otherwise, setup the state to FAILED.
                 * @param {Object} input
                 */
                tryEmit: function (input) {
                    if (this.canEmit()) {
                        return this.emit(input);
                    }
                    // it's failing anyway
                    this.state = STATE_FAILED;
                },

                /**
                 * can we emit?
                 * @returns {boolean}
                 */
                canEmit: function () {
                    var i = 0;
                    while (i < this.requireFail.length) {
                        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                            return false;
                        }
                        i++;
                    }
                    return true;
                },

                /**
                 * update the recognizer
                 * @param {Object} inputData
                 */
                recognize: function (inputData) {
                    // make a new copy of the inputData
                    // so we can change the inputData without messing up the other recognizers
                    var inputDataClone = extend({}, inputData);

                    // is is enabled and allow recognizing?
                    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                        this.reset();
                        this.state = STATE_FAILED;
                        return;
                    }

                    // reset when we've reached the end
                    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                        this.state = STATE_POSSIBLE;
                    }

                    this.state = this.process(inputDataClone);

                    // the recognizer has recognized a gesture
                    // so trigger an event
                    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                        this.tryEmit(inputDataClone);
                    }
                },

                /**
                 * return the state of the recognizer
                 * the actual recognizing happens in this method
                 * @virtual
                 * @param {Object} inputData
                 * @returns {Const} STATE
                 */
                process: function (inputData) {
                }, // jshint ignore:line

                /**
                 * return the preferred touch-action
                 * @virtual
                 * @returns {Array}
                 */
                getTouchAction: function () {
                },

                /**
                 * called when the gesture isn't allowed to recognize
                 * like when another is being recognized or it is disabled
                 * @virtual
                 */
                reset: function () {
                }
            };

            /**
             * get a usable string, used as event postfix
             * @param {Const} state
             * @returns {String} state
             */
            function stateStr(state) {
                if (state & STATE_CANCELLED) {
                    return 'cancel';
                } else if (state & STATE_ENDED) {
                    return 'end';
                } else if (state & STATE_CHANGED) {
                    return 'move';
                } else if (state & STATE_BEGAN) {
                    return 'start';
                }
                return '';
            }

            /**
             * direction cons to string
             * @param {Const} direction
             * @returns {String}
             */
            function directionStr(direction) {
                if (direction == DIRECTION_DOWN) {
                    return 'down';
                } else if (direction == DIRECTION_UP) {
                    return 'up';
                } else if (direction == DIRECTION_LEFT) {
                    return 'left';
                } else if (direction == DIRECTION_RIGHT) {
                    return 'right';
                }
                return '';
            }

            /**
             * get a recognizer by name if it is bound to a manager
             * @param {Recognizer|String} otherRecognizer
             * @param {Recognizer} recognizer
             * @returns {Recognizer}
             */
            function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
                var manager = recognizer.manager;
                if (manager) {
                    return manager.get(otherRecognizer);
                }
                return otherRecognizer;
            }

            /**
             * This recognizer is just used as a base for the simple attribute recognizers.
             * @constructor
             * @extends Recognizer
             */
            function AttrRecognizer() {
                Recognizer.apply(this, arguments);
            }

            inherit(AttrRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof AttrRecognizer
                 */
                defaults: {
                    /**
                     * @type {Number}
                     * @default 1
                     */
                    pointers: 1
                },

                /**
                 * Used to check if it the recognizer receives valid input, like input.distance > 10.
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {Boolean} recognized
                 */
                attrTest: function (input) {
                    var optionPointers = this.options.pointers;
                    return optionPointers === 0 || input.pointers.length === optionPointers;
                },

                /**
                 * Process the input and return the state for the recognizer
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {*} State
                 */
                process: function (input) {
                    var state = this.state;
                    var eventType = input.eventType;

                    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                    var isValid = this.attrTest(input);

                    // on cancel input and we've recognized before, return STATE_CANCELLED
                    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                        return state | STATE_CANCELLED;
                    } else if (isRecognized || isValid) {
                        if (eventType & INPUT_END) {
                            return state | STATE_ENDED;
                        } else if (!(state & STATE_BEGAN)) {
                            return STATE_BEGAN;
                        }
                        return state | STATE_CHANGED;
                    }
                    return STATE_FAILED;
                }
            });

            /**
             * Pan
             * Recognized when the pointer is down and moved in the allowed direction.
             * @constructor
             * @extends AttrRecognizer
             */
            function PanRecognizer() {
                AttrRecognizer.apply(this, arguments);

                this.pX = null;
                this.pY = null;
            }

            inherit(PanRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PanRecognizer
                 */
                defaults: {
                    event: 'pan',
                    threshold: 10,
                    pointers: 1,
                    direction: DIRECTION_ALL
                },

                getTouchAction: function () {
                    var direction = this.options.direction;
                    var actions = [];
                    if (direction & DIRECTION_HORIZONTAL) {
                        actions.push(TOUCH_ACTION_PAN_Y);
                    }
                    if (direction & DIRECTION_VERTICAL) {
                        actions.push(TOUCH_ACTION_PAN_X);
                    }
                    return actions;
                },

                directionTest: function (input) {
                    var options = this.options;
                    var hasMoved = true;
                    var distance = input.distance;
                    var direction = input.direction;
                    var x = input.deltaX;
                    var y = input.deltaY;

                    // lock to axis?
                    if (!(direction & options.direction)) {
                        if (options.direction & DIRECTION_HORIZONTAL) {
                            direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                            hasMoved = x != this.pX;
                            distance = Math.abs(input.deltaX);
                        } else {
                            direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                            hasMoved = y != this.pY;
                            distance = Math.abs(input.deltaY);
                        }
                    }
                    input.direction = direction;
                    return hasMoved && distance > options.threshold && direction & options.direction;
                },

                attrTest: function (input) {
                    return AttrRecognizer.prototype.attrTest.call(this, input) &&
                        (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
                },

                emit: function (input) {
                    this.pX = input.deltaX;
                    this.pY = input.deltaY;

                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }

                    this._super.emit.call(this, input);
                }
            });

            /**
             * Pinch
             * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
             * @constructor
             * @extends AttrRecognizer
             */
            function PinchRecognizer() {
                AttrRecognizer.apply(this, arguments);
            }

            inherit(PinchRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'pinch',
                    threshold: 0,
                    pointers: 2
                },

                getTouchAction: function () {
                    return [TOUCH_ACTION_NONE];
                },

                attrTest: function (input) {
                    return this._super.attrTest.call(this, input) &&
                        (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },

                emit: function (input) {
                    this._super.emit.call(this, input);
                    if (input.scale !== 1) {
                        var inOut = input.scale < 1 ? 'in' : 'out';
                        this.manager.emit(this.options.event + inOut, input);
                    }
                }
            });

            /**
             * Press
             * Recognized when the pointer is down for x ms without any movement.
             * @constructor
             * @extends Recognizer
             */
            function PressRecognizer() {
                Recognizer.apply(this, arguments);

                this._timer = null;
                this._input = null;
            }

            inherit(PressRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PressRecognizer
                 */
                defaults: {
                    event: 'press',
                    pointers: 1,
                    time: 500, // minimal time of the pointer to be pressed
                    threshold: 5 // a minimal movement is ok, but keep it low
                },

                getTouchAction: function () {
                    return [TOUCH_ACTION_AUTO];
                },

                process: function (input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTime = input.deltaTime > options.time;

                    this._input = input;

                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
                        this.reset();
                    } else if (input.eventType & INPUT_START) {
                        this.reset();
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.time, this);
                    } else if (input.eventType & INPUT_END) {
                        return STATE_RECOGNIZED;
                    }
                    return STATE_FAILED;
                },

                reset: function () {
                    clearTimeout(this._timer);
                },

                emit: function (input) {
                    if (this.state !== STATE_RECOGNIZED) {
                        return;
                    }

                    if (input && (input.eventType & INPUT_END)) {
                        this.manager.emit(this.options.event + 'up', input);
                    } else {
                        this._input.timeStamp = now();
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });

            /**
             * Rotate
             * Recognized when two or more pointer are moving in a circular motion.
             * @constructor
             * @extends AttrRecognizer
             */
            function RotateRecognizer() {
                AttrRecognizer.apply(this, arguments);
            }

            inherit(RotateRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof RotateRecognizer
                 */
                defaults: {
                    event: 'rotate',
                    threshold: 0,
                    pointers: 2
                },

                getTouchAction: function () {
                    return [TOUCH_ACTION_NONE];
                },

                attrTest: function (input) {
                    return this._super.attrTest.call(this, input) &&
                        (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
            });

            /**
             * Swipe
             * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
             * @constructor
             * @extends AttrRecognizer
             */
            function SwipeRecognizer() {
                AttrRecognizer.apply(this, arguments);
            }

            inherit(SwipeRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof SwipeRecognizer
                 */
                defaults: {
                    event: 'swipe',
                    threshold: 10,
                    velocity: 0.65,
                    direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                    pointers: 1
                },

                getTouchAction: function () {
                    return PanRecognizer.prototype.getTouchAction.call(this);
                },

                attrTest: function (input) {
                    var direction = this.options.direction;
                    var velocity;

                    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                        velocity = input.velocity;
                    } else if (direction & DIRECTION_HORIZONTAL) {
                        velocity = input.velocityX;
                    } else if (direction & DIRECTION_VERTICAL) {
                        velocity = input.velocityY;
                    }

                    return this._super.attrTest.call(this, input) &&
                        direction & input.direction &&
                        input.distance > this.options.threshold &&
                        abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },

                emit: function (input) {
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }

                    this.manager.emit(this.options.event, input);
                }
            });

            /**
             * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
             * between the given interval and position. The delay option can be used to recognize multi-taps without firing
             * a single tap.
             *
             * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
             * multi-taps being recognized.
             * @constructor
             * @extends Recognizer
             */
            function TapRecognizer() {
                Recognizer.apply(this, arguments);

                // previous time and center,
                // used for tap counting
                this.pTime = false;
                this.pCenter = false;

                this._timer = null;
                this._input = null;
                this.count = 0;
            }

            inherit(TapRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'tap',
                    pointers: 1,
                    taps: 1,
                    interval: 300, // max time between the multi-tap taps
                    time: 250, // max time of the pointer to be down (like finger on the screen)
                    threshold: 2, // a minimal movement is ok, but keep it low
                    posThreshold: 10 // a multi-tap can be a bit off the initial position
                },

                getTouchAction: function () {
                    return [TOUCH_ACTION_MANIPULATION];
                },

                process: function (input) {
                    var options = this.options;

                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTouchTime = input.deltaTime < options.time;

                    this.reset();

                    if ((input.eventType & INPUT_START) && (this.count === 0)) {
                        return this.failTimeout();
                    }

                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (validMovement && validTouchTime && validPointers) {
                        if (input.eventType != INPUT_END) {
                            return this.failTimeout();
                        }

                        var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
                        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                        this.pTime = input.timeStamp;
                        this.pCenter = input.center;

                        if (!validMultiTap || !validInterval) {
                            this.count = 1;
                        } else {
                            this.count += 1;
                        }

                        this._input = input;

                        // if tap count matches we have recognized it,
                        // else it has began recognizing...
                        var tapCount = this.count % options.taps;
                        if (tapCount === 0) {
                            // no failing requirements, immediately trigger the tap event
                            // or wait as long as the multitap interval to trigger
                            if (!this.hasRequireFailures()) {
                                return STATE_RECOGNIZED;
                            } else {
                                this._timer = setTimeoutContext(function () {
                                    this.state = STATE_RECOGNIZED;
                                    this.tryEmit();
                                }, options.interval, this);
                                return STATE_BEGAN;
                            }
                        }
                    }
                    return STATE_FAILED;
                },

                failTimeout: function () {
                    this._timer = setTimeoutContext(function () {
                        this.state = STATE_FAILED;
                    }, this.options.interval, this);
                    return STATE_FAILED;
                },

                reset: function () {
                    clearTimeout(this._timer);
                },

                emit: function () {
                    if (this.state == STATE_RECOGNIZED) {
                        this._input.tapCount = this.count;
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });

            /**
             * Simple way to create an manager with a default set of recognizers.
             * @param {HTMLElement} element
             * @param {Object} [options]
             * @constructor
             */
            function Hammer(element, options) {
                options = options || {};
                options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
                return new Manager(element, options);
            }

            /**
             * @const {string}
             */
            Hammer.VERSION = '2.0.4';

            /**
             * default settings
             * @namespace
             */
            Hammer.defaults = {
                /**
                 * set if DOM events are being triggered.
                 * But this is slower and unused by simple implementations, so disabled by default.
                 * @type {Boolean}
                 * @default false
                 */
                domEvents: false,

                /**
                 * The value for the touchAction property/fallback.
                 * When set to `compute` it will magically set the correct value based on the added recognizers.
                 * @type {String}
                 * @default compute
                 */
                touchAction: TOUCH_ACTION_COMPUTE,

                /**
                 * @type {Boolean}
                 * @default true
                 */
                enable: true,

                /**
                 * EXPERIMENTAL FEATURE -- can be removed/changed
                 * Change the parent input target element.
                 * If Null, then it is being set the to main element.
                 * @type {Null|EventTarget}
                 * @default null
                 */
                inputTarget: null,

                /**
                 * force an input class
                 * @type {Null|Function}
                 * @default null
                 */
                inputClass: null,

                /**
                 * Default recognizer setup when calling `Hammer()`
                 * When creating a new Manager these will be skipped.
                 * @type {Array}
                 */
                preset: [
                    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                    [RotateRecognizer, {enable: false}],
                    [PinchRecognizer, {enable: false}, ['rotate']],
                    [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
                    [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
                    [TapRecognizer],
                    [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
                    [PressRecognizer]
                ],

                /**
                 * Some CSS properties can be used to improve the working of Hammer.
                 * Add them to this method and they will be set when creating a new Manager.
                 * @namespace
                 */
                cssProps: {
                    /**
                     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userSelect: 'none',

                    /**
                     * Disable the Windows Phone grippers when pressing an element.
                     * @type {String}
                     * @default 'none'
                     */
                    touchSelect: 'none',

                    /**
                     * Disables the default callout shown when you touch and hold a touch target.
                     * On iOS, when you touch and hold a touch target such as a link, Safari displays
                     * a callout containing information about the link. This property allows you to disable that callout.
                     * @type {String}
                     * @default 'none'
                     */
                    touchCallout: 'none',

                    /**
                     * Specifies whether zooming is enabled. Used by IE10>
                     * @type {String}
                     * @default 'none'
                     */
                    contentZooming: 'none',

                    /**
                     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userDrag: 'none',

                    /**
                     * Overrides the highlight color shown when the user taps a link or a JavaScript
                     * clickable element in iOS. This property obeys the alpha value, if specified.
                     * @type {String}
                     * @default 'rgba(0,0,0,0)'
                     */
                    tapHighlightColor: 'rgba(0,0,0,0)'
                }
            };

            var STOP = 1;
            var FORCED_STOP = 2;

            /**
             * Manager
             * @param {HTMLElement} element
             * @param {Object} [options]
             * @constructor
             */
            function Manager(element, options) {
                options = options || {};

                this.options = merge(options, Hammer.defaults);
                this.options.inputTarget = this.options.inputTarget || element;

                this.handlers = {};
                this.session = {};
                this.recognizers = [];

                this.element = element;
                this.input = createInputInstance(this);
                this.touchAction = new TouchAction(this, this.options.touchAction);

                toggleCssProps(this, true);

                each(options.recognizers, function (item) {
                    var recognizer = this.add(new (item[0])(item[1]));
                    item[2] && recognizer.recognizeWith(item[2]);
                    item[3] && recognizer.requireFailure(item[3]);
                }, this);
            }

            Manager.prototype = {
                /**
                 * set options
                 * @param {Object} options
                 * @returns {Manager}
                 */
                set: function (options) {
                    extend(this.options, options);

                    // Options that need a little more setup
                    if (options.touchAction) {
                        this.touchAction.update();
                    }
                    if (options.inputTarget) {
                        // Clean up existing event listeners and reinitialize
                        this.input.destroy();
                        this.input.target = options.inputTarget;
                        this.input.init();
                    }
                    return this;
                },

                /**
                 * stop recognizing for this session.
                 * This session will be discarded, when a new [input]start event is fired.
                 * When forced, the recognizer cycle is stopped immediately.
                 * @param {Boolean} [force]
                 */
                stop: function (force) {
                    this.session.stopped = force ? FORCED_STOP : STOP;
                },

                /**
                 * run the recognizers!
                 * called by the inputHandler function on every movement of the pointers (touches)
                 * it walks through all the recognizers and tries to detect the gesture that is being made
                 * @param {Object} inputData
                 */
                recognize: function (inputData) {
                    var session = this.session;
                    if (session.stopped) {
                        return;
                    }

                    // run the touch-action polyfill
                    this.touchAction.preventDefaults(inputData);

                    var recognizer;
                    var recognizers = this.recognizers;

                    // this holds the recognizer that is being recognized.
                    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
                    // if no recognizer is detecting a thing, it is set to `null`
                    var curRecognizer = session.curRecognizer;

                    // reset when the last recognizer is recognized
                    // or when we're in a new session
                    if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
                        curRecognizer = session.curRecognizer = null;
                    }

                    var i = 0;
                    while (i < recognizers.length) {
                        recognizer = recognizers[i];

                        // find out if we are allowed try to recognize the input for this one.
                        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                        //      that is being recognized.
                        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                        //      this can be setup with the `recognizeWith()` method on the recognizer.
                        if (session.stopped !== FORCED_STOP && ( // 1
                            !curRecognizer || recognizer == curRecognizer || // 2
                            recognizer.canRecognizeWith(curRecognizer))) { // 3
                            recognizer.recognize(inputData);
                        } else {
                            recognizer.reset();
                        }

                        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                        // current active recognizer. but only if we don't already have an active recognizer
                        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                            curRecognizer = session.curRecognizer = recognizer;
                        }
                        i++;
                    }
                },

                /**
                 * get a recognizer by its event name.
                 * @param {Recognizer|String} recognizer
                 * @returns {Recognizer|Null}
                 */
                get: function (recognizer) {
                    if (recognizer instanceof Recognizer) {
                        return recognizer;
                    }

                    var recognizers = this.recognizers;
                    for (var i = 0; i < recognizers.length; i++) {
                        if (recognizers[i].options.event == recognizer) {
                            return recognizers[i];
                        }
                    }
                    return null;
                },

                /**
                 * add a recognizer to the manager
                 * existing recognizers with the same event name will be removed
                 * @param {Recognizer} recognizer
                 * @returns {Recognizer|Manager}
                 */
                add: function (recognizer) {
                    if (invokeArrayArg(recognizer, 'add', this)) {
                        return this;
                    }

                    // remove existing
                    var existing = this.get(recognizer.options.event);
                    if (existing) {
                        this.remove(existing);
                    }

                    this.recognizers.push(recognizer);
                    recognizer.manager = this;

                    this.touchAction.update();
                    return recognizer;
                },

                /**
                 * remove a recognizer by name or instance
                 * @param {Recognizer|String} recognizer
                 * @returns {Manager}
                 */
                remove: function (recognizer) {
                    if (invokeArrayArg(recognizer, 'remove', this)) {
                        return this;
                    }

                    var recognizers = this.recognizers;
                    recognizer = this.get(recognizer);
                    recognizers.splice(inArray(recognizers, recognizer), 1);

                    this.touchAction.update();
                    return this;
                },

                /**
                 * bind event
                 * @param {String} events
                 * @param {Function} handler
                 * @returns {EventEmitter} this
                 */
                on: function (events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        handlers[event] = handlers[event] || [];
                        handlers[event].push(handler);
                    });
                    return this;
                },

                /**
                 * unbind event, leave emit blank to remove all handlers
                 * @param {String} events
                 * @param {Function} [handler]
                 * @returns {EventEmitter} this
                 */
                off: function (events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        if (!handler) {
                            delete handlers[event];
                        } else {
                            handlers[event].splice(inArray(handlers[event], handler), 1);
                        }
                    });
                    return this;
                },

                /**
                 * emit event to the listeners
                 * @param {String} event
                 * @param {Object} data
                 */
                emit: function (event, data) {
                    // we also want to trigger dom events
                    if (this.options.domEvents) {
                        triggerDomEvent(event, data);
                    }

                    // no handlers, so skip it all
                    var handlers = this.handlers[event] && this.handlers[event].slice();
                    if (!handlers || !handlers.length) {
                        return;
                    }

                    data.type = event;
                    data.preventDefault = function () {
                        data.srcEvent.preventDefault();
                    };

                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                },

                /**
                 * destroy the manager and unbinds all events
                 * it doesn't unbind dom events, that is the user own responsibility
                 */
                destroy: function () {
                    this.element && toggleCssProps(this, false);

                    this.handlers = {};
                    this.session = {};
                    this.input.destroy();
                    this.element = null;
                }
            };

            /**
             * add/remove the css properties as defined in manager.options.cssProps
             * @param {Manager} manager
             * @param {Boolean} add
             */
            function toggleCssProps(manager, add) {
                var element = manager.element;
                each(manager.options.cssProps, function (value, name) {
                    element.style[prefixed(element.style, name)] = add ? value : '';
                });
            }

            /**
             * trigger dom event
             * @param {String} event
             * @param {Object} data
             */
            function triggerDomEvent(event, data) {
                var gestureEvent = document.createEvent('Event');
                gestureEvent.initEvent(event, true, true);
                gestureEvent.gesture = data;
                data.target.dispatchEvent(gestureEvent);
            }

            extend(Hammer, {
                INPUT_START: INPUT_START,
                INPUT_MOVE: INPUT_MOVE,
                INPUT_END: INPUT_END,
                INPUT_CANCEL: INPUT_CANCEL,

                STATE_POSSIBLE: STATE_POSSIBLE,
                STATE_BEGAN: STATE_BEGAN,
                STATE_CHANGED: STATE_CHANGED,
                STATE_ENDED: STATE_ENDED,
                STATE_RECOGNIZED: STATE_RECOGNIZED,
                STATE_CANCELLED: STATE_CANCELLED,
                STATE_FAILED: STATE_FAILED,

                DIRECTION_NONE: DIRECTION_NONE,
                DIRECTION_LEFT: DIRECTION_LEFT,
                DIRECTION_RIGHT: DIRECTION_RIGHT,
                DIRECTION_UP: DIRECTION_UP,
                DIRECTION_DOWN: DIRECTION_DOWN,
                DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL: DIRECTION_VERTICAL,
                DIRECTION_ALL: DIRECTION_ALL,

                Manager: Manager,
                Input: Input,
                TouchAction: TouchAction,

                TouchInput: TouchInput,
                MouseInput: MouseInput,
                PointerEventInput: PointerEventInput,
                TouchMouseInput: TouchMouseInput,
                SingleTouchInput: SingleTouchInput,

                Recognizer: Recognizer,
                AttrRecognizer: AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,

                on: addEventListeners,
                off: removeEventListeners,
                each: each,
                merge: merge,
                extend: extend,
                inherit: inherit,
                bindFn: bindFn,
                prefixed: prefixed
            });

            if (typeof define == TYPE_FUNCTION && define.amd) {
                define(function () {
                    return Hammer;
                });
            } else if (typeof module != 'undefined' && module.exports) {
                module.exports = Hammer;
            } else {
                window[exportName] = Hammer;
            }

        })(window, document, 'Hammer');

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/inherits/inherits_browser.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/inherits/inherits_browser.js"][0].apply(exports, arguments)
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/attr.js": [function (require, module, exports) {
        /**
         * Set attribute `name` to `val`, or get attr `name`.
         *
         * @param {Element} el
         * @param {String} name
         * @param {String} [val]
         * @api public
         */

        module.exports = function (el, name, val) {
            // get
            if (arguments.length == 2) {
                return el.getAttribute(name);
            }

            // remove
            if (val === null) {
                return el.removeAttribute(name);
            }

            // set
            el.setAttribute(name, val);

            return el;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/classes.js": [function (require, module, exports) {
        module.exports = require('component-classes');
    }, {"component-classes": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-classes/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/clear.js": [function (require, module, exports) {
        module.exports = function (el) {

            var c;

            while (el.childNodes.length) {
                c = el.childNodes[0];
                el.removeChild(c);
            }

            return el;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/closest.js": [function (require, module, exports) {
        module.exports = require('component-closest');
    }, {"component-closest": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-closest/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/delegate.js": [function (require, module, exports) {
        module.exports = require('component-delegate');
    }, {"component-delegate": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-delegate/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/domify.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/domify.js"][0].apply(exports, arguments)
    }, {"domify": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/domify/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/event.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/event.js"][0].apply(exports, arguments)
    }, {"component-event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-event/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/matches.js": [function (require, module, exports) {
        module.exports = require('component-matches-selector');
    }, {"component-matches-selector": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-matches-selector/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/query.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/query.js"][0].apply(exports, arguments)
    }, {"component-query": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-query/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/lib/remove.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/lib/remove.js"][0].apply(exports, arguments)
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-classes/index.js": [function (require, module, exports) {
        /**
         * Module dependencies.
         */

        var index = require('indexof');

        /**
         * Whitespace regexp.
         */

        var re = /\s+/;

        /**
         * toString reference.
         */

        var toString = Object.prototype.toString;

        /**
         * Wrap `el` in a `ClassList`.
         *
         * @param {Element} el
         * @return {ClassList}
         * @api public
         */

        module.exports = function (el) {
            return new ClassList(el);
        };

        /**
         * Initialize a new ClassList for `el`.
         *
         * @param {Element} el
         * @api private
         */

        function ClassList(el) {
            if (!el || !el.nodeType) {
                throw new Error('A DOM element reference is required');
            }
            this.el = el;
            this.list = el.classList;
        }

        /**
         * Add class `name` if not already present.
         *
         * @param {String} name
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.add = function (name) {
            // classList
            if (this.list) {
                this.list.add(name);
                return this;
            }

            // fallback
            var arr = this.array();
            var i = index(arr, name);
            if (!~i) arr.push(name);
            this.el.className = arr.join(' ');
            return this;
        };

        /**
         * Remove class `name` when present, or
         * pass a regular expression to remove
         * any which match.
         *
         * @param {String|RegExp} name
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.remove = function (name) {
            if ('[object RegExp]' == toString.call(name)) {
                return this.removeMatching(name);
            }

            // classList
            if (this.list) {
                this.list.remove(name);
                return this;
            }

            // fallback
            var arr = this.array();
            var i = index(arr, name);
            if (~i) arr.splice(i, 1);
            this.el.className = arr.join(' ');
            return this;
        };

        /**
         * Remove all classes matching `re`.
         *
         * @param {RegExp} re
         * @return {ClassList}
         * @api private
         */

        ClassList.prototype.removeMatching = function (re) {
            var arr = this.array();
            for (var i = 0; i < arr.length; i++) {
                if (re.test(arr[i])) {
                    this.remove(arr[i]);
                }
            }
            return this;
        };

        /**
         * Toggle class `name`, can force state via `force`.
         *
         * For browsers that support classList, but do not support `force` yet,
         * the mistake will be detected and corrected.
         *
         * @param {String} name
         * @param {Boolean} force
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.toggle = function (name, force) {
            // classList
            if (this.list) {
                if ("undefined" !== typeof force) {
                    if (force !== this.list.toggle(name, force)) {
                        this.list.toggle(name); // toggle again to correct
                    }
                } else {
                    this.list.toggle(name);
                }
                return this;
            }

            // fallback
            if ("undefined" !== typeof force) {
                if (!force) {
                    this.remove(name);
                } else {
                    this.add(name);
                }
            } else {
                if (this.has(name)) {
                    this.remove(name);
                } else {
                    this.add(name);
                }
            }

            return this;
        };

        /**
         * Return an array of classes.
         *
         * @return {Array}
         * @api public
         */

        ClassList.prototype.array = function () {
            var className = this.el.getAttribute('class') || '';
            var str = className.replace(/^\s+|\s+$/g, '');
            var arr = str.split(re);
            if ('' === arr[0]) arr.shift();
            return arr;
        };

        /**
         * Check if class `name` is present.
         *
         * @param {String} name
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.has =
            ClassList.prototype.contains = function (name) {
                return this.list
                    ? this.list.contains(name)
                    : !!~index(this.array(), name);
            };

    }, {"indexof": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-classes/node_modules/component-indexof/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-classes/node_modules/component-indexof/index.js": [function (require, module, exports) {
        module.exports = function (arr, obj) {
            if (arr.indexOf) return arr.indexOf(obj);
            for (var i = 0; i < arr.length; ++i) {
                if (arr[i] === obj) return i;
            }
            return -1;
        };
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-closest/index.js": [function (require, module, exports) {
        var matches = require('matches-selector')

        module.exports = function (element, selector, checkYoSelf, root) {
            element = checkYoSelf ? {parentNode: element} : element

            root = root || document

            // Make sure `element !== document` and `element != null`
            // otherwise we get an illegal invocation
            while ((element = element.parentNode) && element !== document) {
                if (matches(element, selector))
                    return element
                // After `matches` on the edge case that
                // the selector matches the root
                // (when the root is not the document)
                if (element === root)
                    return
            }
        }

    }, {"matches-selector": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-matches-selector/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-delegate/index.js": [function (require, module, exports) {
        /**
         * Module dependencies.
         */

        var closest = require('closest')
            , event = require('event');

        /**
         * Delegate event `type` to `selector`
         * and invoke `fn(e)`. A callback function
         * is returned which may be passed to `.unbind()`.
         *
         * @param {Element} el
         * @param {String} selector
         * @param {String} type
         * @param {Function} fn
         * @param {Boolean} capture
         * @return {Function}
         * @api public
         */

        exports.bind = function (el, selector, type, fn, capture) {
            return event.bind(el, type, function (e) {
                var target = e.target || e.srcElement;
                e.delegateTarget = closest(target, selector, true, el);
                if (e.delegateTarget) fn.call(el, e);
            }, capture);
        };

        /**
         * Unbind event `type`'s callback `fn`.
         *
         * @param {Element} el
         * @param {String} type
         * @param {Function} fn
         * @param {Boolean} capture
         * @api public
         */

        exports.unbind = function (el, type, fn, capture) {
            event.unbind(el, type, fn, capture);
        };

    }, {
        "closest": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-closest/index.js",
        "event": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-event/index.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-event/index.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/node_modules/component-event/index.js"][0].apply(exports, arguments)
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-matches-selector/index.js": [function (require, module, exports) {
        /**
         * Module dependencies.
         */

        var query = require('query');

        /**
         * Element prototype.
         */

        var proto = Element.prototype;

        /**
         * Vendor function.
         */

        var vendor = proto.matches
            || proto.webkitMatchesSelector
            || proto.mozMatchesSelector
            || proto.msMatchesSelector
            || proto.oMatchesSelector;

        /**
         * Expose `match()`.
         */

        module.exports = match;

        /**
         * Match `el` to `selector`.
         *
         * @param {Element} el
         * @param {String} selector
         * @return {Boolean}
         * @api public
         */

        function match(el, selector) {
            if (!el || el.nodeType !== 1) return false;
            if (vendor) return vendor.call(el, selector);
            var nodes = query.all(selector, el.parentNode);
            for (var i = 0; i < nodes.length; ++i) {
                if (nodes[i] == el) return true;
            }
            return false;
        }

    }, {"query": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-query/index.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/component-query/index.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/node_modules/component-query/index.js"][0].apply(exports, arguments)
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/min-dom/node_modules/domify/index.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/min-dom/node_modules/domify/index.js"][0].apply(exports, arguments)
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/object-refs/index.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/index.js"][0].apply(exports, arguments)
    }, {
        "./lib/collection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/object-refs/lib/collection.js",
        "./lib/refs": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/object-refs/lib/refs.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/object-refs/lib/collection.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/lib/collection.js"][0].apply(exports, arguments)
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/object-refs/lib/refs.js": [function (require, module, exports) {
        arguments[4]["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/bpmn-js/node_modules/object-refs/lib/refs.js"][0].apply(exports, arguments)
    }, {"./collection": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/object-refs/lib/collection.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/snapsvg/dist/snap.svg.js": [function (require, module, exports) {
// Snap.svg 0.3.0
// 
// Copyright (c) 2013 – 2014 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// build: 2014-09-08

        (function (glob, factory) {
            // AMD support
            if (typeof define === "function" && define.amd) {
                // Define as an anonymous module
                define(["eve"], function (eve) {
                    return factory(glob, eve);
                });
            } else if (typeof exports !== 'undefined') {
                // Next for Node.js or CommonJS
                var eve = require('eve');
                module.exports = factory(glob, eve);
            } else {
                // Browser globals (glob is window)
                // Snap adds itself to window
                factory(glob, glob.eve);
            }
        }(window || this, function (window, eve) {

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
            var mina = (function (eve) {
                var animations = {},
                    requestAnimFrame = window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        function (callback) {
                            setTimeout(callback, 16);
                        },
                    isArray = Array.isArray || function (a) {
                            return a instanceof Array ||
                                Object.prototype.toString.call(a) == "[object Array]";
                        },
                    idgen = 0,
                    idprefix = "M" + (+new Date).toString(36),
                    ID = function () {
                        return idprefix + (idgen++).toString(36);
                    },
                    diff = function (a, b, A, B) {
                        if (isArray(a)) {
                            res = [];
                            for (var i = 0, ii = a.length; i < ii; i++) {
                                res[i] = diff(a[i], b, A[i], B);
                            }
                            return res;
                        }
                        var dif = (A - a) / (B - b);
                        return function (bb) {
                            return a + dif * (bb - b);
                        };
                    },
                    timer = Date.now || function () {
                            return +new Date;
                        },
                    sta = function (val) {
                        var a = this;
                        if (val == null) {
                            return a.s;
                        }
                        var ds = a.s - val;
                        a.b += a.dur * ds;
                        a.B += a.dur * ds;
                        a.s = val;
                    },
                    speed = function (val) {
                        var a = this;
                        if (val == null) {
                            return a.spd;
                        }
                        a.spd = val;
                    },
                    duration = function (val) {
                        var a = this;
                        if (val == null) {
                            return a.dur;
                        }
                        a.s = a.s * val / a.dur;
                        a.dur = val;
                    },
                    stopit = function () {
                        var a = this;
                        delete animations[a.id];
                        a.update();
                        eve("mina.stop." + a.id, a);
                    },
                    pause = function () {
                        var a = this;
                        if (a.pdif) {
                            return;
                        }
                        delete animations[a.id];
                        a.update();
                        a.pdif = a.get() - a.b;
                    },
                    resume = function () {
                        var a = this;
                        if (!a.pdif) {
                            return;
                        }
                        a.b = a.get() - a.pdif;
                        delete a.pdif;
                        animations[a.id] = a;
                    },
                    update = function () {
                        var a = this,
                            res;
                        if (isArray(a.start)) {
                            res = [];
                            for (var j = 0, jj = a.start.length; j < jj; j++) {
                                res[j] = +a.start[j] +
                                (a.end[j] - a.start[j]) * a.easing(a.s);
                            }
                        } else {
                            res = +a.start + (a.end - a.start) * a.easing(a.s);
                        }
                        a.set(res);
                    },
                    frame = function () {
                        var len = 0;
                        for (var i in animations) if (animations.hasOwnProperty(i)) {
                            var a = animations[i],
                                b = a.get(),
                                res;
                            len++;
                            a.s = (b - a.b) / (a.dur / a.spd);
                            if (a.s >= 1) {
                                delete animations[i];
                                a.s = 1;
                                len--;
                                (function (a) {
                                    setTimeout(function () {
                                        eve("mina.finish." + a.id, a);
                                    });
                                }(a));
                            }
                            a.update();
                        }
                        len && requestAnimFrame(frame);
                    },
                /*\
                 * mina
                 [ method ]
                 **
                 * Generic animation of numbers
                 **
                 - a (number) start _slave_ number
                 - A (number) end _slave_ number
                 - b (number) start _master_ number (start time in general case)
                 - B (number) end _master_ number (end time in gereal case)
                 - get (function) getter of _master_ number (see @mina.time)
                 - set (function) setter of _slave_ number
                 - easing (function) #optional easing function, default is @mina.linear
                 = (object) animation descriptor
                 o {
                 o         id (string) animation id,
                 o         start (number) start _slave_ number,
                 o         end (number) end _slave_ number,
                 o         b (number) start _master_ number,
                 o         s (number) animation status (0..1),
                 o         dur (number) animation duration,
                 o         spd (number) animation speed,
                 o         get (function) getter of _master_ number (see @mina.time),
                 o         set (function) setter of _slave_ number,
                 o         easing (function) easing function, default is @mina.linear,
                 o         status (function) status getter/setter,
                 o         speed (function) speed getter/setter,
                 o         duration (function) duration getter/setter,
                 o         stop (function) animation stopper
                 o         pause (function) pauses the animation
                 o         resume (function) resumes the animation
                 o         update (function) calles setter with the right value of the animation
                 o }
                 \*/
                    mina = function (a, A, b, B, get, set, easing) {
                        var anim = {
                            id: ID(),
                            start: a,
                            end: A,
                            b: b,
                            s: 0,
                            dur: B - b,
                            spd: 1,
                            get: get,
                            set: set,
                            easing: easing || mina.linear,
                            status: sta,
                            speed: speed,
                            duration: duration,
                            stop: stopit,
                            pause: pause,
                            resume: resume,
                            update: update
                        };
                        animations[anim.id] = anim;
                        var len = 0, i;
                        for (i in animations) if (animations.hasOwnProperty(i)) {
                            len++;
                            if (len == 2) {
                                break;
                            }
                        }
                        len == 1 && requestAnimFrame(frame);
                        return anim;
                    };
                /*\
                 * mina.time
                 [ method ]
                 **
                 * Returns the current time. Equivalent to:
                 | function () {
                 |     return (new Date).getTime();
                 | }
                 \*/
                mina.time = timer;
                /*\
                 * mina.getById
                 [ method ]
                 **
                 * Returns an animation by its id
                 - id (string) animation's id
                 = (object) See @mina
                 \*/
                mina.getById = function (id) {
                    return animations[id] || null;
                };

                /*\
                 * mina.linear
                 [ method ]
                 **
                 * Default linear easing
                 - n (number) input 0..1
                 = (number) output 0..1
                 \*/
                mina.linear = function (n) {
                    return n;
                };
                /*\
                 * mina.easeout
                 [ method ]
                 **
                 * Easeout easing
                 - n (number) input 0..1
                 = (number) output 0..1
                 \*/
                mina.easeout = function (n) {
                    return Math.pow(n, 1.7);
                };
                /*\
                 * mina.easein
                 [ method ]
                 **
                 * Easein easing
                 - n (number) input 0..1
                 = (number) output 0..1
                 \*/
                mina.easein = function (n) {
                    return Math.pow(n, .48);
                };
                /*\
                 * mina.easeinout
                 [ method ]
                 **
                 * Easeinout easing
                 - n (number) input 0..1
                 = (number) output 0..1
                 \*/
                mina.easeinout = function (n) {
                    if (n == 1) {
                        return 1;
                    }
                    if (n == 0) {
                        return 0;
                    }
                    var q = .48 - n / 1.04,
                        Q = Math.sqrt(.1734 + q * q),
                        x = Q - q,
                        X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                        y = -Q - q,
                        Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                        t = X + Y + .5;
                    return (1 - t) * 3 * t * t + t * t * t;
                };
                /*\
                 * mina.backin
                 [ method ]
                 **
                 * Backin easing
                 - n (number) input 0..1
                 = (number) output 0..1
                 \*/
                mina.backin = function (n) {
                    if (n == 1) {
                        return 1;
                    }
                    var s = 1.70158;
                    return n * n * ((s + 1) * n - s);
                };
                /*\
                 * mina.backout
                 [ method ]
                 **
                 * Backout easing
                 - n (number) input 0..1
                 = (number) output 0..1
                 \*/
                mina.backout = function (n) {
                    if (n == 0) {
                        return 0;
                    }
                    n = n - 1;
                    var s = 1.70158;
                    return n * n * ((s + 1) * n + s) + 1;
                };
                /*\
                 * mina.elastic
                 [ method ]
                 **
                 * Elastic easing
                 - n (number) input 0..1
                 = (number) output 0..1
                 \*/
                mina.elastic = function (n) {
                    if (n == !!n) {
                        return n;
                    }
                    return Math.pow(2, -10 * n) * Math.sin((n - .075) *
                        (2 * Math.PI) / .3) + 1;
                };
                /*\
                 * mina.bounce
                 [ method ]
                 **
                 * Bounce easing
                 - n (number) input 0..1
                 = (number) output 0..1
                 \*/
                mina.bounce = function (n) {
                    var s = 7.5625,
                        p = 2.75,
                        l;
                    if (n < (1 / p)) {
                        l = s * n * n;
                    } else {
                        if (n < (2 / p)) {
                            n -= (1.5 / p);
                            l = s * n * n + .75;
                        } else {
                            if (n < (2.5 / p)) {
                                n -= (2.25 / p);
                                l = s * n * n + .9375;
                            } else {
                                n -= (2.625 / p);
                                l = s * n * n + .984375;
                            }
                        }
                    }
                    return l;
                };
                window.mina = mina;
                return mina;
            })(typeof eve == "undefined" ? function () {
            } : eve);
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

            var Snap = (function (root) {
                Snap.version = "0.3.0";
                /*\
                 * Snap
                 [ method ]
                 **
                 * Creates a drawing surface or wraps existing SVG element.
                 **
                 - width (number|string) width of surface
                 - height (number|string) height of surface
                 * or
                 - DOM (SVGElement) element to be wrapped into Snap structure
                 * or
                 - array (array) array of elements (will return set of elements)
                 * or
                 - query (string) CSS query selector
                 = (object) @Element
                 \*/
                function Snap(w, h) {
                    if (w) {
                        if (w.tagName) {
                            return wrap(w);
                        }
                        if (is(w, "array") && Snap.set) {
                            return Snap.set.apply(Snap, w);
                        }
                        if (w instanceof Element) {
                            return w;
                        }
                        if (h == null) {
                            w = glob.doc.querySelector(w);
                            return wrap(w);
                        }
                    }
                    w = w == null ? "100%" : w;
                    h = h == null ? "100%" : h;
                    return new Paper(w, h);
                }

                Snap.toString = function () {
                    return "Snap v" + this.version;
                };
                Snap._ = {};
                var glob = {
                    win: root.window,
                    doc: root.window.document
                };
                Snap._.glob = glob;
                var has = "hasOwnProperty",
                    Str = String,
                    toFloat = parseFloat,
                    toInt = parseInt,
                    math = Math,
                    mmax = math.max,
                    mmin = math.min,
                    abs = math.abs,
                    pow = math.pow,
                    PI = math.PI,
                    round = math.round,
                    E = "",
                    S = " ",
                    objectToString = Object.prototype.toString,
                    ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
                    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
                    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
                    reURLValue = /^url\(#?([^)]+)\)$/,
                    separator = Snap._.separator = /[,\s]+/,
                    whitespace = /[\s]/g,
                    commaSpaces = /[\s]*,[\s]*/,
                    hsrg = {hs: 1, rg: 1},
                    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
                    tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
                    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/ig,
                    idgen = 0,
                    idprefix = "S" + (+new Date).toString(36),
                    ID = function (el) {
                        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
                    },
                    xlink = "http://www.w3.org/1999/xlink",
                    xmlns = "http://www.w3.org/2000/svg",
                    hub = {},
                    URL = Snap.url = function (url) {
                        return "url('#" + url + "')";
                    };

                function $(el, attr) {
                    if (attr) {
                        if (el == "#text") {
                            el = glob.doc.createTextNode(attr.text || "");
                        }
                        if (typeof el == "string") {
                            el = $(el);
                        }
                        if (typeof attr == "string") {
                            if (attr.substring(0, 6) == "xlink:") {
                                return el.getAttributeNS(xlink, attr.substring(6));
                            }
                            if (attr.substring(0, 4) == "xml:") {
                                return el.getAttributeNS(xmlns, attr.substring(4));
                            }
                            return el.getAttribute(attr);
                        }
                        for (var key in attr) if (attr[has](key)) {
                            var val = Str(attr[key]);
                            if (val) {
                                if (key.substring(0, 6) == "xlink:") {
                                    el.setAttributeNS(xlink, key.substring(6), val);
                                } else if (key.substring(0, 4) == "xml:") {
                                    el.setAttributeNS(xmlns, key.substring(4), val);
                                } else {
                                    el.setAttribute(key, val);
                                }
                            } else {
                                el.removeAttribute(key);
                            }
                        }
                    } else {
                        el = glob.doc.createElementNS(xmlns, el);
                    }
                    return el;
                }

                Snap._.$ = $;
                Snap._.id = ID;
                function getAttrs(el) {
                    var attrs = el.attributes,
                        name,
                        out = {};
                    for (var i = 0; i < attrs.length; i++) {
                        if (attrs[i].namespaceURI == xlink) {
                            name = "xlink:";
                        } else {
                            name = "";
                        }
                        name += attrs[i].name;
                        out[name] = attrs[i].textContent;
                    }
                    return out;
                }

                function is(o, type) {
                    type = Str.prototype.toLowerCase.call(type);
                    if (type == "finite") {
                        return isFinite(o);
                    }
                    if (type == "array" &&
                        (o instanceof Array || Array.isArray && Array.isArray(o))) {
                        return true;
                    }
                    return (type == "null" && o === null) ||
                        (type == typeof o && o !== null) ||
                        (type == "object" && o === Object(o)) ||
                        objectToString.call(o).slice(8, -1).toLowerCase() == type;
                }

                /*\
                 * Snap.format
                 [ method ]
                 **
                 * Replaces construction of type `{<name>}` to the corresponding argument
                 **
                 - token (string) string to format
                 - json (object) object which properties are used as a replacement
                 = (string) formatted string
                 > Usage
                 | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
                 | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
                 |     x: 10,
                 |     y: 20,
                 |     dim: {
                 |         width: 40,
                 |         height: 50,
                 |         "negative width": -40
                 |     }
                 | }));
                 \*/
                Snap.format = (function () {
                    var tokenRegex = /\{([^\}]+)\}/g,
                        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
                        replacer = function (all, key, obj) {
                            var res = obj;
                            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                                name = name || quotedName;
                                if (res) {
                                    if (name in res) {
                                        res = res[name];
                                    }
                                    typeof res == "function" && isFunc && (res = res());
                                }
                            });
                            res = (res == null || res == obj ? all : res) + "";
                            return res;
                        };
                    return function (str, obj) {
                        return Str(str).replace(tokenRegex, function (all, key) {
                            return replacer(all, key, obj);
                        });
                    };
                })();
                function clone(obj) {
                    if (typeof obj == "function" || Object(obj) !== obj) {
                        return obj;
                    }
                    var res = new obj.constructor;
                    for (var key in obj) if (obj[has](key)) {
                        res[key] = clone(obj[key]);
                    }
                    return res;
                }

                Snap._.clone = clone;
                function repush(array, item) {
                    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
                        return array.push(array.splice(i, 1)[0]);
                    }
                }

                function cacher(f, scope, postprocessor) {
                    function newf() {
                        var arg = Array.prototype.slice.call(arguments, 0),
                            args = arg.join("\u2400"),
                            cache = newf.cache = newf.cache || {},
                            count = newf.count = newf.count || [];
                        if (cache[has](args)) {
                            repush(count, args);
                            return postprocessor ? postprocessor(cache[args]) : cache[args];
                        }
                        count.length >= 1e3 && delete cache[count.shift()];
                        count.push(args);
                        cache[args] = f.apply(scope, arg);
                        return postprocessor ? postprocessor(cache[args]) : cache[args];
                    }

                    return newf;
                }

                Snap._.cacher = cacher;
                function angle(x1, y1, x2, y2, x3, y3) {
                    if (x3 == null) {
                        var x = x1 - x2,
                            y = y1 - y2;
                        if (!x && !y) {
                            return 0;
                        }
                        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
                    } else {
                        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
                    }
                }

                function rad(deg) {
                    return deg % 360 * PI / 180;
                }

                function deg(rad) {
                    return rad * 180 / PI % 360;
                }

                function x_y() {
                    return this.x + S + this.y;
                }

                function x_y_w_h() {
                    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
                }

                /*\
                 * Snap.rad
                 [ method ]
                 **
                 * Transform angle to radians
                 - deg (number) angle in degrees
                 = (number) angle in radians
                 \*/
                Snap.rad = rad;
                /*\
                 * Snap.deg
                 [ method ]
                 **
                 * Transform angle to degrees
                 - rad (number) angle in radians
                 = (number) angle in degrees
                 \*/
                Snap.deg = deg;
                /*\
                 * Snap.angle
                 [ method ]
                 **
                 * Returns an angle between two or three points
                 > Parameters
                 - x1 (number) x coord of first point
                 - y1 (number) y coord of first point
                 - x2 (number) x coord of second point
                 - y2 (number) y coord of second point
                 - x3 (number) #optional x coord of third point
                 - y3 (number) #optional y coord of third point
                 = (number) angle in degrees
                 \*/
                Snap.angle = angle;
                /*\
                 * Snap.is
                 [ method ]
                 **
                 * Handy replacement for the `typeof` operator
                 - o (…) any object or primitive
                 - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
                 = (boolean) `true` if given value is of given type
                 \*/
                Snap.is = is;
                /*\
                 * Snap.snapTo
                 [ method ]
                 **
                 * Snaps given value to given grid
                 - values (array|number) given array of values or step of the grid
                 - value (number) value to adjust
                 - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
                 = (number) adjusted value
                 \*/
                Snap.snapTo = function (values, value, tolerance) {
                    tolerance = is(tolerance, "finite") ? tolerance : 10;
                    if (is(values, "array")) {
                        var i = values.length;
                        while (i--) if (abs(values[i] - value) <= tolerance) {
                            return values[i];
                        }
                    } else {
                        values = +values;
                        var rem = value % values;
                        if (rem < tolerance) {
                            return value - rem;
                        }
                        if (rem > values - tolerance) {
                            return value - rem + values;
                        }
                    }
                    return value;
                };
// Colour
                /*\
                 * Snap.getRGB
                 [ method ]
                 **
                 * Parses color string as RGB object
                 - color (string) color string in one of the following formats:
                 # <ul>
                 #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
                 #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
                 #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
                 #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
                 #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>
                 #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
                 #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>
                 #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
                 #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>
                 #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
                 #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>
                 #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
                 #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>
                 #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
                 #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>
                 # </ul>
                 * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
                 = (object) RGB object in the following format:
                 o {
                 o     r (number) red,
                 o     g (number) green,
                 o     b (number) blue,
                 o     hex (string) color in HTML/CSS format: #••••••,
                 o     error (boolean) true if string can't be parsed
                 o }
                 \*/
                Snap.getRGB = cacher(function (colour) {
                    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
                        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
                    }
                    if (colour == "none") {
                        return {r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString};
                    }
                    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
                    if (!colour) {
                        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
                    }
                    var res,
                        red,
                        green,
                        blue,
                        opacity,
                        t,
                        values,
                        rgb = colour.match(colourRegExp);
                    if (rgb) {
                        if (rgb[2]) {
                            blue = toInt(rgb[2].substring(5), 16);
                            green = toInt(rgb[2].substring(3, 5), 16);
                            red = toInt(rgb[2].substring(1, 3), 16);
                        }
                        if (rgb[3]) {
                            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                            green = toInt((t = rgb[3].charAt(2)) + t, 16);
                            red = toInt((t = rgb[3].charAt(1)) + t, 16);
                        }
                        if (rgb[4]) {
                            values = rgb[4].split(commaSpaces);
                            red = toFloat(values[0]);
                            values[0].slice(-1) == "%" && (red *= 2.55);
                            green = toFloat(values[1]);
                            values[1].slice(-1) == "%" && (green *= 2.55);
                            blue = toFloat(values[2]);
                            values[2].slice(-1) == "%" && (blue *= 2.55);
                            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                        }
                        if (rgb[5]) {
                            values = rgb[5].split(commaSpaces);
                            red = toFloat(values[0]);
                            values[0].slice(-1) == "%" && (red /= 100);
                            green = toFloat(values[1]);
                            values[1].slice(-1) == "%" && (green /= 100);
                            blue = toFloat(values[2]);
                            values[2].slice(-1) == "%" && (blue /= 100);
                            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                            return Snap.hsb2rgb(red, green, blue, opacity);
                        }
                        if (rgb[6]) {
                            values = rgb[6].split(commaSpaces);
                            red = toFloat(values[0]);
                            values[0].slice(-1) == "%" && (red /= 100);
                            green = toFloat(values[1]);
                            values[1].slice(-1) == "%" && (green /= 100);
                            blue = toFloat(values[2]);
                            values[2].slice(-1) == "%" && (blue /= 100);
                            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                            return Snap.hsl2rgb(red, green, blue, opacity);
                        }
                        red = mmin(math.round(red), 255);
                        green = mmin(math.round(green), 255);
                        blue = mmin(math.round(blue), 255);
                        opacity = mmin(mmax(opacity, 0), 1);
                        rgb = {r: red, g: green, b: blue, toString: rgbtoString};
                        rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
                        rgb.opacity = is(opacity, "finite") ? opacity : 1;
                        return rgb;
                    }
                    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
                }, Snap);
// SIERRA It seems odd that the following 3 conversion methods are not expressed as .this2that(), like the others.
                /*\
                 * Snap.hsb
                 [ method ]
                 **
                 * Converts HSB values to a hex representation of the color
                 - h (number) hue
                 - s (number) saturation
                 - b (number) value or brightness
                 = (string) hex representation of the color
                 \*/
                Snap.hsb = cacher(function (h, s, b) {
                    return Snap.hsb2rgb(h, s, b).hex;
                });
                /*\
                 * Snap.hsl
                 [ method ]
                 **
                 * Converts HSL values to a hex representation of the color
                 - h (number) hue
                 - s (number) saturation
                 - l (number) luminosity
                 = (string) hex representation of the color
                 \*/
                Snap.hsl = cacher(function (h, s, l) {
                    return Snap.hsl2rgb(h, s, l).hex;
                });
                /*\
                 * Snap.rgb
                 [ method ]
                 **
                 * Converts RGB values to a hex representation of the color
                 - r (number) red
                 - g (number) green
                 - b (number) blue
                 = (string) hex representation of the color
                 \*/
                Snap.rgb = cacher(function (r, g, b, o) {
                    if (is(o, "finite")) {
                        var round = math.round;
                        return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
                    }
                    return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
                });
                var toHex = function (color) {
                        var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
                            red = "rgb(255, 0, 0)";
                        toHex = cacher(function (color) {
                            if (color.toLowerCase() == "red") {
                                return red;
                            }
                            i.style.color = red;
                            i.style.color = color;
                            var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                            return out == red ? null : out;
                        });
                        return toHex(color);
                    },
                    hsbtoString = function () {
                        return "hsb(" + [this.h, this.s, this.b] + ")";
                    },
                    hsltoString = function () {
                        return "hsl(" + [this.h, this.s, this.l] + ")";
                    },
                    rgbtoString = function () {
                        return this.opacity == 1 || this.opacity == null ?
                            this.hex :
                        "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
                    },
                    prepareRGB = function (r, g, b) {
                        if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
                            b = r.b;
                            g = r.g;
                            r = r.r;
                        }
                        if (g == null && is(r, string)) {
                            var clr = Snap.getRGB(r);
                            r = clr.r;
                            g = clr.g;
                            b = clr.b;
                        }
                        if (r > 1 || g > 1 || b > 1) {
                            r /= 255;
                            g /= 255;
                            b /= 255;
                        }

                        return [r, g, b];
                    },
                    packageRGB = function (r, g, b, o) {
                        r = math.round(r * 255);
                        g = math.round(g * 255);
                        b = math.round(b * 255);
                        var rgb = {
                            r: r,
                            g: g,
                            b: b,
                            opacity: is(o, "finite") ? o : 1,
                            hex: Snap.rgb(r, g, b),
                            toString: rgbtoString
                        };
                        is(o, "finite") && (rgb.opacity = o);
                        return rgb;
                    };
// SIERRA Clarify if Snap does not support consolidated HSLA/RGBA colors. E.g., can you specify a semi-transparent value for Snap.filter.shadow()?
                /*\
                 * Snap.color
                 [ method ]
                 **
                 * Parses the color string and returns an object featuring the color's component values
                 - clr (string) color string in one of the supported formats (see @Snap.getRGB)
                 = (object) Combined RGB/HSB object in the following format:
                 o {
                 o     r (number) red,
                 o     g (number) green,
                 o     b (number) blue,
                 o     hex (string) color in HTML/CSS format: #••••••,
                 o     error (boolean) `true` if string can't be parsed,
                 o     h (number) hue,
                 o     s (number) saturation,
                 o     v (number) value (brightness),
                 o     l (number) lightness
                 o }
                 \*/
                Snap.color = function (clr) {
                    var rgb;
                    if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
                        rgb = Snap.hsb2rgb(clr);
                        clr.r = rgb.r;
                        clr.g = rgb.g;
                        clr.b = rgb.b;
                        clr.opacity = 1;
                        clr.hex = rgb.hex;
                    } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
                        rgb = Snap.hsl2rgb(clr);
                        clr.r = rgb.r;
                        clr.g = rgb.g;
                        clr.b = rgb.b;
                        clr.opacity = 1;
                        clr.hex = rgb.hex;
                    } else {
                        if (is(clr, "string")) {
                            clr = Snap.getRGB(clr);
                        }
                        if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
                            rgb = Snap.rgb2hsl(clr);
                            clr.h = rgb.h;
                            clr.s = rgb.s;
                            clr.l = rgb.l;
                            rgb = Snap.rgb2hsb(clr);
                            clr.v = rgb.b;
                        } else {
                            clr = {hex: "none"};
                            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
                            clr.error = 1;
                        }
                    }
                    clr.toString = rgbtoString;
                    return clr;
                };
                /*\
                 * Snap.hsb2rgb
                 [ method ]
                 **
                 * Converts HSB values to an RGB object
                 - h (number) hue
                 - s (number) saturation
                 - v (number) value or brightness
                 = (object) RGB object in the following format:
                 o {
                 o     r (number) red,
                 o     g (number) green,
                 o     b (number) blue,
                 o     hex (string) color in HTML/CSS format: #••••••
                 o }
                 \*/
                Snap.hsb2rgb = function (h, s, v, o) {
                    if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
                        v = h.b;
                        s = h.s;
                        h = h.h;
                        o = h.o;
                    }
                    h *= 360;
                    var R, G, B, X, C;
                    h = (h % 360) / 60;
                    C = v * s;
                    X = C * (1 - abs(h % 2 - 1));
                    R = G = B = v - C;

                    h = ~~h;
                    R += [C, X, 0, 0, X, C][h];
                    G += [X, C, C, X, 0, 0][h];
                    B += [0, 0, X, C, C, X][h];
                    return packageRGB(R, G, B, o);
                };
                /*\
                 * Snap.hsl2rgb
                 [ method ]
                 **
                 * Converts HSL values to an RGB object
                 - h (number) hue
                 - s (number) saturation
                 - l (number) luminosity
                 = (object) RGB object in the following format:
                 o {
                 o     r (number) red,
                 o     g (number) green,
                 o     b (number) blue,
                 o     hex (string) color in HTML/CSS format: #••••••
                 o }
                 \*/
                Snap.hsl2rgb = function (h, s, l, o) {
                    if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
                        l = h.l;
                        s = h.s;
                        h = h.h;
                    }
                    if (h > 1 || s > 1 || l > 1) {
                        h /= 360;
                        s /= 100;
                        l /= 100;
                    }
                    h *= 360;
                    var R, G, B, X, C;
                    h = (h % 360) / 60;
                    C = 2 * s * (l < .5 ? l : 1 - l);
                    X = C * (1 - abs(h % 2 - 1));
                    R = G = B = l - C / 2;

                    h = ~~h;
                    R += [C, X, 0, 0, X, C][h];
                    G += [X, C, C, X, 0, 0][h];
                    B += [0, 0, X, C, C, X][h];
                    return packageRGB(R, G, B, o);
                };
                /*\
                 * Snap.rgb2hsb
                 [ method ]
                 **
                 * Converts RGB values to an HSB object
                 - r (number) red
                 - g (number) green
                 - b (number) blue
                 = (object) HSB object in the following format:
                 o {
                 o     h (number) hue,
                 o     s (number) saturation,
                 o     b (number) brightness
                 o }
                 \*/
                Snap.rgb2hsb = function (r, g, b) {
                    b = prepareRGB(r, g, b);
                    r = b[0];
                    g = b[1];
                    b = b[2];

                    var H, S, V, C;
                    V = mmax(r, g, b);
                    C = V - mmin(r, g, b);
                    H = (C == 0 ? null :
                        V == r ? (g - b) / C :
                            V == g ? (b - r) / C + 2 :
                            (r - g) / C + 4
                    );
                    H = ((H + 360) % 6) * 60 / 360;
                    S = C == 0 ? 0 : C / V;
                    return {h: H, s: S, b: V, toString: hsbtoString};
                };
                /*\
                 * Snap.rgb2hsl
                 [ method ]
                 **
                 * Converts RGB values to an HSL object
                 - r (number) red
                 - g (number) green
                 - b (number) blue
                 = (object) HSL object in the following format:
                 o {
                 o     h (number) hue,
                 o     s (number) saturation,
                 o     l (number) luminosity
                 o }
                 \*/
                Snap.rgb2hsl = function (r, g, b) {
                    b = prepareRGB(r, g, b);
                    r = b[0];
                    g = b[1];
                    b = b[2];

                    var H, S, L, M, m, C;
                    M = mmax(r, g, b);
                    m = mmin(r, g, b);
                    C = M - m;
                    H = (C == 0 ? null :
                        M == r ? (g - b) / C :
                            M == g ? (b - r) / C + 2 :
                            (r - g) / C + 4);
                    H = ((H + 360) % 6) * 60 / 360;
                    L = (M + m) / 2;
                    S = (C == 0 ? 0 :
                        L < .5 ? C / (2 * L) :
                        C / (2 - 2 * L));
                    return {h: H, s: S, l: L, toString: hsltoString};
                };

// Transformations
// SIERRA Snap.parsePathString(): By _array of arrays,_ I assume you mean a format like this for two separate segments? [ ["M10,10","L90,90"], ["M90,10","L10,90"] ] Otherwise how is each command structured?
                /*\
                 * Snap.parsePathString
                 [ method ]
                 **
                 * Utility method
                 **
                 * Parses given path string into an array of arrays of path segments
                 - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
                 = (array) array of segments
                 \*/
                Snap.parsePathString = function (pathString) {
                    if (!pathString) {
                        return null;
                    }
                    var pth = Snap.path(pathString);
                    if (pth.arr) {
                        return Snap.path.clone(pth.arr);
                    }

                    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},
                        data = [];
                    if (is(pathString, "array") && is(pathString[0], "array")) { // rough assumption
                        data = Snap.path.clone(pathString);
                    }
                    if (!data.length) {
                        Str(pathString).replace(pathCommand, function (a, b, c) {
                            var params = [],
                                name = b.toLowerCase();
                            c.replace(pathValues, function (a, b) {
                                b && params.push(+b);
                            });
                            if (name == "m" && params.length > 2) {
                                data.push([b].concat(params.splice(0, 2)));
                                name = "l";
                                b = b == "m" ? "l" : "L";
                            }
                            if (name == "o" && params.length == 1) {
                                data.push([b, params[0]]);
                            }
                            if (name == "r") {
                                data.push([b].concat(params));
                            } else while (params.length >= paramCounts[name]) {
                                data.push([b].concat(params.splice(0, paramCounts[name])));
                                if (!paramCounts[name]) {
                                    break;
                                }
                            }
                        });
                    }
                    data.toString = Snap.path.toString;
                    pth.arr = Snap.path.clone(data);
                    return data;
                };
                /*\
                 * Snap.parseTransformString
                 [ method ]
                 **
                 * Utility method
                 **
                 * Parses given transform string into an array of transformations
                 - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
                 = (array) array of transformations
                 \*/
                var parseTransformString = Snap.parseTransformString = function (TString) {
                    if (!TString) {
                        return null;
                    }
                    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
                        data = [];
                    if (is(TString, "array") && is(TString[0], "array")) { // rough assumption
                        data = Snap.path.clone(TString);
                    }
                    if (!data.length) {
                        Str(TString).replace(tCommand, function (a, b, c) {
                            var params = [],
                                name = b.toLowerCase();
                            c.replace(pathValues, function (a, b) {
                                b && params.push(+b);
                            });
                            data.push([b].concat(params));
                        });
                    }
                    data.toString = Snap.path.toString;
                    return data;
                };

                function svgTransform2string(tstr) {
                    var res = [];
                    tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
                        params = params.split(/\s*,\s*|\s+/);
                        if (name == "rotate" && params.length == 1) {
                            params.push(0, 0);
                        }
                        if (name == "scale") {
                            if (params.length > 2) {
                                params = params.slice(0, 2);
                            } else if (params.length == 2) {
                                params.push(0, 0);
                            }
                            if (params.length == 1) {
                                params.push(params[0], 0, 0);
                            }
                        }
                        if (name == "skewX") {
                            res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
                        } else if (name == "skewY") {
                            res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
                        } else {
                            res.push([name.charAt(0)].concat(params));
                        }
                        return all;
                    });
                    return res;
                }

                Snap._.svgTransform2string = svgTransform2string;
                Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
                function transform2matrix(tstr, bbox) {
                    var tdata = parseTransformString(tstr),
                        m = new Snap.Matrix;
                    if (tdata) {
                        for (var i = 0, ii = tdata.length; i < ii; i++) {
                            var t = tdata[i],
                                tlen = t.length,
                                command = Str(t[0]).toLowerCase(),
                                absolute = t[0] != command,
                                inver = absolute ? m.invert() : 0,
                                x1,
                                y1,
                                x2,
                                y2,
                                bb;
                            if (command == "t" && tlen == 2) {
                                m.translate(t[1], 0);
                            } else if (command == "t" && tlen == 3) {
                                if (absolute) {
                                    x1 = inver.x(0, 0);
                                    y1 = inver.y(0, 0);
                                    x2 = inver.x(t[1], t[2]);
                                    y2 = inver.y(t[1], t[2]);
                                    m.translate(x2 - x1, y2 - y1);
                                } else {
                                    m.translate(t[1], t[2]);
                                }
                            } else if (command == "r") {
                                if (tlen == 2) {
                                    bb = bb || bbox;
                                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                                } else if (tlen == 4) {
                                    if (absolute) {
                                        x2 = inver.x(t[2], t[3]);
                                        y2 = inver.y(t[2], t[3]);
                                        m.rotate(t[1], x2, y2);
                                    } else {
                                        m.rotate(t[1], t[2], t[3]);
                                    }
                                }
                            } else if (command == "s") {
                                if (tlen == 2 || tlen == 3) {
                                    bb = bb || bbox;
                                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                                } else if (tlen == 4) {
                                    if (absolute) {
                                        x2 = inver.x(t[2], t[3]);
                                        y2 = inver.y(t[2], t[3]);
                                        m.scale(t[1], t[1], x2, y2);
                                    } else {
                                        m.scale(t[1], t[1], t[2], t[3]);
                                    }
                                } else if (tlen == 5) {
                                    if (absolute) {
                                        x2 = inver.x(t[3], t[4]);
                                        y2 = inver.y(t[3], t[4]);
                                        m.scale(t[1], t[2], x2, y2);
                                    } else {
                                        m.scale(t[1], t[2], t[3], t[4]);
                                    }
                                }
                            } else if (command == "m" && tlen == 7) {
                                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                            }
                        }
                    }
                    return m;
                }

                Snap._.transform2matrix = transform2matrix;
                Snap._unit2px = unit2px;
                var contains = glob.doc.contains || glob.doc.compareDocumentPosition ?
                    function (a, b) {
                        var adown = a.nodeType == 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a == bup || !!(bup && bup.nodeType == 1 && (
                                adown.contains ?
                                    adown.contains(bup) :
                                a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                            ));
                    } :
                    function (a, b) {
                        if (b) {
                            while (b) {
                                b = b.parentNode;
                                if (b == a) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                function getSomeDefs(el) {
                    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||
                            (el.node.parentNode && wrap(el.node.parentNode)) ||
                            Snap.select("svg") ||
                            Snap(0, 0),
                        pdefs = p.select("defs"),
                        defs = pdefs == null ? false : pdefs.node;
                    if (!defs) {
                        defs = make("defs", p.node).node;
                    }
                    return defs;
                }

                function getSomeSVG(el) {
                    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
                }

                Snap._.getSomeDefs = getSomeDefs;
                Snap._.getSomeSVG = getSomeSVG;
                function unit2px(el, name, value) {
                    var svg = getSomeSVG(el).node,
                        out = {},
                        mgr = svg.querySelector(".svg---mgr");
                    if (!mgr) {
                        mgr = $("rect");
                        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none"});
                        svg.appendChild(mgr);
                    }
                    function getW(val) {
                        if (val == null) {
                            return E;
                        }
                        if (val == +val) {
                            return val;
                        }
                        $(mgr, {width: val});
                        try {
                            return mgr.getBBox().width;
                        } catch (e) {
                            return 0;
                        }
                    }

                    function getH(val) {
                        if (val == null) {
                            return E;
                        }
                        if (val == +val) {
                            return val;
                        }
                        $(mgr, {height: val});
                        try {
                            return mgr.getBBox().height;
                        } catch (e) {
                            return 0;
                        }
                    }

                    function set(nam, f) {
                        if (name == null) {
                            out[nam] = f(el.attr(nam) || 0);
                        } else if (nam == name) {
                            out = f(value == null ? el.attr(nam) || 0 : value);
                        }
                    }

                    switch (el.type) {
                        case "rect":
                            set("rx", getW);
                            set("ry", getH);
                        case "image":
                            set("width", getW);
                            set("height", getH);
                        case "text":
                            set("x", getW);
                            set("y", getH);
                            break;
                        case "circle":
                            set("cx", getW);
                            set("cy", getH);
                            set("r", getW);
                            break;
                        case "ellipse":
                            set("cx", getW);
                            set("cy", getH);
                            set("rx", getW);
                            set("ry", getH);
                            break;
                        case "line":
                            set("x1", getW);
                            set("x2", getW);
                            set("y1", getH);
                            set("y2", getH);
                            break;
                        case "marker":
                            set("refX", getW);
                            set("markerWidth", getW);
                            set("refY", getH);
                            set("markerHeight", getH);
                            break;
                        case "radialGradient":
                            set("fx", getW);
                            set("fy", getH);
                            break;
                        case "tspan":
                            set("dx", getW);
                            set("dy", getH);
                            break;
                        default:
                            set(name, getW);
                    }
                    svg.removeChild(mgr);
                    return out;
                }

                /*\
                 * Snap.select
                 [ method ]
                 **
                 * Wraps a DOM element specified by CSS selector as @Element
                 - query (string) CSS selector of the element
                 = (Element) the current element
                 \*/
                Snap.select = function (query) {
                    query = Str(query).replace(/([^\\]):/g, "$1\\:");
                    return wrap(glob.doc.querySelector(query));
                };
                /*\
                 * Snap.selectAll
                 [ method ]
                 **
                 * Wraps DOM elements specified by CSS selector as set or array of @Element
                 - query (string) CSS selector of the element
                 = (Element) the current element
                 \*/
                Snap.selectAll = function (query) {
                    var nodelist = glob.doc.querySelectorAll(query),
                        set = (Snap.set || Array)();
                    for (var i = 0; i < nodelist.length; i++) {
                        set.push(wrap(nodelist[i]));
                    }
                    return set;
                };

                function add2group(list) {
                    if (!is(list, "array")) {
                        list = Array.prototype.slice.call(arguments, 0);
                    }
                    var i = 0,
                        j = 0,
                        node = this.node;
                    while (this[i]) delete this[i++];
                    for (i = 0; i < list.length; i++) {
                        if (list[i].type == "set") {
                            list[i].forEach(function (el) {
                                node.appendChild(el.node);
                            });
                        } else {
                            node.appendChild(list[i].node);
                        }
                    }
                    var children = node.childNodes;
                    for (i = 0; i < children.length; i++) {
                        this[j++] = wrap(children[i]);
                    }
                    return this;
                }

// Hub garbage collector every 10s
                setInterval(function () {
                    for (var key in hub) if (hub[has](key)) {
                        var el = hub[key],
                            node = el.node;
                        if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
                            delete hub[key];
                        }
                    }
                }, 1e4);
                function Element(el) {
                    if (el.snap in hub) {
                        return hub[el.snap];
                    }
                    var svg;
                    try {
                        svg = el.ownerSVGElement;
                    } catch (e) {
                    }
                    /*\
                     * Element.node
                     [ property (object) ]
                     **
                     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
                     > Usage
                     | // draw a circle at coordinate 10,10 with radius of 10
                     | var c = paper.circle(10, 10, 10);
                     | c.node.onclick = function () {
                     |     c.attr("fill", "red");
                     | };
                     \*/
                    this.node = el;
                    if (svg) {
                        this.paper = new Paper(svg);
                    }
                    /*\
                     * Element.type
                     [ property (string) ]
                     **
                     * SVG tag name of the given element.
                     \*/
                    this.type = el.tagName;
                    var id = this.id = ID(this);
                    this.anims = {};
                    this._ = {
                        transform: []
                    };
                    el.snap = id;
                    hub[id] = this;
                    if (this.type == "g") {
                        this.add = add2group;
                    }
                    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {
                        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {
                            this[method] = Paper.prototype[method];
                        }
                    }
                }

                /*\
                 * Element.attr
                 [ method ]
                 **
                 * Gets or sets given attributes of the element.
                 **
                 - params (object) contains key-value pairs of attributes you want to set
                 * or
                 - param (string) name of the attribute
                 = (Element) the current element
                 * or
                 = (string) value of attribute
                 > Usage
                 | el.attr({
                 |     fill: "#fc0",
                 |     stroke: "#000",
                 |     strokeWidth: 2, // CamelCase...
                 |     "fill-opacity": 0.5, // or dash-separated names
                 |     width: "*=2" // prefixed values
                 | });
                 | console.log(el.attr("fill")); // #fc0
                 * Prefixed values in format `"+=10"` supported. All four operations
                 * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
                 * and `-`: `"+=2em"`.
                 \*/
                Element.prototype.attr = function (params, value) {
                    var el = this,
                        node = el.node;
                    if (!params) {
                        return el;
                    }
                    if (is(params, "string")) {
                        if (arguments.length > 1) {
                            var json = {};
                            json[params] = value;
                            params = json;
                        } else {
                            return eve("snap.util.getattr." + params, el).firstDefined();
                        }
                    }
                    for (var att in params) {
                        if (params[has](att)) {
                            eve("snap.util.attr." + att, el, params[att]);
                        }
                    }
                    return el;
                };
                /*\
                 * Snap.parse
                 [ method ]
                 **
                 * Parses SVG fragment and converts it into a @Fragment
                 **
                 - svg (string) SVG string
                 = (Fragment) the @Fragment
                 \*/
                Snap.parse = function (svg) {
                    var f = glob.doc.createDocumentFragment(),
                        full = true,
                        div = glob.doc.createElement("div");
                    svg = Str(svg);
                    if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
                        svg = "<svg>" + svg + "</svg>";
                        full = false;
                    }
                    div.innerHTML = svg;
                    svg = div.getElementsByTagName("svg")[0];
                    if (svg) {
                        if (full) {
                            f = svg;
                        } else {
                            while (svg.firstChild) {
                                f.appendChild(svg.firstChild);
                            }
                            div.innerHTML = E;
                        }
                    }
                    return new Fragment(f);
                };
                function Fragment(frag) {
                    this.node = frag;
                }

// SIERRA Snap.fragment() could especially use a code example
                /*\
                 * Snap.fragment
                 [ method ]
                 **
                 * Creates a DOM fragment from a given list of elements or strings
                 **
                 - varargs (…) SVG string
                 = (Fragment) the @Fragment
                 \*/
                Snap.fragment = function () {
                    var args = Array.prototype.slice.call(arguments, 0),
                        f = glob.doc.createDocumentFragment();
                    for (var i = 0, ii = args.length; i < ii; i++) {
                        var item = args[i];
                        if (item.node && item.node.nodeType) {
                            f.appendChild(item.node);
                        }
                        if (item.nodeType) {
                            f.appendChild(item);
                        }
                        if (typeof item == "string") {
                            f.appendChild(Snap.parse(item).node);
                        }
                    }
                    return new Fragment(f);
                };

                function make(name, parent) {
                    var res = $(name);
                    parent.appendChild(res);
                    var el = wrap(res);
                    return el;
                }

                function Paper(w, h) {
                    var res,
                        desc,
                        defs,
                        proto = Paper.prototype;
                    if (w && w.tagName == "svg") {
                        if (w.snap in hub) {
                            return hub[w.snap];
                        }
                        var doc = w.ownerDocument;
                        res = new Element(w);
                        desc = w.getElementsByTagName("desc")[0];
                        defs = w.getElementsByTagName("defs")[0];
                        if (!desc) {
                            desc = $("desc");
                            desc.appendChild(doc.createTextNode("Created with Snap"));
                            res.node.appendChild(desc);
                        }
                        if (!defs) {
                            defs = $("defs");
                            res.node.appendChild(defs);
                        }
                        res.defs = defs;
                        for (var key in proto) if (proto[has](key)) {
                            res[key] = proto[key];
                        }
                        res.paper = res.root = res;
                    } else {
                        res = make("svg", glob.doc.body);
                        $(res.node, {
                            height: h,
                            version: 1.1,
                            width: w,
                            xmlns: xmlns
                        });
                    }
                    return res;
                }

                function wrap(dom) {
                    if (!dom) {
                        return dom;
                    }
                    if (dom instanceof Element || dom instanceof Fragment) {
                        return dom;
                    }
                    if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
                        return new Paper(dom);
                    }
                    if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
                        return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
                    }
                    return new Element(dom);
                }

                Snap._.make = make;
                Snap._.wrap = wrap;
                /*\
                 * Paper.el
                 [ method ]
                 **
                 * Creates an element on paper with a given name and no attributes
                 **
                 - name (string) tag name
                 - attr (object) attributes
                 = (Element) the current element
                 > Usage
                 | var c = paper.circle(10, 10, 10); // is the same as...
                 | var c = paper.el("circle").attr({
                 |     cx: 10,
                 |     cy: 10,
                 |     r: 10
                 | });
                 | // and the same as
                 | var c = paper.el("circle", {
                 |     cx: 10,
                 |     cy: 10,
                 |     r: 10
                 | });
                 \*/
                Paper.prototype.el = function (name, attr) {
                    var el = make(name, this.node);
                    attr && el.attr(attr);
                    return el;
                };
// default
                eve.on("snap.util.getattr", function () {
                    var att = eve.nt();
                    att = att.substring(att.lastIndexOf(".") + 1);
                    var css = att.replace(/[A-Z]/g, function (letter) {
                        return "-" + letter.toLowerCase();
                    });
                    if (cssAttr[has](css)) {
                        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
                    } else {
                        return $(this.node, att);
                    }
                });
                var cssAttr = {
                    "alignment-baseline": 0,
                    "baseline-shift": 0,
                    "clip": 0,
                    "clip-path": 0,
                    "clip-rule": 0,
                    "color": 0,
                    "color-interpolation": 0,
                    "color-interpolation-filters": 0,
                    "color-profile": 0,
                    "color-rendering": 0,
                    "cursor": 0,
                    "direction": 0,
                    "display": 0,
                    "dominant-baseline": 0,
                    "enable-background": 0,
                    "fill": 0,
                    "fill-opacity": 0,
                    "fill-rule": 0,
                    "filter": 0,
                    "flood-color": 0,
                    "flood-opacity": 0,
                    "font": 0,
                    "font-family": 0,
                    "font-size": 0,
                    "font-size-adjust": 0,
                    "font-stretch": 0,
                    "font-style": 0,
                    "font-variant": 0,
                    "font-weight": 0,
                    "glyph-orientation-horizontal": 0,
                    "glyph-orientation-vertical": 0,
                    "image-rendering": 0,
                    "kerning": 0,
                    "letter-spacing": 0,
                    "lighting-color": 0,
                    "marker": 0,
                    "marker-end": 0,
                    "marker-mid": 0,
                    "marker-start": 0,
                    "mask": 0,
                    "opacity": 0,
                    "overflow": 0,
                    "pointer-events": 0,
                    "shape-rendering": 0,
                    "stop-color": 0,
                    "stop-opacity": 0,
                    "stroke": 0,
                    "stroke-dasharray": 0,
                    "stroke-dashoffset": 0,
                    "stroke-linecap": 0,
                    "stroke-linejoin": 0,
                    "stroke-miterlimit": 0,
                    "stroke-opacity": 0,
                    "stroke-width": 0,
                    "text-anchor": 0,
                    "text-decoration": 0,
                    "text-rendering": 0,
                    "unicode-bidi": 0,
                    "visibility": 0,
                    "word-spacing": 0,
                    "writing-mode": 0
                };

                eve.on("snap.util.attr", function (value) {
                    var att = eve.nt(),
                        attr = {};
                    att = att.substring(att.lastIndexOf(".") + 1);
                    attr[att] = value;
                    var style = att.replace(/-(\w)/gi, function (all, letter) {
                            return letter.toUpperCase();
                        }),
                        css = att.replace(/[A-Z]/g, function (letter) {
                            return "-" + letter.toLowerCase();
                        });
                    if (cssAttr[has](css)) {
                        this.node.style[style] = value == null ? E : value;
                    } else {
                        $(this.node, attr);
                    }
                });
                (function (proto) {
                }(Paper.prototype));

// simple ajax
                /*\
                 * Snap.ajax
                 [ method ]
                 **
                 * Simple implementation of Ajax
                 **
                 - url (string) URL
                 - postData (object|string) data for post request
                 - callback (function) callback
                 - scope (object) #optional scope of callback
                 * or
                 - url (string) URL
                 - callback (function) callback
                 - scope (object) #optional scope of callback
                 = (XMLHttpRequest) the XMLHttpRequest object, just in case
                 \*/
                Snap.ajax = function (url, postData, callback, scope) {
                    var req = new XMLHttpRequest,
                        id = ID();
                    if (req) {
                        if (is(postData, "function")) {
                            scope = callback;
                            callback = postData;
                            postData = null;
                        } else if (is(postData, "object")) {
                            var pd = [];
                            for (var key in postData) if (postData.hasOwnProperty(key)) {
                                pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
                            }
                            postData = pd.join("&");
                        }
                        req.open((postData ? "POST" : "GET"), url, true);
                        if (postData) {
                            req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                        }
                        if (callback) {
                            eve.once("snap.ajax." + id + ".0", callback);
                            eve.once("snap.ajax." + id + ".200", callback);
                            eve.once("snap.ajax." + id + ".304", callback);
                        }
                        req.onreadystatechange = function () {
                            if (req.readyState != 4) return;
                            eve("snap.ajax." + id + "." + req.status, scope, req);
                        };
                        if (req.readyState == 4) {
                            return req;
                        }
                        req.send(postData);
                        return req;
                    }
                };
                /*\
                 * Snap.load
                 [ method ]
                 **
                 * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
                 **
                 - url (string) URL
                 - callback (function) callback
                 - scope (object) #optional scope of callback
                 \*/
                Snap.load = function (url, callback, scope) {
                    Snap.ajax(url, function (req) {
                        var f = Snap.parse(req.responseText);
                        scope ? callback.call(scope, f) : callback(f);
                    });
                };
                var getOffset = function (elem) {
                    var box = elem.getBoundingClientRect(),
                        doc = elem.ownerDocument,
                        body = doc.body,
                        docElem = doc.documentElement,
                        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
                        top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
                        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
                    return {
                        y: top,
                        x: left
                    };
                };
                /*\
                 * Snap.getElementByPoint
                 [ method ]
                 **
                 * Returns you topmost element under given point.
                 **
                 = (object) Snap element object
                 - x (number) x coordinate from the top left corner of the window
                 - y (number) y coordinate from the top left corner of the window
                 > Usage
                 | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
                 \*/
                Snap.getElementByPoint = function (x, y) {
                    var paper = this,
                        svg = paper.canvas,
                        target = glob.doc.elementFromPoint(x, y);
                    if (glob.win.opera && target.tagName == "svg") {
                        var so = getOffset(target),
                            sr = target.createSVGRect();
                        sr.x = x - so.x;
                        sr.y = y - so.y;
                        sr.width = sr.height = 1;
                        var hits = target.getIntersectionList(sr, null);
                        if (hits.length) {
                            target = hits[hits.length - 1];
                        }
                    }
                    if (!target) {
                        return null;
                    }
                    return wrap(target);
                };
                /*\
                 * Snap.plugin
                 [ method ]
                 **
                 * Let you write plugins. You pass in a function with four arguments, like this:
                 | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
                 |     Snap.newmethod = function () {};
                 |     Element.prototype.newmethod = function () {};
                 |     Paper.prototype.newmethod = function () {};
                 | });
                 * Inside the function you have access to all main objects (and their
                 * prototypes). This allow you to extend anything you want.
                 **
                 - f (function) your plugin body
                 \*/
                Snap.plugin = function (f) {
                    f(Snap, Element, Paper, glob, Fragment);
                };
                glob.win.Snap = Snap;
                return Snap;
            }(window || this));
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
            Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
                var elproto = Element.prototype,
                    is = Snap.is,
                    Str = String,
                    unit2px = Snap._unit2px,
                    $ = Snap._.$,
                    make = Snap._.make,
                    getSomeDefs = Snap._.getSomeDefs,
                    has = "hasOwnProperty",
                    wrap = Snap._.wrap;
                /*\
                 * Element.getBBox
                 [ method ]
                 **
                 * Returns the bounding box descriptor for the given element
                 **
                 = (object) bounding box descriptor:
                 o {
                 o     cx: (number) x of the center,
                 o     cy: (number) x of the center,
                 o     h: (number) height,
                 o     height: (number) height,
                 o     path: (string) path command for the box,
                 o     r0: (number) radius of a circle that fully encloses the box,
                 o     r1: (number) radius of the smallest circle that can be enclosed,
                 o     r2: (number) radius of the largest circle that can be enclosed,
                 o     vb: (string) box as a viewbox command,
                 o     w: (number) width,
                 o     width: (number) width,
                 o     x2: (number) x of the right side,
                 o     x: (number) x of the left side,
                 o     y2: (number) y of the bottom edge,
                 o     y: (number) y of the top edge
                 o }
                 \*/
                elproto.getBBox = function (isWithoutTransform) {
                    if (!Snap.Matrix || !Snap.path) {
                        return this.node.getBBox();
                    }
                    var el = this,
                        m = new Snap.Matrix;
                    if (el.removed) {
                        return Snap._.box();
                    }
                    while (el.type == "use") {
                        if (!isWithoutTransform) {
                            m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
                        }
                        if (el.original) {
                            el = el.original;
                        } else {
                            var href = el.attr("xlink:href");
                            el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
                        }
                    }
                    var _ = el._,
                        pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
                    try {
                        if (isWithoutTransform) {
                            _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
                            return Snap._.box(_.bboxwt);
                        } else {
                            el.realPath = pathfinder(el);
                            el.matrix = el.transform().localMatrix;
                            _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
                            return Snap._.box(_.bbox);
                        }
                    } catch (e) {
                        // Firefox doesn’t give you bbox of hidden element
                        return Snap._.box();
                    }
                };
                var propString = function () {
                    return this.string;
                };

                function extractTransform(el, tstr) {
                    if (tstr == null) {
                        var doReturn = true;
                        if (el.type == "linearGradient" || el.type == "radialGradient") {
                            tstr = el.node.getAttribute("gradientTransform");
                        } else if (el.type == "pattern") {
                            tstr = el.node.getAttribute("patternTransform");
                        } else {
                            tstr = el.node.getAttribute("transform");
                        }
                        if (!tstr) {
                            return new Snap.Matrix;
                        }
                        tstr = Snap._.svgTransform2string(tstr);
                    } else {
                        if (!Snap._.rgTransform.test(tstr)) {
                            tstr = Snap._.svgTransform2string(tstr);
                        } else {
                            tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
                        }
                        if (is(tstr, "array")) {
                            tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
                        }
                        el._.transform = tstr;
                    }
                    var m = Snap._.transform2matrix(tstr, el.getBBox(1));
                    if (doReturn) {
                        return m;
                    } else {
                        el.matrix = m;
                    }
                }

                /*\
                 * Element.transform
                 [ method ]
                 **
                 * Gets or sets transformation of the element
                 **
                 - tstr (string) transform string in Snap or SVG format
                 = (Element) the current element
                 * or
                 = (object) transformation descriptor:
                 o {
                 o     string (string) transform string,
                 o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
                 o     localMatrix (Matrix) matrix of transformations applied only to the element,
                 o     diffMatrix (Matrix) matrix of difference between global and local transformations,
                 o     global (string) global transformation as string,
                 o     local (string) local transformation as string,
                 o     toString (function) returns `string` property
                 o }
                 \*/
                elproto.transform = function (tstr) {
                    var _ = this._;
                    if (tstr == null) {
                        var papa = this,
                            global = new Snap.Matrix(this.node.getCTM()),
                            local = extractTransform(this),
                            ms = [local],
                            m = new Snap.Matrix,
                            i,
                            localString = local.toTransformString(),
                            string = Str(local) == Str(this.matrix) ?
                                Str(_.transform) : localString;
                        while (papa.type != "svg" && (papa = papa.parent())) {
                            ms.push(extractTransform(papa));
                        }
                        i = ms.length;
                        while (i--) {
                            m.add(ms[i]);
                        }
                        return {
                            string: string,
                            globalMatrix: global,
                            totalMatrix: m,
                            localMatrix: local,
                            diffMatrix: global.clone().add(local.invert()),
                            global: global.toTransformString(),
                            total: m.toTransformString(),
                            local: localString,
                            toString: propString
                        };
                    }
                    if (tstr instanceof Snap.Matrix) {
                        this.matrix = tstr;
                        this._.transform = tstr.toTransformString();
                    } else {
                        extractTransform(this, tstr);
                    }

                    if (this.node) {
                        if (this.type == "linearGradient" || this.type == "radialGradient") {
                            $(this.node, {gradientTransform: this.matrix});
                        } else if (this.type == "pattern") {
                            $(this.node, {patternTransform: this.matrix});
                        } else {
                            $(this.node, {transform: this.matrix});
                        }
                    }

                    return this;
                };
                /*\
                 * Element.parent
                 [ method ]
                 **
                 * Returns the element's parent
                 **
                 = (Element) the parent element
                 \*/
                elproto.parent = function () {
                    return wrap(this.node.parentNode);
                };
                /*\
                 * Element.append
                 [ method ]
                 **
                 * Appends the given element to current one
                 **
                 - el (Element|Set) element to append
                 = (Element) the parent element
                 \*/
                /*\
                 * Element.add
                 [ method ]
                 **
                 * See @Element.append
                 \*/
                elproto.append = elproto.add = function (el) {
                    if (el) {
                        if (el.type == "set") {
                            var it = this;
                            el.forEach(function (el) {
                                it.add(el);
                            });
                            return this;
                        }
                        el = wrap(el);
                        this.node.appendChild(el.node);
                        el.paper = this.paper;
                    }
                    return this;
                };
                /*\
                 * Element.appendTo
                 [ method ]
                 **
                 * Appends the current element to the given one
                 **
                 - el (Element) parent element to append to
                 = (Element) the child element
                 \*/
                elproto.appendTo = function (el) {
                    if (el) {
                        el = wrap(el);
                        el.append(this);
                    }
                    return this;
                };
                /*\
                 * Element.prepend
                 [ method ]
                 **
                 * Prepends the given element to the current one
                 **
                 - el (Element) element to prepend
                 = (Element) the parent element
                 \*/
                elproto.prepend = function (el) {
                    if (el) {
                        if (el.type == "set") {
                            var it = this,
                                first;
                            el.forEach(function (el) {
                                if (first) {
                                    first.after(el);
                                } else {
                                    it.prepend(el);
                                }
                                first = el;
                            });
                            return this;
                        }
                        el = wrap(el);
                        var parent = el.parent();
                        this.node.insertBefore(el.node, this.node.firstChild);
                        this.add && this.add();
                        el.paper = this.paper;
                        this.parent() && this.parent().add();
                        parent && parent.add();
                    }
                    return this;
                };
                /*\
                 * Element.prependTo
                 [ method ]
                 **
                 * Prepends the current element to the given one
                 **
                 - el (Element) parent element to prepend to
                 = (Element) the child element
                 \*/
                elproto.prependTo = function (el) {
                    el = wrap(el);
                    el.prepend(this);
                    return this;
                };
                /*\
                 * Element.before
                 [ method ]
                 **
                 * Inserts given element before the current one
                 **
                 - el (Element) element to insert
                 = (Element) the parent element
                 \*/
                elproto.before = function (el) {
                    if (el.type == "set") {
                        var it = this;
                        el.forEach(function (el) {
                            var parent = el.parent();
                            it.node.parentNode.insertBefore(el.node, it.node);
                            parent && parent.add();
                        });
                        this.parent().add();
                        return this;
                    }
                    el = wrap(el);
                    var parent = el.parent();
                    this.node.parentNode.insertBefore(el.node, this.node);
                    this.parent() && this.parent().add();
                    parent && parent.add();
                    el.paper = this.paper;
                    return this;
                };
                /*\
                 * Element.after
                 [ method ]
                 **
                 * Inserts given element after the current one
                 **
                 - el (Element) element to insert
                 = (Element) the parent element
                 \*/
                elproto.after = function (el) {
                    el = wrap(el);
                    var parent = el.parent();
                    if (this.node.nextSibling) {
                        this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
                    } else {
                        this.node.parentNode.appendChild(el.node);
                    }
                    this.parent() && this.parent().add();
                    parent && parent.add();
                    el.paper = this.paper;
                    return this;
                };
                /*\
                 * Element.insertBefore
                 [ method ]
                 **
                 * Inserts the element after the given one
                 **
                 - el (Element) element next to whom insert to
                 = (Element) the parent element
                 \*/
                elproto.insertBefore = function (el) {
                    el = wrap(el);
                    var parent = this.parent();
                    el.node.parentNode.insertBefore(this.node, el.node);
                    this.paper = el.paper;
                    parent && parent.add();
                    el.parent() && el.parent().add();
                    return this;
                };
                /*\
                 * Element.insertAfter
                 [ method ]
                 **
                 * Inserts the element after the given one
                 **
                 - el (Element) element next to whom insert to
                 = (Element) the parent element
                 \*/
                elproto.insertAfter = function (el) {
                    el = wrap(el);
                    var parent = this.parent();
                    el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
                    this.paper = el.paper;
                    parent && parent.add();
                    el.parent() && el.parent().add();
                    return this;
                };
                /*\
                 * Element.remove
                 [ method ]
                 **
                 * Removes element from the DOM
                 = (Element) the detached element
                 \*/
                elproto.remove = function () {
                    var parent = this.parent();
                    this.node.parentNode && this.node.parentNode.removeChild(this.node);
                    delete this.paper;
                    this.removed = true;
                    parent && parent.add();
                    return this;
                };
                /*\
                 * Element.select
                 [ method ]
                 **
                 * Gathers the nested @Element matching the given set of CSS selectors
                 **
                 - query (string) CSS selector
                 = (Element) result of query selection
                 \*/
                elproto.select = function (query) {
                    query = Str(query).replace(/([^\\]):/g, "$1\\:");
                    return wrap(this.node.querySelector(query));
                };
                /*\
                 * Element.selectAll
                 [ method ]
                 **
                 * Gathers nested @Element objects matching the given set of CSS selectors
                 **
                 - query (string) CSS selector
                 = (Set|array) result of query selection
                 \*/
                elproto.selectAll = function (query) {
                    var nodelist = this.node.querySelectorAll(query),
                        set = (Snap.set || Array)();
                    for (var i = 0; i < nodelist.length; i++) {
                        set.push(wrap(nodelist[i]));
                    }
                    return set;
                };
                /*\
                 * Element.asPX
                 [ method ]
                 **
                 * Returns given attribute of the element as a `px` value (not %, em, etc.)
                 **
                 - attr (string) attribute name
                 - value (string) #optional attribute value
                 = (Element) result of query selection
                 \*/
                elproto.asPX = function (attr, value) {
                    if (value == null) {
                        value = this.attr(attr);
                    }
                    return +unit2px(this, attr, value);
                };
                // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
                /*\
                 * Element.use
                 [ method ]
                 **
                 * Creates a `<use>` element linked to the current element
                 **
                 = (Element) the `<use>` element
                 \*/
                elproto.use = function () {
                    var use,
                        id = this.node.id;
                    if (!id) {
                        id = this.id;
                        $(this.node, {
                            id: id
                        });
                    }
                    if (this.type == "linearGradient" || this.type == "radialGradient" ||
                        this.type == "pattern") {
                        use = make(this.type, this.node.parentNode);
                    } else {
                        use = make("use", this.node.parentNode);
                    }
                    $(use.node, {
                        "xlink:href": "#" + id
                    });
                    use.original = this;
                    return use;
                };
                function fixids(el) {
                    var els = el.selectAll("*"),
                        it,
                        url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
                        ids = [],
                        uses = {};

                    function urltest(it, name) {
                        var val = $(it.node, name);
                        val = val && val.match(url);
                        val = val && val[2];
                        if (val && val.charAt() == "#") {
                            val = val.substring(1);
                        } else {
                            return;
                        }
                        if (val) {
                            uses[val] = (uses[val] || []).concat(function (id) {
                                var attr = {};
                                attr[name] = URL(id);
                                $(it.node, attr);
                            });
                        }
                    }

                    function linktest(it) {
                        var val = $(it.node, "xlink:href");
                        if (val && val.charAt() == "#") {
                            val = val.substring(1);
                        } else {
                            return;
                        }
                        if (val) {
                            uses[val] = (uses[val] || []).concat(function (id) {
                                it.attr("xlink:href", "#" + id);
                            });
                        }
                    }

                    for (var i = 0, ii = els.length; i < ii; i++) {
                        it = els[i];
                        urltest(it, "fill");
                        urltest(it, "stroke");
                        urltest(it, "filter");
                        urltest(it, "mask");
                        urltest(it, "clip-path");
                        linktest(it);
                        var oldid = $(it.node, "id");
                        if (oldid) {
                            $(it.node, {id: it.id});
                            ids.push({
                                old: oldid,
                                id: it.id
                            });
                        }
                    }
                    for (i = 0, ii = ids.length; i < ii; i++) {
                        var fs = uses[ids[i].old];
                        if (fs) {
                            for (var j = 0, jj = fs.length; j < jj; j++) {
                                fs[j](ids[i].id);
                            }
                        }
                    }
                }

                /*\
                 * Element.clone
                 [ method ]
                 **
                 * Creates a clone of the element and inserts it after the element
                 **
                 = (Element) the clone
                 \*/
                elproto.clone = function () {
                    var clone = wrap(this.node.cloneNode(true));
                    if ($(clone.node, "id")) {
                        $(clone.node, {id: clone.id});
                    }
                    fixids(clone);
                    clone.insertAfter(this);
                    return clone;
                };
                /*\
                 * Element.toDefs
                 [ method ]
                 **
                 * Moves element to the shared `<defs>` area
                 **
                 = (Element) the element
                 \*/
                elproto.toDefs = function () {
                    var defs = getSomeDefs(this);
                    defs.appendChild(this.node);
                    return this;
                };
                /*\
                 * Element.toPattern
                 [ method ]
                 **
                 * Creates a `<pattern>` element from the current element
                 **
                 * To create a pattern you have to specify the pattern rect:
                 - x (string|number)
                 - y (string|number)
                 - width (string|number)
                 - height (string|number)
                 = (Element) the `<pattern>` element
                 * You can use pattern later on as an argument for `fill` attribute:
                 | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
                 |         fill: "none",
                 |         stroke: "#bada55",
                 |         strokeWidth: 5
                 |     }).pattern(0, 0, 10, 10),
                 |     c = paper.circle(200, 200, 100);
                 | c.attr({
                 |     fill: p
                 | });
                 \*/
                elproto.pattern = elproto.toPattern = function (x, y, width, height) {
                    var p = make("pattern", getSomeDefs(this));
                    if (x == null) {
                        x = this.getBBox();
                    }
                    if (is(x, "object") && "x" in x) {
                        y = x.y;
                        width = x.width;
                        height = x.height;
                        x = x.x;
                    }
                    $(p.node, {
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        patternUnits: "userSpaceOnUse",
                        id: p.id,
                        viewBox: [x, y, width, height].join(" ")
                    });
                    p.node.appendChild(this.node);
                    return p;
                };
// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
                /*\
                 * Element.marker
                 [ method ]
                 **
                 * Creates a `<marker>` element from the current element
                 **
                 * To create a marker you have to specify the bounding rect and reference point:
                 - x (number)
                 - y (number)
                 - width (number)
                 - height (number)
                 - refX (number)
                 - refY (number)
                 = (Element) the `<marker>` element
                 * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
                 \*/
                // TODO add usage for markers
                elproto.marker = function (x, y, width, height, refX, refY) {
                    var p = make("marker", getSomeDefs(this));
                    if (x == null) {
                        x = this.getBBox();
                    }
                    if (is(x, "object") && "x" in x) {
                        y = x.y;
                        width = x.width;
                        height = x.height;
                        refX = x.refX || x.cx;
                        refY = x.refY || x.cy;
                        x = x.x;
                    }
                    $(p.node, {
                        viewBox: [x, y, width, height].join(" "),
                        markerWidth: width,
                        markerHeight: height,
                        orient: "auto",
                        refX: refX || 0,
                        refY: refY || 0,
                        id: p.id
                    });
                    p.node.appendChild(this.node);
                    return p;
                };
                // animation
                function slice(from, to, f) {
                    return function (arr) {
                        var res = arr.slice(from, to);
                        if (res.length == 1) {
                            res = res[0];
                        }
                        return f ? f(res) : res;
                    };
                }

                var Animation = function (attr, ms, easing, callback) {
                    if (typeof easing == "function" && !easing.length) {
                        callback = easing;
                        easing = mina.linear;
                    }
                    this.attr = attr;
                    this.dur = ms;
                    easing && (this.easing = easing);
                    callback && (this.callback = callback);
                };
                Snap._.Animation = Animation;
                /*\
                 * Snap.animation
                 [ method ]
                 **
                 * Creates an animation object
                 **
                 - attr (object) attributes of final destination
                 - duration (number) duration of the animation, in milliseconds
                 - easing (function) #optional one of easing functions of @mina or custom one
                 - callback (function) #optional callback function that fires when animation ends
                 = (object) animation object
                 \*/
                Snap.animation = function (attr, ms, easing, callback) {
                    return new Animation(attr, ms, easing, callback);
                };
                /*\
                 * Element.inAnim
                 [ method ]
                 **
                 * Returns a set of animations that may be able to manipulate the current element
                 **
                 = (object) in format:
                 o {
                 o     anim (object) animation object,
                 o     mina (object) @mina object,
                 o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,
                 o     status (function) gets or sets the status of the animation,
                 o     stop (function) stops the animation
                 o }
                 \*/
                elproto.inAnim = function () {
                    var el = this,
                        res = [];
                    for (var id in el.anims) if (el.anims[has](id)) {
                        (function (a) {
                            res.push({
                                anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
                                mina: a,
                                curStatus: a.status(),
                                status: function (val) {
                                    return a.status(val);
                                },
                                stop: function () {
                                    a.stop();
                                }
                            });
                        }(el.anims[id]));
                    }
                    return res;
                };
                /*\
                 * Snap.animate
                 [ method ]
                 **
                 * Runs generic animation of one number into another with a caring function
                 **
                 - from (number|array) number or array of numbers
                 - to (number|array) number or array of numbers
                 - setter (function) caring function that accepts one number argument
                 - duration (number) duration, in milliseconds
                 - easing (function) #optional easing function from @mina or custom
                 - callback (function) #optional callback function to execute when animation ends
                 = (object) animation object in @mina format
                 o {
                 o     id (string) animation id, consider it read-only,
                 o     duration (function) gets or sets the duration of the animation,
                 o     easing (function) easing,
                 o     speed (function) gets or sets the speed of the animation,
                 o     status (function) gets or sets the status of the animation,
                 o     stop (function) stops the animation
                 o }
                 | var rect = Snap().rect(0, 0, 10, 10);
                 | Snap.animate(0, 10, function (val) {
                 |     rect.attr({
                 |         x: val
                 |     });
                 | }, 1000);
                 | // in given context is equivalent to
                 | rect.animate({x: 10}, 1000);
                 \*/
                Snap.animate = function (from, to, setter, ms, easing, callback) {
                    if (typeof easing == "function" && !easing.length) {
                        callback = easing;
                        easing = mina.linear;
                    }
                    var now = mina.time(),
                        anim = mina(from, to, now, now + ms, mina.time, setter, easing);
                    callback && eve.once("mina.finish." + anim.id, callback);
                    return anim;
                };
                /*\
                 * Element.stop
                 [ method ]
                 **
                 * Stops all the animations for the current element
                 **
                 = (Element) the current element
                 \*/
                elproto.stop = function () {
                    var anims = this.inAnim();
                    for (var i = 0, ii = anims.length; i < ii; i++) {
                        anims[i].stop();
                    }
                    return this;
                };
                /*\
                 * Element.animate
                 [ method ]
                 **
                 * Animates the given attributes of the element
                 **
                 - attrs (object) key-value pairs of destination attributes
                 - duration (number) duration of the animation in milliseconds
                 - easing (function) #optional easing function from @mina or custom
                 - callback (function) #optional callback function that executes when the animation ends
                 = (Element) the current element
                 \*/
                elproto.animate = function (attrs, ms, easing, callback) {
                    if (typeof easing == "function" && !easing.length) {
                        callback = easing;
                        easing = mina.linear;
                    }
                    if (attrs instanceof Animation) {
                        callback = attrs.callback;
                        easing = attrs.easing;
                        ms = easing.dur;
                        attrs = attrs.attr;
                    }
                    var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,
                        el = this;
                    for (var key in attrs) if (attrs[has](key)) {
                        if (el.equal) {
                            eq = el.equal(key, Str(attrs[key]));
                            from = eq.from;
                            to = eq.to;
                            f = eq.f;
                        } else {
                            from = +el.attr(key);
                            to = +attrs[key];
                        }
                        var len = is(from, "array") ? from.length : 1;
                        keys[key] = slice(fkeys.length, fkeys.length + len, f);
                        fkeys = fkeys.concat(from);
                        tkeys = tkeys.concat(to);
                    }
                    var now = mina.time(),
                        anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
                            var attr = {};
                            for (var key in keys) if (keys[has](key)) {
                                attr[key] = keys[key](val);
                            }
                            el.attr(attr);
                        }, easing);
                    el.anims[anim.id] = anim;
                    anim._attrs = attrs;
                    anim._callback = callback;
                    eve("snap.animcreated." + el.id, anim);
                    eve.once("mina.finish." + anim.id, function () {
                        delete el.anims[anim.id];
                        callback && callback.call(el);
                    });
                    eve.once("mina.stop." + anim.id, function () {
                        delete el.anims[anim.id];
                    });
                    return el;
                };
                var eldata = {};
                /*\
                 * Element.data
                 [ method ]
                 **
                 * Adds or retrieves given value associated with given key. (Don’t confuse
                 * with `data-` attributes)
                 *
                 * See also @Element.removeData
                 - key (string) key to store data
                 - value (any) #optional value to store
                 = (object) @Element
                 * or, if value is not specified:
                 = (any) value
                 > Usage
                 | for (var i = 0, i < 5, i++) {
                 |     paper.circle(10 + 15 * i, 10, 10)
                 |          .attr({fill: "#000"})
                 |          .data("i", i)
                 |          .click(function () {
                 |             alert(this.data("i"));
                 |          });
                 | }
                 \*/
                elproto.data = function (key, value) {
                    var data = eldata[this.id] = eldata[this.id] || {};
                    if (arguments.length == 0) {
                        eve("snap.data.get." + this.id, this, data, null);
                        return data;
                    }
                    if (arguments.length == 1) {
                        if (Snap.is(key, "object")) {
                            for (var i in key) if (key[has](i)) {
                                this.data(i, key[i]);
                            }
                            return this;
                        }
                        eve("snap.data.get." + this.id, this, data[key], key);
                        return data[key];
                    }
                    data[key] = value;
                    eve("snap.data.set." + this.id, this, value, key);
                    return this;
                };
                /*\
                 * Element.removeData
                 [ method ]
                 **
                 * Removes value associated with an element by given key.
                 * If key is not provided, removes all the data of the element.
                 - key (string) #optional key
                 = (object) @Element
                 \*/
                elproto.removeData = function (key) {
                    if (key == null) {
                        eldata[this.id] = {};
                    } else {
                        eldata[this.id] && delete eldata[this.id][key];
                    }
                    return this;
                };
                /*\
                 * Element.outerSVG
                 [ method ]
                 **
                 * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
                 *
                 * See also @Element.innerSVG
                 = (string) SVG code for the element
                 \*/
                /*\
                 * Element.toString
                 [ method ]
                 **
                 * See @Element.outerSVG
                 \*/
                elproto.outerSVG = elproto.toString = toString(1);
                /*\
                 * Element.innerSVG
                 [ method ]
                 **
                 * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
                 = (string) SVG code for the element
                 \*/
                elproto.innerSVG = toString();
                function toString(type) {
                    return function () {
                        var res = type ? "<" + this.type : "",
                            attr = this.node.attributes,
                            chld = this.node.childNodes;
                        if (type) {
                            for (var i = 0, ii = attr.length; i < ii; i++) {
                                res += " " + attr[i].name + '="' +
                                attr[i].value.replace(/"/g, '\\"') + '"';
                            }
                        }
                        if (chld.length) {
                            type && (res += ">");
                            for (i = 0, ii = chld.length; i < ii; i++) {
                                if (chld[i].nodeType == 3) {
                                    res += chld[i].nodeValue;
                                } else if (chld[i].nodeType == 1) {
                                    res += wrap(chld[i]).toString();
                                }
                            }
                            type && (res += "</" + this.type + ">");
                        } else {
                            type && (res += "/>");
                        }
                        return res;
                    };
                }

                elproto.toDataURL = function () {
                    if (window && window.btoa) {
                        var bb = this.getBBox(),
                            svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
                                x: +bb.x.toFixed(3),
                                y: +bb.y.toFixed(3),
                                width: +bb.width.toFixed(3),
                                height: +bb.height.toFixed(3),
                                contents: this.outerSVG()
                            });
                        return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
                    }
                };
                /*\
                 * Fragment.select
                 [ method ]
                 **
                 * See @Element.select
                 \*/
                Fragment.prototype.select = elproto.select;
                /*\
                 * Fragment.selectAll
                 [ method ]
                 **
                 * See @Element.selectAll
                 \*/
                Fragment.prototype.selectAll = elproto.selectAll;
            });

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
            Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
                var objectToString = Object.prototype.toString,
                    Str = String,
                    math = Math,
                    E = "";

                function Matrix(a, b, c, d, e, f) {
                    if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
                        this.a = a.a;
                        this.b = a.b;
                        this.c = a.c;
                        this.d = a.d;
                        this.e = a.e;
                        this.f = a.f;
                        return;
                    }
                    if (a != null) {
                        this.a = +a;
                        this.b = +b;
                        this.c = +c;
                        this.d = +d;
                        this.e = +e;
                        this.f = +f;
                    } else {
                        this.a = 1;
                        this.b = 0;
                        this.c = 0;
                        this.d = 1;
                        this.e = 0;
                        this.f = 0;
                    }
                }

                (function (matrixproto) {
                    /*\
                     * Matrix.add
                     [ method ]
                     **
                     * Adds the given matrix to existing one
                     - a (number)
                     - b (number)
                     - c (number)
                     - d (number)
                     - e (number)
                     - f (number)
                     * or
                     - matrix (object) @Matrix
                     \*/
                    matrixproto.add = function (a, b, c, d, e, f) {
                        var out = [[], [], []],
                            m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                            matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                            x, y, z, res;

                        if (a && a instanceof Matrix) {
                            matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
                        }

                        for (x = 0; x < 3; x++) {
                            for (y = 0; y < 3; y++) {
                                res = 0;
                                for (z = 0; z < 3; z++) {
                                    res += m[x][z] * matrix[z][y];
                                }
                                out[x][y] = res;
                            }
                        }
                        this.a = out[0][0];
                        this.b = out[1][0];
                        this.c = out[0][1];
                        this.d = out[1][1];
                        this.e = out[0][2];
                        this.f = out[1][2];
                        return this;
                    };
                    /*\
                     * Matrix.invert
                     [ method ]
                     **
                     * Returns an inverted version of the matrix
                     = (object) @Matrix
                     \*/
                    matrixproto.invert = function () {
                        var me = this,
                            x = me.a * me.d - me.b * me.c;
                        return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
                    };
                    /*\
                     * Matrix.clone
                     [ method ]
                     **
                     * Returns a copy of the matrix
                     = (object) @Matrix
                     \*/
                    matrixproto.clone = function () {
                        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
                    };
                    /*\
                     * Matrix.translate
                     [ method ]
                     **
                     * Translate the matrix
                     - x (number) horizontal offset distance
                     - y (number) vertical offset distance
                     \*/
                    matrixproto.translate = function (x, y) {
                        return this.add(1, 0, 0, 1, x, y);
                    };
                    /*\
                     * Matrix.scale
                     [ method ]
                     **
                     * Scales the matrix
                     - x (number) amount to be scaled, with `1` resulting in no change
                     - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
                     - cx (number) #optional horizontal origin point from which to scale
                     - cy (number) #optional vertical origin point from which to scale
                     * Default cx, cy is the middle point of the element.
                     \*/
                    matrixproto.scale = function (x, y, cx, cy) {
                        y == null && (y = x);
                        (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
                        this.add(x, 0, 0, y, 0, 0);
                        (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
                        return this;
                    };
                    /*\
                     * Matrix.rotate
                     [ method ]
                     **
                     * Rotates the matrix
                     - a (number) angle of rotation, in degrees
                     - x (number) horizontal origin point from which to rotate
                     - y (number) vertical origin point from which to rotate
                     \*/
                    matrixproto.rotate = function (a, x, y) {
                        a = Snap.rad(a);
                        x = x || 0;
                        y = y || 0;
                        var cos = +math.cos(a).toFixed(9),
                            sin = +math.sin(a).toFixed(9);
                        this.add(cos, sin, -sin, cos, x, y);
                        return this.add(1, 0, 0, 1, -x, -y);
                    };
                    /*\
                     * Matrix.x
                     [ method ]
                     **
                     * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
                     - x (number)
                     - y (number)
                     = (number) x
                     \*/
                    matrixproto.x = function (x, y) {
                        return x * this.a + y * this.c + this.e;
                    };
                    /*\
                     * Matrix.y
                     [ method ]
                     **
                     * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
                     - x (number)
                     - y (number)
                     = (number) y
                     \*/
                    matrixproto.y = function (x, y) {
                        return x * this.b + y * this.d + this.f;
                    };
                    matrixproto.get = function (i) {
                        return +this[Str.fromCharCode(97 + i)].toFixed(4);
                    };
                    matrixproto.toString = function () {
                        return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
                    };
                    matrixproto.offset = function () {
                        return [this.e.toFixed(4), this.f.toFixed(4)];
                    };
                    function norm(a) {
                        return a[0] * a[0] + a[1] * a[1];
                    }

                    function normalize(a) {
                        var mag = math.sqrt(norm(a));
                        a[0] && (a[0] /= mag);
                        a[1] && (a[1] /= mag);
                    }

                    /*\
                     * Matrix.determinant
                     [ method ]
                     **
                     * Finds determinant of the given matrix.
                     = (number) determinant
                     \*/
                    matrixproto.determinant = function () {
                        return this.a * this.d - this.b * this.c;
                    };
                    /*\
                     * Matrix.split
                     [ method ]
                     **
                     * Splits matrix into primitive transformations
                     = (object) in format:
                     o dx (number) translation by x
                     o dy (number) translation by y
                     o scalex (number) scale by x
                     o scaley (number) scale by y
                     o shear (number) shear
                     o rotate (number) rotation in deg
                     o isSimple (boolean) could it be represented via simple transformations
                     \*/
                    matrixproto.split = function () {
                        var out = {};
                        // translation
                        out.dx = this.e;
                        out.dy = this.f;

                        // scale and shear
                        var row = [[this.a, this.c], [this.b, this.d]];
                        out.scalex = math.sqrt(norm(row[0]));
                        normalize(row[0]);

                        out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
                        row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

                        out.scaley = math.sqrt(norm(row[1]));
                        normalize(row[1]);
                        out.shear /= out.scaley;

                        if (this.determinant() < 0) {
                            out.scalex = -out.scalex;
                        }

                        // rotation
                        var sin = -row[0][1],
                            cos = row[1][1];
                        if (cos < 0) {
                            out.rotate = Snap.deg(math.acos(cos));
                            if (sin < 0) {
                                out.rotate = 360 - out.rotate;
                            }
                        } else {
                            out.rotate = Snap.deg(math.asin(sin));
                        }

                        out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
                        out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
                        out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
                        return out;
                    };
                    /*\
                     * Matrix.toTransformString
                     [ method ]
                     **
                     * Returns transform string that represents given matrix
                     = (string) transform string
                     \*/
                    matrixproto.toTransformString = function (shorter) {
                        var s = shorter || this.split();
                        if (!+s.shear.toFixed(9)) {
                            s.scalex = +s.scalex.toFixed(4);
                            s.scaley = +s.scaley.toFixed(4);
                            s.rotate = +s.rotate.toFixed(4);
                            return (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +
                                (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                                (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E);
                        } else {
                            return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
                        }
                    };
                })(Matrix.prototype);
                /*\
                 * Snap.Matrix
                 [ method ]
                 **
                 * Matrix constructor, extend on your own risk.
                 * To create matrices use @Snap.matrix.
                 \*/
                Snap.Matrix = Matrix;
                /*\
                 * Snap.matrix
                 [ method ]
                 **
                 * Utility method
                 **
                 * Returns a matrix based on the given parameters
                 - a (number)
                 - b (number)
                 - c (number)
                 - d (number)
                 - e (number)
                 - f (number)
                 * or
                 - svgMatrix (SVGMatrix)
                 = (object) @Matrix
                 \*/
                Snap.matrix = function (a, b, c, d, e, f) {
                    return new Matrix(a, b, c, d, e, f);
                };
            });
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
            Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
                var has = "hasOwnProperty",
                    make = Snap._.make,
                    wrap = Snap._.wrap,
                    is = Snap.is,
                    getSomeDefs = Snap._.getSomeDefs,
                    reURLValue = /^url\(#?([^)]+)\)$/,
                    $ = Snap._.$,
                    URL = Snap.url,
                    Str = String,
                    separator = Snap._.separator,
                    E = "";
                // Attributes event handlers
                eve.on("snap.util.attr.mask", function (value) {
                    if (value instanceof Element || value instanceof Fragment) {
                        eve.stop();
                        if (value instanceof Fragment && value.node.childNodes.length == 1) {
                            value = value.node.firstChild;
                            getSomeDefs(this).appendChild(value);
                            value = wrap(value);
                        }
                        if (value.type == "mask") {
                            var mask = value;
                        } else {
                            mask = make("mask", getSomeDefs(this));
                            mask.node.appendChild(value.node);
                        }
                        !mask.node.id && $(mask.node, {
                            id: mask.id
                        });
                        $(this.node, {
                            mask: URL(mask.id)
                        });
                    }
                });
                (function (clipIt) {
                    eve.on("snap.util.attr.clip", clipIt);
                    eve.on("snap.util.attr.clip-path", clipIt);
                    eve.on("snap.util.attr.clipPath", clipIt);
                }(function (value) {
                    if (value instanceof Element || value instanceof Fragment) {
                        eve.stop();
                        if (value.type == "clipPath") {
                            var clip = value;
                        } else {
                            clip = make("clipPath", getSomeDefs(this));
                            clip.node.appendChild(value.node);
                            !clip.node.id && $(clip.node, {
                                id: clip.id
                            });
                        }
                        $(this.node, {
                            "clip-path": URL(clip.node.id || clip.id)
                        });
                    }
                }));
                function fillStroke(name) {
                    return function (value) {
                        eve.stop();
                        if (value instanceof Fragment && value.node.childNodes.length == 1 &&
                            (value.node.firstChild.tagName == "radialGradient" ||
                            value.node.firstChild.tagName == "linearGradient" ||
                            value.node.firstChild.tagName == "pattern")) {
                            value = value.node.firstChild;
                            getSomeDefs(this).appendChild(value);
                            value = wrap(value);
                        }
                        if (value instanceof Element) {
                            if (value.type == "radialGradient" || value.type == "linearGradient"
                                || value.type == "pattern") {
                                if (!value.node.id) {
                                    $(value.node, {
                                        id: value.id
                                    });
                                }
                                var fill = URL(value.node.id);
                            } else {
                                fill = value.attr(name);
                            }
                        } else {
                            fill = Snap.color(value);
                            if (fill.error) {
                                var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
                                if (grad) {
                                    if (!grad.node.id) {
                                        $(grad.node, {
                                            id: grad.id
                                        });
                                    }
                                    fill = URL(grad.node.id);
                                } else {
                                    fill = value;
                                }
                            } else {
                                fill = Str(fill);
                            }
                        }
                        var attrs = {};
                        attrs[name] = fill;
                        $(this.node, attrs);
                        this.node.style[name] = E;
                    };
                }

                eve.on("snap.util.attr.fill", fillStroke("fill"));
                eve.on("snap.util.attr.stroke", fillStroke("stroke"));
                var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
                eve.on("snap.util.grad.parse", function parseGrad(string) {
                    string = Str(string);
                    var tokens = string.match(gradrg);
                    if (!tokens) {
                        return null;
                    }
                    var type = tokens[1],
                        params = tokens[2],
                        stops = tokens[3];
                    params = params.split(/\s*,\s*/).map(function (el) {
                        return +el == el ? +el : el;
                    });
                    if (params.length == 1 && params[0] == 0) {
                        params = [];
                    }
                    stops = stops.split("-");
                    stops = stops.map(function (el) {
                        el = el.split(":");
                        var out = {
                            color: el[0]
                        };
                        if (el[1]) {
                            out.offset = parseFloat(el[1]);
                        }
                        return out;
                    });
                    return {
                        type: type,
                        params: params,
                        stops: stops
                    };
                });

                eve.on("snap.util.attr.d", function (value) {
                    eve.stop();
                    if (is(value, "array") && is(value[0], "array")) {
                        value = Snap.path.toString.call(value);
                    }
                    value = Str(value);
                    if (value.match(/[ruo]/i)) {
                        value = Snap.path.toAbsolute(value);
                    }
                    $(this.node, {d: value});
                })(-1);
                eve.on("snap.util.attr.#text", function (value) {
                    eve.stop();
                    value = Str(value);
                    var txt = glob.doc.createTextNode(value);
                    while (this.node.firstChild) {
                        this.node.removeChild(this.node.firstChild);
                    }
                    this.node.appendChild(txt);
                })(-1);
                eve.on("snap.util.attr.path", function (value) {
                    eve.stop();
                    this.attr({d: value});
                })(-1);
                eve.on("snap.util.attr.class", function (value) {
                    eve.stop();
                    this.node.className.baseVal = value;
                })(-1);
                eve.on("snap.util.attr.viewBox", function (value) {
                    var vb;
                    if (is(value, "object") && "x" in value) {
                        vb = [value.x, value.y, value.width, value.height].join(" ");
                    } else if (is(value, "array")) {
                        vb = value.join(" ");
                    } else {
                        vb = value;
                    }
                    $(this.node, {
                        viewBox: vb
                    });
                    eve.stop();
                })(-1);
                eve.on("snap.util.attr.transform", function (value) {
                    this.transform(value);
                    eve.stop();
                })(-1);
                eve.on("snap.util.attr.r", function (value) {
                    if (this.type == "rect") {
                        eve.stop();
                        $(this.node, {
                            rx: value,
                            ry: value
                        });
                    }
                })(-1);
                eve.on("snap.util.attr.textpath", function (value) {
                    eve.stop();
                    if (this.type == "text") {
                        var id, tp, node;
                        if (!value && this.textPath) {
                            tp = this.textPath;
                            while (tp.node.firstChild) {
                                this.node.appendChild(tp.node.firstChild);
                            }
                            tp.remove();
                            delete this.textPath;
                            return;
                        }
                        if (is(value, "string")) {
                            var defs = getSomeDefs(this),
                                path = wrap(defs.parentNode).path(value);
                            defs.appendChild(path.node);
                            id = path.id;
                            path.attr({id: id});
                        } else {
                            value = wrap(value);
                            if (value instanceof Element) {
                                id = value.attr("id");
                                if (!id) {
                                    id = value.id;
                                    value.attr({id: id});
                                }
                            }
                        }
                        if (id) {
                            tp = this.textPath;
                            node = this.node;
                            if (tp) {
                                tp.attr({"xlink:href": "#" + id});
                            } else {
                                tp = $("textPath", {
                                    "xlink:href": "#" + id
                                });
                                while (node.firstChild) {
                                    tp.appendChild(node.firstChild);
                                }
                                node.appendChild(tp);
                                this.textPath = wrap(tp);
                            }
                        }
                    }
                })(-1);
                eve.on("snap.util.attr.text", function (value) {
                    if (this.type == "text") {
                        var i = 0,
                            node = this.node,
                            tuner = function (chunk) {
                                var out = $("tspan");
                                if (is(chunk, "array")) {
                                    for (var i = 0; i < chunk.length; i++) {
                                        out.appendChild(tuner(chunk[i]));
                                    }
                                } else {
                                    out.appendChild(glob.doc.createTextNode(chunk));
                                }
                                out.normalize && out.normalize();
                                return out;
                            };
                        while (node.firstChild) {
                            node.removeChild(node.firstChild);
                        }
                        var tuned = tuner(value);
                        while (tuned.firstChild) {
                            node.appendChild(tuned.firstChild);
                        }
                    }
                    eve.stop();
                })(-1);
                function setFontSize(value) {
                    eve.stop();
                    if (value == +value) {
                        value += "px";
                    }
                    this.node.style.fontSize = value;
                }

                eve.on("snap.util.attr.fontSize", setFontSize)(-1);
                eve.on("snap.util.attr.font-size", setFontSize)(-1);


                eve.on("snap.util.getattr.transform", function () {
                    eve.stop();
                    return this.transform();
                })(-1);
                eve.on("snap.util.getattr.textpath", function () {
                    eve.stop();
                    return this.textPath;
                })(-1);
                // Markers
                (function () {
                    function getter(end) {
                        return function () {
                            eve.stop();
                            var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
                            if (style == "none") {
                                return style;
                            } else {
                                return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
                            }
                        };
                    }

                    function setter(end) {
                        return function (value) {
                            eve.stop();
                            var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
                            if (value == "" || !value) {
                                this.node.style[name] = "none";
                                return;
                            }
                            if (value.type == "marker") {
                                var id = value.node.id;
                                if (!id) {
                                    $(value.node, {id: value.id});
                                }
                                this.node.style[name] = URL(id);
                                return;
                            }
                        };
                    }

                    eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
                    eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
                    eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
                    eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
                    eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
                    eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
                    eve.on("snap.util.attr.marker-end", setter("end"))(-1);
                    eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
                    eve.on("snap.util.attr.marker-start", setter("start"))(-1);
                    eve.on("snap.util.attr.markerStart", setter("start"))(-1);
                    eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
                    eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
                }());
                eve.on("snap.util.getattr.r", function () {
                    if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
                        eve.stop();
                        return $(this.node, "rx");
                    }
                })(-1);
                function textExtract(node) {
                    var out = [];
                    var children = node.childNodes;
                    for (var i = 0, ii = children.length; i < ii; i++) {
                        var chi = children[i];
                        if (chi.nodeType == 3) {
                            out.push(chi.nodeValue);
                        }
                        if (chi.tagName == "tspan") {
                            if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
                                out.push(chi.firstChild.nodeValue);
                            } else {
                                out.push(textExtract(chi));
                            }
                        }
                    }
                    return out;
                }

                eve.on("snap.util.getattr.text", function () {
                    if (this.type == "text" || this.type == "tspan") {
                        eve.stop();
                        var out = textExtract(this.node);
                        return out.length == 1 ? out[0] : out;
                    }
                })(-1);
                eve.on("snap.util.getattr.#text", function () {
                    return this.node.textContent;
                })(-1);
                eve.on("snap.util.getattr.viewBox", function () {
                    eve.stop();
                    var vb = $(this.node, "viewBox");
                    if (vb) {
                        vb = vb.split(separator);
                        return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
                    } else {
                        return;
                    }
                })(-1);
                eve.on("snap.util.getattr.points", function () {
                    var p = $(this.node, "points");
                    eve.stop();
                    if (p) {
                        return p.split(separator);
                    } else {
                        return;
                    }
                })(-1);
                eve.on("snap.util.getattr.path", function () {
                    var p = $(this.node, "d");
                    eve.stop();
                    return p;
                })(-1);
                eve.on("snap.util.getattr.class", function () {
                    return this.node.className.baseVal;
                })(-1);
                function getFontSize() {
                    eve.stop();
                    return this.node.style.fontSize;
                }

                eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
                eve.on("snap.util.getattr.font-size", getFontSize)(-1);
            });

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
            Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
                var proto = Paper.prototype,
                    is = Snap.is;
                /*\
                 * Paper.rect
                 [ method ]
                 *
                 * Draws a rectangle
                 **
                 - x (number) x coordinate of the top left corner
                 - y (number) y coordinate of the top left corner
                 - width (number) width
                 - height (number) height
                 - rx (number) #optional horizontal radius for rounded corners, default is 0
                 - ry (number) #optional vertical radius for rounded corners, default is rx or 0
                 = (object) the `rect` element
                 **
                 > Usage
                 | // regular rectangle
                 | var c = paper.rect(10, 10, 50, 50);
                 | // rectangle with rounded corners
                 | var c = paper.rect(40, 40, 50, 50, 10);
                 \*/
                proto.rect = function (x, y, w, h, rx, ry) {
                    var attr;
                    if (ry == null) {
                        ry = rx;
                    }
                    if (is(x, "object") && x == "[object Object]") {
                        attr = x;
                    } else if (x != null) {
                        attr = {
                            x: x,
                            y: y,
                            width: w,
                            height: h
                        };
                        if (rx != null) {
                            attr.rx = rx;
                            attr.ry = ry;
                        }
                    }
                    return this.el("rect", attr);
                };
                /*\
                 * Paper.circle
                 [ method ]
                 **
                 * Draws a circle
                 **
                 - x (number) x coordinate of the centre
                 - y (number) y coordinate of the centre
                 - r (number) radius
                 = (object) the `circle` element
                 **
                 > Usage
                 | var c = paper.circle(50, 50, 40);
                 \*/
                proto.circle = function (cx, cy, r) {
                    var attr;
                    if (is(cx, "object") && cx == "[object Object]") {
                        attr = cx;
                    } else if (cx != null) {
                        attr = {
                            cx: cx,
                            cy: cy,
                            r: r
                        };
                    }
                    return this.el("circle", attr);
                };

                var preload = (function () {
                    function onerror() {
                        this.parentNode.removeChild(this);
                    }

                    return function (src, f) {
                        var img = glob.doc.createElement("img"),
                            body = glob.doc.body;
                        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
                        img.onload = function () {
                            f.call(img);
                            img.onload = img.onerror = null;
                            body.removeChild(img);
                        };
                        img.onerror = onerror;
                        body.appendChild(img);
                        img.src = src;
                    };
                }());

                /*\
                 * Paper.image
                 [ method ]
                 **
                 * Places an image on the surface
                 **
                 - src (string) URI of the source image
                 - x (number) x offset position
                 - y (number) y offset position
                 - width (number) width of the image
                 - height (number) height of the image
                 = (object) the `image` element
                 * or
                 = (object) Snap element object with type `image`
                 **
                 > Usage
                 | var c = paper.image("apple.png", 10, 10, 80, 80);
                 \*/
                proto.image = function (src, x, y, width, height) {
                    var el = this.el("image");
                    if (is(src, "object") && "src" in src) {
                        el.attr(src);
                    } else if (src != null) {
                        var set = {
                            "xlink:href": src,
                            preserveAspectRatio: "none"
                        };
                        if (x != null && y != null) {
                            set.x = x;
                            set.y = y;
                        }
                        if (width != null && height != null) {
                            set.width = width;
                            set.height = height;
                        } else {
                            preload(src, function () {
                                Snap._.$(el.node, {
                                    width: this.offsetWidth,
                                    height: this.offsetHeight
                                });
                            });
                        }
                        Snap._.$(el.node, set);
                    }
                    return el;
                };
                /*\
                 * Paper.ellipse
                 [ method ]
                 **
                 * Draws an ellipse
                 **
                 - x (number) x coordinate of the centre
                 - y (number) y coordinate of the centre
                 - rx (number) horizontal radius
                 - ry (number) vertical radius
                 = (object) the `ellipse` element
                 **
                 > Usage
                 | var c = paper.ellipse(50, 50, 40, 20);
                 \*/
                proto.ellipse = function (cx, cy, rx, ry) {
                    var attr;
                    if (is(cx, "object") && cx == "[object Object]") {
                        attr = cx;
                    } else if (cx != null) {
                        attr = {
                            cx: cx,
                            cy: cy,
                            rx: rx,
                            ry: ry
                        };
                    }
                    return this.el("ellipse", attr);
                };
                // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
                /*\
                 * Paper.path
                 [ method ]
                 **
                 * Creates a `<path>` element using the given string as the path's definition
                 - pathString (string) #optional path string in SVG format
                 * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
                 | "M10,20L30,40"
                 * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
                 *
                 # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
                 # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
                 # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
                 # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
                 # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
                 # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
                 # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
                 # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
                 # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
                 # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
                 # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
                 # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
                 # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
                 * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
                 * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.
                 > Usage
                 | var c = paper.path("M10 10L90 90");
                 | // draw a diagonal line:
                 | // move to 10,10, line to 90,90
                 \*/
                proto.path = function (d) {
                    var attr;
                    if (is(d, "object") && !is(d, "array")) {
                        attr = d;
                    } else if (d) {
                        attr = {d: d};
                    }
                    return this.el("path", attr);
                };
                /*\
                 * Paper.g
                 [ method ]
                 **
                 * Creates a group element
                 **
                 - varargs (…) #optional elements to nest within the group
                 = (object) the `g` element
                 **
                 > Usage
                 | var c1 = paper.circle(),
                 |     c2 = paper.rect(),
                 |     g = paper.g(c2, c1); // note that the order of elements is different
                 * or
                 | var c1 = paper.circle(),
                 |     c2 = paper.rect(),
                 |     g = paper.g();
                 | g.add(c2, c1);
                 \*/
                /*\
                 * Paper.group
                 [ method ]
                 **
                 * See @Paper.g
                 \*/
                proto.group = proto.g = function (first) {
                    var attr,
                        el = this.el("g");
                    if (arguments.length == 1 && first && !first.type) {
                        el.attr(first);
                    } else if (arguments.length) {
                        el.add(Array.prototype.slice.call(arguments, 0));
                    }
                    return el;
                };
                /*\
                 * Paper.svg
                 [ method ]
                 **
                 * Creates a nested SVG element.
                 - x (number) @optional X of the element
                 - y (number) @optional Y of the element
                 - width (number) @optional width of the element
                 - height (number) @optional height of the element
                 - vbx (number) @optional viewbox X
                 - vby (number) @optional viewbox Y
                 - vbw (number) @optional viewbox width
                 - vbh (number) @optional viewbox height
                 **
                 = (object) the `svg` element
                 **
                 \*/
                proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
                    var attrs = {};
                    if (is(x, "object") && y == null) {
                        attrs = x;
                    } else {
                        if (x != null) {
                            attrs.x = x;
                        }
                        if (y != null) {
                            attrs.y = y;
                        }
                        if (width != null) {
                            attrs.width = width;
                        }
                        if (height != null) {
                            attrs.height = height;
                        }
                        if (vbx != null && vby != null && vbw != null && vbh != null) {
                            attrs.viewBox = [vbx, vby, vbw, vbh];
                        }
                    }
                    return this.el("svg", attrs);
                };
                /*\
                 * Paper.mask
                 [ method ]
                 **
                 * Equivalent in behaviour to @Paper.g, except it’s a mask.
                 **
                 = (object) the `mask` element
                 **
                 \*/
                proto.mask = function (first) {
                    var attr,
                        el = this.el("mask");
                    if (arguments.length == 1 && first && !first.type) {
                        el.attr(first);
                    } else if (arguments.length) {
                        el.add(Array.prototype.slice.call(arguments, 0));
                    }
                    return el;
                };
                /*\
                 * Paper.ptrn
                 [ method ]
                 **
                 * Equivalent in behaviour to @Paper.g, except it’s a pattern.
                 - x (number) @optional X of the element
                 - y (number) @optional Y of the element
                 - width (number) @optional width of the element
                 - height (number) @optional height of the element
                 - vbx (number) @optional viewbox X
                 - vby (number) @optional viewbox Y
                 - vbw (number) @optional viewbox width
                 - vbh (number) @optional viewbox height
                 **
                 = (object) the `pattern` element
                 **
                 \*/
                proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
                    if (is(x, "object")) {
                        var attr = x;
                    } else {
                        attr = {patternUnits: "userSpaceOnUse"};
                        if (x) {
                            attr.x = x;
                        }
                        if (y) {
                            attr.y = y;
                        }
                        if (width != null) {
                            attr.width = width;
                        }
                        if (height != null) {
                            attr.height = height;
                        }
                        if (vx != null && vy != null && vw != null && vh != null) {
                            attr.viewBox = [vx, vy, vw, vh];
                        }
                    }
                    return this.el("pattern", attr);
                };
                /*\
                 * Paper.use
                 [ method ]
                 **
                 * Creates a <use> element.
                 - id (string) @optional id of element to link
                 * or
                 - id (Element) @optional element to link
                 **
                 = (object) the `use` element
                 **
                 \*/
                proto.use = function (id) {
                    if (id != null) {
                        if (id instanceof Element) {
                            if (!id.attr("id")) {
                                id.attr({id: Snap._.id(id)});
                            }
                            id = id.attr("id");
                        }
                        if (String(id).charAt() == "#") {
                            id = id.substring(1);
                        }
                        return this.el("use", {"xlink:href": "#" + id});
                    } else {
                        return Element.prototype.use.call(this);
                    }
                };
                /*\
                 * Paper.symbol
                 [ method ]
                 **
                 * Creates a <symbol> element.
                 - vbx (number) @optional viewbox X
                 - vby (number) @optional viewbox Y
                 - vbw (number) @optional viewbox width
                 - vbh (number) @optional viewbox height
                 = (object) the `symbol` element
                 **
                 \*/
                proto.symbol = function (vx, vy, vw, vh) {
                    var attr = {};
                    if (vx != null && vy != null && vw != null && vh != null) {
                        attr.viewBox = [vx, vy, vw, vh];
                    }

                    return this.el("symbol", attr);
                };
                /*\
                 * Paper.text
                 [ method ]
                 **
                 * Draws a text string
                 **
                 - x (number) x coordinate position
                 - y (number) y coordinate position
                 - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
                 = (object) the `text` element
                 **
                 > Usage
                 | var t1 = paper.text(50, 50, "Snap");
                 | var t2 = paper.text(50, 50, ["S","n","a","p"]);
                 | // Text path usage
                 | t1.attr({textpath: "M10,10L100,100"});
                 | // or
                 | var pth = paper.path("M10,10L100,100");
                 | t1.attr({textpath: pth});
                 \*/
                proto.text = function (x, y, text) {
                    var attr = {};
                    if (is(x, "object")) {
                        attr = x;
                    } else if (x != null) {
                        attr = {
                            x: x,
                            y: y,
                            text: text || ""
                        };
                    }
                    return this.el("text", attr);
                };
                /*\
                 * Paper.line
                 [ method ]
                 **
                 * Draws a line
                 **
                 - x1 (number) x coordinate position of the start
                 - y1 (number) y coordinate position of the start
                 - x2 (number) x coordinate position of the end
                 - y2 (number) y coordinate position of the end
                 = (object) the `line` element
                 **
                 > Usage
                 | var t1 = paper.line(50, 50, 100, 100);
                 \*/
                proto.line = function (x1, y1, x2, y2) {
                    var attr = {};
                    if (is(x1, "object")) {
                        attr = x1;
                    } else if (x1 != null) {
                        attr = {
                            x1: x1,
                            x2: x2,
                            y1: y1,
                            y2: y2
                        };
                    }
                    return this.el("line", attr);
                };
                /*\
                 * Paper.polyline
                 [ method ]
                 **
                 * Draws a polyline
                 **
                 - points (array) array of points
                 * or
                 - varargs (…) points
                 = (object) the `polyline` element
                 **
                 > Usage
                 | var p1 = paper.polyline([10, 10, 100, 100]);
                 | var p2 = paper.polyline(10, 10, 100, 100);
                 \*/
                proto.polyline = function (points) {
                    if (arguments.length > 1) {
                        points = Array.prototype.slice.call(arguments, 0);
                    }
                    var attr = {};
                    if (is(points, "object") && !is(points, "array")) {
                        attr = points;
                    } else if (points != null) {
                        attr = {points: points};
                    }
                    return this.el("polyline", attr);
                };
                /*\
                 * Paper.polygon
                 [ method ]
                 **
                 * Draws a polygon. See @Paper.polyline
                 \*/
                proto.polygon = function (points) {
                    if (arguments.length > 1) {
                        points = Array.prototype.slice.call(arguments, 0);
                    }
                    var attr = {};
                    if (is(points, "object") && !is(points, "array")) {
                        attr = points;
                    } else if (points != null) {
                        attr = {points: points};
                    }
                    return this.el("polygon", attr);
                };
                // gradients
                (function () {
                    var $ = Snap._.$;
                    // gradients' helpers
                    function Gstops() {
                        return this.selectAll("stop");
                    }

                    function GaddStop(color, offset) {
                        var stop = $("stop"),
                            attr = {
                                offset: +offset + "%"
                            };
                        color = Snap.color(color);
                        attr["stop-color"] = color.hex;
                        if (color.opacity < 1) {
                            attr["stop-opacity"] = color.opacity;
                        }
                        $(stop, attr);
                        this.node.appendChild(stop);
                        return this;
                    }

                    function GgetBBox() {
                        if (this.type == "linearGradient") {
                            var x1 = $(this.node, "x1") || 0,
                                x2 = $(this.node, "x2") || 1,
                                y1 = $(this.node, "y1") || 0,
                                y2 = $(this.node, "y2") || 0;
                            return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
                        } else {
                            var cx = this.node.cx || .5,
                                cy = this.node.cy || .5,
                                r = this.node.r || 0;
                            return Snap._.box(cx - r, cy - r, r * 2, r * 2);
                        }
                    }

                    function gradient(defs, str) {
                        var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
                            el;
                        if (!grad) {
                            return null;
                        }
                        grad.params.unshift(defs);
                        if (grad.type.toLowerCase() == "l") {
                            el = gradientLinear.apply(0, grad.params);
                        } else {
                            el = gradientRadial.apply(0, grad.params);
                        }
                        if (grad.type != grad.type.toLowerCase()) {
                            $(el.node, {
                                gradientUnits: "userSpaceOnUse"
                            });
                        }
                        var stops = grad.stops,
                            len = stops.length,
                            start = 0,
                            j = 0;

                        function seed(i, end) {
                            var step = (end - start) / (i - j);
                            for (var k = j; k < i; k++) {
                                stops[k].offset = +(+start + step * (k - j)).toFixed(2);
                            }
                            j = i;
                            start = end;
                        }

                        len--;
                        for (var i = 0; i < len; i++) if ("offset" in stops[i]) {
                            seed(i, stops[i].offset);
                        }
                        stops[len].offset = stops[len].offset || 100;
                        seed(len, stops[len].offset);
                        for (i = 0; i <= len; i++) {
                            var stop = stops[i];
                            el.addStop(stop.color, stop.offset);
                        }
                        return el;
                    }

                    function gradientLinear(defs, x1, y1, x2, y2) {
                        var el = Snap._.make("linearGradient", defs);
                        el.stops = Gstops;
                        el.addStop = GaddStop;
                        el.getBBox = GgetBBox;
                        if (x1 != null) {
                            $(el.node, {
                                x1: x1,
                                y1: y1,
                                x2: x2,
                                y2: y2
                            });
                        }
                        return el;
                    }

                    function gradientRadial(defs, cx, cy, r, fx, fy) {
                        var el = Snap._.make("radialGradient", defs);
                        el.stops = Gstops;
                        el.addStop = GaddStop;
                        el.getBBox = GgetBBox;
                        if (cx != null) {
                            $(el.node, {
                                cx: cx,
                                cy: cy,
                                r: r
                            });
                        }
                        if (fx != null && fy != null) {
                            $(el.node, {
                                fx: fx,
                                fy: fy
                            });
                        }
                        return el;
                    }

                    /*\
                     * Paper.gradient
                     [ method ]
                     **
                     * Creates a gradient element
                     **
                     - gradient (string) gradient descriptor
                     > Gradient Descriptor
                     * The gradient descriptor is an expression formatted as
                     * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
                     * either linear or radial.  The uppercase `L` or `R` letters
                     * indicate absolute coordinates offset from the SVG surface.
                     * Lowercase `l` or `r` letters indicate coordinates
                     * calculated relative to the element to which the gradient is
                     * applied.  Coordinates specify a linear gradient vector as
                     * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
                     * `r` and optional `fx`, `fy` specifying a focal point away
                     * from the center of the circle. Specify `<colors>` as a list
                     * of dash-separated CSS color values.  Each color may be
                     * followed by a custom offset value, separated with a colon
                     * character.
                     > Examples
                     * Linear gradient, relative from top-left corner to bottom-right
                     * corner, from black through red to white:
                     | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
                     * Linear gradient, absolute from (0, 0) to (100, 100), from black
                     * through red at 25% to white:
                     | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
                     * Radial gradient, relative from the center of the element with radius
                     * half the width, from black to white:
                     | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
                     * To apply the gradient:
                     | paper.circle(50, 50, 40).attr({
                     |     fill: g
                     | });
                     = (object) the `gradient` element
                     \*/
                    proto.gradient = function (str) {
                        return gradient(this.defs, str);
                    };
                    proto.gradientLinear = function (x1, y1, x2, y2) {
                        return gradientLinear(this.defs, x1, y1, x2, y2);
                    };
                    proto.gradientRadial = function (cx, cy, r, fx, fy) {
                        return gradientRadial(this.defs, cx, cy, r, fx, fy);
                    };
                    /*\
                     * Paper.toString
                     [ method ]
                     **
                     * Returns SVG code for the @Paper
                     = (string) SVG code for the @Paper
                     \*/
                    proto.toString = function () {
                        var doc = this.node.ownerDocument,
                            f = doc.createDocumentFragment(),
                            d = doc.createElement("div"),
                            svg = this.node.cloneNode(true),
                            res;
                        f.appendChild(d);
                        d.appendChild(svg);
                        Snap._.$(svg, {xmlns: "http://www.w3.org/2000/svg"});
                        res = d.innerHTML;
                        f.removeChild(f.firstChild);
                        return res;
                    };
                    /*\
                     * Paper.toDataURL
                     [ method ]
                     **
                     * Returns SVG code for the @Paper as Data URI string.
                     = (string) Data URI string
                     \*/
                    proto.toDataURL = function () {
                        if (window && window.btoa) {
                            return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
                        }
                    };
                    /*\
                     * Paper.clear
                     [ method ]
                     **
                     * Removes all child nodes of the paper, except <defs>.
                     \*/
                    proto.clear = function () {
                        var node = this.node.firstChild,
                            next;
                        while (node) {
                            next = node.nextSibling;
                            if (node.tagName != "defs") {
                                node.parentNode.removeChild(node);
                            } else {
                                proto.clear.call({node: node});
                            }
                            node = next;
                        }
                    };
                }());
            });

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
            Snap.plugin(function (Snap, Element, Paper, glob) {
                var elproto = Element.prototype,
                    is = Snap.is,
                    clone = Snap._.clone,
                    has = "hasOwnProperty",
                    p2s = /,?([a-z]),?/gi,
                    toFloat = parseFloat,
                    math = Math,
                    PI = math.PI,
                    mmin = math.min,
                    mmax = math.max,
                    pow = math.pow,
                    abs = math.abs;

                function paths(ps) {
                    var p = paths.ps = paths.ps || {};
                    if (p[ps]) {
                        p[ps].sleep = 100;
                    } else {
                        p[ps] = {
                            sleep: 100
                        };
                    }
                    setTimeout(function () {
                        for (var key in p) if (p[has](key) && key != ps) {
                            p[key].sleep--;
                            !p[key].sleep && delete p[key];
                        }
                    });
                    return p[ps];
                }

                function box(x, y, width, height) {
                    if (x == null) {
                        x = y = width = height = 0;
                    }
                    if (y == null) {
                        y = x.y;
                        width = x.width;
                        height = x.height;
                        x = x.x;
                    }
                    return {
                        x: x,
                        y: y,
                        width: width,
                        w: width,
                        height: height,
                        h: height,
                        x2: x + width,
                        y2: y + height,
                        cx: x + width / 2,
                        cy: y + height / 2,
                        r1: math.min(width, height) / 2,
                        r2: math.max(width, height) / 2,
                        r0: math.sqrt(width * width + height * height) / 2,
                        path: rectPath(x, y, width, height),
                        vb: [x, y, width, height].join(" ")
                    };
                }

                function toString() {
                    return this.join(",").replace(p2s, "$1");
                }

                function pathClone(pathArray) {
                    var res = clone(pathArray);
                    res.toString = toString;
                    return res;
                }

                function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
                    if (length == null) {
                        return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
                    } else {
                        return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
                            getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
                    }
                }

                function getLengthFactory(istotal, subpath) {
                    function O(val) {
                        return +(+val).toFixed(3);
                    }

                    return Snap._.cacher(function (path, length, onlystart) {
                        if (path instanceof Element) {
                            path = path.attr("d");
                        }
                        path = path2curve(path);
                        var x, y, p, l, sp = "", subpaths = {}, point,
                            len = 0;
                        for (var i = 0, ii = path.length; i < ii; i++) {
                            p = path[i];
                            if (p[0] == "M") {
                                x = +p[1];
                                y = +p[2];
                            } else {
                                l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                                if (len + l > length) {
                                    if (subpath && !subpaths.start) {
                                        point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                        sp += [
                                            "C" + O(point.start.x),
                                            O(point.start.y),
                                            O(point.m.x),
                                            O(point.m.y),
                                            O(point.x),
                                            O(point.y)
                                        ];
                                        if (onlystart) {
                                            return sp;
                                        }
                                        subpaths.start = sp;
                                        sp = [
                                            "M" + O(point.x),
                                            O(point.y) + "C" + O(point.n.x),
                                            O(point.n.y),
                                            O(point.end.x),
                                            O(point.end.y),
                                            O(p[5]),
                                            O(p[6])
                                        ].join();
                                        len += l;
                                        x = +p[5];
                                        y = +p[6];
                                        continue;
                                    }
                                    if (!istotal && !subpath) {
                                        point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                        return point;
                                    }
                                }
                                len += l;
                                x = +p[5];
                                y = +p[6];
                            }
                            sp += p.shift() + p;
                        }
                        subpaths.end = sp;
                        point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                        return point;
                    }, null, Snap._.clone);
                }

                var getTotalLength = getLengthFactory(1),
                    getPointAtLength = getLengthFactory(),
                    getSubpathsAtLength = getLengthFactory(0, 1);

                function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
                    var t1 = 1 - t,
                        t13 = pow(t1, 3),
                        t12 = pow(t1, 2),
                        t2 = t * t,
                        t3 = t2 * t,
                        x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
                        y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
                        mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
                        my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
                        nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
                        ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
                        ax = t1 * p1x + t * c1x,
                        ay = t1 * p1y + t * c1y,
                        cx = t1 * c2x + t * p2x,
                        cy = t1 * c2y + t * p2y,
                        alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
                    // (mx > nx || my < ny) && (alpha += 180);
                    return {
                        x: x,
                        y: y,
                        m: {x: mx, y: my},
                        n: {x: nx, y: ny},
                        start: {x: ax, y: ay},
                        end: {x: cx, y: cy},
                        alpha: alpha
                    };
                }

                function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
                    if (!Snap.is(p1x, "array")) {
                        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
                    }
                    var bbox = curveDim.apply(null, p1x);
                    return box(
                        bbox.min.x,
                        bbox.min.y,
                        bbox.max.x - bbox.min.x,
                        bbox.max.y - bbox.min.y
                    );
                }

                function isPointInsideBBox(bbox, x, y) {
                    return x >= bbox.x &&
                        x <= bbox.x + bbox.width &&
                        y >= bbox.y &&
                        y <= bbox.y + bbox.height;
                }

                function isBBoxIntersect(bbox1, bbox2) {
                    bbox1 = box(bbox1);
                    bbox2 = box(bbox2);
                    return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
                        || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
                        || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
                        || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
                        || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
                        || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
                        || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
                        || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
                        || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
                        || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
                        && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
                        || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
                }

                function base3(t, p1, p2, p3, p4) {
                    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
                        t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
                    return t * t2 - 3 * p1 + 3 * p2;
                }

                function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
                    if (z == null) {
                        z = 1;
                    }
                    z = z > 1 ? 1 : z < 0 ? 0 : z;
                    var z2 = z / 2,
                        n = 12,
                        Tvalues = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816],
                        Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
                        sum = 0;
                    for (var i = 0; i < n; i++) {
                        var ct = z2 * Tvalues[i] + z2,
                            xbase = base3(ct, x1, x2, x3, x4),
                            ybase = base3(ct, y1, y2, y3, y4),
                            comb = xbase * xbase + ybase * ybase;
                        sum += Cvalues[i] * math.sqrt(comb);
                    }
                    return z2 * sum;
                }

                function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
                    if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
                        return;
                    }
                    var t = 1,
                        step = t / 2,
                        t2 = t - step,
                        l,
                        e = .01;
                    l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                    while (abs(l - ll) > e) {
                        step /= 2;
                        t2 += (l < ll ? 1 : -1) * step;
                        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                    }
                    return t2;
                }

                function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
                    if (
                        mmax(x1, x2) < mmin(x3, x4) ||
                        mmin(x1, x2) > mmax(x3, x4) ||
                        mmax(y1, y2) < mmin(y3, y4) ||
                        mmin(y1, y2) > mmax(y3, y4)
                    ) {
                        return;
                    }
                    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
                        ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
                        denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

                    if (!denominator) {
                        return;
                    }
                    var px = nx / denominator,
                        py = ny / denominator,
                        px2 = +px.toFixed(2),
                        py2 = +py.toFixed(2);
                    if (
                        px2 < +mmin(x1, x2).toFixed(2) ||
                        px2 > +mmax(x1, x2).toFixed(2) ||
                        px2 < +mmin(x3, x4).toFixed(2) ||
                        px2 > +mmax(x3, x4).toFixed(2) ||
                        py2 < +mmin(y1, y2).toFixed(2) ||
                        py2 > +mmax(y1, y2).toFixed(2) ||
                        py2 < +mmin(y3, y4).toFixed(2) ||
                        py2 > +mmax(y3, y4).toFixed(2)
                    ) {
                        return;
                    }
                    return {x: px, y: py};
                }

                function inter(bez1, bez2) {
                    return interHelper(bez1, bez2);
                }

                function interCount(bez1, bez2) {
                    return interHelper(bez1, bez2, 1);
                }

                function interHelper(bez1, bez2, justCount) {
                    var bbox1 = bezierBBox(bez1),
                        bbox2 = bezierBBox(bez2);
                    if (!isBBoxIntersect(bbox1, bbox2)) {
                        return justCount ? 0 : [];
                    }
                    var l1 = bezlen.apply(0, bez1),
                        l2 = bezlen.apply(0, bez2),
                        n1 = ~~(l1 / 8),
                        n2 = ~~(l2 / 8),
                        dots1 = [],
                        dots2 = [],
                        xy = {},
                        res = justCount ? 0 : [];
                    for (var i = 0; i < n1 + 1; i++) {
                        var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
                        dots1.push({x: p.x, y: p.y, t: i / n1});
                    }
                    for (i = 0; i < n2 + 1; i++) {
                        p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
                        dots2.push({x: p.x, y: p.y, t: i / n2});
                    }
                    for (i = 0; i < n1; i++) {
                        for (var j = 0; j < n2; j++) {
                            var di = dots1[i],
                                di1 = dots1[i + 1],
                                dj = dots2[j],
                                dj1 = dots2[j + 1],
                                ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                                cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                                is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                            if (is) {
                                if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                                    continue;
                                }
                                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                                var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                                    t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                                if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                                    if (justCount) {
                                        res++;
                                    } else {
                                        res.push({
                                            x: is.x,
                                            y: is.y,
                                            t1: t1,
                                            t2: t2
                                        });
                                    }
                                }
                            }
                        }
                    }
                    return res;
                }

                function pathIntersection(path1, path2) {
                    return interPathHelper(path1, path2);
                }

                function pathIntersectionNumber(path1, path2) {
                    return interPathHelper(path1, path2, 1);
                }

                function interPathHelper(path1, path2, justCount) {
                    path1 = path2curve(path1);
                    path2 = path2curve(path2);
                    var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
                        res = justCount ? 0 : [];
                    for (var i = 0, ii = path1.length; i < ii; i++) {
                        var pi = path1[i];
                        if (pi[0] == "M") {
                            x1 = x1m = pi[1];
                            y1 = y1m = pi[2];
                        } else {
                            if (pi[0] == "C") {
                                bez1 = [x1, y1].concat(pi.slice(1));
                                x1 = bez1[6];
                                y1 = bez1[7];
                            } else {
                                bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                                x1 = x1m;
                                y1 = y1m;
                            }
                            for (var j = 0, jj = path2.length; j < jj; j++) {
                                var pj = path2[j];
                                if (pj[0] == "M") {
                                    x2 = x2m = pj[1];
                                    y2 = y2m = pj[2];
                                } else {
                                    if (pj[0] == "C") {
                                        bez2 = [x2, y2].concat(pj.slice(1));
                                        x2 = bez2[6];
                                        y2 = bez2[7];
                                    } else {
                                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                                        x2 = x2m;
                                        y2 = y2m;
                                    }
                                    var intr = interHelper(bez1, bez2, justCount);
                                    if (justCount) {
                                        res += intr;
                                    } else {
                                        for (var k = 0, kk = intr.length; k < kk; k++) {
                                            intr[k].segment1 = i;
                                            intr[k].segment2 = j;
                                            intr[k].bez1 = bez1;
                                            intr[k].bez2 = bez2;
                                        }
                                        res = res.concat(intr);
                                    }
                                }
                            }
                        }
                    }
                    return res;
                }

                function isPointInsidePath(path, x, y) {
                    var bbox = pathBBox(path);
                    return isPointInsideBBox(bbox, x, y) &&
                        interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
                }

                function pathBBox(path) {
                    var pth = paths(path);
                    if (pth.bbox) {
                        return clone(pth.bbox);
                    }
                    if (!path) {
                        return box();
                    }
                    path = path2curve(path);
                    var x = 0,
                        y = 0,
                        X = [],
                        Y = [],
                        p;
                    for (var i = 0, ii = path.length; i < ii; i++) {
                        p = path[i];
                        if (p[0] == "M") {
                            x = p[1];
                            y = p[2];
                            X.push(x);
                            Y.push(y);
                        } else {
                            var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                            X = X.concat(dim.min.x, dim.max.x);
                            Y = Y.concat(dim.min.y, dim.max.y);
                            x = p[5];
                            y = p[6];
                        }
                    }
                    var xmin = mmin.apply(0, X),
                        ymin = mmin.apply(0, Y),
                        xmax = mmax.apply(0, X),
                        ymax = mmax.apply(0, Y),
                        bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
                    pth.bbox = clone(bb);
                    return bb;
                }

                function rectPath(x, y, w, h, r) {
                    if (r) {
                        return [
                            ["M", +x + (+r), y],
                            ["l", w - r * 2, 0],
                            ["a", r, r, 0, 0, 1, r, r],
                            ["l", 0, h - r * 2],
                            ["a", r, r, 0, 0, 1, -r, r],
                            ["l", r * 2 - w, 0],
                            ["a", r, r, 0, 0, 1, -r, -r],
                            ["l", 0, r * 2 - h],
                            ["a", r, r, 0, 0, 1, r, -r],
                            ["z"]
                        ];
                    }
                    var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
                    res.toString = toString;
                    return res;
                }

                function ellipsePath(x, y, rx, ry, a) {
                    if (a == null && ry == null) {
                        ry = rx;
                    }
                    x = +x;
                    y = +y;
                    rx = +rx;
                    ry = +ry;
                    if (a != null) {
                        var rad = Math.PI / 180,
                            x1 = x + rx * Math.cos(-ry * rad),
                            x2 = x + rx * Math.cos(-a * rad),
                            y1 = y + rx * Math.sin(-ry * rad),
                            y2 = y + rx * Math.sin(-a * rad),
                            res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
                    } else {
                        res = [
                            ["M", x, y],
                            ["m", 0, -ry],
                            ["a", rx, ry, 0, 1, 1, 0, 2 * ry],
                            ["a", rx, ry, 0, 1, 1, 0, -2 * ry],
                            ["z"]
                        ];
                    }
                    res.toString = toString;
                    return res;
                }

                var unit2px = Snap._unit2px,
                    getPath = {
                        path: function (el) {
                            return el.attr("path");
                        },
                        circle: function (el) {
                            var attr = unit2px(el);
                            return ellipsePath(attr.cx, attr.cy, attr.r);
                        },
                        ellipse: function (el) {
                            var attr = unit2px(el);
                            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
                        },
                        rect: function (el) {
                            var attr = unit2px(el);
                            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
                        },
                        image: function (el) {
                            var attr = unit2px(el);
                            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
                        },
                        line: function (el) {
                            return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
                        },
                        polyline: function (el) {
                            return "M" + el.attr("points");
                        },
                        polygon: function (el) {
                            return "M" + el.attr("points") + "z";
                        },
                        deflt: function (el) {
                            var bbox = el.node.getBBox();
                            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
                        }
                    };

                function pathToRelative(pathArray) {
                    var pth = paths(pathArray),
                        lowerCase = String.prototype.toLowerCase;
                    if (pth.rel) {
                        return pathClone(pth.rel);
                    }
                    if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
                        pathArray = Snap.parsePathString(pathArray);
                    }
                    var res = [],
                        x = 0,
                        y = 0,
                        mx = 0,
                        my = 0,
                        start = 0;
                    if (pathArray[0][0] == "M") {
                        x = pathArray[0][1];
                        y = pathArray[0][2];
                        mx = x;
                        my = y;
                        start++;
                        res.push(["M", x, y]);
                    }
                    for (var i = start, ii = pathArray.length; i < ii; i++) {
                        var r = res[i] = [],
                            pa = pathArray[i];
                        if (pa[0] != lowerCase.call(pa[0])) {
                            r[0] = lowerCase.call(pa[0]);
                            switch (r[0]) {
                                case "a":
                                    r[1] = pa[1];
                                    r[2] = pa[2];
                                    r[3] = pa[3];
                                    r[4] = pa[4];
                                    r[5] = pa[5];
                                    r[6] = +(pa[6] - x).toFixed(3);
                                    r[7] = +(pa[7] - y).toFixed(3);
                                    break;
                                case "v":
                                    r[1] = +(pa[1] - y).toFixed(3);
                                    break;
                                case "m":
                                    mx = pa[1];
                                    my = pa[2];
                                default:
                                    for (var j = 1, jj = pa.length; j < jj; j++) {
                                        r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                                    }
                            }
                        } else {
                            r = res[i] = [];
                            if (pa[0] == "m") {
                                mx = pa[1] + x;
                                my = pa[2] + y;
                            }
                            for (var k = 0, kk = pa.length; k < kk; k++) {
                                res[i][k] = pa[k];
                            }
                        }
                        var len = res[i].length;
                        switch (res[i][0]) {
                            case "z":
                                x = mx;
                                y = my;
                                break;
                            case "h":
                                x += +res[i][len - 1];
                                break;
                            case "v":
                                y += +res[i][len - 1];
                                break;
                            default:
                                x += +res[i][len - 2];
                                y += +res[i][len - 1];
                        }
                    }
                    res.toString = toString;
                    pth.rel = pathClone(res);
                    return res;
                }

                function pathToAbsolute(pathArray) {
                    var pth = paths(pathArray);
                    if (pth.abs) {
                        return pathClone(pth.abs);
                    }
                    if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) { // rough assumption
                        pathArray = Snap.parsePathString(pathArray);
                    }
                    if (!pathArray || !pathArray.length) {
                        return [["M", 0, 0]];
                    }
                    var res = [],
                        x = 0,
                        y = 0,
                        mx = 0,
                        my = 0,
                        start = 0,
                        pa0;
                    if (pathArray[0][0] == "M") {
                        x = +pathArray[0][1];
                        y = +pathArray[0][2];
                        mx = x;
                        my = y;
                        start++;
                        res[0] = ["M", x, y];
                    }
                    var crz = pathArray.length == 3 &&
                        pathArray[0][0] == "M" &&
                        pathArray[1][0].toUpperCase() == "R" &&
                        pathArray[2][0].toUpperCase() == "Z";
                    for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                        res.push(r = []);
                        pa = pathArray[i];
                        pa0 = pa[0];
                        if (pa0 != pa0.toUpperCase()) {
                            r[0] = pa0.toUpperCase();
                            switch (r[0]) {
                                case "A":
                                    r[1] = pa[1];
                                    r[2] = pa[2];
                                    r[3] = pa[3];
                                    r[4] = pa[4];
                                    r[5] = pa[5];
                                    r[6] = +pa[6] + x;
                                    r[7] = +pa[7] + y;
                                    break;
                                case "V":
                                    r[1] = +pa[1] + y;
                                    break;
                                case "H":
                                    r[1] = +pa[1] + x;
                                    break;
                                case "R":
                                    var dots = [x, y].concat(pa.slice(1));
                                    for (var j = 2, jj = dots.length; j < jj; j++) {
                                        dots[j] = +dots[j] + x;
                                        dots[++j] = +dots[j] + y;
                                    }
                                    res.pop();
                                    res = res.concat(catmullRom2bezier(dots, crz));
                                    break;
                                case "O":
                                    res.pop();
                                    dots = ellipsePath(x, y, pa[1], pa[2]);
                                    dots.push(dots[0]);
                                    res = res.concat(dots);
                                    break;
                                case "U":
                                    res.pop();
                                    res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                                    r = ["U"].concat(res[res.length - 1].slice(-2));
                                    break;
                                case "M":
                                    mx = +pa[1] + x;
                                    my = +pa[2] + y;
                                default:
                                    for (j = 1, jj = pa.length; j < jj; j++) {
                                        r[j] = +pa[j] + ((j % 2) ? x : y);
                                    }
                            }
                        } else if (pa0 == "R") {
                            dots = [x, y].concat(pa.slice(1));
                            res.pop();
                            res = res.concat(catmullRom2bezier(dots, crz));
                            r = ["R"].concat(pa.slice(-2));
                        } else if (pa0 == "O") {
                            res.pop();
                            dots = ellipsePath(x, y, pa[1], pa[2]);
                            dots.push(dots[0]);
                            res = res.concat(dots);
                        } else if (pa0 == "U") {
                            res.pop();
                            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                            r = ["U"].concat(res[res.length - 1].slice(-2));
                        } else {
                            for (var k = 0, kk = pa.length; k < kk; k++) {
                                r[k] = pa[k];
                            }
                        }
                        pa0 = pa0.toUpperCase();
                        if (pa0 != "O") {
                            switch (r[0]) {
                                case "Z":
                                    x = +mx;
                                    y = +my;
                                    break;
                                case "H":
                                    x = r[1];
                                    break;
                                case "V":
                                    y = r[1];
                                    break;
                                case "M":
                                    mx = r[r.length - 2];
                                    my = r[r.length - 1];
                                default:
                                    x = r[r.length - 2];
                                    y = r[r.length - 1];
                            }
                        }
                    }
                    res.toString = toString;
                    pth.abs = pathClone(res);
                    return res;
                }

                function l2c(x1, y1, x2, y2) {
                    return [x1, y1, x2, y2, x2, y2];
                }

                function q2c(x1, y1, ax, ay, x2, y2) {
                    var _13 = 1 / 3,
                        _23 = 2 / 3;
                    return [
                        _13 * x1 + _23 * ax,
                        _13 * y1 + _23 * ay,
                        _13 * x2 + _23 * ax,
                        _13 * y2 + _23 * ay,
                        x2,
                        y2
                    ];
                }

                function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
                    // for more information of where this math came from visit:
                    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                    var _120 = PI * 120 / 180,
                        rad = PI / 180 * (+angle || 0),
                        res = [],
                        xy,
                        rotate = Snap._.cacher(function (x, y, rad) {
                            var X = x * math.cos(rad) - y * math.sin(rad),
                                Y = x * math.sin(rad) + y * math.cos(rad);
                            return {x: X, y: Y};
                        });
                    if (!recursive) {
                        xy = rotate(x1, y1, -rad);
                        x1 = xy.x;
                        y1 = xy.y;
                        xy = rotate(x2, y2, -rad);
                        x2 = xy.x;
                        y2 = xy.y;
                        var cos = math.cos(PI / 180 * angle),
                            sin = math.sin(PI / 180 * angle),
                            x = (x1 - x2) / 2,
                            y = (y1 - y2) / 2;
                        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                        if (h > 1) {
                            h = math.sqrt(h);
                            rx = h * rx;
                            ry = h * ry;
                        }
                        var rx2 = rx * rx,
                            ry2 = ry * ry,
                            k = (large_arc_flag == sweep_flag ? -1 : 1) *
                                math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                            cx = k * rx * y / ry + (x1 + x2) / 2,
                            cy = k * -ry * x / rx + (y1 + y2) / 2,
                            f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                            f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                        f1 = x1 < cx ? PI - f1 : f1;
                        f2 = x2 < cx ? PI - f2 : f2;
                        f1 < 0 && (f1 = PI * 2 + f1);
                        f2 < 0 && (f2 = PI * 2 + f2);
                        if (sweep_flag && f1 > f2) {
                            f1 = f1 - PI * 2;
                        }
                        if (!sweep_flag && f2 > f1) {
                            f2 = f2 - PI * 2;
                        }
                    } else {
                        f1 = recursive[0];
                        f2 = recursive[1];
                        cx = recursive[2];
                        cy = recursive[3];
                    }
                    var df = f2 - f1;
                    if (abs(df) > _120) {
                        var f2old = f2,
                            x2old = x2,
                            y2old = y2;
                        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                        x2 = cx + rx * math.cos(f2);
                        y2 = cy + ry * math.sin(f2);
                        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
                    }
                    df = f2 - f1;
                    var c1 = math.cos(f1),
                        s1 = math.sin(f1),
                        c2 = math.cos(f2),
                        s2 = math.sin(f2),
                        t = math.tan(df / 4),
                        hx = 4 / 3 * rx * t,
                        hy = 4 / 3 * ry * t,
                        m1 = [x1, y1],
                        m2 = [x1 + hx * s1, y1 - hy * c1],
                        m3 = [x2 + hx * s2, y2 - hy * c2],
                        m4 = [x2, y2];
                    m2[0] = 2 * m1[0] - m2[0];
                    m2[1] = 2 * m1[1] - m2[1];
                    if (recursive) {
                        return [m2, m3, m4].concat(res);
                    } else {
                        res = [m2, m3, m4].concat(res).join().split(",");
                        var newres = [];
                        for (var i = 0, ii = res.length; i < ii; i++) {
                            newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                        }
                        return newres;
                    }
                }

                function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
                    var t1 = 1 - t;
                    return {
                        x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                        y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
                    };
                }

                // Returns bounding box of cubic bezier curve.
                // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
                // Original version: NISHIO Hirokazu
                // Modifications: https://github.com/timo22345
                function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
                    var tvalues = [],
                        bounds = [[], []],
                        a, b, c, t, t1, t2, b2ac, sqrtb2ac;
                    for (var i = 0; i < 2; ++i) {
                        if (i == 0) {
                            b = 6 * x0 - 12 * x1 + 6 * x2;
                            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                            c = 3 * x1 - 3 * x0;
                        } else {
                            b = 6 * y0 - 12 * y1 + 6 * y2;
                            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                            c = 3 * y1 - 3 * y0;
                        }
                        if (abs(a) < 1e-12) {
                            if (abs(b) < 1e-12) {
                                continue;
                            }
                            t = -c / b;
                            if (0 < t && t < 1) {
                                tvalues.push(t);
                            }
                            continue;
                        }
                        b2ac = b * b - 4 * c * a;
                        sqrtb2ac = math.sqrt(b2ac);
                        if (b2ac < 0) {
                            continue;
                        }
                        t1 = (-b + sqrtb2ac) / (2 * a);
                        if (0 < t1 && t1 < 1) {
                            tvalues.push(t1);
                        }
                        t2 = (-b - sqrtb2ac) / (2 * a);
                        if (0 < t2 && t2 < 1) {
                            tvalues.push(t2);
                        }
                    }

                    var x, y, j = tvalues.length,
                        jlen = j,
                        mt;
                    while (j--) {
                        t = tvalues[j];
                        mt = 1 - t;
                        bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
                        bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
                    }

                    bounds[0][jlen] = x0;
                    bounds[1][jlen] = y0;
                    bounds[0][jlen + 1] = x3;
                    bounds[1][jlen + 1] = y3;
                    bounds[0].length = bounds[1].length = jlen + 2;


                    return {
                        min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},
                        max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}
                    };
                }

                function path2curve(path, path2) {
                    var pth = !path2 && paths(path);
                    if (!path2 && pth.curve) {
                        return pathClone(pth.curve);
                    }
                    var p = pathToAbsolute(path),
                        p2 = path2 && pathToAbsolute(path2),
                        attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                        attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                        processPath = function (path, d, pcom) {
                            var nx, ny;
                            if (!path) {
                                return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                            }
                            !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);
                            switch (path[0]) {
                                case "M":
                                    d.X = path[1];
                                    d.Y = path[2];
                                    break;
                                case "A":
                                    path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                                    break;
                                case "S":
                                    if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                                        nx = d.x * 2 - d.bx;          // And reflect the previous
                                        ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                                    }
                                    else {                            // or some else or nothing
                                        nx = d.x;
                                        ny = d.y;
                                    }
                                    path = ["C", nx, ny].concat(path.slice(1));
                                    break;
                                case "T":
                                    if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                                        d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                        d.qy = d.y * 2 - d.qy;        // to case "S".
                                    }
                                    else {                            // or something else or nothing
                                        d.qx = d.x;
                                        d.qy = d.y;
                                    }
                                    path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                                    break;
                                case "Q":
                                    d.qx = path[1];
                                    d.qy = path[2];
                                    path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                                    break;
                                case "L":
                                    path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
                                    break;
                                case "H":
                                    path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
                                    break;
                                case "V":
                                    path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
                                    break;
                                case "Z":
                                    path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
                                    break;
                            }
                            return path;
                        },
                        fixArc = function (pp, i) {
                            if (pp[i].length > 7) {
                                pp[i].shift();
                                var pi = pp[i];
                                while (pi.length) {
                                    pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
                                    p2 && (pcoms2[i] = "A"); // the same as above
                                    pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
                                }
                                pp.splice(i, 1);
                                ii = mmax(p.length, p2 && p2.length || 0);
                            }
                        },
                        fixM = function (path1, path2, a1, a2, i) {
                            if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                                path2.splice(i, 0, ["M", a2.x, a2.y]);
                                a1.bx = 0;
                                a1.by = 0;
                                a1.x = path1[i][1];
                                a1.y = path1[i][2];
                                ii = mmax(p.length, p2 && p2.length || 0);
                            }
                        },
                        pcoms1 = [], // path commands of original path p
                        pcoms2 = [], // path commands of original path p2
                        pfirst = "", // temporary holder for original path command
                        pcom = ""; // holder for previous path command of original path
                    for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                        p[i] && (pfirst = p[i][0]); // save current path command

                        if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                        {
                            pcoms1[i] = pfirst; // Save current path command
                            i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom
                        }
                        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                        if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
                        // which may produce multiple C:s
                        // so we have to make sure that C is also C in original path

                        fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                        if (p2) { // the same procedures is done to p2
                            p2[i] && (pfirst = p2[i][0]);
                            if (pfirst != "C") {
                                pcoms2[i] = pfirst;
                                i && (pcom = pcoms2[i - 1]);
                            }
                            p2[i] = processPath(p2[i], attrs2, pcom);

                            if (pcoms2[i] != "A" && pfirst == "C") {
                                pcoms2[i] = "C";
                            }

                            fixArc(p2, i);
                        }
                        fixM(p, p2, attrs, attrs2, i);
                        fixM(p2, p, attrs2, attrs, i);
                        var seg = p[i],
                            seg2 = p2 && p2[i],
                            seglen = seg.length,
                            seg2len = p2 && seg2.length;
                        attrs.x = seg[seglen - 2];
                        attrs.y = seg[seglen - 1];
                        attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                        attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                        attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                        attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                        attrs2.x = p2 && seg2[seg2len - 2];
                        attrs2.y = p2 && seg2[seg2len - 1];
                    }
                    if (!p2) {
                        pth.curve = pathClone(p);
                    }
                    return p2 ? [p, p2] : p;
                }

                function mapPath(path, matrix) {
                    if (!matrix) {
                        return path;
                    }
                    var x, y, i, j, ii, jj, pathi;
                    path = path2curve(path);
                    for (i = 0, ii = path.length; i < ii; i++) {
                        pathi = path[i];
                        for (j = 1, jj = pathi.length; j < jj; j += 2) {
                            x = matrix.x(pathi[j], pathi[j + 1]);
                            y = matrix.y(pathi[j], pathi[j + 1]);
                            pathi[j] = x;
                            pathi[j + 1] = y;
                        }
                    }
                    return path;
                }

                // http://schepers.cc/getting-to-the-point
                function catmullRom2bezier(crp, z) {
                    var d = [];
                    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
                        var p = [
                            {x: +crp[i - 2], y: +crp[i - 1]},
                            {x: +crp[i], y: +crp[i + 1]},
                            {x: +crp[i + 2], y: +crp[i + 3]},
                            {x: +crp[i + 4], y: +crp[i + 5]}
                        ];
                        if (z) {
                            if (!i) {
                                p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                            } else if (iLen - 4 == i) {
                                p[3] = {x: +crp[0], y: +crp[1]};
                            } else if (iLen - 2 == i) {
                                p[2] = {x: +crp[0], y: +crp[1]};
                                p[3] = {x: +crp[2], y: +crp[3]};
                            }
                        } else {
                            if (iLen - 4 == i) {
                                p[3] = p[2];
                            } else if (!i) {
                                p[0] = {x: +crp[i], y: +crp[i + 1]};
                            }
                        }
                        d.push(["C",
                            (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                            (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                            (p[1].x + 6 * p[2].x - p[3].x) / 6,
                            (p[1].y + 6 * p[2].y - p[3].y) / 6,
                            p[2].x,
                            p[2].y
                        ]);
                    }

                    return d;
                }

                // export
                Snap.path = paths;

                /*\
                 * Snap.path.getTotalLength
                 [ method ]
                 **
                 * Returns the length of the given path in pixels
                 **
                 - path (string) SVG path string
                 **
                 = (number) length
                 \*/
                Snap.path.getTotalLength = getTotalLength;
                /*\
                 * Snap.path.getPointAtLength
                 [ method ]
                 **
                 * Returns the coordinates of the point located at the given length along the given path
                 **
                 - path (string) SVG path string
                 - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
                 **
                 = (object) representation of the point:
                 o {
                 o     x: (number) x coordinate,
                 o     y: (number) y coordinate,
                 o     alpha: (number) angle of derivative
                 o }
                 \*/
                Snap.path.getPointAtLength = getPointAtLength;
                /*\
                 * Snap.path.getSubpath
                 [ method ]
                 **
                 * Returns the subpath of a given path between given start and end lengths
                 **
                 - path (string) SVG path string
                 - from (number) length, in pixels, from the start of the path to the start of the segment
                 - to (number) length, in pixels, from the start of the path to the end of the segment
                 **
                 = (string) path string definition for the segment
                 \*/
                Snap.path.getSubpath = function (path, from, to) {
                    if (this.getTotalLength(path) - to < 1e-6) {
                        return getSubpathsAtLength(path, from).end;
                    }
                    var a = getSubpathsAtLength(path, to, 1);
                    return from ? getSubpathsAtLength(a, from).end : a;
                };
                /*\
                 * Element.getTotalLength
                 [ method ]
                 **
                 * Returns the length of the path in pixels (only works for `path` elements)
                 = (number) length
                 \*/
                elproto.getTotalLength = function () {
                    if (this.node.getTotalLength) {
                        return this.node.getTotalLength();
                    }
                };
                // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
                /*\
                 * Element.getPointAtLength
                 [ method ]
                 **
                 * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
                 **
                 - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
                 **
                 = (object) representation of the point:
                 o {
                 o     x: (number) x coordinate,
                 o     y: (number) y coordinate,
                 o     alpha: (number) angle of derivative
                 o }
                 \*/
                elproto.getPointAtLength = function (length) {
                    return getPointAtLength(this.attr("d"), length);
                };
                // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
                /*\
                 * Element.getSubpath
                 [ method ]
                 **
                 * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
                 **
                 - from (number) length, in pixels, from the start of the path to the start of the segment
                 - to (number) length, in pixels, from the start of the path to the end of the segment
                 **
                 = (string) path string definition for the segment
                 \*/
                elproto.getSubpath = function (from, to) {
                    return Snap.path.getSubpath(this.attr("d"), from, to);
                };
                Snap._.box = box;
                /*\
                 * Snap.path.findDotsAtSegment
                 [ method ]
                 **
                 * Utility method
                 **
                 * Finds dot coordinates on the given cubic beziér curve at the given t
                 - p1x (number) x of the first point of the curve
                 - p1y (number) y of the first point of the curve
                 - c1x (number) x of the first anchor of the curve
                 - c1y (number) y of the first anchor of the curve
                 - c2x (number) x of the second anchor of the curve
                 - c2y (number) y of the second anchor of the curve
                 - p2x (number) x of the second point of the curve
                 - p2y (number) y of the second point of the curve
                 - t (number) position on the curve (0..1)
                 = (object) point information in format:
                 o {
                 o     x: (number) x coordinate of the point,
                 o     y: (number) y coordinate of the point,
                 o     m: {
                 o         x: (number) x coordinate of the left anchor,
                 o         y: (number) y coordinate of the left anchor
                 o     },
                 o     n: {
                 o         x: (number) x coordinate of the right anchor,
                 o         y: (number) y coordinate of the right anchor
                 o     },
                 o     start: {
                 o         x: (number) x coordinate of the start of the curve,
                 o         y: (number) y coordinate of the start of the curve
                 o     },
                 o     end: {
                 o         x: (number) x coordinate of the end of the curve,
                 o         y: (number) y coordinate of the end of the curve
                 o     },
                 o     alpha: (number) angle of the curve derivative at the point
                 o }
                 \*/
                Snap.path.findDotsAtSegment = findDotsAtSegment;
                /*\
                 * Snap.path.bezierBBox
                 [ method ]
                 **
                 * Utility method
                 **
                 * Returns the bounding box of a given cubic beziér curve
                 - p1x (number) x of the first point of the curve
                 - p1y (number) y of the first point of the curve
                 - c1x (number) x of the first anchor of the curve
                 - c1y (number) y of the first anchor of the curve
                 - c2x (number) x of the second anchor of the curve
                 - c2y (number) y of the second anchor of the curve
                 - p2x (number) x of the second point of the curve
                 - p2y (number) y of the second point of the curve
                 * or
                 - bez (array) array of six points for beziér curve
                 = (object) bounding box
                 o {
                 o     x: (number) x coordinate of the left top point of the box,
                 o     y: (number) y coordinate of the left top point of the box,
                 o     x2: (number) x coordinate of the right bottom point of the box,
                 o     y2: (number) y coordinate of the right bottom point of the box,
                 o     width: (number) width of the box,
                 o     height: (number) height of the box
                 o }
                 \*/
                Snap.path.bezierBBox = bezierBBox;
                /*\
                 * Snap.path.isPointInsideBBox
                 [ method ]
                 **
                 * Utility method
                 **
                 * Returns `true` if given point is inside bounding box
                 - bbox (string) bounding box
                 - x (string) x coordinate of the point
                 - y (string) y coordinate of the point
                 = (boolean) `true` if point is inside
                 \*/
                Snap.path.isPointInsideBBox = isPointInsideBBox;
                /*\
                 * Snap.path.isBBoxIntersect
                 [ method ]
                 **
                 * Utility method
                 **
                 * Returns `true` if two bounding boxes intersect
                 - bbox1 (string) first bounding box
                 - bbox2 (string) second bounding box
                 = (boolean) `true` if bounding boxes intersect
                 \*/
                Snap.path.isBBoxIntersect = isBBoxIntersect;
                /*\
                 * Snap.path.intersection
                 [ method ]
                 **
                 * Utility method
                 **
                 * Finds intersections of two paths
                 - path1 (string) path string
                 - path2 (string) path string
                 = (array) dots of intersection
                 o [
                 o     {
                 o         x: (number) x coordinate of the point,
                 o         y: (number) y coordinate of the point,
                 o         t1: (number) t value for segment of path1,
                 o         t2: (number) t value for segment of path2,
                 o         segment1: (number) order number for segment of path1,
                 o         segment2: (number) order number for segment of path2,
                 o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,
                 o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
                 o     }
                 o ]
                 \*/
                Snap.path.intersection = pathIntersection;
                Snap.path.intersectionNumber = pathIntersectionNumber;
                /*\
                 * Snap.path.isPointInside
                 [ method ]
                 **
                 * Utility method
                 **
                 * Returns `true` if given point is inside a given closed path.
                 *
                 * Note: fill mode doesn’t affect the result of this method.
                 - path (string) path string
                 - x (number) x of the point
                 - y (number) y of the point
                 = (boolean) `true` if point is inside the path
                 \*/
                Snap.path.isPointInside = isPointInsidePath;
                /*\
                 * Snap.path.getBBox
                 [ method ]
                 **
                 * Utility method
                 **
                 * Returns the bounding box of a given path
                 - path (string) path string
                 = (object) bounding box
                 o {
                 o     x: (number) x coordinate of the left top point of the box,
                 o     y: (number) y coordinate of the left top point of the box,
                 o     x2: (number) x coordinate of the right bottom point of the box,
                 o     y2: (number) y coordinate of the right bottom point of the box,
                 o     width: (number) width of the box,
                 o     height: (number) height of the box
                 o }
                 \*/
                Snap.path.getBBox = pathBBox;
                Snap.path.get = getPath;
                /*\
                 * Snap.path.toRelative
                 [ method ]
                 **
                 * Utility method
                 **
                 * Converts path coordinates into relative values
                 - path (string) path string
                 = (array) path string
                 \*/
                Snap.path.toRelative = pathToRelative;
                /*\
                 * Snap.path.toAbsolute
                 [ method ]
                 **
                 * Utility method
                 **
                 * Converts path coordinates into absolute values
                 - path (string) path string
                 = (array) path string
                 \*/
                Snap.path.toAbsolute = pathToAbsolute;
                /*\
                 * Snap.path.toCubic
                 [ method ]
                 **
                 * Utility method
                 **
                 * Converts path to a new path where all segments are cubic beziér curves
                 - pathString (string|array) path string or array of segments
                 = (array) array of segments
                 \*/
                Snap.path.toCubic = path2curve;
                /*\
                 * Snap.path.map
                 [ method ]
                 **
                 * Transform the path string with the given matrix
                 - path (string) path string
                 - matrix (object) see @Matrix
                 = (string) transformed path string
                 \*/
                Snap.path.map = mapPath;
                Snap.path.toString = toString;
                Snap.path.clone = pathClone;
            });
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
            Snap.plugin(function (Snap, Element, Paper, glob) {
                var elproto = Element.prototype,
                    has = "hasOwnProperty",
                    supportsTouch = "createTouch" in glob.doc,
                    events = [
                        "click", "dblclick", "mousedown", "mousemove", "mouseout",
                        "mouseover", "mouseup", "touchstart", "touchmove", "touchend",
                        "touchcancel"
                    ],
                    touchMap = {
                        mousedown: "touchstart",
                        mousemove: "touchmove",
                        mouseup: "touchend"
                    },
                    getScroll = function (xy, el) {
                        var name = xy == "y" ? "scrollTop" : "scrollLeft",
                            doc = el && el.node ? el.node.ownerDocument : glob.doc;
                        return doc[name in doc.documentElement ? "documentElement" : "body"][name];
                    },
                    preventDefault = function () {
                        this.returnValue = false;
                    },
                    preventTouch = function () {
                        return this.originalEvent.preventDefault();
                    },
                    stopPropagation = function () {
                        this.cancelBubble = true;
                    },
                    stopTouch = function () {
                        return this.originalEvent.stopPropagation();
                    },
                    addEvent = (function () {
                        if (glob.doc.addEventListener) {
                            return function (obj, type, fn, element) {
                                var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
                                    f = function (e) {
                                        var scrollY = getScroll("y", element),
                                            scrollX = getScroll("x", element);
                                        if (supportsTouch && touchMap[has](type)) {
                                            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                                                if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
                                                    var olde = e;
                                                    e = e.targetTouches[i];
                                                    e.originalEvent = olde;
                                                    e.preventDefault = preventTouch;
                                                    e.stopPropagation = stopTouch;
                                                    break;
                                                }
                                            }
                                        }
                                        var x = e.clientX + scrollX,
                                            y = e.clientY + scrollY;
                                        return fn.call(element, e, x, y);
                                    };

                                if (type !== realName) {
                                    obj.addEventListener(type, f, false);
                                }

                                obj.addEventListener(realName, f, false);

                                return function () {
                                    if (type !== realName) {
                                        obj.removeEventListener(type, f, false);
                                    }

                                    obj.removeEventListener(realName, f, false);
                                    return true;
                                };
                            };
                        } else if (glob.doc.attachEvent) {
                            return function (obj, type, fn, element) {
                                var f = function (e) {
                                    e = e || element.node.ownerDocument.window.event;
                                    var scrollY = getScroll("y", element),
                                        scrollX = getScroll("x", element),
                                        x = e.clientX + scrollX,
                                        y = e.clientY + scrollY;
                                    e.preventDefault = e.preventDefault || preventDefault;
                                    e.stopPropagation = e.stopPropagation || stopPropagation;
                                    return fn.call(element, e, x, y);
                                };
                                obj.attachEvent("on" + type, f);
                                var detacher = function () {
                                    obj.detachEvent("on" + type, f);
                                    return true;
                                };
                                return detacher;
                            };
                        }
                    })(),
                    drag = [],
                    dragMove = function (e) {
                        var x = e.clientX,
                            y = e.clientY,
                            scrollY = getScroll("y"),
                            scrollX = getScroll("x"),
                            dragi,
                            j = drag.length;
                        while (j--) {
                            dragi = drag[j];
                            if (supportsTouch) {
                                var i = e.touches && e.touches.length,
                                    touch;
                                while (i--) {
                                    touch = e.touches[i];
                                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
                                        x = touch.clientX;
                                        y = touch.clientY;
                                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                                        break;
                                    }
                                }
                            } else {
                                e.preventDefault();
                            }
                            var node = dragi.el.node,
                                o,
                                next = node.nextSibling,
                                parent = node.parentNode,
                                display = node.style.display;
                            // glob.win.opera && parent.removeChild(node);
                            // node.style.display = "none";
                            // o = dragi.el.paper.getElementByPoint(x, y);
                            // node.style.display = display;
                            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                            // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
                            x += scrollX;
                            y += scrollY;
                            eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
                        }
                    },
                    dragUp = function (e) {
                        Snap.unmousemove(dragMove).unmouseup(dragUp);
                        var i = drag.length,
                            dragi;
                        while (i--) {
                            dragi = drag[i];
                            dragi.el._drag = {};
                            eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
                        }
                        drag = [];
                    };
                /*\
                 * Element.click
                 [ method ]
                 **
                 * Adds a click event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.unclick
                 [ method ]
                 **
                 * Removes a click event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.dblclick
                 [ method ]
                 **
                 * Adds a double click event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.undblclick
                 [ method ]
                 **
                 * Removes a double click event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.mousedown
                 [ method ]
                 **
                 * Adds a mousedown event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.unmousedown
                 [ method ]
                 **
                 * Removes a mousedown event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.mousemove
                 [ method ]
                 **
                 * Adds a mousemove event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.unmousemove
                 [ method ]
                 **
                 * Removes a mousemove event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.mouseout
                 [ method ]
                 **
                 * Adds a mouseout event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.unmouseout
                 [ method ]
                 **
                 * Removes a mouseout event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.mouseover
                 [ method ]
                 **
                 * Adds a mouseover event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.unmouseover
                 [ method ]
                 **
                 * Removes a mouseover event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.mouseup
                 [ method ]
                 **
                 * Adds a mouseup event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.unmouseup
                 [ method ]
                 **
                 * Removes a mouseup event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.touchstart
                 [ method ]
                 **
                 * Adds a touchstart event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.untouchstart
                 [ method ]
                 **
                 * Removes a touchstart event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.touchmove
                 [ method ]
                 **
                 * Adds a touchmove event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.untouchmove
                 [ method ]
                 **
                 * Removes a touchmove event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.touchend
                 [ method ]
                 **
                 * Adds a touchend event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.untouchend
                 [ method ]
                 **
                 * Removes a touchend event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/

                /*\
                 * Element.touchcancel
                 [ method ]
                 **
                 * Adds a touchcancel event handler to the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                /*\
                 * Element.untouchcancel
                 [ method ]
                 **
                 * Removes a touchcancel event handler from the element
                 - handler (function) handler for the event
                 = (object) @Element
                 \*/
                for (var i = events.length; i--;) {
                    (function (eventName) {
                        Snap[eventName] = elproto[eventName] = function (fn, scope) {
                            if (Snap.is(fn, "function")) {
                                this.events = this.events || [];
                                this.events.push({
                                    name: eventName,
                                    f: fn,
                                    unbind: addEvent(this.node || document, eventName, fn, scope || this)
                                });
                            }
                            return this;
                        };
                        Snap["un" + eventName] =
                            elproto["un" + eventName] = function (fn) {
                                var events = this.events || [],
                                    l = events.length;
                                while (l--) if (events[l].name == eventName &&
                                    (events[l].f == fn || !fn)) {
                                    events[l].unbind();
                                    events.splice(l, 1);
                                    !events.length && delete this.events;
                                    return this;
                                }
                                return this;
                            };
                    })(events[i]);
                }
                /*\
                 * Element.hover
                 [ method ]
                 **
                 * Adds hover event handlers to the element
                 - f_in (function) handler for hover in
                 - f_out (function) handler for hover out
                 - icontext (object) #optional context for hover in handler
                 - ocontext (object) #optional context for hover out handler
                 = (object) @Element
                 \*/
                elproto.hover = function (f_in, f_out, scope_in, scope_out) {
                    return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
                };
                /*\
                 * Element.unhover
                 [ method ]
                 **
                 * Removes hover event handlers from the element
                 - f_in (function) handler for hover in
                 - f_out (function) handler for hover out
                 = (object) @Element
                 \*/
                elproto.unhover = function (f_in, f_out) {
                    return this.unmouseover(f_in).unmouseout(f_out);
                };
                var draggable = [];
                // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
                // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
                // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
                // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
                /*\
                 * Element.drag
                 [ method ]
                 **
                 * Adds event handlers for an element's drag gesture
                 **
                 - onmove (function) handler for moving
                 - onstart (function) handler for drag start
                 - onend (function) handler for drag end
                 - mcontext (object) #optional context for moving handler
                 - scontext (object) #optional context for drag start handler
                 - econtext (object) #optional context for drag end handler
                 * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, 
                 * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element 
                 * `drag.over.<id>` fires as well.
                 *
                 * Start event and start handler are called in specified context or in context of the element with following parameters:
                 o x (number) x position of the mouse
                 o y (number) y position of the mouse
                 o event (object) DOM event object
                 * Move event and move handler are called in specified context or in context of the element with following parameters:
                 o dx (number) shift by x from the start point
                 o dy (number) shift by y from the start point
                 o x (number) x position of the mouse
                 o y (number) y position of the mouse
                 o event (object) DOM event object
                 * End event and end handler are called in specified context or in context of the element with following parameters:
                 o event (object) DOM event object
                 = (object) @Element
                 \*/
                elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
                    if (!arguments.length) {
                        var origTransform;
                        return this.drag(function (dx, dy) {
                            this.attr({
                                transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
                            });
                        }, function () {
                            origTransform = this.transform().local;
                        });
                    }
                    function start(e, x, y) {
                        (e.originalEvent || e).preventDefault();
                        this._drag.x = x;
                        this._drag.y = y;
                        this._drag.id = e.identifier;
                        !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
                        drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
                        onstart && eve.on("snap.drag.start." + this.id, onstart);
                        onmove && eve.on("snap.drag.move." + this.id, onmove);
                        onend && eve.on("snap.drag.end." + this.id, onend);
                        eve("snap.drag.start." + this.id, start_scope || move_scope || this, x, y, e);
                    }

                    this._drag = {};
                    draggable.push({el: this, start: start});
                    this.mousedown(start);
                    return this;
                };
                /*
                 * Element.onDragOver
                 [ method ]
                 **
                 * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
                 - f (function) handler for event, first argument would be the element you are dragging over
                 \*/
                // elproto.onDragOver = function (f) {
                //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
                // };
                /*\
                 * Element.undrag
                 [ method ]
                 **
                 * Removes all drag event handlers from the given element
                 \*/
                elproto.undrag = function () {
                    var i = draggable.length;
                    while (i--) if (draggable[i].el == this) {
                        this.unmousedown(draggable[i].start);
                        draggable.splice(i, 1);
                        eve.unbind("snap.drag.*." + this.id);
                    }
                    !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
                    return this;
                };
            });
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
            Snap.plugin(function (Snap, Element, Paper, glob) {
                var elproto = Element.prototype,
                    pproto = Paper.prototype,
                    rgurl = /^\s*url\((.+)\)/,
                    Str = String,
                    $ = Snap._.$;
                Snap.filter = {};
                /*\
                 * Paper.filter
                 [ method ]
                 **
                 * Creates a `<filter>` element
                 **
                 - filstr (string) SVG fragment of filter provided as a string
                 = (object) @Element
                 * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
                 > Usage
                 | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
                 |     c = paper.circle(10, 10, 10).attr({
                 |         filter: f
                 |     });
                 \*/
                pproto.filter = function (filstr) {
                    var paper = this;
                    if (paper.type != "svg") {
                        paper = paper.paper;
                    }
                    var f = Snap.parse(Str(filstr)),
                        id = Snap._.id(),
                        width = paper.node.offsetWidth,
                        height = paper.node.offsetHeight,
                        filter = $("filter");
                    $(filter, {
                        id: id,
                        filterUnits: "userSpaceOnUse"
                    });
                    filter.appendChild(f.node);
                    paper.defs.appendChild(filter);
                    return new Element(filter);
                };

                eve.on("snap.util.getattr.filter", function () {
                    eve.stop();
                    var p = $(this.node, "filter");
                    if (p) {
                        var match = Str(p).match(rgurl);
                        return match && Snap.select(match[1]);
                    }
                });
                eve.on("snap.util.attr.filter", function (value) {
                    if (value instanceof Element && value.type == "filter") {
                        eve.stop();
                        var id = value.node.id;
                        if (!id) {
                            $(value.node, {id: value.id});
                            id = value.id;
                        }
                        $(this.node, {
                            filter: Snap.url(id)
                        });
                    }
                    if (!value || value == "none") {
                        eve.stop();
                        this.node.removeAttribute("filter");
                    }
                });
                /*\
                 * Snap.filter.blur
                 [ method ]
                 **
                 * Returns an SVG markup string for the blur filter
                 **
                 - x (number) amount of horizontal blur, in pixels
                 - y (number) #optional amount of vertical blur, in pixels
                 = (string) filter representation
                 > Usage
                 | var f = paper.filter(Snap.filter.blur(5, 10)),
                 |     c = paper.circle(10, 10, 10).attr({
                 |         filter: f
                 |     });
                 \*/
                Snap.filter.blur = function (x, y) {
                    if (x == null) {
                        x = 2;
                    }
                    var def = y == null ? x : [x, y];
                    return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
                        def: def
                    });
                };
                Snap.filter.blur.toString = function () {
                    return this();
                };
                /*\
                 * Snap.filter.shadow
                 [ method ]
                 **
                 * Returns an SVG markup string for the shadow filter
                 **
                 - dx (number) #optional horizontal shift of the shadow, in pixels
                 - dy (number) #optional vertical shift of the shadow, in pixels
                 - blur (number) #optional amount of blur
                 - color (string) #optional color of the shadow
                 - opacity (number) #optional `0..1` opacity of the shadow
                 * or
                 - dx (number) #optional horizontal shift of the shadow, in pixels
                 - dy (number) #optional vertical shift of the shadow, in pixels
                 - color (string) #optional color of the shadow
                 - opacity (number) #optional `0..1` opacity of the shadow
                 * which makes blur default to `4`. Or
                 - dx (number) #optional horizontal shift of the shadow, in pixels
                 - dy (number) #optional vertical shift of the shadow, in pixels
                 - opacity (number) #optional `0..1` opacity of the shadow
                 = (string) filter representation
                 > Usage
                 | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),
                 |     c = paper.circle(10, 10, 10).attr({
                 |         filter: f
                 |     });
                 \*/
                Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
                    if (typeof blur == "string") {
                        color = blur;
                        opacity = color;
                        blur = 4;
                    }
                    if (typeof color != "string") {
                        opacity = color;
                        color = "#000";
                    }
                    color = color || "#000";
                    if (blur == null) {
                        blur = 4;
                    }
                    if (opacity == null) {
                        opacity = 1;
                    }
                    if (dx == null) {
                        dx = 0;
                        dy = 2;
                    }
                    if (dy == null) {
                        dy = dx;
                    }
                    color = Snap.color(color);
                    return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
                        color: color,
                        dx: dx,
                        dy: dy,
                        blur: blur,
                        opacity: opacity
                    });
                };
                Snap.filter.shadow.toString = function () {
                    return this();
                };
                /*\
                 * Snap.filter.grayscale
                 [ method ]
                 **
                 * Returns an SVG markup string for the grayscale filter
                 **
                 - amount (number) amount of filter (`0..1`)
                 = (string) filter representation
                 \*/
                Snap.filter.grayscale = function (amount) {
                    if (amount == null) {
                        amount = 1;
                    }
                    return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
                        a: 0.2126 + 0.7874 * (1 - amount),
                        b: 0.7152 - 0.7152 * (1 - amount),
                        c: 0.0722 - 0.0722 * (1 - amount),
                        d: 0.2126 - 0.2126 * (1 - amount),
                        e: 0.7152 + 0.2848 * (1 - amount),
                        f: 0.0722 - 0.0722 * (1 - amount),
                        g: 0.2126 - 0.2126 * (1 - amount),
                        h: 0.0722 + 0.9278 * (1 - amount)
                    });
                };
                Snap.filter.grayscale.toString = function () {
                    return this();
                };
                /*\
                 * Snap.filter.sepia
                 [ method ]
                 **
                 * Returns an SVG markup string for the sepia filter
                 **
                 - amount (number) amount of filter (`0..1`)
                 = (string) filter representation
                 \*/
                Snap.filter.sepia = function (amount) {
                    if (amount == null) {
                        amount = 1;
                    }
                    return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
                        a: 0.393 + 0.607 * (1 - amount),
                        b: 0.769 - 0.769 * (1 - amount),
                        c: 0.189 - 0.189 * (1 - amount),
                        d: 0.349 - 0.349 * (1 - amount),
                        e: 0.686 + 0.314 * (1 - amount),
                        f: 0.168 - 0.168 * (1 - amount),
                        g: 0.272 - 0.272 * (1 - amount),
                        h: 0.534 - 0.534 * (1 - amount),
                        i: 0.131 + 0.869 * (1 - amount)
                    });
                };
                Snap.filter.sepia.toString = function () {
                    return this();
                };
                /*\
                 * Snap.filter.saturate
                 [ method ]
                 **
                 * Returns an SVG markup string for the saturate filter
                 **
                 - amount (number) amount of filter (`0..1`)
                 = (string) filter representation
                 \*/
                Snap.filter.saturate = function (amount) {
                    if (amount == null) {
                        amount = 1;
                    }
                    return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
                        amount: 1 - amount
                    });
                };
                Snap.filter.saturate.toString = function () {
                    return this();
                };
                /*\
                 * Snap.filter.hueRotate
                 [ method ]
                 **
                 * Returns an SVG markup string for the hue-rotate filter
                 **
                 - angle (number) angle of rotation
                 = (string) filter representation
                 \*/
                Snap.filter.hueRotate = function (angle) {
                    angle = angle || 0;
                    return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
                        angle: angle
                    });
                };
                Snap.filter.hueRotate.toString = function () {
                    return this();
                };
                /*\
                 * Snap.filter.invert
                 [ method ]
                 **
                 * Returns an SVG markup string for the invert filter
                 **
                 - amount (number) amount of filter (`0..1`)
                 = (string) filter representation
                 \*/
                Snap.filter.invert = function (amount) {
                    if (amount == null) {
                        amount = 1;
                    }
                    return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
                        amount: amount,
                        amount2: 1 - amount
                    });
                };
                Snap.filter.invert.toString = function () {
                    return this();
                };
                /*\
                 * Snap.filter.brightness
                 [ method ]
                 **
                 * Returns an SVG markup string for the brightness filter
                 **
                 - amount (number) amount of filter (`0..1`)
                 = (string) filter representation
                 \*/
                Snap.filter.brightness = function (amount) {
                    if (amount == null) {
                        amount = 1;
                    }
                    return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
                        amount: amount
                    });
                };
                Snap.filter.brightness.toString = function () {
                    return this();
                };
                /*\
                 * Snap.filter.contrast
                 [ method ]
                 **
                 * Returns an SVG markup string for the contrast filter
                 **
                 - amount (number) amount of filter (`0..1`)
                 = (string) filter representation
                 \*/
                Snap.filter.contrast = function (amount) {
                    if (amount == null) {
                        amount = 1;
                    }
                    return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
                        amount: amount,
                        amount2: .5 - amount / 2
                    });
                };
                Snap.filter.contrast.toString = function () {
                    return this();
                };
            });

            return Snap;
        }));
    }, {"eve": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/eve/eve.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/vendor/snapsvg.js": [function (require, module, exports) {
        'use strict';

        var snapsvg = module.exports = require('snapsvg');

        snapsvg.plugin(function (Snap, Element) {

            /*\
             * Element.children
             [ method ]
             **
             * Returns array of all the children of the element.
             = (array) array of Elements
             \*/
            Element.prototype.children = function () {
                var out = [],
                    ch = this.node.childNodes;
                for (var i = 0, ii = ch.length; i < ii; i++) {
                    out[i] = new Snap(ch[i]);
                }
                return out;
            };
        });


        /**
         * @class ClassPlugin
         *
         * Extends snapsvg with methods to add and remove classes
         */
        snapsvg.plugin(function (Snap, Element, Paper, global) {

            function split(str) {
                return str.split(/\s+/);
            }

            function join(array) {
                return array.join(' ');
            }

            function getClasses(e) {
                return split(e.attr('class') || '');
            }

            function setClasses(e, classes) {
                e.attr('class', join(classes));
            }

            /**
             * @method snapsvg.Element#addClass
             *
             * @example
             *
             * e.attr('class', 'selector');
             *
             * e.addClass('foo bar'); // adds classes foo and bar
             * e.attr('class'); // -> 'selector foo bar'
             *
             * e.addClass('fooBar');
             * e.attr('class'); // -> 'selector foo bar fooBar'
             *
             * @param {String} cls classes to be added to the element
             *
             * @return {snapsvg.Element} the element (this)
             */
            Element.prototype.addClass = function (cls) {
                var current = getClasses(this),
                    add = split(cls),
                    i, e;

                for (i = 0, e; !!(e = add[i]); i++) {
                    if (current.indexOf(e) === -1) {
                        current.push(e);
                    }
                }

                setClasses(this, current);

                return this;
            };

            /**
             * @method snapsvg.Element#hasClass
             *
             * @param  {String}  cls the class to query for
             * @return {Boolean} returns true if the element has the given class
             */
            Element.prototype.hasClass = function (cls) {
                if (!cls) {
                    throw new Error('[snapsvg] syntax: hasClass(clsStr)');
                }

                return getClasses(this).indexOf(cls) !== -1;
            };

            /**
             * @method snapsvg.Element#removeClass
             *
             * @example
             *
             * e.attr('class', 'foo bar');
             *
             * e.removeClass('foo');
             * e.attr('class'); // -> 'bar'
             *
             * e.removeClass('foo bar'); // removes classes foo and bar
             * e.attr('class'); // -> ''
             *
             * @param {String} cls classes to be removed from element
             *
             * @return {snapsvg.Element} the element (this)
             */
            Element.prototype.removeClass = function (cls) {
                var current = getClasses(this),
                    remove = split(cls),
                    i, e, idx;

                for (i = 0, e; !!(e = remove[i]); i++) {
                    idx = current.indexOf(e);

                    if (idx !== -1) {
                        // remove element from array
                        current.splice(idx, 1);
                    }
                }

                setClasses(this, current);

                return this;
            };

        });

        /**
         * @class TranslatePlugin
         *
         * Extends snapsvg with methods to translate elements
         */
        snapsvg.plugin(function (Snap, Element, Paper, global) {

            /*
             * @method snapsvg.Element#translate
             *
             * @example
             *
             * e.translate(10, 20);
             *
             * // sets transform matrix to translate(10, 20)
             *
             * @param {Number} x translation
             * @param {Number} y translation
             *
             * @return {snapsvg.Element} the element (this)
             */
            Element.prototype.translate = function (x, y) {
                var matrix = new Snap.Matrix();
                matrix.translate(x, y);
                return this.transform(matrix);
            };
        });


        /**
         * @class CreatePlugin
         *
         * Create an svg element without attaching it to the dom
         */
        snapsvg.plugin(function (Snap) {

            Snap.create = function (name, attrs) {
                return Snap._.wrap(Snap._.$(name, attrs));
            };
        });


        /**
         * @class CreatSnapAtPlugin
         *
         * Extends snap.svg with a method to create a SVG element
         * at a specific position in the DOM.
         */
        snapsvg.plugin(function (Snap, Element, Paper, global) {

            /*
             * @method snapsvg.createSnapAt
             *
             * @example
             *
             * snapsvg.createSnapAt(parentNode, 200, 200);
             *
             * @param {Number} width of svg
             * @param {Number} height of svg
             * @param {Object} parentNode svg Element will be child of this
             *
             * @return {snapsvg.Element} the newly created wrapped SVG element instance
             */
            Snap.createSnapAt = function (width, height, parentNode) {

                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
                if (!parentNode) {
                    parentNode = document.body;
                }
                parentNode.appendChild(svg);

                return new Snap(svg);
            };
        });
    }, {"snapsvg": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/diagram-js/node_modules/snapsvg/dist/snap.svg.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/jquery/dist/jquery.js": [function (require, module, exports) {
        /*!
         * jQuery JavaScript Library v2.1.4
         * http://jquery.com/
         *
         * Includes Sizzle.js
         * http://sizzlejs.com/
         *
         * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2015-04-28T16:01Z
         */

        (function (global, factory) {

            if (typeof module === "object" && typeof module.exports === "object") {
                // For CommonJS and CommonJS-like environments where a proper `window`
                // is present, execute the factory and get jQuery.
                // For environments that do not have a `window` with a `document`
                // (such as Node.js), expose a factory as module.exports.
                // This accentuates the need for the creation of a real `window`.
                // e.g. var jQuery = require("jquery")(window);
                // See ticket #14549 for more info.
                module.exports = global.document ?
                    factory(global, true) :
                    function (w) {
                        if (!w.document) {
                            throw new Error("jQuery requires a window with a document");
                        }
                        return factory(w);
                    };
            } else {
                factory(global);
            }

// Pass this if window is not defined yet
        }(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

            var arr = [];

            var slice = arr.slice;

            var concat = arr.concat;

            var push = arr.push;

            var indexOf = arr.indexOf;

            var class2type = {};

            var toString = class2type.toString;

            var hasOwn = class2type.hasOwnProperty;

            var support = {};


            var
            // Use the correct document accordingly with window argument (sandbox)
                document = window.document,

                version = "2.1.4",

            // Define a local copy of jQuery
                jQuery = function (selector, context) {
                    // The jQuery object is actually just the init constructor 'enhanced'
                    // Need init if jQuery is called (just allow error to be thrown if not included)
                    return new jQuery.fn.init(selector, context);
                },

            // Support: Android<4.1
            // Make sure we trim BOM and NBSP
                rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

            // Matches dashed string for camelizing
                rmsPrefix = /^-ms-/,
                rdashAlpha = /-([\da-z])/gi,

            // Used by jQuery.camelCase as callback to replace()
                fcamelCase = function (all, letter) {
                    return letter.toUpperCase();
                };

            jQuery.fn = jQuery.prototype = {
                // The current version of jQuery being used
                jquery: version,

                constructor: jQuery,

                // Start with an empty selector
                selector: "",

                // The default length of a jQuery object is 0
                length: 0,

                toArray: function () {
                    return slice.call(this);
                },

                // Get the Nth element in the matched element set OR
                // Get the whole matched element set as a clean array
                get: function (num) {
                    return num != null ?

                        // Return just the one element from the set
                        ( num < 0 ? this[num + this.length] : this[num] ) :

                        // Return all the elements in a clean array
                        slice.call(this);
                },

                // Take an array of elements and push it onto the stack
                // (returning the new matched element set)
                pushStack: function (elems) {

                    // Build a new jQuery matched element set
                    var ret = jQuery.merge(this.constructor(), elems);

                    // Add the old object onto the stack (as a reference)
                    ret.prevObject = this;
                    ret.context = this.context;

                    // Return the newly-formed element set
                    return ret;
                },

                // Execute a callback for every element in the matched set.
                // (You can seed the arguments with an array of args, but this is
                // only used internally.)
                each: function (callback, args) {
                    return jQuery.each(this, callback, args);
                },

                map: function (callback) {
                    return this.pushStack(jQuery.map(this, function (elem, i) {
                        return callback.call(elem, i, elem);
                    }));
                },

                slice: function () {
                    return this.pushStack(slice.apply(this, arguments));
                },

                first: function () {
                    return this.eq(0);
                },

                last: function () {
                    return this.eq(-1);
                },

                eq: function (i) {
                    var len = this.length,
                        j = +i + ( i < 0 ? len : 0 );
                    return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
                },

                end: function () {
                    return this.prevObject || this.constructor(null);
                },

                // For internal use only.
                // Behaves like an Array's method, not like a jQuery method.
                push: push,
                sort: arr.sort,
                splice: arr.splice
            };

            jQuery.extend = jQuery.fn.extend = function () {
                var options, name, src, copy, copyIsArray, clone,
                    target = arguments[0] || {},
                    i = 1,
                    length = arguments.length,
                    deep = false;

                // Handle a deep copy situation
                if (typeof target === "boolean") {
                    deep = target;

                    // Skip the boolean and the target
                    target = arguments[i] || {};
                    i++;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if (typeof target !== "object" && !jQuery.isFunction(target)) {
                    target = {};
                }

                // Extend jQuery itself if only one argument is passed
                if (i === length) {
                    target = this;
                    i--;
                }

                for (; i < length; i++) {
                    // Only deal with non-null/undefined values
                    if ((options = arguments[i]) != null) {
                        // Extend the base object
                        for (name in options) {
                            src = target[name];
                            copy = options[name];

                            // Prevent never-ending loop
                            if (target === copy) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if (deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) )) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && jQuery.isArray(src) ? src : [];

                                } else {
                                    clone = src && jQuery.isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[name] = jQuery.extend(deep, clone, copy);

                                // Don't bring in undefined values
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            jQuery.extend({
                // Unique for each copy of jQuery on the page
                expando: "jQuery" + ( version + Math.random() ).replace(/\D/g, ""),

                // Assume jQuery is ready without the ready module
                isReady: true,

                error: function (msg) {
                    throw new Error(msg);
                },

                noop: function () {
                },

                isFunction: function (obj) {
                    return jQuery.type(obj) === "function";
                },

                isArray: Array.isArray,

                isWindow: function (obj) {
                    return obj != null && obj === obj.window;
                },

                isNumeric: function (obj) {
                    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
                    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                    // subtraction forces infinities to NaN
                    // adding 1 corrects loss of precision from parseFloat (#15100)
                    return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
                },

                isPlainObject: function (obj) {
                    // Not plain objects:
                    // - Any object or value whose internal [[Class]] property is not "[object Object]"
                    // - DOM nodes
                    // - window
                    if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                        return false;
                    }

                    if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                        return false;
                    }

                    // If the function hasn't returned already, we're confident that
                    // |obj| is a plain object, created by {} or constructed with new Object
                    return true;
                },

                isEmptyObject: function (obj) {
                    var name;
                    for (name in obj) {
                        return false;
                    }
                    return true;
                },

                type: function (obj) {
                    if (obj == null) {
                        return obj + "";
                    }
                    // Support: Android<4.0, iOS<6 (functionish RegExp)
                    return typeof obj === "object" || typeof obj === "function" ?
                    class2type[toString.call(obj)] || "object" :
                        typeof obj;
                },

                // Evaluates a script in a global context
                globalEval: function (code) {
                    var script,
                        indirect = eval;

                    code = jQuery.trim(code);

                    if (code) {
                        // If the code includes a valid, prologue position
                        // strict mode pragma, execute code by injecting a
                        // script tag into the document.
                        if (code.indexOf("use strict") === 1) {
                            script = document.createElement("script");
                            script.text = code;
                            document.head.appendChild(script).parentNode.removeChild(script);
                        } else {
                            // Otherwise, avoid the DOM node creation, insertion
                            // and removal by using an indirect global eval
                            indirect(code);
                        }
                    }
                },

                // Convert dashed to camelCase; used by the css and data modules
                // Support: IE9-11+
                // Microsoft forgot to hump their vendor prefix (#9572)
                camelCase: function (string) {
                    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
                },

                nodeName: function (elem, name) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                },

                // args is for internal usage only
                each: function (obj, callback, args) {
                    var value,
                        i = 0,
                        length = obj.length,
                        isArray = isArraylike(obj);

                    if (args) {
                        if (isArray) {
                            for (; i < length; i++) {
                                value = callback.apply(obj[i], args);

                                if (value === false) {
                                    break;
                                }
                            }
                        } else {
                            for (i in obj) {
                                value = callback.apply(obj[i], args);

                                if (value === false) {
                                    break;
                                }
                            }
                        }

                        // A special, fast, case for the most common use of each
                    } else {
                        if (isArray) {
                            for (; i < length; i++) {
                                value = callback.call(obj[i], i, obj[i]);

                                if (value === false) {
                                    break;
                                }
                            }
                        } else {
                            for (i in obj) {
                                value = callback.call(obj[i], i, obj[i]);

                                if (value === false) {
                                    break;
                                }
                            }
                        }
                    }

                    return obj;
                },

                // Support: Android<4.1
                trim: function (text) {
                    return text == null ?
                        "" :
                        ( text + "" ).replace(rtrim, "");
                },

                // results is for internal usage only
                makeArray: function (arr, results) {
                    var ret = results || [];

                    if (arr != null) {
                        if (isArraylike(Object(arr))) {
                            jQuery.merge(ret,
                                typeof arr === "string" ?
                                    [arr] : arr
                            );
                        } else {
                            push.call(ret, arr);
                        }
                    }

                    return ret;
                },

                inArray: function (elem, arr, i) {
                    return arr == null ? -1 : indexOf.call(arr, elem, i);
                },

                merge: function (first, second) {
                    var len = +second.length,
                        j = 0,
                        i = first.length;

                    for (; j < len; j++) {
                        first[i++] = second[j];
                    }

                    first.length = i;

                    return first;
                },

                grep: function (elems, callback, invert) {
                    var callbackInverse,
                        matches = [],
                        i = 0,
                        length = elems.length,
                        callbackExpect = !invert;

                    // Go through the array, only saving the items
                    // that pass the validator function
                    for (; i < length; i++) {
                        callbackInverse = !callback(elems[i], i);
                        if (callbackInverse !== callbackExpect) {
                            matches.push(elems[i]);
                        }
                    }

                    return matches;
                },

                // arg is for internal usage only
                map: function (elems, callback, arg) {
                    var value,
                        i = 0,
                        length = elems.length,
                        isArray = isArraylike(elems),
                        ret = [];

                    // Go through the array, translating each of the items to their new values
                    if (isArray) {
                        for (; i < length; i++) {
                            value = callback(elems[i], i, arg);

                            if (value != null) {
                                ret.push(value);
                            }
                        }

                        // Go through every key on the object,
                    } else {
                        for (i in elems) {
                            value = callback(elems[i], i, arg);

                            if (value != null) {
                                ret.push(value);
                            }
                        }
                    }

                    // Flatten any nested arrays
                    return concat.apply([], ret);
                },

                // A global GUID counter for objects
                guid: 1,

                // Bind a function to a context, optionally partially applying any
                // arguments.
                proxy: function (fn, context) {
                    var tmp, args, proxy;

                    if (typeof context === "string") {
                        tmp = fn[context];
                        context = fn;
                        fn = tmp;
                    }

                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if (!jQuery.isFunction(fn)) {
                        return undefined;
                    }

                    // Simulated bind
                    args = slice.call(arguments, 2);
                    proxy = function () {
                        return fn.apply(context || this, args.concat(slice.call(arguments)));
                    };

                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                    return proxy;
                },

                now: Date.now,

                // jQuery.support is not used in Core but other projects attach their
                // properties to it so it needs to exist.
                support: support
            });

// Populate the class2type map
            jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
                class2type["[object " + name + "]"] = name.toLowerCase();
            });

            function isArraylike(obj) {

                // Support: iOS 8.2 (not reproducible in simulator)
                // `in` check used to prevent JIT error (gh-2145)
                // hasOwn isn't used here due to false negatives
                // regarding Nodelist length in IE
                var length = "length" in obj && obj.length,
                    type = jQuery.type(obj);

                if (type === "function" || jQuery.isWindow(obj)) {
                    return false;
                }

                if (obj.nodeType === 1 && length) {
                    return true;
                }

                return type === "array" || length === 0 ||
                    typeof length === "number" && length > 0 && ( length - 1 ) in obj;
            }

            var Sizzle =
                /*!
                 * Sizzle CSS Selector Engine v2.2.0-pre
                 * http://sizzlejs.com/
                 *
                 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
                 * Released under the MIT license
                 * http://jquery.org/license
                 *
                 * Date: 2014-12-16
                 */
                (function (window) {

                    var i,
                        support,
                        Expr,
                        getText,
                        isXML,
                        tokenize,
                        compile,
                        select,
                        outermostContext,
                        sortInput,
                        hasDuplicate,

                    // Local document vars
                        setDocument,
                        document,
                        docElem,
                        documentIsHTML,
                        rbuggyQSA,
                        rbuggyMatches,
                        matches,
                        contains,

                    // Instance-specific data
                        expando = "sizzle" + 1 * new Date(),
                        preferredDoc = window.document,
                        dirruns = 0,
                        done = 0,
                        classCache = createCache(),
                        tokenCache = createCache(),
                        compilerCache = createCache(),
                        sortOrder = function (a, b) {
                            if (a === b) {
                                hasDuplicate = true;
                            }
                            return 0;
                        },

                    // General-purpose constants
                        MAX_NEGATIVE = 1 << 31,

                    // Instance methods
                        hasOwn = ({}).hasOwnProperty,
                        arr = [],
                        pop = arr.pop,
                        push_native = arr.push,
                        push = arr.push,
                        slice = arr.slice,
                    // Use a stripped-down indexOf as it's faster than native
                    // http://jsperf.com/thor-indexof-vs-for/5
                        indexOf = function (list, elem) {
                            var i = 0,
                                len = list.length;
                            for (; i < len; i++) {
                                if (list[i] === elem) {
                                    return i;
                                }
                            }
                            return -1;
                        },

                        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                    // Regular expressions

                    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                        whitespace = "[\\x20\\t\\r\\n\\f]",
                    // http://www.w3.org/TR/css3-syntax/#characters
                        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                    // Loosely modeled on CSS identifier characters
                    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                        identifier = characterEncoding.replace("w", "w#"),

                    // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
                                // Operator (capture 2)
                            "*([*^$|!~]?=)" + whitespace +
                                // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                            "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                            "*\\]",

                        pseudos = ":(" + characterEncoding + ")(?:\\((" +
                                // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                                // 1. quoted (capture 3; capture 4 or capture 5)
                            "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                                // 2. simple (capture 6)
                            "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                                // 3. anything else (capture 2)
                            ".*" +
                            ")\\)|)",

                    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                        rwhitespace = new RegExp(whitespace + "+", "g"),
                        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

                        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

                        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

                        rpseudo = new RegExp(pseudos),
                        ridentifier = new RegExp("^" + identifier + "$"),

                        matchExpr = {
                            "ID": new RegExp("^#(" + characterEncoding + ")"),
                            "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
                            "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                            "ATTR": new RegExp("^" + attributes),
                            "PSEUDO": new RegExp("^" + pseudos),
                            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                            "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                            // For use in libraries implementing .is()
                            // We use this for POS matching in `select`
                            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                        },

                        rinputs = /^(?:input|select|textarea|button)$/i,
                        rheader = /^h\d$/i,

                        rnative = /^[^{]+\{\s*\[native \w/,

                    // Easily-parseable/retrievable ID or TAG or CLASS selectors
                        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                        rsibling = /[+~]/,
                        rescape = /'|\\/g,

                    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                        funescape = function (_, escaped, escapedWhitespace) {
                            var high = "0x" + escaped - 0x10000;
                            // NaN means non-codepoint
                            // Support: Firefox<24
                            // Workaround erroneous numeric interpretation of +"0x"
                            return high !== high || escapedWhitespace ?
                                escaped :
                                high < 0 ?
                                    // BMP codepoint
                                    String.fromCharCode(high + 0x10000) :
                                    // Supplemental Plane codepoint (surrogate pair)
                                    String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                        },

                    // Used for iframes
                    // See setDocument()
                    // Removing the function wrapper causes a "Permission Denied"
                    // error in IE
                        unloadHandler = function () {
                            setDocument();
                        };

// Optimize for push.apply( _, NodeList )
                    try {
                        push.apply(
                            (arr = slice.call(preferredDoc.childNodes)),
                            preferredDoc.childNodes
                        );
                        // Support: Android<4.0
                        // Detect silently failing push.apply
                        arr[preferredDoc.childNodes.length].nodeType;
                    } catch (e) {
                        push = {
                            apply: arr.length ?

                                // Leverage slice if possible
                                function (target, els) {
                                    push_native.apply(target, slice.call(els));
                                } :

                                // Support: IE<9
                                // Otherwise append directly
                                function (target, els) {
                                    var j = target.length,
                                        i = 0;
                                    // Can't trust NodeList.length
                                    while ((target[j++] = els[i++])) {
                                    }
                                    target.length = j - 1;
                                }
                        };
                    }

                    function Sizzle(selector, context, results, seed) {
                        var match, elem, m, nodeType,
                        // QSA vars
                            i, groups, old, nid, newContext, newSelector;

                        if (( context ? context.ownerDocument || context : preferredDoc ) !== document) {
                            setDocument(context);
                        }

                        context = context || document;
                        results = results || [];
                        nodeType = context.nodeType;

                        if (typeof selector !== "string" || !selector ||
                            nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                            return results;
                        }

                        if (!seed && documentIsHTML) {

                            // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
                            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                                // Speed-up: Sizzle("#ID")
                                if ((m = match[1])) {
                                    if (nodeType === 9) {
                                        elem = context.getElementById(m);
                                        // Check parentNode to catch when Blackberry 4.6 returns
                                        // nodes that are no longer in the document (jQuery #6963)
                                        if (elem && elem.parentNode) {
                                            // Handle the case where IE, Opera, and Webkit return items
                                            // by name instead of ID
                                            if (elem.id === m) {
                                                results.push(elem);
                                                return results;
                                            }
                                        } else {
                                            return results;
                                        }
                                    } else {
                                        // Context is not a document
                                        if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
                                            contains(context, elem) && elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    }

                                    // Speed-up: Sizzle("TAG")
                                } else if (match[2]) {
                                    push.apply(results, context.getElementsByTagName(selector));
                                    return results;

                                    // Speed-up: Sizzle(".CLASS")
                                } else if ((m = match[3]) && support.getElementsByClassName) {
                                    push.apply(results, context.getElementsByClassName(m));
                                    return results;
                                }
                            }

                            // QSA path
                            if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                                nid = old = expando;
                                newContext = context;
                                newSelector = nodeType !== 1 && selector;

                                // qSA works strangely on Element-rooted queries
                                // We can work around this by specifying an extra ID on the root
                                // and working up from there (Thanks to Andrew Dupont for the technique)
                                // IE 8 doesn't work on object elements
                                if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                                    groups = tokenize(selector);

                                    if ((old = context.getAttribute("id"))) {
                                        nid = old.replace(rescape, "\\$&");
                                    } else {
                                        context.setAttribute("id", nid);
                                    }
                                    nid = "[id='" + nid + "'] ";

                                    i = groups.length;
                                    while (i--) {
                                        groups[i] = nid + toSelector(groups[i]);
                                    }
                                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                                    newSelector = groups.join(",");
                                }

                                if (newSelector) {
                                    try {
                                        push.apply(results,
                                            newContext.querySelectorAll(newSelector)
                                        );
                                        return results;
                                    } catch (qsaError) {
                                    } finally {
                                        if (!old) {
                                            context.removeAttribute("id");
                                        }
                                    }
                                }
                            }
                        }

                        // All others
                        return select(selector.replace(rtrim, "$1"), context, results, seed);
                    }

                    /**
                     * Create key-value caches of limited size
                     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
                     *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                     *    deleting the oldest entry
                     */
                    function createCache() {
                        var keys = [];

                        function cache(key, value) {
                            // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                            if (keys.push(key + " ") > Expr.cacheLength) {
                                // Only keep the most recent entries
                                delete cache[keys.shift()];
                            }
                            return (cache[key + " "] = value);
                        }

                        return cache;
                    }

                    /**
                     * Mark a function for special use by Sizzle
                     * @param {Function} fn The function to mark
                     */
                    function markFunction(fn) {
                        fn[expando] = true;
                        return fn;
                    }

                    /**
                     * Support testing using an element
                     * @param {Function} fn Passed the created div and expects a boolean result
                     */
                    function assert(fn) {
                        var div = document.createElement("div");

                        try {
                            return !!fn(div);
                        } catch (e) {
                            return false;
                        } finally {
                            // Remove from its parent by default
                            if (div.parentNode) {
                                div.parentNode.removeChild(div);
                            }
                            // release memory in IE
                            div = null;
                        }
                    }

                    /**
                     * Adds the same handler for all of the specified attrs
                     * @param {String} attrs Pipe-separated list of attributes
                     * @param {Function} handler The method that will be applied
                     */
                    function addHandle(attrs, handler) {
                        var arr = attrs.split("|"),
                            i = attrs.length;

                        while (i--) {
                            Expr.attrHandle[arr[i]] = handler;
                        }
                    }

                    /**
                     * Checks document order of two siblings
                     * @param {Element} a
                     * @param {Element} b
                     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                     */
                    function siblingCheck(a, b) {
                        var cur = b && a,
                            diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                                ( ~b.sourceIndex || MAX_NEGATIVE ) -
                                ( ~a.sourceIndex || MAX_NEGATIVE );

                        // Use IE sourceIndex if available on both nodes
                        if (diff) {
                            return diff;
                        }

                        // Check if b follows a
                        if (cur) {
                            while ((cur = cur.nextSibling)) {
                                if (cur === b) {
                                    return -1;
                                }
                            }
                        }

                        return a ? 1 : -1;
                    }

                    /**
                     * Returns a function to use in pseudos for input types
                     * @param {String} type
                     */
                    function createInputPseudo(type) {
                        return function (elem) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for buttons
                     * @param {String} type
                     */
                    function createButtonPseudo(type) {
                        return function (elem) {
                            var name = elem.nodeName.toLowerCase();
                            return (name === "input" || name === "button") && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for positionals
                     * @param {Function} fn
                     */
                    function createPositionalPseudo(fn) {
                        return markFunction(function (argument) {
                            argument = +argument;
                            return markFunction(function (seed, matches) {
                                var j,
                                    matchIndexes = fn([], seed.length, argument),
                                    i = matchIndexes.length;

                                // Match elements found at the specified indexes
                                while (i--) {
                                    if (seed[(j = matchIndexes[i])]) {
                                        seed[j] = !(matches[j] = seed[j]);
                                    }
                                }
                            });
                        });
                    }

                    /**
                     * Checks a node for validity as a Sizzle context
                     * @param {Element|Object=} context
                     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                     */
                    function testContext(context) {
                        return context && typeof context.getElementsByTagName !== "undefined" && context;
                    }

// Expose support vars for convenience
                    support = Sizzle.support = {};

                    /**
                     * Detects XML nodes
                     * @param {Element|Object} elem An element or a document
                     * @returns {Boolean} True iff elem is a non-HTML XML node
                     */
                    isXML = Sizzle.isXML = function (elem) {
                        // documentElement is verified for cases where it doesn't yet exist
                        // (such as loading iframes in IE - #4833)
                        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                        return documentElement ? documentElement.nodeName !== "HTML" : false;
                    };

                    /**
                     * Sets document-related variables once based on the current document
                     * @param {Element|Object} [doc] An element or document object to use to set the document
                     * @returns {Object} Returns the current document
                     */
                    setDocument = Sizzle.setDocument = function (node) {
                        var hasCompare, parent,
                            doc = node ? node.ownerDocument || node : preferredDoc;

                        // If no document and documentElement is available, return
                        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                            return document;
                        }

                        // Set our document
                        document = doc;
                        docElem = doc.documentElement;
                        parent = doc.defaultView;

                        // Support: IE>8
                        // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                        // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                        // IE6-8 do not support the defaultView property so parent will be undefined
                        if (parent && parent !== parent.top) {
                            // IE11 does not have attachEvent, so all must suffer
                            if (parent.addEventListener) {
                                parent.addEventListener("unload", unloadHandler, false);
                            } else if (parent.attachEvent) {
                                parent.attachEvent("onunload", unloadHandler);
                            }
                        }

                        /* Support tests
                         ---------------------------------------------------------------------- */
                        documentIsHTML = !isXML(doc);

                        /* Attributes
                         ---------------------------------------------------------------------- */

                        // Support: IE<8
                        // Verify that getAttribute really returns attributes and not properties
                        // (excepting IE8 booleans)
                        support.attributes = assert(function (div) {
                            div.className = "i";
                            return !div.getAttribute("className");
                        });

                        /* getElement(s)By*
                         ---------------------------------------------------------------------- */

                        // Check if getElementsByTagName("*") returns only elements
                        support.getElementsByTagName = assert(function (div) {
                            div.appendChild(doc.createComment(""));
                            return !div.getElementsByTagName("*").length;
                        });

                        // Support: IE<9
                        support.getElementsByClassName = rnative.test(doc.getElementsByClassName);

                        // Support: IE<10
                        // Check if getElementById returns elements by name
                        // The broken getElementById methods don't pick up programatically-set names,
                        // so use a roundabout getElementsByName test
                        support.getById = assert(function (div) {
                            docElem.appendChild(div).id = expando;
                            return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                        });

                        // ID find and filter
                        if (support.getById) {
                            Expr.find["ID"] = function (id, context) {
                                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                    var m = context.getElementById(id);
                                    // Check parentNode to catch when Blackberry 4.6 returns
                                    // nodes that are no longer in the document #6963
                                    return m && m.parentNode ? [m] : [];
                                }
                            };
                            Expr.filter["ID"] = function (id) {
                                var attrId = id.replace(runescape, funescape);
                                return function (elem) {
                                    return elem.getAttribute("id") === attrId;
                                };
                            };
                        } else {
                            // Support: IE6/7
                            // getElementById is not reliable as a find shortcut
                            delete Expr.find["ID"];

                            Expr.filter["ID"] = function (id) {
                                var attrId = id.replace(runescape, funescape);
                                return function (elem) {
                                    var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                                    return node && node.value === attrId;
                                };
                            };
                        }

                        // Tag
                        Expr.find["TAG"] = support.getElementsByTagName ?
                            function (tag, context) {
                                if (typeof context.getElementsByTagName !== "undefined") {
                                    return context.getElementsByTagName(tag);

                                    // DocumentFragment nodes don't have gEBTN
                                } else if (support.qsa) {
                                    return context.querySelectorAll(tag);
                                }
                            } :

                            function (tag, context) {
                                var elem,
                                    tmp = [],
                                    i = 0,
                                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                    results = context.getElementsByTagName(tag);

                                // Filter out possible comments
                                if (tag === "*") {
                                    while ((elem = results[i++])) {
                                        if (elem.nodeType === 1) {
                                            tmp.push(elem);
                                        }
                                    }

                                    return tmp;
                                }
                                return results;
                            };

                        // Class
                        Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
                            if (documentIsHTML) {
                                return context.getElementsByClassName(className);
                            }
                        };

                        /* QSA/matchesSelector
                         ---------------------------------------------------------------------- */

                        // QSA and matchesSelector support

                        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                        rbuggyMatches = [];

                        // qSa(:focus) reports false when true (Chrome 21)
                        // We allow this because of a bug in IE8/9 that throws an error
                        // whenever `document.activeElement` is accessed on an iframe
                        // So, we allow :focus to pass through QSA all the time to avoid the IE error
                        // See http://bugs.jquery.com/ticket/13378
                        rbuggyQSA = [];

                        if ((support.qsa = rnative.test(doc.querySelectorAll))) {
                            // Build QSA regex
                            // Regex strategy adopted from Diego Perini
                            assert(function (div) {
                                // Select is set to empty string on purpose
                                // This is to test IE's treatment of not explicitly
                                // setting a boolean content attribute,
                                // since its presence should be enough
                                // http://bugs.jquery.com/ticket/12359
                                docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" +
                                "<select id='" + expando + "-\f]' msallowcapture=''>" +
                                "<option selected=''></option></select>";

                                // Support: IE8, Opera 11-12.16
                                // Nothing should be selected when empty strings follow ^= or $= or *=
                                // The test attribute must be unknown in Opera but "safe" for WinRT
                                // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                if (div.querySelectorAll("[msallowcapture^='']").length) {
                                    rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                                }

                                // Support: IE8
                                // Boolean attributes and "value" are not treated correctly
                                if (!div.querySelectorAll("[selected]").length) {
                                    rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                                }

                                // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
                                if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                                    rbuggyQSA.push("~=");
                                }

                                // Webkit/Opera - :checked should return selected option elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                // IE8 throws error here and will not see later tests
                                if (!div.querySelectorAll(":checked").length) {
                                    rbuggyQSA.push(":checked");
                                }

                                // Support: Safari 8+, iOS 8+
                                // https://bugs.webkit.org/show_bug.cgi?id=136851
                                // In-page `selector#id sibing-combinator selector` fails
                                if (!div.querySelectorAll("a#" + expando + "+*").length) {
                                    rbuggyQSA.push(".#.+[+~]");
                                }
                            });

                            assert(function (div) {
                                // Support: Windows 8 Native Apps
                                // The type and name attributes are restricted during .innerHTML assignment
                                var input = doc.createElement("input");
                                input.setAttribute("type", "hidden");
                                div.appendChild(input).setAttribute("name", "D");

                                // Support: IE8
                                // Enforce case-sensitivity of name attribute
                                if (div.querySelectorAll("[name=d]").length) {
                                    rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                                }

                                // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                // IE8 throws error here and will not see later tests
                                if (!div.querySelectorAll(":enabled").length) {
                                    rbuggyQSA.push(":enabled", ":disabled");
                                }

                                // Opera 10-11 does not throw on post-comma invalid pseudos
                                div.querySelectorAll("*,:x");
                                rbuggyQSA.push(",.*:");
                            });
                        }

                        if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                            docElem.webkitMatchesSelector ||
                            docElem.mozMatchesSelector ||
                            docElem.oMatchesSelector ||
                            docElem.msMatchesSelector)))) {

                            assert(function (div) {
                                // Check to see if it's possible to do matchesSelector
                                // on a disconnected node (IE 9)
                                support.disconnectedMatch = matches.call(div, "div");

                                // This should fail with an exception
                                // Gecko does not error, returns false instead
                                matches.call(div, "[s!='']:x");
                                rbuggyMatches.push("!=", pseudos);
                            });
                        }

                        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                        /* Contains
                         ---------------------------------------------------------------------- */
                        hasCompare = rnative.test(docElem.compareDocumentPosition);

                        // Element contains another
                        // Purposefully does not implement inclusive descendent
                        // As in, an element does not contain itself
                        contains = hasCompare || rnative.test(docElem.contains) ?
                            function (a, b) {
                                var adown = a.nodeType === 9 ? a.documentElement : a,
                                    bup = b && b.parentNode;
                                return a === bup || !!( bup && bup.nodeType === 1 && (
                                        adown.contains ?
                                            adown.contains(bup) :
                                        a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                                    ));
                            } :
                            function (a, b) {
                                if (b) {
                                    while ((b = b.parentNode)) {
                                        if (b === a) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            };

                        /* Sorting
                         ---------------------------------------------------------------------- */

                        // Document order sorting
                        sortOrder = hasCompare ?
                            function (a, b) {

                                // Flag for duplicate removal
                                if (a === b) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                // Sort on method existence if only one input has compareDocumentPosition
                                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                                if (compare) {
                                    return compare;
                                }

                                // Calculate position if both inputs belong to the same document
                                compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                                    a.compareDocumentPosition(b) :

                                    // Otherwise we know they are disconnected
                                    1;

                                // Disconnected nodes
                                if (compare & 1 ||
                                    (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                                    // Choose the first element that is related to our preferred document
                                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                        return -1;
                                    }
                                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                        return 1;
                                    }

                                    // Maintain original order
                                    return sortInput ?
                                        ( indexOf(sortInput, a) - indexOf(sortInput, b) ) :
                                        0;
                                }

                                return compare & 4 ? -1 : 1;
                            } :
                            function (a, b) {
                                // Exit early if the nodes are identical
                                if (a === b) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                var cur,
                                    i = 0,
                                    aup = a.parentNode,
                                    bup = b.parentNode,
                                    ap = [a],
                                    bp = [b];

                                // Parentless nodes are either documents or disconnected
                                if (!aup || !bup) {
                                    return a === doc ? -1 :
                                        b === doc ? 1 :
                                            aup ? -1 :
                                                bup ? 1 :
                                                    sortInput ?
                                                        ( indexOf(sortInput, a) - indexOf(sortInput, b) ) :
                                                        0;

                                    // If the nodes are siblings, we can do a quick check
                                } else if (aup === bup) {
                                    return siblingCheck(a, b);
                                }

                                // Otherwise we need full lists of their ancestors for comparison
                                cur = a;
                                while ((cur = cur.parentNode)) {
                                    ap.unshift(cur);
                                }
                                cur = b;
                                while ((cur = cur.parentNode)) {
                                    bp.unshift(cur);
                                }

                                // Walk down the tree looking for a discrepancy
                                while (ap[i] === bp[i]) {
                                    i++;
                                }

                                return i ?
                                    // Do a sibling check if the nodes have a common ancestor
                                    siblingCheck(ap[i], bp[i]) :

                                    // Otherwise nodes in our document sort first
                                    ap[i] === preferredDoc ? -1 :
                                        bp[i] === preferredDoc ? 1 :
                                            0;
                            };

                        return doc;
                    };

                    Sizzle.matches = function (expr, elements) {
                        return Sizzle(expr, null, null, elements);
                    };

                    Sizzle.matchesSelector = function (elem, expr) {
                        // Set document vars if needed
                        if (( elem.ownerDocument || elem ) !== document) {
                            setDocument(elem);
                        }

                        // Make sure that attribute selectors are quoted
                        expr = expr.replace(rattributeQuotes, "='$1']");

                        if (support.matchesSelector && documentIsHTML &&
                            ( !rbuggyMatches || !rbuggyMatches.test(expr) ) &&
                            ( !rbuggyQSA || !rbuggyQSA.test(expr) )) {

                            try {
                                var ret = matches.call(elem, expr);

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || support.disconnectedMatch ||
                                        // As well, disconnected nodes are said to be in a document
                                        // fragment in IE 9
                                    elem.document && elem.document.nodeType !== 11) {
                                    return ret;
                                }
                            } catch (e) {
                            }
                        }

                        return Sizzle(expr, document, null, [elem]).length > 0;
                    };

                    Sizzle.contains = function (context, elem) {
                        // Set document vars if needed
                        if (( context.ownerDocument || context ) !== document) {
                            setDocument(context);
                        }
                        return contains(context, elem);
                    };

                    Sizzle.attr = function (elem, name) {
                        // Set document vars if needed
                        if (( elem.ownerDocument || elem ) !== document) {
                            setDocument(elem);
                        }

                        var fn = Expr.attrHandle[name.toLowerCase()],
                        // Don't get fooled by Object.prototype properties (jQuery #13807)
                            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                                fn(elem, name, !documentIsHTML) :
                                undefined;

                        return val !== undefined ?
                            val :
                            support.attributes || !documentIsHTML ?
                                elem.getAttribute(name) :
                                (val = elem.getAttributeNode(name)) && val.specified ?
                                    val.value :
                                    null;
                    };

                    Sizzle.error = function (msg) {
                        throw new Error("Syntax error, unrecognized expression: " + msg);
                    };

                    /**
                     * Document sorting and removing duplicates
                     * @param {ArrayLike} results
                     */
                    Sizzle.uniqueSort = function (results) {
                        var elem,
                            duplicates = [],
                            j = 0,
                            i = 0;

                        // Unless we *know* we can detect duplicates, assume their presence
                        hasDuplicate = !support.detectDuplicates;
                        sortInput = !support.sortStable && results.slice(0);
                        results.sort(sortOrder);

                        if (hasDuplicate) {
                            while ((elem = results[i++])) {
                                if (elem === results[i]) {
                                    j = duplicates.push(i);
                                }
                            }
                            while (j--) {
                                results.splice(duplicates[j], 1);
                            }
                        }

                        // Clear input after sorting to release objects
                        // See https://github.com/jquery/sizzle/pull/225
                        sortInput = null;

                        return results;
                    };

                    /**
                     * Utility function for retrieving the text value of an array of DOM nodes
                     * @param {Array|Element} elem
                     */
                    getText = Sizzle.getText = function (elem) {
                        var node,
                            ret = "",
                            i = 0,
                            nodeType = elem.nodeType;

                        if (!nodeType) {
                            // If no nodeType, this is expected to be an array
                            while ((node = elem[i++])) {
                                // Do not traverse comment nodes
                                ret += getText(node);
                            }
                        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                            // Use textContent for elements
                            // innerText usage removed for consistency of new lines (jQuery #11153)
                            if (typeof elem.textContent === "string") {
                                return elem.textContent;
                            } else {
                                // Traverse its children
                                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                    ret += getText(elem);
                                }
                            }
                        } else if (nodeType === 3 || nodeType === 4) {
                            return elem.nodeValue;
                        }
                        // Do not include comment or processing instruction nodes

                        return ret;
                    };

                    Expr = Sizzle.selectors = {

                        // Can be adjusted by the user
                        cacheLength: 50,

                        createPseudo: markFunction,

                        match: matchExpr,

                        attrHandle: {},

                        find: {},

                        relative: {
                            ">": {dir: "parentNode", first: true},
                            " ": {dir: "parentNode"},
                            "+": {dir: "previousSibling", first: true},
                            "~": {dir: "previousSibling"}
                        },

                        preFilter: {
                            "ATTR": function (match) {
                                match[1] = match[1].replace(runescape, funescape);

                                // Move the given value to match[3] whether quoted or unquoted
                                match[3] = ( match[3] || match[4] || match[5] || "" ).replace(runescape, funescape);

                                if (match[2] === "~=") {
                                    match[3] = " " + match[3] + " ";
                                }

                                return match.slice(0, 4);
                            },

                            "CHILD": function (match) {
                                /* matches from matchExpr["CHILD"]
                                 1 type (only|nth|...)
                                 2 what (child|of-type)
                                 3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                                 4 xn-component of xn+y argument ([+-]?\d*n|)
                                 5 sign of xn-component
                                 6 x of xn-component
                                 7 sign of y-component
                                 8 y of y-component
                                 */
                                match[1] = match[1].toLowerCase();

                                if (match[1].slice(0, 3) === "nth") {
                                    // nth-* requires argument
                                    if (!match[3]) {
                                        Sizzle.error(match[0]);
                                    }

                                    // numeric x and y parameters for Expr.filter.CHILD
                                    // remember that false/true cast respectively to 0/1
                                    match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                                    match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

                                    // other types prohibit arguments
                                } else if (match[3]) {
                                    Sizzle.error(match[0]);
                                }

                                return match;
                            },

                            "PSEUDO": function (match) {
                                var excess,
                                    unquoted = !match[6] && match[2];

                                if (matchExpr["CHILD"].test(match[0])) {
                                    return null;
                                }

                                // Accept quoted arguments as-is
                                if (match[3]) {
                                    match[2] = match[4] || match[5] || "";

                                    // Strip excess characters from unquoted arguments
                                } else if (unquoted && rpseudo.test(unquoted) &&
                                        // Get excess from tokenize (recursively)
                                    (excess = tokenize(unquoted, true)) &&
                                        // advance to the next closing parenthesis
                                    (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                                    // excess is a negative index
                                    match[0] = match[0].slice(0, excess);
                                    match[2] = unquoted.slice(0, excess);
                                }

                                // Return only captures needed by the pseudo filter method (type and argument)
                                return match.slice(0, 3);
                            }
                        },

                        filter: {

                            "TAG": function (nodeNameSelector) {
                                var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                                return nodeNameSelector === "*" ?
                                    function () {
                                        return true;
                                    } :
                                    function (elem) {
                                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                    };
                            },

                            "CLASS": function (className) {
                                var pattern = classCache[className + " "];

                                return pattern ||
                                    (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                                    classCache(className, function (elem) {
                                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                                    });
                            },

                            "ATTR": function (name, operator, check) {
                                return function (elem) {
                                    var result = Sizzle.attr(elem, name);

                                    if (result == null) {
                                        return operator === "!=";
                                    }
                                    if (!operator) {
                                        return true;
                                    }

                                    result += "";

                                    return operator === "=" ? result === check :
                                        operator === "!=" ? result !== check :
                                            operator === "^=" ? check && result.indexOf(check) === 0 :
                                                operator === "*=" ? check && result.indexOf(check) > -1 :
                                                    operator === "$=" ? check && result.slice(-check.length) === check :
                                                        operator === "~=" ? ( " " + result.replace(rwhitespace, " ") + " " ).indexOf(check) > -1 :
                                                            operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                                                false;
                                };
                            },

                            "CHILD": function (type, what, argument, first, last) {
                                var simple = type.slice(0, 3) !== "nth",
                                    forward = type.slice(-4) !== "last",
                                    ofType = what === "of-type";

                                return first === 1 && last === 0 ?

                                    // Shortcut for :nth-*(n)
                                    function (elem) {
                                        return !!elem.parentNode;
                                    } :

                                    function (elem, context, xml) {
                                        var cache, outerCache, node, diff, nodeIndex, start,
                                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                                            parent = elem.parentNode,
                                            name = ofType && elem.nodeName.toLowerCase(),
                                            useCache = !xml && !ofType;

                                        if (parent) {

                                            // :(first|last|only)-(child|of-type)
                                            if (simple) {
                                                while (dir) {
                                                    node = elem;
                                                    while ((node = node[dir])) {
                                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                            return false;
                                                        }
                                                    }
                                                    // Reverse direction for :only-* (if we haven't yet done so)
                                                    start = dir = type === "only" && !start && "nextSibling";
                                                }
                                                return true;
                                            }

                                            start = [forward ? parent.firstChild : parent.lastChild];

                                            // non-xml :nth-child(...) stores cache data on `parent`
                                            if (forward && useCache) {
                                                // Seek `elem` from a previously-cached index
                                                outerCache = parent[expando] || (parent[expando] = {});
                                                cache = outerCache[type] || [];
                                                nodeIndex = cache[0] === dirruns && cache[1];
                                                diff = cache[0] === dirruns && cache[2];
                                                node = nodeIndex && parent.childNodes[nodeIndex];

                                                while ((node = ++nodeIndex && node && node[dir] ||

                                                    // Fallback to seeking `elem` from the start
                                                (diff = nodeIndex = 0) || start.pop())) {

                                                    // When found, cache indexes on `parent` and break
                                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                                        outerCache[type] = [dirruns, nodeIndex, diff];
                                                        break;
                                                    }
                                                }

                                                // Use previously-cached element index if available
                                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                                diff = cache[1];

                                                // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                            } else {
                                                // Use the same loop as above to seek `elem` from the start
                                                while ((node = ++nodeIndex && node && node[dir] ||
                                                (diff = nodeIndex = 0) || start.pop())) {

                                                    if (( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff) {
                                                        // Cache the index of each encountered element
                                                        if (useCache) {
                                                            (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                                                        }

                                                        if (node === elem) {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }

                                            // Incorporate the offset, then check against cycle size
                                            diff -= last;
                                            return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                        }
                                    };
                            },

                            "PSEUDO": function (pseudo, argument) {
                                // pseudo-class names are case-insensitive
                                // http://www.w3.org/TR/selectors/#pseudo-classes
                                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                // Remember that setFilters inherits from pseudos
                                var args,
                                    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                        Sizzle.error("unsupported pseudo: " + pseudo);

                                // The user may use createPseudo to indicate that
                                // arguments are needed to create the filter function
                                // just as Sizzle does
                                if (fn[expando]) {
                                    return fn(argument);
                                }

                                // But maintain support for old signatures
                                if (fn.length > 1) {
                                    args = [pseudo, pseudo, "", argument];
                                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                        markFunction(function (seed, matches) {
                                            var idx,
                                                matched = fn(seed, argument),
                                                i = matched.length;
                                            while (i--) {
                                                idx = indexOf(seed, matched[i]);
                                                seed[idx] = !( matches[idx] = matched[i] );
                                            }
                                        }) :
                                        function (elem) {
                                            return fn(elem, 0, args);
                                        };
                                }

                                return fn;
                            }
                        },

                        pseudos: {
                            // Potentially complex pseudos
                            "not": markFunction(function (selector) {
                                // Trim the selector passed to compile
                                // to avoid treating leading and trailing
                                // spaces as combinators
                                var input = [],
                                    results = [],
                                    matcher = compile(selector.replace(rtrim, "$1"));

                                return matcher[expando] ?
                                    markFunction(function (seed, matches, context, xml) {
                                        var elem,
                                            unmatched = matcher(seed, null, xml, []),
                                            i = seed.length;

                                        // Match elements unmatched by `matcher`
                                        while (i--) {
                                            if ((elem = unmatched[i])) {
                                                seed[i] = !(matches[i] = elem);
                                            }
                                        }
                                    }) :
                                    function (elem, context, xml) {
                                        input[0] = elem;
                                        matcher(input, null, xml, results);
                                        // Don't keep the element (issue #299)
                                        input[0] = null;
                                        return !results.pop();
                                    };
                            }),

                            "has": markFunction(function (selector) {
                                return function (elem) {
                                    return Sizzle(selector, elem).length > 0;
                                };
                            }),

                            "contains": markFunction(function (text) {
                                text = text.replace(runescape, funescape);
                                return function (elem) {
                                    return ( elem.textContent || elem.innerText || getText(elem) ).indexOf(text) > -1;
                                };
                            }),

                            // "Whether an element is represented by a :lang() selector
                            // is based solely on the element's language value
                            // being equal to the identifier C,
                            // or beginning with the identifier C immediately followed by "-".
                            // The matching of C against the element's language value is performed case-insensitively.
                            // The identifier C does not have to be a valid language name."
                            // http://www.w3.org/TR/selectors/#lang-pseudo
                            "lang": markFunction(function (lang) {
                                // lang value must be a valid identifier
                                if (!ridentifier.test(lang || "")) {
                                    Sizzle.error("unsupported lang: " + lang);
                                }
                                lang = lang.replace(runescape, funescape).toLowerCase();
                                return function (elem) {
                                    var elemLang;
                                    do {
                                        if ((elemLang = documentIsHTML ?
                                                elem.lang :
                                            elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                            elemLang = elemLang.toLowerCase();
                                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                        }
                                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                    return false;
                                };
                            }),

                            // Miscellaneous
                            "target": function (elem) {
                                var hash = window.location && window.location.hash;
                                return hash && hash.slice(1) === elem.id;
                            },

                            "root": function (elem) {
                                return elem === docElem;
                            },

                            "focus": function (elem) {
                                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                            },

                            // Boolean properties
                            "enabled": function (elem) {
                                return elem.disabled === false;
                            },

                            "disabled": function (elem) {
                                return elem.disabled === true;
                            },

                            "checked": function (elem) {
                                // In CSS3, :checked should return both checked and selected elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                var nodeName = elem.nodeName.toLowerCase();
                                return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                            },

                            "selected": function (elem) {
                                // Accessing this property makes selected-by-default
                                // options in Safari work properly
                                if (elem.parentNode) {
                                    elem.parentNode.selectedIndex;
                                }

                                return elem.selected === true;
                            },

                            // Contents
                            "empty": function (elem) {
                                // http://www.w3.org/TR/selectors/#empty-pseudo
                                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                //   but not by others (comment: 8; processing instruction: 7; etc.)
                                // nodeType < 6 works because attributes (2) do not appear as children
                                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                    if (elem.nodeType < 6) {
                                        return false;
                                    }
                                }
                                return true;
                            },

                            "parent": function (elem) {
                                return !Expr.pseudos["empty"](elem);
                            },

                            // Element/input types
                            "header": function (elem) {
                                return rheader.test(elem.nodeName);
                            },

                            "input": function (elem) {
                                return rinputs.test(elem.nodeName);
                            },

                            "button": function (elem) {
                                var name = elem.nodeName.toLowerCase();
                                return name === "input" && elem.type === "button" || name === "button";
                            },

                            "text": function (elem) {
                                var attr;
                                return elem.nodeName.toLowerCase() === "input" &&
                                    elem.type === "text" &&

                                        // Support: IE<8
                                        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                    ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                            },

                            // Position-in-collection
                            "first": createPositionalPseudo(function () {
                                return [0];
                            }),

                            "last": createPositionalPseudo(function (matchIndexes, length) {
                                return [length - 1];
                            }),

                            "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
                                return [argument < 0 ? argument + length : argument];
                            }),

                            "even": createPositionalPseudo(function (matchIndexes, length) {
                                var i = 0;
                                for (; i < length; i += 2) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "odd": createPositionalPseudo(function (matchIndexes, length) {
                                var i = 1;
                                for (; i < length; i += 2) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
                                var i = argument < 0 ? argument + length : argument;
                                for (; --i >= 0;) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
                                var i = argument < 0 ? argument + length : argument;
                                for (; ++i < length;) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            })
                        }
                    };

                    Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
                    for (i in {radio: true, checkbox: true, file: true, password: true, image: true}) {
                        Expr.pseudos[i] = createInputPseudo(i);
                    }
                    for (i in {submit: true, reset: true}) {
                        Expr.pseudos[i] = createButtonPseudo(i);
                    }

// Easy API for creating new setFilters
                    function setFilters() {
                    }

                    setFilters.prototype = Expr.filters = Expr.pseudos;
                    Expr.setFilters = new setFilters();

                    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                        var matched, match, tokens, type,
                            soFar, groups, preFilters,
                            cached = tokenCache[selector + " "];

                        if (cached) {
                            return parseOnly ? 0 : cached.slice(0);
                        }

                        soFar = selector;
                        groups = [];
                        preFilters = Expr.preFilter;

                        while (soFar) {

                            // Comma and first run
                            if (!matched || (match = rcomma.exec(soFar))) {
                                if (match) {
                                    // Don't consume trailing commas as valid
                                    soFar = soFar.slice(match[0].length) || soFar;
                                }
                                groups.push((tokens = []));
                            }

                            matched = false;

                            // Combinators
                            if ((match = rcombinators.exec(soFar))) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    // Cast descendant combinators to space
                                    type: match[0].replace(rtrim, " ")
                                });
                                soFar = soFar.slice(matched.length);
                            }

                            // Filters
                            for (type in Expr.filter) {
                                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                                    (match = preFilters[type](match)))) {
                                    matched = match.shift();
                                    tokens.push({
                                        value: matched,
                                        type: type,
                                        matches: match
                                    });
                                    soFar = soFar.slice(matched.length);
                                }
                            }

                            if (!matched) {
                                break;
                            }
                        }

                        // Return the length of the invalid excess
                        // if we're just parsing
                        // Otherwise, throw an error or return tokens
                        return parseOnly ?
                            soFar.length :
                            soFar ?
                                Sizzle.error(selector) :
                                // Cache the tokens
                                tokenCache(selector, groups).slice(0);
                    };

                    function toSelector(tokens) {
                        var i = 0,
                            len = tokens.length,
                            selector = "";
                        for (; i < len; i++) {
                            selector += tokens[i].value;
                        }
                        return selector;
                    }

                    function addCombinator(matcher, combinator, base) {
                        var dir = combinator.dir,
                            checkNonElements = base && dir === "parentNode",
                            doneName = done++;

                        return combinator.first ?
                            // Check against closest ancestor/preceding element
                            function (elem, context, xml) {
                                while ((elem = elem[dir])) {
                                    if (elem.nodeType === 1 || checkNonElements) {
                                        return matcher(elem, context, xml);
                                    }
                                }
                            } :

                            // Check against all ancestor/preceding elements
                            function (elem, context, xml) {
                                var oldCache, outerCache,
                                    newCache = [dirruns, doneName];

                                // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                                if (xml) {
                                    while ((elem = elem[dir])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            if (matcher(elem, context, xml)) {
                                                return true;
                                            }
                                        }
                                    }
                                } else {
                                    while ((elem = elem[dir])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            outerCache = elem[expando] || (elem[expando] = {});
                                            if ((oldCache = outerCache[dir]) &&
                                                oldCache[0] === dirruns && oldCache[1] === doneName) {

                                                // Assign to newCache so results back-propagate to previous elements
                                                return (newCache[2] = oldCache[2]);
                                            } else {
                                                // Reuse newcache so results back-propagate to previous elements
                                                outerCache[dir] = newCache;

                                                // A match means we're done; a fail means we have to keep checking
                                                if ((newCache[2] = matcher(elem, context, xml))) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                    }

                    function elementMatcher(matchers) {
                        return matchers.length > 1 ?
                            function (elem, context, xml) {
                                var i = matchers.length;
                                while (i--) {
                                    if (!matchers[i](elem, context, xml)) {
                                        return false;
                                    }
                                }
                                return true;
                            } :
                            matchers[0];
                    }

                    function multipleContexts(selector, contexts, results) {
                        var i = 0,
                            len = contexts.length;
                        for (; i < len; i++) {
                            Sizzle(selector, contexts[i], results);
                        }
                        return results;
                    }

                    function condense(unmatched, map, filter, context, xml) {
                        var elem,
                            newUnmatched = [],
                            i = 0,
                            len = unmatched.length,
                            mapped = map != null;

                        for (; i < len; i++) {
                            if ((elem = unmatched[i])) {
                                if (!filter || filter(elem, context, xml)) {
                                    newUnmatched.push(elem);
                                    if (mapped) {
                                        map.push(i);
                                    }
                                }
                            }
                        }

                        return newUnmatched;
                    }

                    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                        if (postFilter && !postFilter[expando]) {
                            postFilter = setMatcher(postFilter);
                        }
                        if (postFinder && !postFinder[expando]) {
                            postFinder = setMatcher(postFinder, postSelector);
                        }
                        return markFunction(function (seed, results, context, xml) {
                            var temp, i, elem,
                                preMap = [],
                                postMap = [],
                                preexisting = results.length,

                            // Get initial elements from seed or context
                                elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                            // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                matcherIn = preFilter && ( seed || !selector ) ?
                                    condense(elems, preMap, preFilter, context, xml) :
                                    elems,

                                matcherOut = matcher ?
                                    // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                    postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                        // ...intermediate processing is necessary
                                        [] :

                                        // ...otherwise use results directly
                                        results :
                                    matcherIn;

                            // Find primary matches
                            if (matcher) {
                                matcher(matcherIn, matcherOut, context, xml);
                            }

                            // Apply postFilter
                            if (postFilter) {
                                temp = condense(matcherOut, postMap);
                                postFilter(temp, [], context, xml);

                                // Un-match failing elements by moving them back to matcherIn
                                i = temp.length;
                                while (i--) {
                                    if ((elem = temp[i])) {
                                        matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                                    }
                                }
                            }

                            if (seed) {
                                if (postFinder || preFilter) {
                                    if (postFinder) {
                                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                        temp = [];
                                        i = matcherOut.length;
                                        while (i--) {
                                            if ((elem = matcherOut[i])) {
                                                // Restore matcherIn since elem is not yet a final match
                                                temp.push((matcherIn[i] = elem));
                                            }
                                        }
                                        postFinder(null, (matcherOut = []), temp, xml);
                                    }

                                    // Move matched elements from seed to results to keep them synchronized
                                    i = matcherOut.length;
                                    while (i--) {
                                        if ((elem = matcherOut[i]) &&
                                            (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                            seed[temp] = !(results[temp] = elem);
                                        }
                                    }
                                }

                                // Add elements to results, through postFinder if defined
                            } else {
                                matcherOut = condense(
                                    matcherOut === results ?
                                        matcherOut.splice(preexisting, matcherOut.length) :
                                        matcherOut
                                );
                                if (postFinder) {
                                    postFinder(null, results, matcherOut, xml);
                                } else {
                                    push.apply(results, matcherOut);
                                }
                            }
                        });
                    }

                    function matcherFromTokens(tokens) {
                        var checkContext, matcher, j,
                            len = tokens.length,
                            leadingRelative = Expr.relative[tokens[0].type],
                            implicitRelative = leadingRelative || Expr.relative[" "],
                            i = leadingRelative ? 1 : 0,

                        // The foundational matcher ensures that elements are reachable from top-level context(s)
                            matchContext = addCombinator(function (elem) {
                                return elem === checkContext;
                            }, implicitRelative, true),
                            matchAnyContext = addCombinator(function (elem) {
                                return indexOf(checkContext, elem) > -1;
                            }, implicitRelative, true),
                            matchers = [function (elem, context, xml) {
                                var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                                        (checkContext = context).nodeType ?
                                            matchContext(elem, context, xml) :
                                            matchAnyContext(elem, context, xml) );
                                // Avoid hanging onto element (issue #299)
                                checkContext = null;
                                return ret;
                            }];

                        for (; i < len; i++) {
                            if ((matcher = Expr.relative[tokens[i].type])) {
                                matchers = [addCombinator(elementMatcher(matchers), matcher)];
                            } else {
                                matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                                // Return special upon seeing a positional matcher
                                if (matcher[expando]) {
                                    // Find the next relative operator (if any) for proper handling
                                    j = ++i;
                                    for (; j < len; j++) {
                                        if (Expr.relative[tokens[j].type]) {
                                            break;
                                        }
                                    }
                                    return setMatcher(
                                        i > 1 && elementMatcher(matchers),
                                        i > 1 && toSelector(
                                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                            tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})
                                        ).replace(rtrim, "$1"),
                                        matcher,
                                        i < j && matcherFromTokens(tokens.slice(i, j)),
                                        j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                        j < len && toSelector(tokens)
                                    );
                                }
                                matchers.push(matcher);
                            }
                        }

                        return elementMatcher(matchers);
                    }

                    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                        var bySet = setMatchers.length > 0,
                            byElement = elementMatchers.length > 0,
                            superMatcher = function (seed, context, xml, results, outermost) {
                                var elem, j, matcher,
                                    matchedCount = 0,
                                    i = "0",
                                    unmatched = seed && [],
                                    setMatched = [],
                                    contextBackup = outermostContext,
                                // We must always have either seed elements or outermost context
                                    elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                                // Use integer dirruns iff this is the outermost matcher
                                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                    len = elems.length;

                                if (outermost) {
                                    outermostContext = context !== document && context;
                                }

                                // Add elements passing elementMatchers directly to results
                                // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                                // Support: IE<9, Safari
                                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                for (; i !== len && (elem = elems[i]) != null; i++) {
                                    if (byElement && elem) {
                                        j = 0;
                                        while ((matcher = elementMatchers[j++])) {
                                            if (matcher(elem, context, xml)) {
                                                results.push(elem);
                                                break;
                                            }
                                        }
                                        if (outermost) {
                                            dirruns = dirrunsUnique;
                                        }
                                    }

                                    // Track unmatched elements for set filters
                                    if (bySet) {
                                        // They will have gone through all possible matchers
                                        if ((elem = !matcher && elem)) {
                                            matchedCount--;
                                        }

                                        // Lengthen the array for every element, matched or not
                                        if (seed) {
                                            unmatched.push(elem);
                                        }
                                    }
                                }

                                // Apply set filters to unmatched elements
                                matchedCount += i;
                                if (bySet && i !== matchedCount) {
                                    j = 0;
                                    while ((matcher = setMatchers[j++])) {
                                        matcher(unmatched, setMatched, context, xml);
                                    }

                                    if (seed) {
                                        // Reintegrate element matches to eliminate the need for sorting
                                        if (matchedCount > 0) {
                                            while (i--) {
                                                if (!(unmatched[i] || setMatched[i])) {
                                                    setMatched[i] = pop.call(results);
                                                }
                                            }
                                        }

                                        // Discard index placeholder values to get only actual matches
                                        setMatched = condense(setMatched);
                                    }

                                    // Add matches to results
                                    push.apply(results, setMatched);

                                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                    if (outermost && !seed && setMatched.length > 0 &&
                                        ( matchedCount + setMatchers.length ) > 1) {

                                        Sizzle.uniqueSort(results);
                                    }
                                }

                                // Override manipulation of globals by nested matchers
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                    outermostContext = contextBackup;
                                }

                                return unmatched;
                            };

                        return bySet ?
                            markFunction(superMatcher) :
                            superMatcher;
                    }

                    compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
                        var i,
                            setMatchers = [],
                            elementMatchers = [],
                            cached = compilerCache[selector + " "];

                        if (!cached) {
                            // Generate a function of recursive functions that can be used to check each element
                            if (!match) {
                                match = tokenize(selector);
                            }
                            i = match.length;
                            while (i--) {
                                cached = matcherFromTokens(match[i]);
                                if (cached[expando]) {
                                    setMatchers.push(cached);
                                } else {
                                    elementMatchers.push(cached);
                                }
                            }

                            // Cache the compiled function
                            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                            // Save selector and tokenization
                            cached.selector = selector;
                        }
                        return cached;
                    };

                    /**
                     * A low-level selection function that works with Sizzle's compiled
                     *  selector functions
                     * @param {String|Function} selector A selector or a pre-compiled
                     *  selector function built with Sizzle.compile
                     * @param {Element} context
                     * @param {Array} [results]
                     * @param {Array} [seed] A set of elements to match against
                     */
                    select = Sizzle.select = function (selector, context, results, seed) {
                        var i, tokens, token, type, find,
                            compiled = typeof selector === "function" && selector,
                            match = !seed && tokenize((selector = compiled.selector || selector));

                        results = results || [];

                        // Try to minimize operations if there is no seed and only one group
                        if (match.length === 1) {

                            // Take a shortcut and set the context if the root selector is an ID
                            tokens = match[0] = match[0].slice(0);
                            if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                                support.getById && context.nodeType === 9 && documentIsHTML &&
                                Expr.relative[tokens[1].type]) {

                                context = ( Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [] )[0];
                                if (!context) {
                                    return results;

                                    // Precompiled matchers will still verify ancestry, so step up a level
                                } else if (compiled) {
                                    context = context.parentNode;
                                }

                                selector = selector.slice(tokens.shift().value.length);
                            }

                            // Fetch a seed set for right-to-left matching
                            i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                            while (i--) {
                                token = tokens[i];

                                // Abort if we hit a combinator
                                if (Expr.relative[(type = token.type)]) {
                                    break;
                                }
                                if ((find = Expr.find[type])) {
                                    // Search, expanding context for leading sibling combinators
                                    if ((seed = find(
                                            token.matches[0].replace(runescape, funescape),
                                            rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                                        ))) {

                                        // If seed is empty or no tokens remain, we can return early
                                        tokens.splice(i, 1);
                                        selector = seed.length && toSelector(tokens);
                                        if (!selector) {
                                            push.apply(results, seed);
                                            return results;
                                        }

                                        break;
                                    }
                                }
                            }
                        }

                        // Compile and execute a filtering function if one is not provided
                        // Provide `match` to avoid retokenization if we modified the selector above
                        ( compiled || compile(selector, match) )(
                            seed,
                            context,
                            !documentIsHTML,
                            results,
                            rsibling.test(selector) && testContext(context.parentNode) || context
                        );
                        return results;
                    };

// One-time assignments

// Sort stability
                    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
                    support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
                    setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
                    support.sortDetached = assert(function (div1) {
                        // Should return 1, but returns 4 (following)
                        return div1.compareDocumentPosition(document.createElement("div")) & 1;
                    });

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                    if (!assert(function (div) {
                            div.innerHTML = "<a href='#'></a>";
                            return div.firstChild.getAttribute("href") === "#";
                        })) {
                        addHandle("type|href|height|width", function (elem, name, isXML) {
                            if (!isXML) {
                                return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                            }
                        });
                    }

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
                    if (!support.attributes || !assert(function (div) {
                            div.innerHTML = "<input/>";
                            div.firstChild.setAttribute("value", "");
                            return div.firstChild.getAttribute("value") === "";
                        })) {
                        addHandle("value", function (elem, name, isXML) {
                            if (!isXML && elem.nodeName.toLowerCase() === "input") {
                                return elem.defaultValue;
                            }
                        });
                    }

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
                    if (!assert(function (div) {
                            return div.getAttribute("disabled") == null;
                        })) {
                        addHandle(booleans, function (elem, name, isXML) {
                            var val;
                            if (!isXML) {
                                return elem[name] === true ? name.toLowerCase() :
                                    (val = elem.getAttributeNode(name)) && val.specified ?
                                        val.value :
                                        null;
                            }
                        });
                    }

                    return Sizzle;

                })(window);


            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[":"] = jQuery.expr.pseudos;
            jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;


            var rneedsContext = jQuery.expr.match.needsContext;

            var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);


            var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
            function winnow(elements, qualifier, not) {
                if (jQuery.isFunction(qualifier)) {
                    return jQuery.grep(elements, function (elem, i) {
                        /* jshint -W018 */
                        return !!qualifier.call(elem, i, elem) !== not;
                    });

                }

                if (qualifier.nodeType) {
                    return jQuery.grep(elements, function (elem) {
                        return ( elem === qualifier ) !== not;
                    });

                }

                if (typeof qualifier === "string") {
                    if (risSimple.test(qualifier)) {
                        return jQuery.filter(qualifier, elements, not);
                    }

                    qualifier = jQuery.filter(qualifier, elements);
                }

                return jQuery.grep(elements, function (elem) {
                    return ( indexOf.call(qualifier, elem) >= 0 ) !== not;
                });
            }

            jQuery.filter = function (expr, elems, not) {
                var elem = elems[0];

                if (not) {
                    expr = ":not(" + expr + ")";
                }

                return elems.length === 1 && elem.nodeType === 1 ?
                    jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
                    jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                        return elem.nodeType === 1;
                    }));
            };

            jQuery.fn.extend({
                find: function (selector) {
                    var i,
                        len = this.length,
                        ret = [],
                        self = this;

                    if (typeof selector !== "string") {
                        return this.pushStack(jQuery(selector).filter(function () {
                            for (i = 0; i < len; i++) {
                                if (jQuery.contains(self[i], this)) {
                                    return true;
                                }
                            }
                        }));
                    }

                    for (i = 0; i < len; i++) {
                        jQuery.find(selector, self[i], ret);
                    }

                    // Needed because $( selector, context ) becomes $( context ).find( selector )
                    ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                    ret.selector = this.selector ? this.selector + " " + selector : selector;
                    return ret;
                },
                filter: function (selector) {
                    return this.pushStack(winnow(this, selector || [], false));
                },
                not: function (selector) {
                    return this.pushStack(winnow(this, selector || [], true));
                },
                is: function (selector) {
                    return !!winnow(
                        this,

                        // If this is a positional/relative selector, check membership in the returned set
                        // so $("p:first").is("p:last") won't return true for a doc with two "p".
                        typeof selector === "string" && rneedsContext.test(selector) ?
                            jQuery(selector) :
                        selector || [],
                        false
                    ).length;
                }
            });


// Initialize a jQuery object


// A central reference to the root jQuery(document)
            var rootjQuery,

            // A simple way to check for HTML strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
            // Strict HTML recognition (#11290: must start with <)
                rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

                init = jQuery.fn.init = function (selector, context) {
                    var match, elem;

                    // HANDLE: $(""), $(null), $(undefined), $(false)
                    if (!selector) {
                        return this;
                    }

                    // Handle HTML strings
                    if (typeof selector === "string") {
                        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                            // Assume that strings that start and end with <> are HTML and skip the regex check
                            match = [null, selector, null];

                        } else {
                            match = rquickExpr.exec(selector);
                        }

                        // Match html or make sure no context is specified for #id
                        if (match && (match[1] || !context)) {

                            // HANDLE: $(html) -> $(array)
                            if (match[1]) {
                                context = context instanceof jQuery ? context[0] : context;

                                // Option to run scripts is true for back-compat
                                // Intentionally let the error be thrown if parseHTML is not present
                                jQuery.merge(this, jQuery.parseHTML(
                                    match[1],
                                    context && context.nodeType ? context.ownerDocument || context : document,
                                    true
                                ));

                                // HANDLE: $(html, props)
                                if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                    for (match in context) {
                                        // Properties of context are called as methods if possible
                                        if (jQuery.isFunction(this[match])) {
                                            this[match](context[match]);

                                            // ...and otherwise set as attributes
                                        } else {
                                            this.attr(match, context[match]);
                                        }
                                    }
                                }

                                return this;

                                // HANDLE: $(#id)
                            } else {
                                elem = document.getElementById(match[2]);

                                // Support: Blackberry 4.6
                                // gEBID returns nodes no longer in the document (#6963)
                                if (elem && elem.parentNode) {
                                    // Inject the element directly into the jQuery object
                                    this.length = 1;
                                    this[0] = elem;
                                }

                                this.context = document;
                                this.selector = selector;
                                return this;
                            }

                            // HANDLE: $(expr, $(...))
                        } else if (!context || context.jquery) {
                            return ( context || rootjQuery ).find(selector);

                            // HANDLE: $(expr, context)
                            // (which is just equivalent to: $(context).find(expr)
                        } else {
                            return this.constructor(context).find(selector);
                        }

                        // HANDLE: $(DOMElement)
                    } else if (selector.nodeType) {
                        this.context = this[0] = selector;
                        this.length = 1;
                        return this;

                        // HANDLE: $(function)
                        // Shortcut for document ready
                    } else if (jQuery.isFunction(selector)) {
                        return typeof rootjQuery.ready !== "undefined" ?
                            rootjQuery.ready(selector) :
                            // Execute immediately if ready is not present
                            selector(jQuery);
                    }

                    if (selector.selector !== undefined) {
                        this.selector = selector.selector;
                        this.context = selector.context;
                    }

                    return jQuery.makeArray(selector, this);
                };

// Give the init function the jQuery prototype for later instantiation
            init.prototype = jQuery.fn;

// Initialize central reference
            rootjQuery = jQuery(document);


            var rparentsprev = /^(?:parents|prev(?:Until|All))/,
            // Methods guaranteed to produce a unique set when starting from a unique set
                guaranteedUnique = {
                    children: true,
                    contents: true,
                    next: true,
                    prev: true
                };

            jQuery.extend({
                dir: function (elem, dir, until) {
                    var matched = [],
                        truncate = until !== undefined;

                    while ((elem = elem[dir]) && elem.nodeType !== 9) {
                        if (elem.nodeType === 1) {
                            if (truncate && jQuery(elem).is(until)) {
                                break;
                            }
                            matched.push(elem);
                        }
                    }
                    return matched;
                },

                sibling: function (n, elem) {
                    var matched = [];

                    for (; n; n = n.nextSibling) {
                        if (n.nodeType === 1 && n !== elem) {
                            matched.push(n);
                        }
                    }

                    return matched;
                }
            });

            jQuery.fn.extend({
                has: function (target) {
                    var targets = jQuery(target, this),
                        l = targets.length;

                    return this.filter(function () {
                        var i = 0;
                        for (; i < l; i++) {
                            if (jQuery.contains(this, targets[i])) {
                                return true;
                            }
                        }
                    });
                },

                closest: function (selectors, context) {
                    var cur,
                        i = 0,
                        l = this.length,
                        matched = [],
                        pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
                            jQuery(selectors, context || this.context) :
                            0;

                    for (; i < l; i++) {
                        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                            // Always skip document fragments
                            if (cur.nodeType < 11 && (pos ?
                                pos.index(cur) > -1 :

                                    // Don't pass non-elements to Sizzle
                                cur.nodeType === 1 &&
                                jQuery.find.matchesSelector(cur, selectors))) {

                                matched.push(cur);
                                break;
                            }
                        }
                    }

                    return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
                },

                // Determine the position of an element within the set
                index: function (elem) {

                    // No argument, return index in parent
                    if (!elem) {
                        return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
                    }

                    // Index in selector
                    if (typeof elem === "string") {
                        return indexOf.call(jQuery(elem), this[0]);
                    }

                    // Locate the position of the desired element
                    return indexOf.call(this,

                        // If it receives a jQuery object, the first element is used
                        elem.jquery ? elem[0] : elem
                    );
                },

                add: function (selector, context) {
                    return this.pushStack(
                        jQuery.unique(
                            jQuery.merge(this.get(), jQuery(selector, context))
                        )
                    );
                },

                addBack: function (selector) {
                    return this.add(selector == null ?
                            this.prevObject : this.prevObject.filter(selector)
                    );
                }
            });

            function sibling(cur, dir) {
                while ((cur = cur[dir]) && cur.nodeType !== 1) {
                }
                return cur;
            }

            jQuery.each({
                parent: function (elem) {
                    var parent = elem.parentNode;
                    return parent && parent.nodeType !== 11 ? parent : null;
                },
                parents: function (elem) {
                    return jQuery.dir(elem, "parentNode");
                },
                parentsUntil: function (elem, i, until) {
                    return jQuery.dir(elem, "parentNode", until);
                },
                next: function (elem) {
                    return sibling(elem, "nextSibling");
                },
                prev: function (elem) {
                    return sibling(elem, "previousSibling");
                },
                nextAll: function (elem) {
                    return jQuery.dir(elem, "nextSibling");
                },
                prevAll: function (elem) {
                    return jQuery.dir(elem, "previousSibling");
                },
                nextUntil: function (elem, i, until) {
                    return jQuery.dir(elem, "nextSibling", until);
                },
                prevUntil: function (elem, i, until) {
                    return jQuery.dir(elem, "previousSibling", until);
                },
                siblings: function (elem) {
                    return jQuery.sibling(( elem.parentNode || {} ).firstChild, elem);
                },
                children: function (elem) {
                    return jQuery.sibling(elem.firstChild);
                },
                contents: function (elem) {
                    return elem.contentDocument || jQuery.merge([], elem.childNodes);
                }
            }, function (name, fn) {
                jQuery.fn[name] = function (until, selector) {
                    var matched = jQuery.map(this, fn, until);

                    if (name.slice(-5) !== "Until") {
                        selector = until;
                    }

                    if (selector && typeof selector === "string") {
                        matched = jQuery.filter(selector, matched);
                    }

                    if (this.length > 1) {
                        // Remove duplicates
                        if (!guaranteedUnique[name]) {
                            jQuery.unique(matched);
                        }

                        // Reverse order for parents* and prev-derivatives
                        if (rparentsprev.test(name)) {
                            matched.reverse();
                        }
                    }

                    return this.pushStack(matched);
                };
            });
            var rnotwhite = (/\S+/g);


// String to Object options format cache
            var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
            function createOptions(options) {
                var object = optionsCache[options] = {};
                jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
                    object[flag] = true;
                });
                return object;
            }

            /*
             * Create a callback list using the following parameters:
             *
             *	options: an optional list of space-separated options that will change how
             *			the callback list behaves or a more traditional option object
             *
             * By default a callback list will act like an event callback list and can be
             * "fired" multiple times.
             *
             * Possible options:
             *
             *	once:			will ensure the callback list can only be fired once (like a Deferred)
             *
             *	memory:			will keep track of previous values and will call any callback added
             *					after the list has been fired right away with the latest "memorized"
             *					values (like a Deferred)
             *
             *	unique:			will ensure a callback can only be added once (no duplicate in the list)
             *
             *	stopOnFalse:	interrupt callings when a callback returns false
             *
             */
            jQuery.Callbacks = function (options) {

                // Convert options from String-formatted to Object-formatted if needed
                // (we check in cache first)
                options = typeof options === "string" ?
                    ( optionsCache[options] || createOptions(options) ) :
                    jQuery.extend({}, options);

                var // Last fire value (for non-forgettable lists)
                    memory,
                // Flag to know if list was already fired
                    fired,
                // Flag to know if list is currently firing
                    firing,
                // First callback to fire (used internally by add and fireWith)
                    firingStart,
                // End of the loop when firing
                    firingLength,
                // Index of currently firing callback (modified by remove if needed)
                    firingIndex,
                // Actual callback list
                    list = [],
                // Stack of fire calls for repeatable lists
                    stack = !options.once && [],
                // Fire callbacks
                    fire = function (data) {
                        memory = options.memory && data;
                        fired = true;
                        firingIndex = firingStart || 0;
                        firingStart = 0;
                        firingLength = list.length;
                        firing = true;
                        for (; list && firingIndex < firingLength; firingIndex++) {
                            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                                memory = false; // To prevent further calls using add
                                break;
                            }
                        }
                        firing = false;
                        if (list) {
                            if (stack) {
                                if (stack.length) {
                                    fire(stack.shift());
                                }
                            } else if (memory) {
                                list = [];
                            } else {
                                self.disable();
                            }
                        }
                    },
                // Actual Callbacks object
                    self = {
                        // Add a callback or a collection of callbacks to the list
                        add: function () {
                            if (list) {
                                // First, we save the current length
                                var start = list.length;
                                (function add(args) {
                                    jQuery.each(args, function (_, arg) {
                                        var type = jQuery.type(arg);
                                        if (type === "function") {
                                            if (!options.unique || !self.has(arg)) {
                                                list.push(arg);
                                            }
                                        } else if (arg && arg.length && type !== "string") {
                                            // Inspect recursively
                                            add(arg);
                                        }
                                    });
                                })(arguments);
                                // Do we need to add the callbacks to the
                                // current firing batch?
                                if (firing) {
                                    firingLength = list.length;
                                    // With memory, if we're not firing then
                                    // we should call right away
                                } else if (memory) {
                                    firingStart = start;
                                    fire(memory);
                                }
                            }
                            return this;
                        },
                        // Remove a callback from the list
                        remove: function () {
                            if (list) {
                                jQuery.each(arguments, function (_, arg) {
                                    var index;
                                    while (( index = jQuery.inArray(arg, list, index) ) > -1) {
                                        list.splice(index, 1);
                                        // Handle firing indexes
                                        if (firing) {
                                            if (index <= firingLength) {
                                                firingLength--;
                                            }
                                            if (index <= firingIndex) {
                                                firingIndex--;
                                            }
                                        }
                                    }
                                });
                            }
                            return this;
                        },
                        // Check if a given callback is in the list.
                        // If no argument is given, return whether or not list has callbacks attached.
                        has: function (fn) {
                            return fn ? jQuery.inArray(fn, list) > -1 : !!( list && list.length );
                        },
                        // Remove all callbacks from the list
                        empty: function () {
                            list = [];
                            firingLength = 0;
                            return this;
                        },
                        // Have the list do nothing anymore
                        disable: function () {
                            list = stack = memory = undefined;
                            return this;
                        },
                        // Is it disabled?
                        disabled: function () {
                            return !list;
                        },
                        // Lock the list in its current state
                        lock: function () {
                            stack = undefined;
                            if (!memory) {
                                self.disable();
                            }
                            return this;
                        },
                        // Is it locked?
                        locked: function () {
                            return !stack;
                        },
                        // Call all callbacks with the given context and arguments
                        fireWith: function (context, args) {
                            if (list && ( !fired || stack )) {
                                args = args || [];
                                args = [context, args.slice ? args.slice() : args];
                                if (firing) {
                                    stack.push(args);
                                } else {
                                    fire(args);
                                }
                            }
                            return this;
                        },
                        // Call all the callbacks with the given arguments
                        fire: function () {
                            self.fireWith(this, arguments);
                            return this;
                        },
                        // To know if the callbacks have already been called at least once
                        fired: function () {
                            return !!fired;
                        }
                    };

                return self;
            };


            jQuery.extend({

                Deferred: function (func) {
                    var tuples = [
                            // action, add listener, listener list, final state
                            ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                            ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                            ["notify", "progress", jQuery.Callbacks("memory")]
                        ],
                        state = "pending",
                        promise = {
                            state: function () {
                                return state;
                            },
                            always: function () {
                                deferred.done(arguments).fail(arguments);
                                return this;
                            },
                            then: function (/* fnDone, fnFail, fnProgress */) {
                                var fns = arguments;
                                return jQuery.Deferred(function (newDefer) {
                                    jQuery.each(tuples, function (i, tuple) {
                                        var fn = jQuery.isFunction(fns[i]) && fns[i];
                                        // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                        deferred[tuple[1]](function () {
                                            var returned = fn && fn.apply(this, arguments);
                                            if (returned && jQuery.isFunction(returned.promise)) {
                                                returned.promise()
                                                    .done(newDefer.resolve)
                                                    .fail(newDefer.reject)
                                                    .progress(newDefer.notify);
                                            } else {
                                                newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                            }
                                        });
                                    });
                                    fns = null;
                                }).promise();
                            },
                            // Get a promise for this deferred
                            // If obj is provided, the promise aspect is added to the object
                            promise: function (obj) {
                                return obj != null ? jQuery.extend(obj, promise) : promise;
                            }
                        },
                        deferred = {};

                    // Keep pipe for back-compat
                    promise.pipe = promise.then;

                    // Add list-specific methods
                    jQuery.each(tuples, function (i, tuple) {
                        var list = tuple[2],
                            stateString = tuple[3];

                        // promise[ done | fail | progress ] = list.add
                        promise[tuple[1]] = list.add;

                        // Handle state
                        if (stateString) {
                            list.add(function () {
                                // state = [ resolved | rejected ]
                                state = stateString;

                                // [ reject_list | resolve_list ].disable; progress_list.lock
                            }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                        }

                        // deferred[ resolve | reject | notify ]
                        deferred[tuple[0]] = function () {
                            deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                            return this;
                        };
                        deferred[tuple[0] + "With"] = list.fireWith;
                    });

                    // Make the deferred a promise
                    promise.promise(deferred);

                    // Call given func if any
                    if (func) {
                        func.call(deferred, deferred);
                    }

                    // All done!
                    return deferred;
                },

                // Deferred helper
                when: function (subordinate /* , ..., subordinateN */) {
                    var i = 0,
                        resolveValues = slice.call(arguments),
                        length = resolveValues.length,

                    // the count of uncompleted subordinates
                        remaining = length !== 1 || ( subordinate && jQuery.isFunction(subordinate.promise) ) ? length : 0,

                    // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                    // Update function for both resolve and progress values
                        updateFunc = function (i, contexts, values) {
                            return function (value) {
                                contexts[i] = this;
                                values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                                if (values === progressValues) {
                                    deferred.notifyWith(contexts, values);
                                } else if (!( --remaining )) {
                                    deferred.resolveWith(contexts, values);
                                }
                            };
                        },

                        progressValues, progressContexts, resolveContexts;

                    // Add listeners to Deferred subordinates; treat others as resolved
                    if (length > 1) {
                        progressValues = new Array(length);
                        progressContexts = new Array(length);
                        resolveContexts = new Array(length);
                        for (; i < length; i++) {
                            if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                                resolveValues[i].promise()
                                    .done(updateFunc(i, resolveContexts, resolveValues))
                                    .fail(deferred.reject)
                                    .progress(updateFunc(i, progressContexts, progressValues));
                            } else {
                                --remaining;
                            }
                        }
                    }

                    // If we're not waiting on anything, resolve the master
                    if (!remaining) {
                        deferred.resolveWith(resolveContexts, resolveValues);
                    }

                    return deferred.promise();
                }
            });


// The deferred used on DOM ready
            var readyList;

            jQuery.fn.ready = function (fn) {
                // Add the callback
                jQuery.ready.promise().done(fn);

                return this;
            };

            jQuery.extend({
                // Is the DOM ready to be used? Set to true once it occurs.
                isReady: false,

                // A counter to track how many items to wait for before
                // the ready event fires. See #6781
                readyWait: 1,

                // Hold (or release) the ready event
                holdReady: function (hold) {
                    if (hold) {
                        jQuery.readyWait++;
                    } else {
                        jQuery.ready(true);
                    }
                },

                // Handle when the DOM is ready
                ready: function (wait) {

                    // Abort if there are pending holds or we're already ready
                    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                        return;
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.resolveWith(document, [jQuery]);

                    // Trigger any bound ready events
                    if (jQuery.fn.triggerHandler) {
                        jQuery(document).triggerHandler("ready");
                        jQuery(document).off("ready");
                    }
                }
            });

            /**
             * The ready event handler and self cleanup method
             */
            function completed() {
                document.removeEventListener("DOMContentLoaded", completed, false);
                window.removeEventListener("load", completed, false);
                jQuery.ready();
            }

            jQuery.ready.promise = function (obj) {
                if (!readyList) {

                    readyList = jQuery.Deferred();

                    // Catch cases where $(document).ready() is called after the browser event has already occurred.
                    // We once tried to use readyState "interactive" here, but it caused issues like the one
                    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
                    if (document.readyState === "complete") {
                        // Handle it asynchronously to allow scripts the opportunity to delay ready
                        setTimeout(jQuery.ready);

                    } else {

                        // Use the handy event callback
                        document.addEventListener("DOMContentLoaded", completed, false);

                        // A fallback to window.onload, that will always work
                        window.addEventListener("load", completed, false);
                    }
                }
                return readyList.promise(obj);
            };

// Kick off the DOM ready check even if the user does not
            jQuery.ready.promise();


// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
            var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0,
                    len = elems.length,
                    bulk = key == null;

                // Sets many values
                if (jQuery.type(key) === "object") {
                    chainable = true;
                    for (i in key) {
                        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
                    }

                    // Sets one value
                } else if (value !== undefined) {
                    chainable = true;

                    if (!jQuery.isFunction(value)) {
                        raw = true;
                    }

                    if (bulk) {
                        // Bulk operations run against the entire set
                        if (raw) {
                            fn.call(elems, value);
                            fn = null;

                            // ...except when executing function values
                        } else {
                            bulk = fn;
                            fn = function (elem, key, value) {
                                return bulk.call(jQuery(elem), value);
                            };
                        }
                    }

                    if (fn) {
                        for (; i < len; i++) {
                            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                        }
                    }
                }

                return chainable ?
                    elems :

                    // Gets
                    bulk ?
                        fn.call(elems) :
                        len ? fn(elems[0], key) : emptyGet;
            };


            /**
             * Determines whether an object can have data
             */
            jQuery.acceptData = function (owner) {
                // Accepts only:
                //  - Node
                //    - Node.ELEMENT_NODE
                //    - Node.DOCUMENT_NODE
                //  - Object
                //    - Any
                /* jshint -W018 */
                return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
            };


            function Data() {
                // Support: Android<4,
                // Old WebKit does not have Object.preventExtensions/freeze method,
                // return new empty object instead with no [[set]] accessor
                Object.defineProperty(this.cache = {}, 0, {
                    get: function () {
                        return {};
                    }
                });

                this.expando = jQuery.expando + Data.uid++;
            }

            Data.uid = 1;
            Data.accepts = jQuery.acceptData;

            Data.prototype = {
                key: function (owner) {
                    // We can accept data for non-element nodes in modern browsers,
                    // but we should not, see #8335.
                    // Always return the key for a frozen object.
                    if (!Data.accepts(owner)) {
                        return 0;
                    }

                    var descriptor = {},
                    // Check if the owner object already has a cache key
                        unlock = owner[this.expando];

                    // If not, create one
                    if (!unlock) {
                        unlock = Data.uid++;

                        // Secure it in a non-enumerable, non-writable property
                        try {
                            descriptor[this.expando] = {value: unlock};
                            Object.defineProperties(owner, descriptor);

                            // Support: Android<4
                            // Fallback to a less secure definition
                        } catch (e) {
                            descriptor[this.expando] = unlock;
                            jQuery.extend(owner, descriptor);
                        }
                    }

                    // Ensure the cache object
                    if (!this.cache[unlock]) {
                        this.cache[unlock] = {};
                    }

                    return unlock;
                },
                set: function (owner, data, value) {
                    var prop,
                    // There may be an unlock assigned to this node,
                    // if there is no entry for this "owner", create one inline
                    // and set the unlock as though an owner entry had always existed
                        unlock = this.key(owner),
                        cache = this.cache[unlock];

                    // Handle: [ owner, key, value ] args
                    if (typeof data === "string") {
                        cache[data] = value;

                        // Handle: [ owner, { properties } ] args
                    } else {
                        // Fresh assignments by object are shallow copied
                        if (jQuery.isEmptyObject(cache)) {
                            jQuery.extend(this.cache[unlock], data);
                            // Otherwise, copy the properties one-by-one to the cache object
                        } else {
                            for (prop in data) {
                                cache[prop] = data[prop];
                            }
                        }
                    }
                    return cache;
                },
                get: function (owner, key) {
                    // Either a valid cache is found, or will be created.
                    // New caches will be created and the unlock returned,
                    // allowing direct access to the newly created
                    // empty data object. A valid owner object must be provided.
                    var cache = this.cache[this.key(owner)];

                    return key === undefined ?
                        cache : cache[key];
                },
                access: function (owner, key, value) {
                    var stored;
                    // In cases where either:
                    //
                    //   1. No key was specified
                    //   2. A string key was specified, but no value provided
                    //
                    // Take the "read" path and allow the get method to determine
                    // which value to return, respectively either:
                    //
                    //   1. The entire cache object
                    //   2. The data stored at the key
                    //
                    if (key === undefined ||
                        ((key && typeof key === "string") && value === undefined)) {

                        stored = this.get(owner, key);

                        return stored !== undefined ?
                            stored : this.get(owner, jQuery.camelCase(key));
                    }

                    // [*]When the key is not a string, or both a key and value
                    // are specified, set or extend (existing objects) with either:
                    //
                    //   1. An object of properties
                    //   2. A key and value
                    //
                    this.set(owner, key, value);

                    // Since the "set" path can have two possible entry points
                    // return the expected data based on which path was taken[*]
                    return value !== undefined ? value : key;
                },
                remove: function (owner, key) {
                    var i, name, camel,
                        unlock = this.key(owner),
                        cache = this.cache[unlock];

                    if (key === undefined) {
                        this.cache[unlock] = {};

                    } else {
                        // Support array or space separated string of keys
                        if (jQuery.isArray(key)) {
                            // If "name" is an array of keys...
                            // When data is initially created, via ("key", "val") signature,
                            // keys will be converted to camelCase.
                            // Since there is no way to tell _how_ a key was added, remove
                            // both plain key and camelCase key. #12786
                            // This will only penalize the array argument path.
                            name = key.concat(key.map(jQuery.camelCase));
                        } else {
                            camel = jQuery.camelCase(key);
                            // Try the string as a key before any manipulation
                            if (key in cache) {
                                name = [key, camel];
                            } else {
                                // If a key with the spaces exists, use it.
                                // Otherwise, create an array by matching non-whitespace
                                name = camel;
                                name = name in cache ?
                                    [name] : ( name.match(rnotwhite) || [] );
                            }
                        }

                        i = name.length;
                        while (i--) {
                            delete cache[name[i]];
                        }
                    }
                },
                hasData: function (owner) {
                    return !jQuery.isEmptyObject(
                        this.cache[owner[this.expando]] || {}
                    );
                },
                discard: function (owner) {
                    if (owner[this.expando]) {
                        delete this.cache[owner[this.expando]];
                    }
                }
            };
            var data_priv = new Data();

            var data_user = new Data();


//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                rmultiDash = /([A-Z])/g;

            function dataAttr(elem, key, data) {
                var name;

                // If nothing was found internally, try to fetch any
                // data from the HTML5 data-* attribute
                if (data === undefined && elem.nodeType === 1) {
                    name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
                    data = elem.getAttribute(name);

                    if (typeof data === "string") {
                        try {
                            data = data === "true" ? true :
                                data === "false" ? false :
                                    data === "null" ? null :
                                        // Only convert to a number if it doesn't change the string
                                        +data + "" === data ? +data :
                                            rbrace.test(data) ? jQuery.parseJSON(data) :
                                                data;
                        } catch (e) {
                        }

                        // Make sure we set the data so it isn't changed later
                        data_user.set(elem, key, data);
                    } else {
                        data = undefined;
                    }
                }
                return data;
            }

            jQuery.extend({
                hasData: function (elem) {
                    return data_user.hasData(elem) || data_priv.hasData(elem);
                },

                data: function (elem, name, data) {
                    return data_user.access(elem, name, data);
                },

                removeData: function (elem, name) {
                    data_user.remove(elem, name);
                },

                // TODO: Now that all calls to _data and _removeData have been replaced
                // with direct calls to data_priv methods, these can be deprecated.
                _data: function (elem, name, data) {
                    return data_priv.access(elem, name, data);
                },

                _removeData: function (elem, name) {
                    data_priv.remove(elem, name);
                }
            });

            jQuery.fn.extend({
                data: function (key, value) {
                    var i, name, data,
                        elem = this[0],
                        attrs = elem && elem.attributes;

                    // Gets all values
                    if (key === undefined) {
                        if (this.length) {
                            data = data_user.get(elem);

                            if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                                i = attrs.length;
                                while (i--) {

                                    // Support: IE11+
                                    // The attrs elements can be null (#14894)
                                    if (attrs[i]) {
                                        name = attrs[i].name;
                                        if (name.indexOf("data-") === 0) {
                                            name = jQuery.camelCase(name.slice(5));
                                            dataAttr(elem, name, data[name]);
                                        }
                                    }
                                }
                                data_priv.set(elem, "hasDataAttrs", true);
                            }
                        }

                        return data;
                    }

                    // Sets multiple values
                    if (typeof key === "object") {
                        return this.each(function () {
                            data_user.set(this, key);
                        });
                    }

                    return access(this, function (value) {
                        var data,
                            camelKey = jQuery.camelCase(key);

                        // The calling jQuery object (element matches) is not empty
                        // (and therefore has an element appears at this[ 0 ]) and the
                        // `value` parameter was not undefined. An empty jQuery object
                        // will result in `undefined` for elem = this[ 0 ] which will
                        // throw an exception if an attempt to read a data cache is made.
                        if (elem && value === undefined) {
                            // Attempt to get data from the cache
                            // with the key as-is
                            data = data_user.get(elem, key);
                            if (data !== undefined) {
                                return data;
                            }

                            // Attempt to get data from the cache
                            // with the key camelized
                            data = data_user.get(elem, camelKey);
                            if (data !== undefined) {
                                return data;
                            }

                            // Attempt to "discover" the data in
                            // HTML5 custom data-* attrs
                            data = dataAttr(elem, camelKey, undefined);
                            if (data !== undefined) {
                                return data;
                            }

                            // We tried really hard, but the data doesn't exist.
                            return;
                        }

                        // Set the data...
                        this.each(function () {
                            // First, attempt to store a copy or reference of any
                            // data that might've been store with a camelCased key.
                            var data = data_user.get(this, camelKey);

                            // For HTML5 data-* attribute interop, we have to
                            // store property names with dashes in a camelCase form.
                            // This might not apply to all properties...*
                            data_user.set(this, camelKey, value);

                            // *... In the case of properties that might _actually_
                            // have dashes, we need to also store a copy of that
                            // unchanged property.
                            if (key.indexOf("-") !== -1 && data !== undefined) {
                                data_user.set(this, key, value);
                            }
                        });
                    }, null, value, arguments.length > 1, null, true);
                },

                removeData: function (key) {
                    return this.each(function () {
                        data_user.remove(this, key);
                    });
                }
            });


            jQuery.extend({
                queue: function (elem, type, data) {
                    var queue;

                    if (elem) {
                        type = ( type || "fx" ) + "queue";
                        queue = data_priv.get(elem, type);

                        // Speed up dequeue by getting out quickly if this is just a lookup
                        if (data) {
                            if (!queue || jQuery.isArray(data)) {
                                queue = data_priv.access(elem, type, jQuery.makeArray(data));
                            } else {
                                queue.push(data);
                            }
                        }
                        return queue || [];
                    }
                },

                dequeue: function (elem, type) {
                    type = type || "fx";

                    var queue = jQuery.queue(elem, type),
                        startLength = queue.length,
                        fn = queue.shift(),
                        hooks = jQuery._queueHooks(elem, type),
                        next = function () {
                            jQuery.dequeue(elem, type);
                        };

                    // If the fx queue is dequeued, always remove the progress sentinel
                    if (fn === "inprogress") {
                        fn = queue.shift();
                        startLength--;
                    }

                    if (fn) {

                        // Add a progress sentinel to prevent the fx queue from being
                        // automatically dequeued
                        if (type === "fx") {
                            queue.unshift("inprogress");
                        }

                        // Clear up the last queue stop function
                        delete hooks.stop;
                        fn.call(elem, next, hooks);
                    }

                    if (!startLength && hooks) {
                        hooks.empty.fire();
                    }
                },

                // Not public - generate a queueHooks object, or return the current one
                _queueHooks: function (elem, type) {
                    var key = type + "queueHooks";
                    return data_priv.get(elem, key) || data_priv.access(elem, key, {
                            empty: jQuery.Callbacks("once memory").add(function () {
                                data_priv.remove(elem, [type + "queue", key]);
                            })
                        });
                }
            });

            jQuery.fn.extend({
                queue: function (type, data) {
                    var setter = 2;

                    if (typeof type !== "string") {
                        data = type;
                        type = "fx";
                        setter--;
                    }

                    if (arguments.length < setter) {
                        return jQuery.queue(this[0], type);
                    }

                    return data === undefined ?
                        this :
                        this.each(function () {
                            var queue = jQuery.queue(this, type, data);

                            // Ensure a hooks for this queue
                            jQuery._queueHooks(this, type);

                            if (type === "fx" && queue[0] !== "inprogress") {
                                jQuery.dequeue(this, type);
                            }
                        });
                },
                dequeue: function (type) {
                    return this.each(function () {
                        jQuery.dequeue(this, type);
                    });
                },
                clearQueue: function (type) {
                    return this.queue(type || "fx", []);
                },
                // Get a promise resolved when queues of a certain type
                // are emptied (fx is the type by default)
                promise: function (type, obj) {
                    var tmp,
                        count = 1,
                        defer = jQuery.Deferred(),
                        elements = this,
                        i = this.length,
                        resolve = function () {
                            if (!( --count )) {
                                defer.resolveWith(elements, [elements]);
                            }
                        };

                    if (typeof type !== "string") {
                        obj = type;
                        type = undefined;
                    }
                    type = type || "fx";

                    while (i--) {
                        tmp = data_priv.get(elements[i], type + "queueHooks");
                        if (tmp && tmp.empty) {
                            count++;
                            tmp.empty.add(resolve);
                        }
                    }
                    resolve();
                    return defer.promise(obj);
                }
            });
            var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

            var cssExpand = ["Top", "Right", "Bottom", "Left"];

            var isHidden = function (elem, el) {
                // isHidden might be called from jQuery#filter function;
                // in that case, element will be second argument
                elem = el || elem;
                return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
            };

            var rcheckableType = (/^(?:checkbox|radio)$/i);


            (function () {
                var fragment = document.createDocumentFragment(),
                    div = fragment.appendChild(document.createElement("div")),
                    input = document.createElement("input");

                // Support: Safari<=5.1
                // Check state lost if the name is set (#11217)
                // Support: Windows Web Apps (WWA)
                // `name` and `type` must use .setAttribute for WWA (#14901)
                input.setAttribute("type", "radio");
                input.setAttribute("checked", "checked");
                input.setAttribute("name", "t");

                div.appendChild(input);

                // Support: Safari<=5.1, Android<4.2
                // Older WebKit doesn't clone checked state correctly in fragments
                support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

                // Support: IE<=11+
                // Make sure textarea (and checkbox) defaultValue is properly cloned
                div.innerHTML = "<textarea>x</textarea>";
                support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
            })();
            var strundefined = typeof undefined;


            support.focusinBubbles = "onfocusin" in window;


            var
                rkeyEvent = /^key/,
                rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
                rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
                rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

            function returnTrue() {
                return true;
            }

            function returnFalse() {
                return false;
            }

            function safeActiveElement() {
                try {
                    return document.activeElement;
                } catch (err) {
                }
            }

            /*
             * Helper functions for managing events -- not part of the public interface.
             * Props to Dean Edwards' addEvent library for many of the ideas.
             */
            jQuery.event = {

                global: {},

                add: function (elem, types, handler, data, selector) {

                    var handleObjIn, eventHandle, tmp,
                        events, t, handleObj,
                        special, handlers, type, namespaces, origType,
                        elemData = data_priv.get(elem);

                    // Don't attach events to noData or text/comment nodes (but allow plain objects)
                    if (!elemData) {
                        return;
                    }

                    // Caller can pass in an object of custom data in lieu of the handler
                    if (handler.handler) {
                        handleObjIn = handler;
                        handler = handleObjIn.handler;
                        selector = handleObjIn.selector;
                    }

                    // Make sure that the handler has a unique ID, used to find/remove it later
                    if (!handler.guid) {
                        handler.guid = jQuery.guid++;
                    }

                    // Init the element's event structure and main handler, if this is the first
                    if (!(events = elemData.events)) {
                        events = elemData.events = {};
                    }
                    if (!(eventHandle = elemData.handle)) {
                        eventHandle = elemData.handle = function (e) {
                            // Discard the second event of a jQuery.event.trigger() and
                            // when an event is called after a page has unloaded
                            return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
                                jQuery.event.dispatch.apply(elem, arguments) : undefined;
                        };
                    }

                    // Handle multiple events separated by a space
                    types = ( types || "" ).match(rnotwhite) || [""];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = ( tmp[2] || "" ).split(".").sort();

                        // There *must* be a type, no attaching namespace-only handlers
                        if (!type) {
                            continue;
                        }

                        // If event changes its type, use the special event handlers for the changed type
                        special = jQuery.event.special[type] || {};

                        // If selector defined, determine special event api type, otherwise given type
                        type = ( selector ? special.delegateType : special.bindType ) || type;

                        // Update special based on newly reset type
                        special = jQuery.event.special[type] || {};

                        // handleObj is passed to all event handlers
                        handleObj = jQuery.extend({
                            type: type,
                            origType: origType,
                            data: data,
                            handler: handler,
                            guid: handler.guid,
                            selector: selector,
                            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                            namespace: namespaces.join(".")
                        }, handleObjIn);

                        // Init the event handler queue if we're the first
                        if (!(handlers = events[type])) {
                            handlers = events[type] = [];
                            handlers.delegateCount = 0;

                            // Only use addEventListener if the special events handler returns false
                            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                                if (elem.addEventListener) {
                                    elem.addEventListener(type, eventHandle, false);
                                }
                            }
                        }

                        if (special.add) {
                            special.add.call(elem, handleObj);

                            if (!handleObj.handler.guid) {
                                handleObj.handler.guid = handler.guid;
                            }
                        }

                        // Add to the element's handler list, delegates in front
                        if (selector) {
                            handlers.splice(handlers.delegateCount++, 0, handleObj);
                        } else {
                            handlers.push(handleObj);
                        }

                        // Keep track of which events have ever been used, for event optimization
                        jQuery.event.global[type] = true;
                    }

                },

                // Detach an event or set of events from an element
                remove: function (elem, types, handler, selector, mappedTypes) {

                    var j, origCount, tmp,
                        events, t, handleObj,
                        special, handlers, type, namespaces, origType,
                        elemData = data_priv.hasData(elem) && data_priv.get(elem);

                    if (!elemData || !(events = elemData.events)) {
                        return;
                    }

                    // Once for each type.namespace in types; type may be omitted
                    types = ( types || "" ).match(rnotwhite) || [""];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = ( tmp[2] || "" ).split(".").sort();

                        // Unbind all events (on this namespace, if provided) for the element
                        if (!type) {
                            for (type in events) {
                                jQuery.event.remove(elem, type + types[t], handler, selector, true);
                            }
                            continue;
                        }

                        special = jQuery.event.special[type] || {};
                        type = ( selector ? special.delegateType : special.bindType ) || type;
                        handlers = events[type] || [];
                        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                        // Remove matching events
                        origCount = j = handlers.length;
                        while (j--) {
                            handleObj = handlers[j];

                            if (( mappedTypes || origType === handleObj.origType ) &&
                                ( !handler || handler.guid === handleObj.guid ) &&
                                ( !tmp || tmp.test(handleObj.namespace) ) &&
                                ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector )) {
                                handlers.splice(j, 1);

                                if (handleObj.selector) {
                                    handlers.delegateCount--;
                                }
                                if (special.remove) {
                                    special.remove.call(elem, handleObj);
                                }
                            }
                        }

                        // Remove generic event handler if we removed something and no more handlers exist
                        // (avoids potential for endless recursion during removal of special event handlers)
                        if (origCount && !handlers.length) {
                            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                                jQuery.removeEvent(elem, type, elemData.handle);
                            }

                            delete events[type];
                        }
                    }

                    // Remove the expando if it's no longer used
                    if (jQuery.isEmptyObject(events)) {
                        delete elemData.handle;
                        data_priv.remove(elem, "events");
                    }
                },

                trigger: function (event, data, elem, onlyHandlers) {

                    var i, cur, tmp, bubbleType, ontype, handle, special,
                        eventPath = [elem || document],
                        type = hasOwn.call(event, "type") ? event.type : event,
                        namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

                    cur = tmp = elem = elem || document;

                    // Don't do events on text and comment nodes
                    if (elem.nodeType === 3 || elem.nodeType === 8) {
                        return;
                    }

                    // focus/blur morphs to focusin/out; ensure we're not firing them right now
                    if (rfocusMorph.test(type + jQuery.event.triggered)) {
                        return;
                    }

                    if (type.indexOf(".") >= 0) {
                        // Namespaced trigger; create a regexp to match event type in handle()
                        namespaces = type.split(".");
                        type = namespaces.shift();
                        namespaces.sort();
                    }
                    ontype = type.indexOf(":") < 0 && "on" + type;

                    // Caller can pass in a jQuery.Event object, Object, or just an event type string
                    event = event[jQuery.expando] ?
                        event :
                        new jQuery.Event(type, typeof event === "object" && event);

                    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                    event.isTrigger = onlyHandlers ? 2 : 3;
                    event.namespace = namespaces.join(".");
                    event.namespace_re = event.namespace ?
                        new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                        null;

                    // Clean up the event in case it is being reused
                    event.result = undefined;
                    if (!event.target) {
                        event.target = elem;
                    }

                    // Clone any incoming data and prepend the event, creating the handler arg list
                    data = data == null ?
                        [event] :
                        jQuery.makeArray(data, [event]);

                    // Allow special events to draw outside the lines
                    special = jQuery.event.special[type] || {};
                    if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                        return;
                    }

                    // Determine event propagation path in advance, per W3C events spec (#9951)
                    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                        bubbleType = special.delegateType || type;
                        if (!rfocusMorph.test(bubbleType + type)) {
                            cur = cur.parentNode;
                        }
                        for (; cur; cur = cur.parentNode) {
                            eventPath.push(cur);
                            tmp = cur;
                        }

                        // Only add window if we got to document (e.g., not plain obj or detached DOM)
                        if (tmp === (elem.ownerDocument || document)) {
                            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                        }
                    }

                    // Fire handlers on the event path
                    i = 0;
                    while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                        event.type = i > 1 ?
                            bubbleType :
                        special.bindType || type;

                        // jQuery handler
                        handle = ( data_priv.get(cur, "events") || {} )[event.type] && data_priv.get(cur, "handle");
                        if (handle) {
                            handle.apply(cur, data);
                        }

                        // Native handler
                        handle = ontype && cur[ontype];
                        if (handle && handle.apply && jQuery.acceptData(cur)) {
                            event.result = handle.apply(cur, data);
                            if (event.result === false) {
                                event.preventDefault();
                            }
                        }
                    }
                    event.type = type;

                    // If nobody prevented the default action, do it now
                    if (!onlyHandlers && !event.isDefaultPrevented()) {

                        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) &&
                            jQuery.acceptData(elem)) {

                            // Call a native DOM method on the target with the same name name as the event.
                            // Don't do default actions on window, that's where global variables be (#6170)
                            if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

                                // Don't re-trigger an onFOO event when we call its FOO() method
                                tmp = elem[ontype];

                                if (tmp) {
                                    elem[ontype] = null;
                                }

                                // Prevent re-triggering of the same event, since we already bubbled it above
                                jQuery.event.triggered = type;
                                elem[type]();
                                jQuery.event.triggered = undefined;

                                if (tmp) {
                                    elem[ontype] = tmp;
                                }
                            }
                        }
                    }

                    return event.result;
                },

                dispatch: function (event) {

                    // Make a writable jQuery.Event from the native event object
                    event = jQuery.event.fix(event);

                    var i, j, ret, matched, handleObj,
                        handlerQueue = [],
                        args = slice.call(arguments),
                        handlers = ( data_priv.get(this, "events") || {} )[event.type] || [],
                        special = jQuery.event.special[event.type] || {};

                    // Use the fix-ed jQuery.Event rather than the (read-only) native event
                    args[0] = event;
                    event.delegateTarget = this;

                    // Call the preDispatch hook for the mapped type, and let it bail if desired
                    if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                        return;
                    }

                    // Determine handlers
                    handlerQueue = jQuery.event.handlers.call(this, event, handlers);

                    // Run delegates first; they may want to stop propagation beneath us
                    i = 0;
                    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                        event.currentTarget = matched.elem;

                        j = 0;
                        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

                            // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                            // a subset or equal to those in the bound event (both can have no namespace).
                            if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

                                event.handleObj = handleObj;
                                event.data = handleObj.data;

                                ret = ( (jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler )
                                    .apply(matched.elem, args);

                                if (ret !== undefined) {
                                    if ((event.result = ret) === false) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                    }

                    // Call the postDispatch hook for the mapped type
                    if (special.postDispatch) {
                        special.postDispatch.call(this, event);
                    }

                    return event.result;
                },

                handlers: function (event, handlers) {
                    var i, matches, sel, handleObj,
                        handlerQueue = [],
                        delegateCount = handlers.delegateCount,
                        cur = event.target;

                    // Find delegate handlers
                    // Black-hole SVG <use> instance trees (#13180)
                    // Avoid non-left-click bubbling in Firefox (#3861)
                    if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {

                        for (; cur !== this; cur = cur.parentNode || this) {

                            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                            if (cur.disabled !== true || event.type !== "click") {
                                matches = [];
                                for (i = 0; i < delegateCount; i++) {
                                    handleObj = handlers[i];

                                    // Don't conflict with Object.prototype properties (#13203)
                                    sel = handleObj.selector + " ";

                                    if (matches[sel] === undefined) {
                                        matches[sel] = handleObj.needsContext ?
                                        jQuery(sel, this).index(cur) >= 0 :
                                            jQuery.find(sel, this, null, [cur]).length;
                                    }
                                    if (matches[sel]) {
                                        matches.push(handleObj);
                                    }
                                }
                                if (matches.length) {
                                    handlerQueue.push({elem: cur, handlers: matches});
                                }
                            }
                        }
                    }

                    // Add the remaining (directly-bound) handlers
                    if (delegateCount < handlers.length) {
                        handlerQueue.push({elem: this, handlers: handlers.slice(delegateCount)});
                    }

                    return handlerQueue;
                },

                // Includes some event props shared by KeyEvent and MouseEvent
                props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

                fixHooks: {},

                keyHooks: {
                    props: "char charCode key keyCode".split(" "),
                    filter: function (event, original) {

                        // Add which for key events
                        if (event.which == null) {
                            event.which = original.charCode != null ? original.charCode : original.keyCode;
                        }

                        return event;
                    }
                },

                mouseHooks: {
                    props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                    filter: function (event, original) {
                        var eventDoc, doc, body,
                            button = original.button;

                        // Calculate pageX/Y if missing and clientX/Y available
                        if (event.pageX == null && original.clientX != null) {
                            eventDoc = event.target.ownerDocument || document;
                            doc = eventDoc.documentElement;
                            body = eventDoc.body;

                            event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                            event.pageY = original.clientY + ( doc && doc.scrollTop || body && body.scrollTop || 0 ) - ( doc && doc.clientTop || body && body.clientTop || 0 );
                        }

                        // Add which for click: 1 === left; 2 === middle; 3 === right
                        // Note: button is not normalized, so don't use it
                        if (!event.which && button !== undefined) {
                            event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                        }

                        return event;
                    }
                },

                fix: function (event) {
                    if (event[jQuery.expando]) {
                        return event;
                    }

                    // Create a writable copy of the event object and normalize some properties
                    var i, prop, copy,
                        type = event.type,
                        originalEvent = event,
                        fixHook = this.fixHooks[type];

                    if (!fixHook) {
                        this.fixHooks[type] = fixHook =
                            rmouseEvent.test(type) ? this.mouseHooks :
                                rkeyEvent.test(type) ? this.keyHooks :
                                {};
                    }
                    copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

                    event = new jQuery.Event(originalEvent);

                    i = copy.length;
                    while (i--) {
                        prop = copy[i];
                        event[prop] = originalEvent[prop];
                    }

                    // Support: Cordova 2.5 (WebKit) (#13255)
                    // All events should have a target; Cordova deviceready doesn't
                    if (!event.target) {
                        event.target = document;
                    }

                    // Support: Safari 6.0+, Chrome<28
                    // Target should not be a text node (#504, #13143)
                    if (event.target.nodeType === 3) {
                        event.target = event.target.parentNode;
                    }

                    return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
                },

                special: {
                    load: {
                        // Prevent triggered image.load events from bubbling to window.load
                        noBubble: true
                    },
                    focus: {
                        // Fire native event if possible so blur/focus sequence is correct
                        trigger: function () {
                            if (this !== safeActiveElement() && this.focus) {
                                this.focus();
                                return false;
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function () {
                            if (this === safeActiveElement() && this.blur) {
                                this.blur();
                                return false;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        // For checkbox, fire native event so checked state will be right
                        trigger: function () {
                            if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                                this.click();
                                return false;
                            }
                        },

                        // For cross-browser consistency, don't fire native .click() on links
                        _default: function (event) {
                            return jQuery.nodeName(event.target, "a");
                        }
                    },

                    beforeunload: {
                        postDispatch: function (event) {

                            // Support: Firefox 20+
                            // Firefox doesn't alert if the returnValue field is not set.
                            if (event.result !== undefined && event.originalEvent) {
                                event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                },

                simulate: function (type, elem, event, bubble) {
                    // Piggyback on a donor event to simulate a different one.
                    // Fake originalEvent to avoid donor's stopPropagation, but if the
                    // simulated event prevents default then we do the same on the donor.
                    var e = jQuery.extend(
                        new jQuery.Event(),
                        event,
                        {
                            type: type,
                            isSimulated: true,
                            originalEvent: {}
                        }
                    );
                    if (bubble) {
                        jQuery.event.trigger(e, null, elem);
                    } else {
                        jQuery.event.dispatch.call(elem, e);
                    }
                    if (e.isDefaultPrevented()) {
                        event.preventDefault();
                    }
                }
            };

            jQuery.removeEvent = function (elem, type, handle) {
                if (elem.removeEventListener) {
                    elem.removeEventListener(type, handle, false);
                }
            };

            jQuery.Event = function (src, props) {
                // Allow instantiation without the 'new' keyword
                if (!(this instanceof jQuery.Event)) {
                    return new jQuery.Event(src, props);
                }

                // Event object
                if (src && src.type) {
                    this.originalEvent = src;
                    this.type = src.type;

                    // Events bubbling up the document may have been marked as prevented
                    // by a handler lower down the tree; reflect the correct value.
                    this.isDefaultPrevented = src.defaultPrevented ||
                    src.defaultPrevented === undefined &&
                        // Support: Android<4.0
                    src.returnValue === false ?
                        returnTrue :
                        returnFalse;

                    // Event type
                } else {
                    this.type = src;
                }

                // Put explicitly provided properties onto the event object
                if (props) {
                    jQuery.extend(this, props);
                }

                // Create a timestamp if incoming event doesn't have one
                this.timeStamp = src && src.timeStamp || jQuery.now();

                // Mark it as fixed
                this[jQuery.expando] = true;
            };

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            jQuery.Event.prototype = {
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,

                preventDefault: function () {
                    var e = this.originalEvent;

                    this.isDefaultPrevented = returnTrue;

                    if (e && e.preventDefault) {
                        e.preventDefault();
                    }
                },
                stopPropagation: function () {
                    var e = this.originalEvent;

                    this.isPropagationStopped = returnTrue;

                    if (e && e.stopPropagation) {
                        e.stopPropagation();
                    }
                },
                stopImmediatePropagation: function () {
                    var e = this.originalEvent;

                    this.isImmediatePropagationStopped = returnTrue;

                    if (e && e.stopImmediatePropagation) {
                        e.stopImmediatePropagation();
                    }

                    this.stopPropagation();
                }
            };

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
            jQuery.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function (orig, fix) {
                jQuery.event.special[orig] = {
                    delegateType: fix,
                    bindType: fix,

                    handle: function (event) {
                        var ret,
                            target = this,
                            related = event.relatedTarget,
                            handleObj = event.handleObj;

                        // For mousenter/leave call the handler if related is outside the target.
                        // NB: No relatedTarget if the mouse left/entered the browser window
                        if (!related || (related !== target && !jQuery.contains(target, related))) {
                            event.type = handleObj.origType;
                            ret = handleObj.handler.apply(this, arguments);
                            event.type = fix;
                        }
                        return ret;
                    }
                };
            });

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
            if (!support.focusinBubbles) {
                jQuery.each({focus: "focusin", blur: "focusout"}, function (orig, fix) {

                    // Attach a single capturing handler on the document while someone wants focusin/focusout
                    var handler = function (event) {
                        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                    };

                    jQuery.event.special[fix] = {
                        setup: function () {
                            var doc = this.ownerDocument || this,
                                attaches = data_priv.access(doc, fix);

                            if (!attaches) {
                                doc.addEventListener(orig, handler, true);
                            }
                            data_priv.access(doc, fix, ( attaches || 0 ) + 1);
                        },
                        teardown: function () {
                            var doc = this.ownerDocument || this,
                                attaches = data_priv.access(doc, fix) - 1;

                            if (!attaches) {
                                doc.removeEventListener(orig, handler, true);
                                data_priv.remove(doc, fix);

                            } else {
                                data_priv.access(doc, fix, attaches);
                            }
                        }
                    };
                });
            }

            jQuery.fn.extend({

                on: function (types, selector, data, fn, /*INTERNAL*/ one) {
                    var origFn, type;

                    // Types can be a map of types/handlers
                    if (typeof types === "object") {
                        // ( types-Object, selector, data )
                        if (typeof selector !== "string") {
                            // ( types-Object, data )
                            data = data || selector;
                            selector = undefined;
                        }
                        for (type in types) {
                            this.on(type, selector, data, types[type], one);
                        }
                        return this;
                    }

                    if (data == null && fn == null) {
                        // ( types, fn )
                        fn = selector;
                        data = selector = undefined;
                    } else if (fn == null) {
                        if (typeof selector === "string") {
                            // ( types, selector, fn )
                            fn = data;
                            data = undefined;
                        } else {
                            // ( types, data, fn )
                            fn = data;
                            data = selector;
                            selector = undefined;
                        }
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    } else if (!fn) {
                        return this;
                    }

                    if (one === 1) {
                        origFn = fn;
                        fn = function (event) {
                            // Can use an empty set, since event contains the info
                            jQuery().off(event);
                            return origFn.apply(this, arguments);
                        };
                        // Use same guid so caller can remove using origFn
                        fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
                    }
                    return this.each(function () {
                        jQuery.event.add(this, types, fn, data, selector);
                    });
                },
                one: function (types, selector, data, fn) {
                    return this.on(types, selector, data, fn, 1);
                },
                off: function (types, selector, fn) {
                    var handleObj, type;
                    if (types && types.preventDefault && types.handleObj) {
                        // ( event )  dispatched jQuery.Event
                        handleObj = types.handleObj;
                        jQuery(types.delegateTarget).off(
                            handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                            handleObj.selector,
                            handleObj.handler
                        );
                        return this;
                    }
                    if (typeof types === "object") {
                        // ( types-object [, selector] )
                        for (type in types) {
                            this.off(type, selector, types[type]);
                        }
                        return this;
                    }
                    if (selector === false || typeof selector === "function") {
                        // ( types [, fn] )
                        fn = selector;
                        selector = undefined;
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    }
                    return this.each(function () {
                        jQuery.event.remove(this, types, fn, selector);
                    });
                },

                trigger: function (type, data) {
                    return this.each(function () {
                        jQuery.event.trigger(type, data, this);
                    });
                },
                triggerHandler: function (type, data) {
                    var elem = this[0];
                    if (elem) {
                        return jQuery.event.trigger(type, data, elem, true);
                    }
                }
            });


            var
                rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
                rtagName = /<([\w:]+)/,
                rhtml = /<|&#?\w+;/,
                rnoInnerhtml = /<(?:script|style|link)/i,
            // checked="checked" or checked
                rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                rscriptType = /^$|\/(?:java|ecma)script/i,
                rscriptTypeMasked = /^true\/(.*)/,
                rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

            // We have to close these tags to support XHTML (#13200)
                wrapMap = {

                    // Support: IE9
                    option: [1, "<select multiple='multiple'>", "</select>"],

                    thead: [1, "<table>", "</table>"],
                    col: [2, "<table><colgroup>", "</colgroup></table>"],
                    tr: [2, "<table><tbody>", "</tbody></table>"],
                    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

                    _default: [0, "", ""]
                };

// Support: IE9
            wrapMap.optgroup = wrapMap.option;

            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
            function manipulationTarget(elem, content) {
                return jQuery.nodeName(elem, "table") &&
                jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?

                elem.getElementsByTagName("tbody")[0] ||
                elem.appendChild(elem.ownerDocument.createElement("tbody")) :
                    elem;
            }

// Replace/restore the type attribute of script elements for safe DOM manipulation
            function disableScript(elem) {
                elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
                return elem;
            }

            function restoreScript(elem) {
                var match = rscriptTypeMasked.exec(elem.type);

                if (match) {
                    elem.type = match[1];
                } else {
                    elem.removeAttribute("type");
                }

                return elem;
            }

// Mark scripts as having already been evaluated
            function setGlobalEval(elems, refElements) {
                var i = 0,
                    l = elems.length;

                for (; i < l; i++) {
                    data_priv.set(
                        elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval")
                    );
                }
            }

            function cloneCopyEvent(src, dest) {
                var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

                if (dest.nodeType !== 1) {
                    return;
                }

                // 1. Copy private data: events, handlers, etc.
                if (data_priv.hasData(src)) {
                    pdataOld = data_priv.access(src);
                    pdataCur = data_priv.set(dest, pdataOld);
                    events = pdataOld.events;

                    if (events) {
                        delete pdataCur.handle;
                        pdataCur.events = {};

                        for (type in events) {
                            for (i = 0, l = events[type].length; i < l; i++) {
                                jQuery.event.add(dest, type, events[type][i]);
                            }
                        }
                    }
                }

                // 2. Copy user data
                if (data_user.hasData(src)) {
                    udataOld = data_user.access(src);
                    udataCur = jQuery.extend({}, udataOld);

                    data_user.set(dest, udataCur);
                }
            }

            function getAll(context, tag) {
                var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") :
                    context.querySelectorAll ? context.querySelectorAll(tag || "*") :
                        [];

                return tag === undefined || tag && jQuery.nodeName(context, tag) ?
                    jQuery.merge([context], ret) :
                    ret;
            }

// Fix IE bugs, see support tests
            function fixInput(src, dest) {
                var nodeName = dest.nodeName.toLowerCase();

                // Fails to persist the checked state of a cloned checkbox or radio button.
                if (nodeName === "input" && rcheckableType.test(src.type)) {
                    dest.checked = src.checked;

                    // Fails to return the selected option to the default selected state when cloning options
                } else if (nodeName === "input" || nodeName === "textarea") {
                    dest.defaultValue = src.defaultValue;
                }
            }

            jQuery.extend({
                clone: function (elem, dataAndEvents, deepDataAndEvents) {
                    var i, l, srcElements, destElements,
                        clone = elem.cloneNode(true),
                        inPage = jQuery.contains(elem.ownerDocument, elem);

                    // Fix IE cloning issues
                    if (!support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc(elem)) {

                        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                        destElements = getAll(clone);
                        srcElements = getAll(elem);

                        for (i = 0, l = srcElements.length; i < l; i++) {
                            fixInput(srcElements[i], destElements[i]);
                        }
                    }

                    // Copy the events from the original to the clone
                    if (dataAndEvents) {
                        if (deepDataAndEvents) {
                            srcElements = srcElements || getAll(elem);
                            destElements = destElements || getAll(clone);

                            for (i = 0, l = srcElements.length; i < l; i++) {
                                cloneCopyEvent(srcElements[i], destElements[i]);
                            }
                        } else {
                            cloneCopyEvent(elem, clone);
                        }
                    }

                    // Preserve script evaluation history
                    destElements = getAll(clone, "script");
                    if (destElements.length > 0) {
                        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
                    }

                    // Return the cloned set
                    return clone;
                },

                buildFragment: function (elems, context, scripts, selection) {
                    var elem, tmp, tag, wrap, contains, j,
                        fragment = context.createDocumentFragment(),
                        nodes = [],
                        i = 0,
                        l = elems.length;

                    for (; i < l; i++) {
                        elem = elems[i];

                        if (elem || elem === 0) {

                            // Add nodes directly
                            if (jQuery.type(elem) === "object") {
                                // Support: QtWebKit, PhantomJS
                                // push.apply(_, arraylike) throws on ancient WebKit
                                jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                                // Convert non-html into a text node
                            } else if (!rhtml.test(elem)) {
                                nodes.push(context.createTextNode(elem));

                                // Convert html into DOM nodes
                            } else {
                                tmp = tmp || fragment.appendChild(context.createElement("div"));

                                // Deserialize a standard representation
                                tag = ( rtagName.exec(elem) || ["", ""] )[1].toLowerCase();
                                wrap = wrapMap[tag] || wrapMap._default;
                                tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];

                                // Descend through wrappers to the right content
                                j = wrap[0];
                                while (j--) {
                                    tmp = tmp.lastChild;
                                }

                                // Support: QtWebKit, PhantomJS
                                // push.apply(_, arraylike) throws on ancient WebKit
                                jQuery.merge(nodes, tmp.childNodes);

                                // Remember the top-level container
                                tmp = fragment.firstChild;

                                // Ensure the created nodes are orphaned (#12392)
                                tmp.textContent = "";
                            }
                        }
                    }

                    // Remove wrapper from fragment
                    fragment.textContent = "";

                    i = 0;
                    while ((elem = nodes[i++])) {

                        // #4087 - If origin and destination elements are the same, and this is
                        // that element, do not do anything
                        if (selection && jQuery.inArray(elem, selection) !== -1) {
                            continue;
                        }

                        contains = jQuery.contains(elem.ownerDocument, elem);

                        // Append to fragment
                        tmp = getAll(fragment.appendChild(elem), "script");

                        // Preserve script evaluation history
                        if (contains) {
                            setGlobalEval(tmp);
                        }

                        // Capture executables
                        if (scripts) {
                            j = 0;
                            while ((elem = tmp[j++])) {
                                if (rscriptType.test(elem.type || "")) {
                                    scripts.push(elem);
                                }
                            }
                        }
                    }

                    return fragment;
                },

                cleanData: function (elems) {
                    var data, elem, type, key,
                        special = jQuery.event.special,
                        i = 0;

                    for (; (elem = elems[i]) !== undefined; i++) {
                        if (jQuery.acceptData(elem)) {
                            key = elem[data_priv.expando];

                            if (key && (data = data_priv.cache[key])) {
                                if (data.events) {
                                    for (type in data.events) {
                                        if (special[type]) {
                                            jQuery.event.remove(elem, type);

                                            // This is a shortcut to avoid jQuery.event.remove's overhead
                                        } else {
                                            jQuery.removeEvent(elem, type, data.handle);
                                        }
                                    }
                                }
                                if (data_priv.cache[key]) {
                                    // Discard any remaining `private` data
                                    delete data_priv.cache[key];
                                }
                            }
                        }
                        // Discard any remaining `user` data
                        delete data_user.cache[elem[data_user.expando]];
                    }
                }
            });

            jQuery.fn.extend({
                text: function (value) {
                    return access(this, function (value) {
                        return value === undefined ?
                            jQuery.text(this) :
                            this.empty().each(function () {
                                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                    this.textContent = value;
                                }
                            });
                    }, null, value, arguments.length);
                },

                append: function () {
                    return this.domManip(arguments, function (elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.appendChild(elem);
                        }
                    });
                },

                prepend: function () {
                    return this.domManip(arguments, function (elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.insertBefore(elem, target.firstChild);
                        }
                    });
                },

                before: function () {
                    return this.domManip(arguments, function (elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this);
                        }
                    });
                },

                after: function () {
                    return this.domManip(arguments, function (elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this.nextSibling);
                        }
                    });
                },

                remove: function (selector, keepData /* Internal Use Only */) {
                    var elem,
                        elems = selector ? jQuery.filter(selector, this) : this,
                        i = 0;

                    for (; (elem = elems[i]) != null; i++) {
                        if (!keepData && elem.nodeType === 1) {
                            jQuery.cleanData(getAll(elem));
                        }

                        if (elem.parentNode) {
                            if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                                setGlobalEval(getAll(elem, "script"));
                            }
                            elem.parentNode.removeChild(elem);
                        }
                    }

                    return this;
                },

                empty: function () {
                    var elem,
                        i = 0;

                    for (; (elem = this[i]) != null; i++) {
                        if (elem.nodeType === 1) {

                            // Prevent memory leaks
                            jQuery.cleanData(getAll(elem, false));

                            // Remove any remaining nodes
                            elem.textContent = "";
                        }
                    }

                    return this;
                },

                clone: function (dataAndEvents, deepDataAndEvents) {
                    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                    return this.map(function () {
                        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                    });
                },

                html: function (value) {
                    return access(this, function (value) {
                        var elem = this[0] || {},
                            i = 0,
                            l = this.length;

                        if (value === undefined && elem.nodeType === 1) {
                            return elem.innerHTML;
                        }

                        // See if we can take a shortcut and just use innerHTML
                        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[( rtagName.exec(value) || ["", ""] )[1].toLowerCase()]) {

                            value = value.replace(rxhtmlTag, "<$1></$2>");

                            try {
                                for (; i < l; i++) {
                                    elem = this[i] || {};

                                    // Remove element nodes and prevent memory leaks
                                    if (elem.nodeType === 1) {
                                        jQuery.cleanData(getAll(elem, false));
                                        elem.innerHTML = value;
                                    }
                                }

                                elem = 0;

                                // If using innerHTML throws an exception, use the fallback method
                            } catch (e) {
                            }
                        }

                        if (elem) {
                            this.empty().append(value);
                        }
                    }, null, value, arguments.length);
                },

                replaceWith: function () {
                    var arg = arguments[0];

                    // Make the changes, replacing each context element with the new content
                    this.domManip(arguments, function (elem) {
                        arg = this.parentNode;

                        jQuery.cleanData(getAll(this));

                        if (arg) {
                            arg.replaceChild(elem, this);
                        }
                    });

                    // Force removal if there was no new content (e.g., from empty arguments)
                    return arg && (arg.length || arg.nodeType) ? this : this.remove();
                },

                detach: function (selector) {
                    return this.remove(selector, true);
                },

                domManip: function (args, callback) {

                    // Flatten any nested arrays
                    args = concat.apply([], args);

                    var fragment, first, scripts, hasScripts, node, doc,
                        i = 0,
                        l = this.length,
                        set = this,
                        iNoClone = l - 1,
                        value = args[0],
                        isFunction = jQuery.isFunction(value);

                    // We can't cloneNode fragments that contain checked, in WebKit
                    if (isFunction ||
                        ( l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value) )) {
                        return this.each(function (index) {
                            var self = set.eq(index);
                            if (isFunction) {
                                args[0] = value.call(this, index, self.html());
                            }
                            self.domManip(args, callback);
                        });
                    }

                    if (l) {
                        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                        first = fragment.firstChild;

                        if (fragment.childNodes.length === 1) {
                            fragment = first;
                        }

                        if (first) {
                            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                            hasScripts = scripts.length;

                            // Use the original fragment for the last item instead of the first because it can end up
                            // being emptied incorrectly in certain situations (#8070).
                            for (; i < l; i++) {
                                node = fragment;

                                if (i !== iNoClone) {
                                    node = jQuery.clone(node, true, true);

                                    // Keep references to cloned scripts for later restoration
                                    if (hasScripts) {
                                        // Support: QtWebKit
                                        // jQuery.merge because push.apply(_, arraylike) throws
                                        jQuery.merge(scripts, getAll(node, "script"));
                                    }
                                }

                                callback.call(this[i], node, i);
                            }

                            if (hasScripts) {
                                doc = scripts[scripts.length - 1].ownerDocument;

                                // Reenable scripts
                                jQuery.map(scripts, restoreScript);

                                // Evaluate executable scripts on first document insertion
                                for (i = 0; i < hasScripts; i++) {
                                    node = scripts[i];
                                    if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {

                                        if (node.src) {
                                            // Optional AJAX dependency, but won't run scripts if not present
                                            if (jQuery._evalUrl) {
                                                jQuery._evalUrl(node.src);
                                            }
                                        } else {
                                            jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    return this;
                }
            });

            jQuery.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function (name, original) {
                jQuery.fn[name] = function (selector) {
                    var elems,
                        ret = [],
                        insert = jQuery(selector),
                        last = insert.length - 1,
                        i = 0;

                    for (; i <= last; i++) {
                        elems = i === last ? this : this.clone(true);
                        jQuery(insert[i])[original](elems);

                        // Support: QtWebKit
                        // .get() because push.apply(_, arraylike) throws
                        push.apply(ret, elems.get());
                    }

                    return this.pushStack(ret);
                };
            });


            var iframe,
                elemdisplay = {};

            /**
             * Retrieve the actual display of a element
             * @param {String} name nodeName of the element
             * @param {Object} doc Document object
             */
// Called only from within defaultDisplay
            function actualDisplay(name, doc) {
                var style,
                    elem = jQuery(doc.createElement(name)).appendTo(doc.body),

                // getDefaultComputedStyle might be reliably used only on attached element
                    display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle(elem[0]) ) ?

                        // Use of this method is a temporary fix (more like optimization) until something better comes along,
                        // since it was removed from specification and supported only in FF
                        style.display : jQuery.css(elem[0], "display");

                // We don't have any data stored on the element,
                // so use "detach" method as fast way to get rid of the element
                elem.detach();

                return display;
            }

            /**
             * Try to determine the default display value of an element
             * @param {String} nodeName
             */
            function defaultDisplay(nodeName) {
                var doc = document,
                    display = elemdisplay[nodeName];

                if (!display) {
                    display = actualDisplay(nodeName, doc);

                    // If the simple way fails, read from inside an iframe
                    if (display === "none" || !display) {

                        // Use the already-created iframe if possible
                        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

                        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                        doc = iframe[0].contentDocument;

                        // Support: IE
                        doc.write();
                        doc.close();

                        display = actualDisplay(nodeName, doc);
                        iframe.detach();
                    }

                    // Store the correct default display
                    elemdisplay[nodeName] = display;
                }

                return display;
            }

            var rmargin = (/^margin/);

            var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

            var getStyles = function (elem) {
                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
                // IE throws on elements created in popups
                // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                if (elem.ownerDocument.defaultView.opener) {
                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
                }

                return window.getComputedStyle(elem, null);
            };


            function curCSS(elem, name, computed) {
                var width, minWidth, maxWidth, ret,
                    style = elem.style;

                computed = computed || getStyles(elem);

                // Support: IE9
                // getPropertyValue is only needed for .css('filter') (#12537)
                if (computed) {
                    ret = computed.getPropertyValue(name) || computed[name];
                }

                if (computed) {

                    if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                        ret = jQuery.style(elem, name);
                    }

                    // Support: iOS < 6
                    // A tribute to the "awesome hack by Dean Edwards"
                    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                    if (rnumnonpx.test(ret) && rmargin.test(name)) {

                        // Remember the original values
                        width = style.width;
                        minWidth = style.minWidth;
                        maxWidth = style.maxWidth;

                        // Put in the new values to get a computed value out
                        style.minWidth = style.maxWidth = style.width = ret;
                        ret = computed.width;

                        // Revert the changed values
                        style.width = width;
                        style.minWidth = minWidth;
                        style.maxWidth = maxWidth;
                    }
                }

                return ret !== undefined ?
                    // Support: IE
                    // IE returns zIndex value as an integer.
                ret + "" :
                    ret;
            }


            function addGetHookIf(conditionFn, hookFn) {
                // Define the hook, we'll check on the first run if it's really needed.
                return {
                    get: function () {
                        if (conditionFn()) {
                            // Hook not needed (or it's not possible to use it due
                            // to missing dependency), remove it.
                            delete this.get;
                            return;
                        }

                        // Hook needed; redefine it so that the support test is not executed again.
                        return (this.get = hookFn).apply(this, arguments);
                    }
                };
            }


            (function () {
                var pixelPositionVal, boxSizingReliableVal,
                    docElem = document.documentElement,
                    container = document.createElement("div"),
                    div = document.createElement("div");

                if (!div.style) {
                    return;
                }

                // Support: IE9-11+
                // Style of cloned element affects source element cloned (#8908)
                div.style.backgroundClip = "content-box";
                div.cloneNode(true).style.backgroundClip = "";
                support.clearCloneStyle = div.style.backgroundClip === "content-box";

                container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
                "position:absolute";
                container.appendChild(div);

                // Executing both pixelPosition & boxSizingReliable tests require only one layout
                // so they're executed at the same time to save the second computation.
                function computePixelPositionAndBoxSizingReliable() {
                    div.style.cssText =
                        // Support: Firefox<29, Android 2.3
                        // Vendor-prefix box-sizing
                        "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
                        "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
                        "border:1px;padding:1px;width:4px;position:absolute";
                    div.innerHTML = "";
                    docElem.appendChild(container);

                    var divStyle = window.getComputedStyle(div, null);
                    pixelPositionVal = divStyle.top !== "1%";
                    boxSizingReliableVal = divStyle.width === "4px";

                    docElem.removeChild(container);
                }

                // Support: node.js jsdom
                // Don't assume that getComputedStyle is a property of the global object
                if (window.getComputedStyle) {
                    jQuery.extend(support, {
                        pixelPosition: function () {

                            // This test is executed only once but we still do memoizing
                            // since we can use the boxSizingReliable pre-computing.
                            // No need to check if the test was already performed, though.
                            computePixelPositionAndBoxSizingReliable();
                            return pixelPositionVal;
                        },
                        boxSizingReliable: function () {
                            if (boxSizingReliableVal == null) {
                                computePixelPositionAndBoxSizingReliable();
                            }
                            return boxSizingReliableVal;
                        },
                        reliableMarginRight: function () {

                            // Support: Android 2.3
                            // Check if div with explicit width and no margin-right incorrectly
                            // gets computed margin-right based on width of container. (#3333)
                            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                            // This support function is only executed once so no memoizing is needed.
                            var ret,
                                marginDiv = div.appendChild(document.createElement("div"));

                            // Reset CSS: box-sizing; display; margin; border; padding
                            marginDiv.style.cssText = div.style.cssText =
                                // Support: Firefox<29, Android 2.3
                                // Vendor-prefix box-sizing
                                "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                                "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                            marginDiv.style.marginRight = marginDiv.style.width = "0";
                            div.style.width = "1px";
                            docElem.appendChild(container);

                            ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);

                            docElem.removeChild(container);
                            div.removeChild(marginDiv);

                            return ret;
                        }
                    });
                }
            })();


// A method for quickly swapping in/out CSS properties to get correct calculations.
            jQuery.swap = function (elem, options, callback, args) {
                var ret, name,
                    old = {};

                // Remember the old values, and insert the new ones
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }

                ret = callback.apply(elem, args || []);

                // Revert the old values
                for (name in options) {
                    elem.style[name] = old[name];
                }

                return ret;
            };


            var
            // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
            // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
                rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),

                cssShow = {position: "absolute", visibility: "hidden", display: "block"},
                cssNormalTransform = {
                    letterSpacing: "0",
                    fontWeight: "400"
                },

                cssPrefixes = ["Webkit", "O", "Moz", "ms"];

// Return a css property mapped to a potentially vendor prefixed property
            function vendorPropName(style, name) {

                // Shortcut for names that are not vendor prefixed
                if (name in style) {
                    return name;
                }

                // Check for vendor prefixed names
                var capName = name[0].toUpperCase() + name.slice(1),
                    origName = name,
                    i = cssPrefixes.length;

                while (i--) {
                    name = cssPrefixes[i] + capName;
                    if (name in style) {
                        return name;
                    }
                }

                return origName;
            }

            function setPositiveNumber(elem, value, subtract) {
                var matches = rnumsplit.exec(value);
                return matches ?
                    // Guard against undefined "subtract", e.g., when used as in cssHooks
                Math.max(0, matches[1] - ( subtract || 0 )) + ( matches[2] || "px" ) :
                    value;
            }

            function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
                var i = extra === ( isBorderBox ? "border" : "content" ) ?
                        // If we already have the right measurement, avoid augmentation
                        4 :
                        // Otherwise initialize for horizontal or vertical properties
                        name === "width" ? 1 : 0,

                    val = 0;

                for (; i < 4; i += 2) {
                    // Both box models exclude margin, so add it if we want it
                    if (extra === "margin") {
                        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                    }

                    if (isBorderBox) {
                        // border-box includes padding, so remove it if we want content
                        if (extra === "content") {
                            val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                        }

                        // At this point, extra isn't border nor margin, so remove border
                        if (extra !== "margin") {
                            val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    } else {
                        // At this point, extra isn't content, so add padding
                        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                        // At this point, extra isn't content nor padding, so add border
                        if (extra !== "padding") {
                            val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    }
                }

                return val;
            }

            function getWidthOrHeight(elem, name, extra) {

                // Start with offset property, which is equivalent to the border-box value
                var valueIsBorderBox = true,
                    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                    styles = getStyles(elem),
                    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

                // Some non-html elements return undefined for offsetWidth, so check for null/undefined
                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                if (val <= 0 || val == null) {
                    // Fall back to computed then uncomputed css if necessary
                    val = curCSS(elem, name, styles);
                    if (val < 0 || val == null) {
                        val = elem.style[name];
                    }

                    // Computed unit is not pixels. Stop here and return.
                    if (rnumnonpx.test(val)) {
                        return val;
                    }

                    // Check for style in case a browser which returns unreliable values
                    // for getComputedStyle silently falls back to the reliable elem.style
                    valueIsBorderBox = isBorderBox &&
                    ( support.boxSizingReliable() || val === elem.style[name] );

                    // Normalize "", auto, and prepare for extra
                    val = parseFloat(val) || 0;
                }

                // Use the active box-sizing model to add/subtract irrelevant styles
                return ( val +
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra || ( isBorderBox ? "border" : "content" ),
                        valueIsBorderBox,
                        styles
                    )
                    ) + "px";
            }

            function showHide(elements, show) {
                var display, elem, hidden,
                    values = [],
                    index = 0,
                    length = elements.length;

                for (; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }

                    values[index] = data_priv.get(elem, "olddisplay");
                    display = elem.style.display;
                    if (show) {
                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if (!values[index] && display === "none") {
                            elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if (elem.style.display === "" && isHidden(elem)) {
                            values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                        }
                    } else {
                        hidden = isHidden(elem);

                        if (display !== "none" || !hidden) {
                            data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (index = 0; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }
                    if (!show || elem.style.display === "none" || elem.style.display === "") {
                        elem.style.display = show ? values[index] || "" : "none";
                    }
                }

                return elements;
            }

            jQuery.extend({

                // Add in style property hooks for overriding the default
                // behavior of getting and setting a style property
                cssHooks: {
                    opacity: {
                        get: function (elem, computed) {
                            if (computed) {

                                // We should always get a number back from opacity
                                var ret = curCSS(elem, "opacity");
                                return ret === "" ? "1" : ret;
                            }
                        }
                    }
                },

                // Don't automatically add "px" to these possibly-unitless properties
                cssNumber: {
                    "columnCount": true,
                    "fillOpacity": true,
                    "flexGrow": true,
                    "flexShrink": true,
                    "fontWeight": true,
                    "lineHeight": true,
                    "opacity": true,
                    "order": true,
                    "orphans": true,
                    "widows": true,
                    "zIndex": true,
                    "zoom": true
                },

                // Add in properties whose names you wish to fix before
                // setting or getting the value
                cssProps: {
                    "float": "cssFloat"
                },

                // Get and set the style property on a DOM Node
                style: function (elem, name, value, extra) {

                    // Don't set styles on text and comment nodes
                    if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                        return;
                    }

                    // Make sure that we're working with the right name
                    var ret, type, hooks,
                        origName = jQuery.camelCase(name),
                        style = elem.style;

                    name = jQuery.cssProps[origName] || ( jQuery.cssProps[origName] = vendorPropName(style, origName) );

                    // Gets hook for the prefixed version, then unprefixed version
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                    // Check if we're setting a value
                    if (value !== undefined) {
                        type = typeof value;

                        // Convert "+=" or "-=" to relative numbers (#7345)
                        if (type === "string" && (ret = rrelNum.exec(value))) {
                            value = ( ret[1] + 1 ) * ret[2] + parseFloat(jQuery.css(elem, name));
                            // Fixes bug #9237
                            type = "number";
                        }

                        // Make sure that null and NaN values aren't set (#7116)
                        if (value == null || value !== value) {
                            return;
                        }

                        // If a number, add 'px' to the (except for certain CSS properties)
                        if (type === "number" && !jQuery.cssNumber[origName]) {
                            value += "px";
                        }

                        // Support: IE9-11+
                        // background-* props affect original clone's values
                        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                            style[name] = "inherit";
                        }

                        // If a hook was provided, use that value, otherwise just set the specified value
                        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                            style[name] = value;
                        }

                    } else {
                        // If a hook was provided get the non-computed value from there
                        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                            return ret;
                        }

                        // Otherwise just get the value from the style object
                        return style[name];
                    }
                },

                css: function (elem, name, extra, styles) {
                    var val, num, hooks,
                        origName = jQuery.camelCase(name);

                    // Make sure that we're working with the right name
                    name = jQuery.cssProps[origName] || ( jQuery.cssProps[origName] = vendorPropName(elem.style, origName) );

                    // Try prefixed name followed by the unprefixed name
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                    // If a hook was provided get the computed value from there
                    if (hooks && "get" in hooks) {
                        val = hooks.get(elem, true, extra);
                    }

                    // Otherwise, if a way to get the computed value exists, use that
                    if (val === undefined) {
                        val = curCSS(elem, name, styles);
                    }

                    // Convert "normal" to computed value
                    if (val === "normal" && name in cssNormalTransform) {
                        val = cssNormalTransform[name];
                    }

                    // Make numeric if forced or a qualifier was provided and val looks numeric
                    if (extra === "" || extra) {
                        num = parseFloat(val);
                        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
                    }
                    return val;
                }
            });

            jQuery.each(["height", "width"], function (i, name) {
                jQuery.cssHooks[name] = {
                    get: function (elem, computed, extra) {
                        if (computed) {

                            // Certain elements can have dimension info if we invisibly show them
                            // but it must have a current display style that would benefit
                            return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ?
                                jQuery.swap(elem, cssShow, function () {
                                    return getWidthOrHeight(elem, name, extra);
                                }) :
                                getWidthOrHeight(elem, name, extra);
                        }
                    },

                    set: function (elem, value, extra) {
                        var styles = extra && getStyles(elem);
                        return setPositiveNumber(elem, value, extra ?
                                augmentWidthOrHeight(
                                    elem,
                                    name,
                                    extra,
                                    jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                                    styles
                                ) : 0
                        );
                    }
                };
            });

// Support: Android 2.3
            jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
                function (elem, computed) {
                    if (computed) {
                        return jQuery.swap(elem, {"display": "inline-block"},
                            curCSS, [elem, "marginRight"]);
                    }
                }
            );

// These hooks are used by animate to expand properties
            jQuery.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function (prefix, suffix) {
                jQuery.cssHooks[prefix + suffix] = {
                    expand: function (value) {
                        var i = 0,
                            expanded = {},

                        // Assumes a single number if not a string
                            parts = typeof value === "string" ? value.split(" ") : [value];

                        for (; i < 4; i++) {
                            expanded[prefix + cssExpand[i] + suffix] =
                                parts[i] || parts[i - 2] || parts[0];
                        }

                        return expanded;
                    }
                };

                if (!rmargin.test(prefix)) {
                    jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
                }
            });

            jQuery.fn.extend({
                css: function (name, value) {
                    return access(this, function (elem, name, value) {
                        var styles, len,
                            map = {},
                            i = 0;

                        if (jQuery.isArray(name)) {
                            styles = getStyles(elem);
                            len = name.length;

                            for (; i < len; i++) {
                                map[name[i]] = jQuery.css(elem, name[i], false, styles);
                            }

                            return map;
                        }

                        return value !== undefined ?
                            jQuery.style(elem, name, value) :
                            jQuery.css(elem, name);
                    }, name, value, arguments.length > 1);
                },
                show: function () {
                    return showHide(this, true);
                },
                hide: function () {
                    return showHide(this);
                },
                toggle: function (state) {
                    if (typeof state === "boolean") {
                        return state ? this.show() : this.hide();
                    }

                    return this.each(function () {
                        if (isHidden(this)) {
                            jQuery(this).show();
                        } else {
                            jQuery(this).hide();
                        }
                    });
                }
            });


            function Tween(elem, options, prop, end, easing) {
                return new Tween.prototype.init(elem, options, prop, end, easing);
            }

            jQuery.Tween = Tween;

            Tween.prototype = {
                constructor: Tween,
                init: function (elem, options, prop, end, easing, unit) {
                    this.elem = elem;
                    this.prop = prop;
                    this.easing = easing || "swing";
                    this.options = options;
                    this.start = this.now = this.cur();
                    this.end = end;
                    this.unit = unit || ( jQuery.cssNumber[prop] ? "" : "px" );
                },
                cur: function () {
                    var hooks = Tween.propHooks[this.prop];

                    return hooks && hooks.get ?
                        hooks.get(this) :
                        Tween.propHooks._default.get(this);
                },
                run: function (percent) {
                    var eased,
                        hooks = Tween.propHooks[this.prop];

                    if (this.options.duration) {
                        this.pos = eased = jQuery.easing[this.easing](
                            percent, this.options.duration * percent, 0, 1, this.options.duration
                        );
                    } else {
                        this.pos = eased = percent;
                    }
                    this.now = ( this.end - this.start ) * eased + this.start;

                    if (this.options.step) {
                        this.options.step.call(this.elem, this.now, this);
                    }

                    if (hooks && hooks.set) {
                        hooks.set(this);
                    } else {
                        Tween.propHooks._default.set(this);
                    }
                    return this;
                }
            };

            Tween.prototype.init.prototype = Tween.prototype;

            Tween.propHooks = {
                _default: {
                    get: function (tween) {
                        var result;

                        if (tween.elem[tween.prop] != null &&
                            (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                            return tween.elem[tween.prop];
                        }

                        // Passing an empty string as a 3rd parameter to .css will automatically
                        // attempt a parseFloat and fallback to a string if the parse fails.
                        // Simple values such as "10px" are parsed to Float;
                        // complex values such as "rotate(1rad)" are returned as-is.
                        result = jQuery.css(tween.elem, tween.prop, "");
                        // Empty strings, null, undefined and "auto" are converted to 0.
                        return !result || result === "auto" ? 0 : result;
                    },
                    set: function (tween) {
                        // Use step hook for back compat.
                        // Use cssHook if its there.
                        // Use .style if available and use plain properties where available.
                        if (jQuery.fx.step[tween.prop]) {
                            jQuery.fx.step[tween.prop](tween);
                        } else if (tween.elem.style && ( tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop] )) {
                            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                        } else {
                            tween.elem[tween.prop] = tween.now;
                        }
                    }
                }
            };

// Support: IE9
// Panic based approach to setting things on disconnected nodes
            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function (tween) {
                    if (tween.elem.nodeType && tween.elem.parentNode) {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            };

            jQuery.easing = {
                linear: function (p) {
                    return p;
                },
                swing: function (p) {
                    return 0.5 - Math.cos(p * Math.PI) / 2;
                }
            };

            jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
            jQuery.fx.step = {};


            var
                fxNow, timerId,
                rfxtypes = /^(?:toggle|show|hide)$/,
                rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
                rrun = /queueHooks$/,
                animationPrefilters = [defaultPrefilter],
                tweeners = {
                    "*": [function (prop, value) {
                        var tween = this.createTween(prop, value),
                            target = tween.cur(),
                            parts = rfxnum.exec(value),
                            unit = parts && parts[3] || ( jQuery.cssNumber[prop] ? "" : "px" ),

                        // Starting value computation is required for potential unit mismatches
                            start = ( jQuery.cssNumber[prop] || unit !== "px" && +target ) &&
                                rfxnum.exec(jQuery.css(tween.elem, prop)),
                            scale = 1,
                            maxIterations = 20;

                        if (start && start[3] !== unit) {
                            // Trust units reported by jQuery.css
                            unit = unit || start[3];

                            // Make sure we update the tween properties later on
                            parts = parts || [];

                            // Iteratively approximate from a nonzero starting point
                            start = +target || 1;

                            do {
                                // If previous iteration zeroed out, double until we get *something*.
                                // Use string for doubling so we don't accidentally see scale as unchanged below
                                scale = scale || ".5";

                                // Adjust and apply
                                start = start / scale;
                                jQuery.style(tween.elem, prop, start + unit);

                                // Update scale, tolerating zero or NaN from tween.cur(),
                                // break the loop if scale is unchanged or perfect, or if we've just had enough
                            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                        }

                        // Update tween properties
                        if (parts) {
                            start = tween.start = +start || +target || 0;
                            tween.unit = unit;
                            // If a +=/-= token was provided, we're doing a relative animation
                            tween.end = parts[1] ?
                            start + ( parts[1] + 1 ) * parts[2] :
                                +parts[2];
                        }

                        return tween;
                    }]
                };

// Animations created synchronously will run synchronously
            function createFxNow() {
                setTimeout(function () {
                    fxNow = undefined;
                });
                return ( fxNow = jQuery.now() );
            }

// Generate parameters to create a standard animation
            function genFx(type, includeWidth) {
                var which,
                    i = 0,
                    attrs = {height: type};

                // If we include width, step value is 1 to do all cssExpand values,
                // otherwise step value is 2 to skip over Left and Right
                includeWidth = includeWidth ? 1 : 0;
                for (; i < 4; i += 2 - includeWidth) {
                    which = cssExpand[i];
                    attrs["margin" + which] = attrs["padding" + which] = type;
                }

                if (includeWidth) {
                    attrs.opacity = attrs.width = type;
                }

                return attrs;
            }

            function createTween(value, prop, animation) {
                var tween,
                    collection = ( tweeners[prop] || [] ).concat(tweeners["*"]),
                    index = 0,
                    length = collection.length;
                for (; index < length; index++) {
                    if ((tween = collection[index].call(animation, prop, value))) {

                        // We're done with this property
                        return tween;
                    }
                }
            }

            function defaultPrefilter(elem, props, opts) {
                /* jshint validthis: true */
                var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
                    anim = this,
                    orig = {},
                    style = elem.style,
                    hidden = elem.nodeType && isHidden(elem),
                    dataShow = data_priv.get(elem, "fxshow");

                // Handle queue: false promises
                if (!opts.queue) {
                    hooks = jQuery._queueHooks(elem, "fx");
                    if (hooks.unqueued == null) {
                        hooks.unqueued = 0;
                        oldfire = hooks.empty.fire;
                        hooks.empty.fire = function () {
                            if (!hooks.unqueued) {
                                oldfire();
                            }
                        };
                    }
                    hooks.unqueued++;

                    anim.always(function () {
                        // Ensure the complete handler is called before this completes
                        anim.always(function () {
                            hooks.unqueued--;
                            if (!jQuery.queue(elem, "fx").length) {
                                hooks.empty.fire();
                            }
                        });
                    });
                }

                // Height/width overflow pass
                if (elem.nodeType === 1 && ( "height" in props || "width" in props )) {
                    // Make sure that nothing sneaks out
                    // Record all 3 overflow attributes because IE9-10 do not
                    // change the overflow attribute when overflowX and
                    // overflowY are set to the same value
                    opts.overflow = [style.overflow, style.overflowX, style.overflowY];

                    // Set display property to inline-block for height/width
                    // animations on inline elements that are having width/height animated
                    display = jQuery.css(elem, "display");

                    // Test default display if display is currently "none"
                    checkDisplay = display === "none" ?
                    data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

                    if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                        style.display = "inline-block";
                    }
                }

                if (opts.overflow) {
                    style.overflow = "hidden";
                    anim.always(function () {
                        style.overflow = opts.overflow[0];
                        style.overflowX = opts.overflow[1];
                        style.overflowY = opts.overflow[2];
                    });
                }

                // show/hide pass
                for (prop in props) {
                    value = props[prop];
                    if (rfxtypes.exec(value)) {
                        delete props[prop];
                        toggle = toggle || value === "toggle";
                        if (value === ( hidden ? "hide" : "show" )) {

                            // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                                hidden = true;
                            } else {
                                continue;
                            }
                        }
                        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

                        // Any non-fx value stops us from restoring the original display value
                    } else {
                        display = undefined;
                    }
                }

                if (!jQuery.isEmptyObject(orig)) {
                    if (dataShow) {
                        if ("hidden" in dataShow) {
                            hidden = dataShow.hidden;
                        }
                    } else {
                        dataShow = data_priv.access(elem, "fxshow", {});
                    }

                    // Store state if its toggle - enables .stop().toggle() to "reverse"
                    if (toggle) {
                        dataShow.hidden = !hidden;
                    }
                    if (hidden) {
                        jQuery(elem).show();
                    } else {
                        anim.done(function () {
                            jQuery(elem).hide();
                        });
                    }
                    anim.done(function () {
                        var prop;

                        data_priv.remove(elem, "fxshow");
                        for (prop in orig) {
                            jQuery.style(elem, prop, orig[prop]);
                        }
                    });
                    for (prop in orig) {
                        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

                        if (!( prop in dataShow )) {
                            dataShow[prop] = tween.start;
                            if (hidden) {
                                tween.end = tween.start;
                                tween.start = prop === "width" || prop === "height" ? 1 : 0;
                            }
                        }
                    }

                    // If this is a noop like .hide().hide(), restore an overwritten display value
                } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
                    style.display = display;
                }
            }

            function propFilter(props, specialEasing) {
                var index, name, easing, value, hooks;

                // camelCase, specialEasing and expand cssHook pass
                for (index in props) {
                    name = jQuery.camelCase(index);
                    easing = specialEasing[name];
                    value = props[index];
                    if (jQuery.isArray(value)) {
                        easing = value[1];
                        value = props[index] = value[0];
                    }

                    if (index !== name) {
                        props[name] = value;
                        delete props[index];
                    }

                    hooks = jQuery.cssHooks[name];
                    if (hooks && "expand" in hooks) {
                        value = hooks.expand(value);
                        delete props[name];

                        // Not quite $.extend, this won't overwrite existing keys.
                        // Reusing 'index' because we have the correct "name"
                        for (index in value) {
                            if (!( index in props )) {
                                props[index] = value[index];
                                specialEasing[index] = easing;
                            }
                        }
                    } else {
                        specialEasing[name] = easing;
                    }
                }
            }

            function Animation(elem, properties, options) {
                var result,
                    stopped,
                    index = 0,
                    length = animationPrefilters.length,
                    deferred = jQuery.Deferred().always(function () {
                        // Don't match elem in the :animated selector
                        delete tick.elem;
                    }),
                    tick = function () {
                        if (stopped) {
                            return false;
                        }
                        var currentTime = fxNow || createFxNow(),
                            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                        // Support: Android 2.3
                        // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                            temp = remaining / animation.duration || 0,
                            percent = 1 - temp,
                            index = 0,
                            length = animation.tweens.length;

                        for (; index < length; index++) {
                            animation.tweens[index].run(percent);
                        }

                        deferred.notifyWith(elem, [animation, percent, remaining]);

                        if (percent < 1 && length) {
                            return remaining;
                        } else {
                            deferred.resolveWith(elem, [animation]);
                            return false;
                        }
                    },
                    animation = deferred.promise({
                        elem: elem,
                        props: jQuery.extend({}, properties),
                        opts: jQuery.extend(true, {specialEasing: {}}, options),
                        originalProperties: properties,
                        originalOptions: options,
                        startTime: fxNow || createFxNow(),
                        duration: options.duration,
                        tweens: [],
                        createTween: function (prop, end) {
                            var tween = jQuery.Tween(elem, animation.opts, prop, end,
                                animation.opts.specialEasing[prop] || animation.opts.easing);
                            animation.tweens.push(tween);
                            return tween;
                        },
                        stop: function (gotoEnd) {
                            var index = 0,
                            // If we are going to the end, we want to run all the tweens
                            // otherwise we skip this part
                                length = gotoEnd ? animation.tweens.length : 0;
                            if (stopped) {
                                return this;
                            }
                            stopped = true;
                            for (; index < length; index++) {
                                animation.tweens[index].run(1);
                            }

                            // Resolve when we played the last frame; otherwise, reject
                            if (gotoEnd) {
                                deferred.resolveWith(elem, [animation, gotoEnd]);
                            } else {
                                deferred.rejectWith(elem, [animation, gotoEnd]);
                            }
                            return this;
                        }
                    }),
                    props = animation.props;

                propFilter(props, animation.opts.specialEasing);

                for (; index < length; index++) {
                    result = animationPrefilters[index].call(animation, elem, props, animation.opts);
                    if (result) {
                        return result;
                    }
                }

                jQuery.map(props, createTween, animation);

                if (jQuery.isFunction(animation.opts.start)) {
                    animation.opts.start.call(elem, animation);
                }

                jQuery.fx.timer(
                    jQuery.extend(tick, {
                        elem: elem,
                        anim: animation,
                        queue: animation.opts.queue
                    })
                );

                // attach callbacks from options
                return animation.progress(animation.opts.progress)
                    .done(animation.opts.done, animation.opts.complete)
                    .fail(animation.opts.fail)
                    .always(animation.opts.always);
            }

            jQuery.Animation = jQuery.extend(Animation, {

                tweener: function (props, callback) {
                    if (jQuery.isFunction(props)) {
                        callback = props;
                        props = ["*"];
                    } else {
                        props = props.split(" ");
                    }

                    var prop,
                        index = 0,
                        length = props.length;

                    for (; index < length; index++) {
                        prop = props[index];
                        tweeners[prop] = tweeners[prop] || [];
                        tweeners[prop].unshift(callback);
                    }
                },

                prefilter: function (callback, prepend) {
                    if (prepend) {
                        animationPrefilters.unshift(callback);
                    } else {
                        animationPrefilters.push(callback);
                    }
                }
            });

            jQuery.speed = function (speed, easing, fn) {
                var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing ||
                    jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };

                opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                    opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

                // Normalize opt.queue - true/undefined/null -> "fx"
                if (opt.queue == null || opt.queue === true) {
                    opt.queue = "fx";
                }

                // Queueing
                opt.old = opt.complete;

                opt.complete = function () {
                    if (jQuery.isFunction(opt.old)) {
                        opt.old.call(this);
                    }

                    if (opt.queue) {
                        jQuery.dequeue(this, opt.queue);
                    }
                };

                return opt;
            };

            jQuery.fn.extend({
                fadeTo: function (speed, to, easing, callback) {

                    // Show any hidden elements after setting opacity to 0
                    return this.filter(isHidden).css("opacity", 0).show()

                        // Animate to the value specified
                        .end().animate({opacity: to}, speed, easing, callback);
                },
                animate: function (prop, speed, easing, callback) {
                    var empty = jQuery.isEmptyObject(prop),
                        optall = jQuery.speed(speed, easing, callback),
                        doAnimation = function () {
                            // Operate on a copy of prop so per-property easing won't be lost
                            var anim = Animation(this, jQuery.extend({}, prop), optall);

                            // Empty animations, or finishing resolves immediately
                            if (empty || data_priv.get(this, "finish")) {
                                anim.stop(true);
                            }
                        };
                    doAnimation.finish = doAnimation;

                    return empty || optall.queue === false ?
                        this.each(doAnimation) :
                        this.queue(optall.queue, doAnimation);
                },
                stop: function (type, clearQueue, gotoEnd) {
                    var stopQueue = function (hooks) {
                        var stop = hooks.stop;
                        delete hooks.stop;
                        stop(gotoEnd);
                    };

                    if (typeof type !== "string") {
                        gotoEnd = clearQueue;
                        clearQueue = type;
                        type = undefined;
                    }
                    if (clearQueue && type !== false) {
                        this.queue(type || "fx", []);
                    }

                    return this.each(function () {
                        var dequeue = true,
                            index = type != null && type + "queueHooks",
                            timers = jQuery.timers,
                            data = data_priv.get(this);

                        if (index) {
                            if (data[index] && data[index].stop) {
                                stopQueue(data[index]);
                            }
                        } else {
                            for (index in data) {
                                if (data[index] && data[index].stop && rrun.test(index)) {
                                    stopQueue(data[index]);
                                }
                            }
                        }

                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                                timers[index].anim.stop(gotoEnd);
                                dequeue = false;
                                timers.splice(index, 1);
                            }
                        }

                        // Start the next in the queue if the last step wasn't forced.
                        // Timers currently will call their complete callbacks, which
                        // will dequeue but only if they were gotoEnd.
                        if (dequeue || !gotoEnd) {
                            jQuery.dequeue(this, type);
                        }
                    });
                },
                finish: function (type) {
                    if (type !== false) {
                        type = type || "fx";
                    }
                    return this.each(function () {
                        var index,
                            data = data_priv.get(this),
                            queue = data[type + "queue"],
                            hooks = data[type + "queueHooks"],
                            timers = jQuery.timers,
                            length = queue ? queue.length : 0;

                        // Enable finishing flag on private data
                        data.finish = true;

                        // Empty the queue first
                        jQuery.queue(this, type, []);

                        if (hooks && hooks.stop) {
                            hooks.stop.call(this, true);
                        }

                        // Look for any active animations, and finish them
                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this && timers[index].queue === type) {
                                timers[index].anim.stop(true);
                                timers.splice(index, 1);
                            }
                        }

                        // Look for any animations in the old queue and finish them
                        for (index = 0; index < length; index++) {
                            if (queue[index] && queue[index].finish) {
                                queue[index].finish.call(this);
                            }
                        }

                        // Turn off finishing flag
                        delete data.finish;
                    });
                }
            });

            jQuery.each(["toggle", "show", "hide"], function (i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function (speed, easing, callback) {
                    return speed == null || typeof speed === "boolean" ?
                        cssFn.apply(this, arguments) :
                        this.animate(genFx(name, true), speed, easing, callback);
                };
            });

// Generate shortcuts for custom animations
            jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: {opacity: "show"},
                fadeOut: {opacity: "hide"},
                fadeToggle: {opacity: "toggle"}
            }, function (name, props) {
                jQuery.fn[name] = function (speed, easing, callback) {
                    return this.animate(props, speed, easing, callback);
                };
            });

            jQuery.timers = [];
            jQuery.fx.tick = function () {
                var timer,
                    i = 0,
                    timers = jQuery.timers;

                fxNow = jQuery.now();

                for (; i < timers.length; i++) {
                    timer = timers[i];
                    // Checks the timer has not already been removed
                    if (!timer() && timers[i] === timer) {
                        timers.splice(i--, 1);
                    }
                }

                if (!timers.length) {
                    jQuery.fx.stop();
                }
                fxNow = undefined;
            };

            jQuery.fx.timer = function (timer) {
                jQuery.timers.push(timer);
                if (timer()) {
                    jQuery.fx.start();
                } else {
                    jQuery.timers.pop();
                }
            };

            jQuery.fx.interval = 13;

            jQuery.fx.start = function () {
                if (!timerId) {
                    timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
                }
            };

            jQuery.fx.stop = function () {
                clearInterval(timerId);
                timerId = null;
            };

            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,
                // Default speed
                _default: 400
            };


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
            jQuery.fn.delay = function (time, type) {
                time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
                type = type || "fx";

                return this.queue(type, function (next, hooks) {
                    var timeout = setTimeout(next, time);
                    hooks.stop = function () {
                        clearTimeout(timeout);
                    };
                });
            };


            (function () {
                var input = document.createElement("input"),
                    select = document.createElement("select"),
                    opt = select.appendChild(document.createElement("option"));

                input.type = "checkbox";

                // Support: iOS<=5.1, Android<=4.2+
                // Default value for a checkbox should be "on"
                support.checkOn = input.value !== "";

                // Support: IE<=11+
                // Must access selectedIndex to make default options select
                support.optSelected = opt.selected;

                // Support: Android<=2.3
                // Options inside disabled selects are incorrectly marked as disabled
                select.disabled = true;
                support.optDisabled = !opt.disabled;

                // Support: IE<=11+
                // An input loses its value after becoming a radio
                input = document.createElement("input");
                input.value = "t";
                input.type = "radio";
                support.radioValue = input.value === "t";
            })();


            var nodeHook, boolHook,
                attrHandle = jQuery.expr.attrHandle;

            jQuery.fn.extend({
                attr: function (name, value) {
                    return access(this, jQuery.attr, name, value, arguments.length > 1);
                },

                removeAttr: function (name) {
                    return this.each(function () {
                        jQuery.removeAttr(this, name);
                    });
                }
            });

            jQuery.extend({
                attr: function (elem, name, value) {
                    var hooks, ret,
                        nType = elem.nodeType;

                    // don't get/set attributes on text, comment and attribute nodes
                    if (!elem || nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }

                    // Fallback to prop when attributes are not supported
                    if (typeof elem.getAttribute === strundefined) {
                        return jQuery.prop(elem, name, value);
                    }

                    // All attributes are lowercase
                    // Grab necessary hook if one is defined
                    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                        name = name.toLowerCase();
                        hooks = jQuery.attrHooks[name] ||
                        ( jQuery.expr.match.bool.test(name) ? boolHook : nodeHook );
                    }

                    if (value !== undefined) {

                        if (value === null) {
                            jQuery.removeAttr(elem, name);

                        } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                            return ret;

                        } else {
                            elem.setAttribute(name, value + "");
                            return value;
                        }

                    } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                        return ret;

                    } else {
                        ret = jQuery.find.attr(elem, name);

                        // Non-existent attributes return null, we normalize to undefined
                        return ret == null ?
                            undefined :
                            ret;
                    }
                },

                removeAttr: function (elem, value) {
                    var name, propName,
                        i = 0,
                        attrNames = value && value.match(rnotwhite);

                    if (attrNames && elem.nodeType === 1) {
                        while ((name = attrNames[i++])) {
                            propName = jQuery.propFix[name] || name;

                            // Boolean attributes get special treatment (#10870)
                            if (jQuery.expr.match.bool.test(name)) {
                                // Set corresponding property to false
                                elem[propName] = false;
                            }

                            elem.removeAttribute(name);
                        }
                    }
                },

                attrHooks: {
                    type: {
                        set: function (elem, value) {
                            if (!support.radioValue && value === "radio" &&
                                jQuery.nodeName(elem, "input")) {
                                var val = elem.value;
                                elem.setAttribute("type", value);
                                if (val) {
                                    elem.value = val;
                                }
                                return value;
                            }
                        }
                    }
                }
            });

// Hooks for boolean attributes
            boolHook = {
                set: function (elem, value, name) {
                    if (value === false) {
                        // Remove boolean attributes when set to false
                        jQuery.removeAttr(elem, name);
                    } else {
                        elem.setAttribute(name, name);
                    }
                    return name;
                }
            };
            jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
                var getter = attrHandle[name] || jQuery.find.attr;

                attrHandle[name] = function (elem, name, isXML) {
                    var ret, handle;
                    if (!isXML) {
                        // Avoid an infinite loop by temporarily removing this function from the getter
                        handle = attrHandle[name];
                        attrHandle[name] = ret;
                        ret = getter(elem, name, isXML) != null ?
                            name.toLowerCase() :
                            null;
                        attrHandle[name] = handle;
                    }
                    return ret;
                };
            });


            var rfocusable = /^(?:input|select|textarea|button)$/i;

            jQuery.fn.extend({
                prop: function (name, value) {
                    return access(this, jQuery.prop, name, value, arguments.length > 1);
                },

                removeProp: function (name) {
                    return this.each(function () {
                        delete this[jQuery.propFix[name] || name];
                    });
                }
            });

            jQuery.extend({
                propFix: {
                    "for": "htmlFor",
                    "class": "className"
                },

                prop: function (elem, name, value) {
                    var ret, hooks, notxml,
                        nType = elem.nodeType;

                    // Don't get/set properties on text, comment and attribute nodes
                    if (!elem || nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }

                    notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

                    if (notxml) {
                        // Fix name and attach hooks
                        name = jQuery.propFix[name] || name;
                        hooks = jQuery.propHooks[name];
                    }

                    if (value !== undefined) {
                        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ?
                            ret :
                            ( elem[name] = value );

                    } else {
                        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ?
                            ret :
                            elem[name];
                    }
                },

                propHooks: {
                    tabIndex: {
                        get: function (elem) {
                            return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ?
                                elem.tabIndex :
                                -1;
                        }
                    }
                }
            });

            if (!support.optSelected) {
                jQuery.propHooks.selected = {
                    get: function (elem) {
                        var parent = elem.parentNode;
                        if (parent && parent.parentNode) {
                            parent.parentNode.selectedIndex;
                        }
                        return null;
                    }
                };
            }

            jQuery.each([
                "tabIndex",
                "readOnly",
                "maxLength",
                "cellSpacing",
                "cellPadding",
                "rowSpan",
                "colSpan",
                "useMap",
                "frameBorder",
                "contentEditable"
            ], function () {
                jQuery.propFix[this.toLowerCase()] = this;
            });


            var rclass = /[\t\r\n\f]/g;

            jQuery.fn.extend({
                addClass: function (value) {
                    var classes, elem, cur, clazz, j, finalValue,
                        proceed = typeof value === "string" && value,
                        i = 0,
                        len = this.length;

                    if (jQuery.isFunction(value)) {
                        return this.each(function (j) {
                            jQuery(this).addClass(value.call(this, j, this.className));
                        });
                    }

                    if (proceed) {
                        // The disjunction here is for better compressibility (see removeClass)
                        classes = ( value || "" ).match(rnotwhite) || [];

                        for (; i < len; i++) {
                            elem = this[i];
                            cur = elem.nodeType === 1 && ( elem.className ?
                                ( " " + elem.className + " " ).replace(rclass, " ") :
                                " "
                            );

                            if (cur) {
                                j = 0;
                                while ((clazz = classes[j++])) {
                                    if (cur.indexOf(" " + clazz + " ") < 0) {
                                        cur += clazz + " ";
                                    }
                                }

                                // only assign if different to avoid unneeded rendering.
                                finalValue = jQuery.trim(cur);
                                if (elem.className !== finalValue) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                removeClass: function (value) {
                    var classes, elem, cur, clazz, j, finalValue,
                        proceed = arguments.length === 0 || typeof value === "string" && value,
                        i = 0,
                        len = this.length;

                    if (jQuery.isFunction(value)) {
                        return this.each(function (j) {
                            jQuery(this).removeClass(value.call(this, j, this.className));
                        });
                    }
                    if (proceed) {
                        classes = ( value || "" ).match(rnotwhite) || [];

                        for (; i < len; i++) {
                            elem = this[i];
                            // This expression is here for better compressibility (see addClass)
                            cur = elem.nodeType === 1 && ( elem.className ?
                                ( " " + elem.className + " " ).replace(rclass, " ") :
                                ""
                            );

                            if (cur) {
                                j = 0;
                                while ((clazz = classes[j++])) {
                                    // Remove *all* instances
                                    while (cur.indexOf(" " + clazz + " ") >= 0) {
                                        cur = cur.replace(" " + clazz + " ", " ");
                                    }
                                }

                                // Only assign if different to avoid unneeded rendering.
                                finalValue = value ? jQuery.trim(cur) : "";
                                if (elem.className !== finalValue) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }

                    return this;
                },

                toggleClass: function (value, stateVal) {
                    var type = typeof value;

                    if (typeof stateVal === "boolean" && type === "string") {
                        return stateVal ? this.addClass(value) : this.removeClass(value);
                    }

                    if (jQuery.isFunction(value)) {
                        return this.each(function (i) {
                            jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                        });
                    }

                    return this.each(function () {
                        if (type === "string") {
                            // Toggle individual class names
                            var className,
                                i = 0,
                                self = jQuery(this),
                                classNames = value.match(rnotwhite) || [];

                            while ((className = classNames[i++])) {
                                // Check each className given, space separated list
                                if (self.hasClass(className)) {
                                    self.removeClass(className);
                                } else {
                                    self.addClass(className);
                                }
                            }

                            // Toggle whole class name
                        } else if (type === strundefined || type === "boolean") {
                            if (this.className) {
                                // store className if set
                                data_priv.set(this, "__className__", this.className);
                            }

                            // If the element has a class name or if we're passed `false`,
                            // then remove the whole classname (if there was one, the above saved it).
                            // Otherwise bring back whatever was previously saved (if anything),
                            // falling back to the empty string if nothing was stored.
                            this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                        }
                    });
                },

                hasClass: function (selector) {
                    var className = " " + selector + " ",
                        i = 0,
                        l = this.length;
                    for (; i < l; i++) {
                        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                            return true;
                        }
                    }

                    return false;
                }
            });


            var rreturn = /\r/g;

            jQuery.fn.extend({
                val: function (value) {
                    var hooks, ret, isFunction,
                        elem = this[0];

                    if (!arguments.length) {
                        if (elem) {
                            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

                            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                                return ret;
                            }

                            ret = elem.value;

                            return typeof ret === "string" ?
                                // Handle most common string cases
                                ret.replace(rreturn, "") :
                                // Handle cases where value is null/undef or number
                                ret == null ? "" : ret;
                        }

                        return;
                    }

                    isFunction = jQuery.isFunction(value);

                    return this.each(function (i) {
                        var val;

                        if (this.nodeType !== 1) {
                            return;
                        }

                        if (isFunction) {
                            val = value.call(this, i, jQuery(this).val());
                        } else {
                            val = value;
                        }

                        // Treat null/undefined as ""; convert numbers to string
                        if (val == null) {
                            val = "";

                        } else if (typeof val === "number") {
                            val += "";

                        } else if (jQuery.isArray(val)) {
                            val = jQuery.map(val, function (value) {
                                return value == null ? "" : value + "";
                            });
                        }

                        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                        // If set returns undefined, fall back to normal setting
                        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                            this.value = val;
                        }
                    });
                }
            });

            jQuery.extend({
                valHooks: {
                    option: {
                        get: function (elem) {
                            var val = jQuery.find.attr(elem, "value");
                            return val != null ?
                                val :
                                // Support: IE10-11+
                                // option.text throws exceptions (#14686, #14858)
                                jQuery.trim(jQuery.text(elem));
                        }
                    },
                    select: {
                        get: function (elem) {
                            var value, option,
                                options = elem.options,
                                index = elem.selectedIndex,
                                one = elem.type === "select-one" || index < 0,
                                values = one ? null : [],
                                max = one ? index + 1 : options.length,
                                i = index < 0 ?
                                    max :
                                    one ? index : 0;

                            // Loop through all the selected options
                            for (; i < max; i++) {
                                option = options[i];

                                // IE6-9 doesn't update selected after form reset (#2551)
                                if (( option.selected || i === index ) &&
                                        // Don't return options that are disabled or in a disabled optgroup
                                    ( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
                                    ( !option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup") )) {

                                    // Get the specific value for the option
                                    value = jQuery(option).val();

                                    // We don't need an array for one selects
                                    if (one) {
                                        return value;
                                    }

                                    // Multi-Selects return an array
                                    values.push(value);
                                }
                            }

                            return values;
                        },

                        set: function (elem, value) {
                            var optionSet, option,
                                options = elem.options,
                                values = jQuery.makeArray(value),
                                i = options.length;

                            while (i--) {
                                option = options[i];
                                if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
                                    optionSet = true;
                                }
                            }

                            // Force browsers to behave consistently when non-matching value is set
                            if (!optionSet) {
                                elem.selectedIndex = -1;
                            }
                            return values;
                        }
                    }
                }
            });

// Radios and checkboxes getter/setter
            jQuery.each(["radio", "checkbox"], function () {
                jQuery.valHooks[this] = {
                    set: function (elem, value) {
                        if (jQuery.isArray(value)) {
                            return ( elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0 );
                        }
                    }
                };
                if (!support.checkOn) {
                    jQuery.valHooks[this].get = function (elem) {
                        return elem.getAttribute("value") === null ? "on" : elem.value;
                    };
                }
            });


// Return jQuery for attributes-only inclusion


            jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
            "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
            "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

                // Handle event binding
                jQuery.fn[name] = function (data, fn) {
                    return arguments.length > 0 ?
                        this.on(name, null, data, fn) :
                        this.trigger(name);
                };
            });

            jQuery.fn.extend({
                hover: function (fnOver, fnOut) {
                    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
                },

                bind: function (types, data, fn) {
                    return this.on(types, null, data, fn);
                },
                unbind: function (types, fn) {
                    return this.off(types, null, fn);
                },

                delegate: function (selector, types, data, fn) {
                    return this.on(types, selector, data, fn);
                },
                undelegate: function (selector, types, fn) {
                    // ( namespace ) or ( selector, types [, fn] )
                    return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
                }
            });


            var nonce = jQuery.now();

            var rquery = (/\?/);


// Support: Android 2.3
// Workaround failure to string-cast null input
            jQuery.parseJSON = function (data) {
                return JSON.parse(data + "");
            };


// Cross-browser xml parsing
            jQuery.parseXML = function (data) {
                var xml, tmp;
                if (!data || typeof data !== "string") {
                    return null;
                }

                // Support: IE9
                try {
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                } catch (e) {
                    xml = undefined;
                }

                if (!xml || xml.getElementsByTagName("parsererror").length) {
                    jQuery.error("Invalid XML: " + data);
                }
                return xml;
            };


            var
                rhash = /#.*$/,
                rts = /([?&])_=[^&]*/,
                rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
            // #7653, #8125, #8152: local protocol detection
                rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                rnoContent = /^(?:GET|HEAD)$/,
                rprotocol = /^\/\//,
                rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

            /* Prefilters
             * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
             * 2) These are called:
             *    - BEFORE asking for a transport
             *    - AFTER param serialization (s.data is a string if s.processData is true)
             * 3) key is the dataType
             * 4) the catchall symbol "*" can be used
             * 5) execution will start with transport dataType and THEN continue down to "*" if needed
             */
                prefilters = {},

            /* Transports bindings
             * 1) key is the dataType
             * 2) the catchall symbol "*" can be used
             * 3) selection will start with transport dataType and THEN go to "*" if needed
             */
                transports = {},

            // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                allTypes = "*/".concat("*"),

            // Document location
                ajaxLocation = window.location.href,

            // Segment location into parts
                ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function addToPrefiltersOrTransports(structure) {

                // dataTypeExpression is optional and defaults to "*"
                return function (dataTypeExpression, func) {

                    if (typeof dataTypeExpression !== "string") {
                        func = dataTypeExpression;
                        dataTypeExpression = "*";
                    }

                    var dataType,
                        i = 0,
                        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

                    if (jQuery.isFunction(func)) {
                        // For each dataType in the dataTypeExpression
                        while ((dataType = dataTypes[i++])) {
                            // Prepend if requested
                            if (dataType[0] === "+") {
                                dataType = dataType.slice(1) || "*";
                                (structure[dataType] = structure[dataType] || []).unshift(func);

                                // Otherwise append
                            } else {
                                (structure[dataType] = structure[dataType] || []).push(func);
                            }
                        }
                    }
                };
            }

// Base inspection function for prefilters and transports
            function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

                var inspected = {},
                    seekingTransport = ( structure === transports );

                function inspect(dataType) {
                    var selected;
                    inspected[dataType] = true;
                    jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                            options.dataTypes.unshift(dataTypeOrTransport);
                            inspect(dataTypeOrTransport);
                            return false;
                        } else if (seekingTransport) {
                            return !( selected = dataTypeOrTransport );
                        }
                    });
                    return selected;
                }

                return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
            }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
            function ajaxExtend(target, src) {
                var key, deep,
                    flatOptions = jQuery.ajaxSettings.flatOptions || {};

                for (key in src) {
                    if (src[key] !== undefined) {
                        ( flatOptions[key] ? target : ( deep || (deep = {}) ) )[key] = src[key];
                    }
                }
                if (deep) {
                    jQuery.extend(true, target, deep);
                }

                return target;
            }

            /* Handles responses to an ajax request:
             * - finds the right dataType (mediates between content-type and expected dataType)
             * - returns the corresponding response
             */
            function ajaxHandleResponses(s, jqXHR, responses) {

                var ct, type, finalDataType, firstDataType,
                    contents = s.contents,
                    dataTypes = s.dataTypes;

                // Remove auto dataType and get content-type in the process
                while (dataTypes[0] === "*") {
                    dataTypes.shift();
                    if (ct === undefined) {
                        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                    }
                }

                // Check if we're dealing with a known content-type
                if (ct) {
                    for (type in contents) {
                        if (contents[type] && contents[type].test(ct)) {
                            dataTypes.unshift(type);
                            break;
                        }
                    }
                }

                // Check to see if we have a response for the expected dataType
                if (dataTypes[0] in responses) {
                    finalDataType = dataTypes[0];
                } else {
                    // Try convertible dataTypes
                    for (type in responses) {
                        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                            finalDataType = type;
                            break;
                        }
                        if (!firstDataType) {
                            firstDataType = type;
                        }
                    }
                    // Or just use first one
                    finalDataType = finalDataType || firstDataType;
                }

                // If we found a dataType
                // We add the dataType to the list if needed
                // and return the corresponding response
                if (finalDataType) {
                    if (finalDataType !== dataTypes[0]) {
                        dataTypes.unshift(finalDataType);
                    }
                    return responses[finalDataType];
                }
            }

            /* Chain conversions given the request and the original response
             * Also sets the responseXXX fields on the jqXHR instance
             */
            function ajaxConvert(s, response, jqXHR, isSuccess) {
                var conv2, current, conv, tmp, prev,
                    converters = {},
                // Work with a copy of dataTypes in case we need to modify it for conversion
                    dataTypes = s.dataTypes.slice();

                // Create converters map with lowercased keys
                if (dataTypes[1]) {
                    for (conv in s.converters) {
                        converters[conv.toLowerCase()] = s.converters[conv];
                    }
                }

                current = dataTypes.shift();

                // Convert to each sequential dataType
                while (current) {

                    if (s.responseFields[current]) {
                        jqXHR[s.responseFields[current]] = response;
                    }

                    // Apply the dataFilter if provided
                    if (!prev && isSuccess && s.dataFilter) {
                        response = s.dataFilter(response, s.dataType);
                    }

                    prev = current;
                    current = dataTypes.shift();

                    if (current) {

                        // There's only work to do if current dataType is non-auto
                        if (current === "*") {

                            current = prev;

                            // Convert response if prev dataType is non-auto and differs from current
                        } else if (prev !== "*" && prev !== current) {

                            // Seek a direct converter
                            conv = converters[prev + " " + current] || converters["* " + current];

                            // If none found, seek a pair
                            if (!conv) {
                                for (conv2 in converters) {

                                    // If conv2 outputs current
                                    tmp = conv2.split(" ");
                                    if (tmp[1] === current) {

                                        // If prev can be converted to accepted input
                                        conv = converters[prev + " " + tmp[0]] ||
                                        converters["* " + tmp[0]];
                                        if (conv) {
                                            // Condense equivalence converters
                                            if (conv === true) {
                                                conv = converters[conv2];

                                                // Otherwise, insert the intermediate dataType
                                            } else if (converters[conv2] !== true) {
                                                current = tmp[0];
                                                dataTypes.unshift(tmp[1]);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }

                            // Apply converter (if not an equivalence)
                            if (conv !== true) {

                                // Unless errors are allowed to bubble, catch and return them
                                if (conv && s["throws"]) {
                                    response = conv(response);
                                } else {
                                    try {
                                        response = conv(response);
                                    } catch (e) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current
                                        };
                                    }
                                }
                            }
                        }
                    }
                }

                return {state: "success", data: response};
            }

            jQuery.extend({

                // Counter for holding the number of active queries
                active: 0,

                // Last-Modified header cache for next request
                lastModified: {},
                etag: {},

                ajaxSettings: {
                    url: ajaxLocation,
                    type: "GET",
                    isLocal: rlocalProtocol.test(ajaxLocParts[1]),
                    global: true,
                    processData: true,
                    async: true,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    /*
                     timeout: 0,
                     data: null,
                     dataType: null,
                     username: null,
                     password: null,
                     cache: null,
                     throws: false,
                     traditional: false,
                     headers: {},
                     */

                    accepts: {
                        "*": allTypes,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },

                    contents: {
                        xml: /xml/,
                        html: /html/,
                        json: /json/
                    },

                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },

                    // Data converters
                    // Keys separate source (or catchall "*") and destination types with a single space
                    converters: {

                        // Convert anything to text
                        "* text": String,

                        // Text to html (true = no transformation)
                        "text html": true,

                        // Evaluate text as a json expression
                        "text json": jQuery.parseJSON,

                        // Parse text as xml
                        "text xml": jQuery.parseXML
                    },

                    // For options that shouldn't be deep extended:
                    // you can add your own custom options here if
                    // and when you create one that shouldn't be
                    // deep extended (see ajaxExtend)
                    flatOptions: {
                        url: true,
                        context: true
                    }
                },

                // Creates a full fledged settings object into target
                // with both ajaxSettings and settings fields.
                // If target is omitted, writes into ajaxSettings.
                ajaxSetup: function (target, settings) {
                    return settings ?

                        // Building a settings object
                        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                        // Extending ajaxSettings
                        ajaxExtend(jQuery.ajaxSettings, target);
                },

                ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                ajaxTransport: addToPrefiltersOrTransports(transports),

                // Main method
                ajax: function (url, options) {

                    // If url is an object, simulate pre-1.5 signature
                    if (typeof url === "object") {
                        options = url;
                        url = undefined;
                    }

                    // Force options to be an object
                    options = options || {};

                    var transport,
                    // URL without anti-cache param
                        cacheURL,
                    // Response headers
                        responseHeadersString,
                        responseHeaders,
                    // timeout handle
                        timeoutTimer,
                    // Cross-domain detection vars
                        parts,
                    // To know if global events are to be dispatched
                        fireGlobals,
                    // Loop variable
                        i,
                    // Create the final options object
                        s = jQuery.ajaxSetup({}, options),
                    // Callbacks context
                        callbackContext = s.context || s,
                    // Context for global events is callbackContext if it is a DOM node or jQuery collection
                        globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                            jQuery(callbackContext) :
                            jQuery.event,
                    // Deferreds
                        deferred = jQuery.Deferred(),
                        completeDeferred = jQuery.Callbacks("once memory"),
                    // Status-dependent callbacks
                        statusCode = s.statusCode || {},
                    // Headers (they are sent all at once)
                        requestHeaders = {},
                        requestHeadersNames = {},
                    // The jqXHR state
                        state = 0,
                    // Default abort message
                        strAbort = "canceled",
                    // Fake xhr
                        jqXHR = {
                            readyState: 0,

                            // Builds headers hashtable if needed
                            getResponseHeader: function (key) {
                                var match;
                                if (state === 2) {
                                    if (!responseHeaders) {
                                        responseHeaders = {};
                                        while ((match = rheaders.exec(responseHeadersString))) {
                                            responseHeaders[match[1].toLowerCase()] = match[2];
                                        }
                                    }
                                    match = responseHeaders[key.toLowerCase()];
                                }
                                return match == null ? null : match;
                            },

                            // Raw string
                            getAllResponseHeaders: function () {
                                return state === 2 ? responseHeadersString : null;
                            },

                            // Caches the header
                            setRequestHeader: function (name, value) {
                                var lname = name.toLowerCase();
                                if (!state) {
                                    name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                                    requestHeaders[name] = value;
                                }
                                return this;
                            },

                            // Overrides response content-type header
                            overrideMimeType: function (type) {
                                if (!state) {
                                    s.mimeType = type;
                                }
                                return this;
                            },

                            // Status-dependent callbacks
                            statusCode: function (map) {
                                var code;
                                if (map) {
                                    if (state < 2) {
                                        for (code in map) {
                                            // Lazy-add the new callback in a way that preserves old ones
                                            statusCode[code] = [statusCode[code], map[code]];
                                        }
                                    } else {
                                        // Execute the appropriate callbacks
                                        jqXHR.always(map[jqXHR.status]);
                                    }
                                }
                                return this;
                            },

                            // Cancel the request
                            abort: function (statusText) {
                                var finalText = statusText || strAbort;
                                if (transport) {
                                    transport.abort(finalText);
                                }
                                done(0, finalText);
                                return this;
                            }
                        };

                    // Attach deferreds
                    deferred.promise(jqXHR).complete = completeDeferred.add;
                    jqXHR.success = jqXHR.done;
                    jqXHR.error = jqXHR.fail;

                    // Remove hash character (#7531: and string promotion)
                    // Add protocol if not provided (prefilters might expect it)
                    // Handle falsy url in the settings object (#10093: consistency with old signature)
                    // We also use the url parameter if available
                    s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace(rhash, "")
                        .replace(rprotocol, ajaxLocParts[1] + "//");

                    // Alias method option to type as per ticket #12004
                    s.type = options.method || options.type || s.method || s.type;

                    // Extract dataTypes list
                    s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

                    // A cross-domain request is in order when we have a protocol:host:port mismatch
                    if (s.crossDomain == null) {
                        parts = rurl.exec(s.url.toLowerCase());
                        s.crossDomain = !!( parts &&
                        ( parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
                        ( parts[3] || ( parts[1] === "http:" ? "80" : "443" ) ) !==
                        ( ajaxLocParts[3] || ( ajaxLocParts[1] === "http:" ? "80" : "443" ) ) )
                        );
                    }

                    // Convert data if not already a string
                    if (s.data && s.processData && typeof s.data !== "string") {
                        s.data = jQuery.param(s.data, s.traditional);
                    }

                    // Apply prefilters
                    inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

                    // If request was aborted inside a prefilter, stop there
                    if (state === 2) {
                        return jqXHR;
                    }

                    // We can fire global events as of now if asked to
                    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                    fireGlobals = jQuery.event && s.global;

                    // Watch for a new set of requests
                    if (fireGlobals && jQuery.active++ === 0) {
                        jQuery.event.trigger("ajaxStart");
                    }

                    // Uppercase the type
                    s.type = s.type.toUpperCase();

                    // Determine if request has content
                    s.hasContent = !rnoContent.test(s.type);

                    // Save the URL in case we're toying with the If-Modified-Since
                    // and/or If-None-Match header later on
                    cacheURL = s.url;

                    // More options handling for requests with no content
                    if (!s.hasContent) {

                        // If data is available, append data to url
                        if (s.data) {
                            cacheURL = ( s.url += ( rquery.test(cacheURL) ? "&" : "?" ) + s.data );
                            // #9682: remove data so that it's not used in an eventual retry
                            delete s.data;
                        }

                        // Add anti-cache in url if needed
                        if (s.cache === false) {
                            s.url = rts.test(cacheURL) ?

                                // If there is already a '_' parameter, set its value
                                cacheURL.replace(rts, "$1_=" + nonce++) :

                                // Otherwise add one to the end
                            cacheURL + ( rquery.test(cacheURL) ? "&" : "?" ) + "_=" + nonce++;
                        }
                    }

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        if (jQuery.lastModified[cacheURL]) {
                            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                        }
                        if (jQuery.etag[cacheURL]) {
                            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                        }
                    }

                    // Set the correct header, if data is being sent
                    if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                        jqXHR.setRequestHeader("Content-Type", s.contentType);
                    }

                    // Set the Accepts header for the server, depending on the dataType
                    jqXHR.setRequestHeader(
                        "Accept",
                        s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                        s.accepts[s.dataTypes[0]] + ( s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                            s.accepts["*"]
                    );

                    // Check for headers option
                    for (i in s.headers) {
                        jqXHR.setRequestHeader(i, s.headers[i]);
                    }

                    // Allow custom headers/mimetypes and early abort
                    if (s.beforeSend && ( s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2 )) {
                        // Abort if not done already and return
                        return jqXHR.abort();
                    }

                    // Aborting is no longer a cancellation
                    strAbort = "abort";

                    // Install callbacks on deferreds
                    for (i in {success: 1, error: 1, complete: 1}) {
                        jqXHR[i](s[i]);
                    }

                    // Get transport
                    transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

                    // If no transport, we auto-abort
                    if (!transport) {
                        done(-1, "No Transport");
                    } else {
                        jqXHR.readyState = 1;

                        // Send global event
                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                        }
                        // Timeout
                        if (s.async && s.timeout > 0) {
                            timeoutTimer = setTimeout(function () {
                                jqXHR.abort("timeout");
                            }, s.timeout);
                        }

                        try {
                            state = 1;
                            transport.send(requestHeaders, done);
                        } catch (e) {
                            // Propagate exception as error if not done
                            if (state < 2) {
                                done(-1, e);
                                // Simply rethrow otherwise
                            } else {
                                throw e;
                            }
                        }
                    }

                    // Callback for when everything is done
                    function done(status, nativeStatusText, responses, headers) {
                        var isSuccess, success, error, response, modified,
                            statusText = nativeStatusText;

                        // Called once
                        if (state === 2) {
                            return;
                        }

                        // State is "done" now
                        state = 2;

                        // Clear timeout if it exists
                        if (timeoutTimer) {
                            clearTimeout(timeoutTimer);
                        }

                        // Dereference transport for early garbage collection
                        // (no matter how long the jqXHR object will be used)
                        transport = undefined;

                        // Cache response headers
                        responseHeadersString = headers || "";

                        // Set readyState
                        jqXHR.readyState = status > 0 ? 4 : 0;

                        // Determine if successful
                        isSuccess = status >= 200 && status < 300 || status === 304;

                        // Get response data
                        if (responses) {
                            response = ajaxHandleResponses(s, jqXHR, responses);
                        }

                        // Convert no matter what (that way responseXXX fields are always set)
                        response = ajaxConvert(s, response, jqXHR, isSuccess);

                        // If successful, handle type chaining
                        if (isSuccess) {

                            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            if (s.ifModified) {
                                modified = jqXHR.getResponseHeader("Last-Modified");
                                if (modified) {
                                    jQuery.lastModified[cacheURL] = modified;
                                }
                                modified = jqXHR.getResponseHeader("etag");
                                if (modified) {
                                    jQuery.etag[cacheURL] = modified;
                                }
                            }

                            // if no content
                            if (status === 204 || s.type === "HEAD") {
                                statusText = "nocontent";

                                // if not modified
                            } else if (status === 304) {
                                statusText = "notmodified";

                                // If we have data, let's convert it
                            } else {
                                statusText = response.state;
                                success = response.data;
                                error = response.error;
                                isSuccess = !error;
                            }
                        } else {
                            // Extract error from statusText and normalize for non-aborts
                            error = statusText;
                            if (status || !statusText) {
                                statusText = "error";
                                if (status < 0) {
                                    status = 0;
                                }
                            }
                        }

                        // Set data for the fake xhr object
                        jqXHR.status = status;
                        jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                        // Success/Error
                        if (isSuccess) {
                            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                        } else {
                            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                        }

                        // Status-dependent callbacks
                        jqXHR.statusCode(statusCode);
                        statusCode = undefined;

                        if (fireGlobals) {
                            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
                                [jqXHR, s, isSuccess ? success : error]);
                        }

                        // Complete
                        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                            // Handle the global AJAX counter
                            if (!( --jQuery.active )) {
                                jQuery.event.trigger("ajaxStop");
                            }
                        }
                    }

                    return jqXHR;
                },

                getJSON: function (url, data, callback) {
                    return jQuery.get(url, data, callback, "json");
                },

                getScript: function (url, callback) {
                    return jQuery.get(url, undefined, callback, "script");
                }
            });

            jQuery.each(["get", "post"], function (i, method) {
                jQuery[method] = function (url, data, callback, type) {
                    // Shift arguments if data argument was omitted
                    if (jQuery.isFunction(data)) {
                        type = type || callback;
                        callback = data;
                        data = undefined;
                    }

                    return jQuery.ajax({
                        url: url,
                        type: method,
                        dataType: type,
                        data: data,
                        success: callback
                    });
                };
            });


            jQuery._evalUrl = function (url) {
                return jQuery.ajax({
                    url: url,
                    type: "GET",
                    dataType: "script",
                    async: false,
                    global: false,
                    "throws": true
                });
            };


            jQuery.fn.extend({
                wrapAll: function (html) {
                    var wrap;

                    if (jQuery.isFunction(html)) {
                        return this.each(function (i) {
                            jQuery(this).wrapAll(html.call(this, i));
                        });
                    }

                    if (this[0]) {

                        // The elements to wrap the target around
                        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                        if (this[0].parentNode) {
                            wrap.insertBefore(this[0]);
                        }

                        wrap.map(function () {
                            var elem = this;

                            while (elem.firstElementChild) {
                                elem = elem.firstElementChild;
                            }

                            return elem;
                        }).append(this);
                    }

                    return this;
                },

                wrapInner: function (html) {
                    if (jQuery.isFunction(html)) {
                        return this.each(function (i) {
                            jQuery(this).wrapInner(html.call(this, i));
                        });
                    }

                    return this.each(function () {
                        var self = jQuery(this),
                            contents = self.contents();

                        if (contents.length) {
                            contents.wrapAll(html);

                        } else {
                            self.append(html);
                        }
                    });
                },

                wrap: function (html) {
                    var isFunction = jQuery.isFunction(html);

                    return this.each(function (i) {
                        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                    });
                },

                unwrap: function () {
                    return this.parent().each(function () {
                        if (!jQuery.nodeName(this, "body")) {
                            jQuery(this).replaceWith(this.childNodes);
                        }
                    }).end();
                }
            });


            jQuery.expr.filters.hidden = function (elem) {
                // Support: Opera <= 12.12
                // Opera reports offsetWidths and offsetHeights less than zero on some elements
                return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
            };
            jQuery.expr.filters.visible = function (elem) {
                return !jQuery.expr.filters.hidden(elem);
            };


            var r20 = /%20/g,
                rbracket = /\[\]$/,
                rCRLF = /\r?\n/g,
                rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                rsubmittable = /^(?:input|select|textarea|keygen)/i;

            function buildParams(prefix, obj, traditional, add) {
                var name;

                if (jQuery.isArray(obj)) {
                    // Serialize array item.
                    jQuery.each(obj, function (i, v) {
                        if (traditional || rbracket.test(prefix)) {
                            // Treat each array item as a scalar.
                            add(prefix, v);

                        } else {
                            // Item is non-scalar (array or object), encode its numeric index.
                            buildParams(prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add);
                        }
                    });

                } else if (!traditional && jQuery.type(obj) === "object") {
                    // Serialize object item.
                    for (name in obj) {
                        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                    }

                } else {
                    // Serialize scalar item.
                    add(prefix, obj);
                }
            }

// Serialize an array of form elements or a set of
// key/values into a query string
            jQuery.param = function (a, traditional) {
                var prefix,
                    s = [],
                    add = function (key, value) {
                        // If value is a function, invoke it and return its value
                        value = jQuery.isFunction(value) ? value() : ( value == null ? "" : value );
                        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                    };

                // Set traditional to true for jQuery <= 1.3.2 behavior.
                if (traditional === undefined) {
                    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                }

                // If an array was passed in, assume that it is an array of form elements.
                if (jQuery.isArray(a) || ( a.jquery && !jQuery.isPlainObject(a) )) {
                    // Serialize the form elements
                    jQuery.each(a, function () {
                        add(this.name, this.value);
                    });

                } else {
                    // If traditional, encode the "old" way (the way 1.3.2 or older
                    // did it), otherwise encode params recursively.
                    for (prefix in a) {
                        buildParams(prefix, a[prefix], traditional, add);
                    }
                }

                // Return the resulting serialization
                return s.join("&").replace(r20, "+");
            };

            jQuery.fn.extend({
                serialize: function () {
                    return jQuery.param(this.serializeArray());
                },
                serializeArray: function () {
                    return this.map(function () {
                        // Can add propHook for "elements" to filter or add form elements
                        var elements = jQuery.prop(this, "elements");
                        return elements ? jQuery.makeArray(elements) : this;
                    })
                        .filter(function () {
                            var type = this.type;

                            // Use .is( ":disabled" ) so that fieldset[disabled] works
                            return this.name && !jQuery(this).is(":disabled") &&
                                rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                                ( this.checked || !rcheckableType.test(type) );
                        })
                        .map(function (i, elem) {
                            var val = jQuery(this).val();

                            return val == null ?
                                null :
                                jQuery.isArray(val) ?
                                    jQuery.map(val, function (val) {
                                        return {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                                    }) :
                                {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                        }).get();
                }
            });


            jQuery.ajaxSettings.xhr = function () {
                try {
                    return new XMLHttpRequest();
                } catch (e) {
                }
            };

            var xhrId = 0,
                xhrCallbacks = {},
                xhrSuccessStatus = {
                    // file protocol always yields status code 0, assume 200
                    0: 200,
                    // Support: IE9
                    // #1450: sometimes IE returns 1223 when it should be 204
                    1223: 204
                },
                xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
            if (window.attachEvent) {
                window.attachEvent("onunload", function () {
                    for (var key in xhrCallbacks) {
                        xhrCallbacks[key]();
                    }
                });
            }

            support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
            support.ajax = xhrSupported = !!xhrSupported;

            jQuery.ajaxTransport(function (options) {
                var callback;

                // Cross domain only allowed if supported through XMLHttpRequest
                if (support.cors || xhrSupported && !options.crossDomain) {
                    return {
                        send: function (headers, complete) {
                            var i,
                                xhr = options.xhr(),
                                id = ++xhrId;

                            xhr.open(options.type, options.url, options.async, options.username, options.password);

                            // Apply custom fields if provided
                            if (options.xhrFields) {
                                for (i in options.xhrFields) {
                                    xhr[i] = options.xhrFields[i];
                                }
                            }

                            // Override mime type if needed
                            if (options.mimeType && xhr.overrideMimeType) {
                                xhr.overrideMimeType(options.mimeType);
                            }

                            // X-Requested-With header
                            // For cross-domain requests, seeing as conditions for a preflight are
                            // akin to a jigsaw puzzle, we simply never set it to be sure.
                            // (it can always be set on a per-request basis or even using ajaxSetup)
                            // For same-domain requests, won't change header if already provided.
                            if (!options.crossDomain && !headers["X-Requested-With"]) {
                                headers["X-Requested-With"] = "XMLHttpRequest";
                            }

                            // Set headers
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }

                            // Callback
                            callback = function (type) {
                                return function () {
                                    if (callback) {
                                        delete xhrCallbacks[id];
                                        callback = xhr.onload = xhr.onerror = null;

                                        if (type === "abort") {
                                            xhr.abort();
                                        } else if (type === "error") {
                                            complete(
                                                // file: protocol always yields status 0; see #8605, #14207
                                                xhr.status,
                                                xhr.statusText
                                            );
                                        } else {
                                            complete(
                                                xhrSuccessStatus[xhr.status] || xhr.status,
                                                xhr.statusText,
                                                // Support: IE9
                                                // Accessing binary-data responseText throws an exception
                                                // (#11426)
                                                typeof xhr.responseText === "string" ? {
                                                    text: xhr.responseText
                                                } : undefined,
                                                xhr.getAllResponseHeaders()
                                            );
                                        }
                                    }
                                };
                            };

                            // Listen to events
                            xhr.onload = callback();
                            xhr.onerror = callback("error");

                            // Create the abort callback
                            callback = xhrCallbacks[id] = callback("abort");

                            try {
                                // Do send the request (this may raise an exception)
                                xhr.send(options.hasContent && options.data || null);
                            } catch (e) {
                                // #14683: Only rethrow if this hasn't been notified as an error yet
                                if (callback) {
                                    throw e;
                                }
                            }
                        },

                        abort: function () {
                            if (callback) {
                                callback();
                            }
                        }
                    };
                }
            });


// Install script dataType
            jQuery.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /(?:java|ecma)script/
                },
                converters: {
                    "text script": function (text) {
                        jQuery.globalEval(text);
                        return text;
                    }
                }
            });

// Handle cache's special case and crossDomain
            jQuery.ajaxPrefilter("script", function (s) {
                if (s.cache === undefined) {
                    s.cache = false;
                }
                if (s.crossDomain) {
                    s.type = "GET";
                }
            });

// Bind script tag hack transport
            jQuery.ajaxTransport("script", function (s) {
                // This transport only deals with cross domain requests
                if (s.crossDomain) {
                    var script, callback;
                    return {
                        send: function (_, complete) {
                            script = jQuery("<script>").prop({
                                async: true,
                                charset: s.scriptCharset,
                                src: s.url
                            }).on(
                                "load error",
                                callback = function (evt) {
                                    script.remove();
                                    callback = null;
                                    if (evt) {
                                        complete(evt.type === "error" ? 404 : 200, evt.type);
                                    }
                                }
                            );
                            document.head.appendChild(script[0]);
                        },
                        abort: function () {
                            if (callback) {
                                callback();
                            }
                        }
                    };
                }
            });


            var oldCallbacks = [],
                rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
            jQuery.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function () {
                    var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
                    this[callback] = true;
                    return callback;
                }
            });

// Detect, normalize options and install callbacks for jsonp requests
            jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

                var callbackName, overwritten, responseContainer,
                    jsonProp = s.jsonp !== false && ( rjsonp.test(s.url) ?
                            "url" :
                        typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data"
                        );

                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if (jsonProp || s.dataTypes[0] === "jsonp") {

                    // Get callback name, remembering preexisting value associated with it
                    callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
                        s.jsonpCallback() :
                        s.jsonpCallback;

                    // Insert callback into url or form data
                    if (jsonProp) {
                        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
                    } else if (s.jsonp !== false) {
                        s.url += ( rquery.test(s.url) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
                    }

                    // Use data converter to retrieve json after script execution
                    s.converters["script json"] = function () {
                        if (!responseContainer) {
                            jQuery.error(callbackName + " was not called");
                        }
                        return responseContainer[0];
                    };

                    // force json dataType
                    s.dataTypes[0] = "json";

                    // Install callback
                    overwritten = window[callbackName];
                    window[callbackName] = function () {
                        responseContainer = arguments;
                    };

                    // Clean-up function (fires after converters)
                    jqXHR.always(function () {
                        // Restore preexisting value
                        window[callbackName] = overwritten;

                        // Save back as free
                        if (s[callbackName]) {
                            // make sure that re-using the options doesn't screw things around
                            s.jsonpCallback = originalSettings.jsonpCallback;

                            // save the callback name for future use
                            oldCallbacks.push(callbackName);
                        }

                        // Call if it was a function and we have a response
                        if (responseContainer && jQuery.isFunction(overwritten)) {
                            overwritten(responseContainer[0]);
                        }

                        responseContainer = overwritten = undefined;
                    });

                    // Delegate to script
                    return "script";
                }
            });


// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
            jQuery.parseHTML = function (data, context, keepScripts) {
                if (!data || typeof data !== "string") {
                    return null;
                }
                if (typeof context === "boolean") {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;

                var parsed = rsingleTag.exec(data),
                    scripts = !keepScripts && [];

                // Single tag
                if (parsed) {
                    return [context.createElement(parsed[1])];
                }

                parsed = jQuery.buildFragment([data], context, scripts);

                if (scripts && scripts.length) {
                    jQuery(scripts).remove();
                }

                return jQuery.merge([], parsed.childNodes);
            };


// Keep a copy of the old load method
            var _load = jQuery.fn.load;

            /**
             * Load a url into a page
             */
            jQuery.fn.load = function (url, params, callback) {
                if (typeof url !== "string" && _load) {
                    return _load.apply(this, arguments);
                }

                var selector, type, response,
                    self = this,
                    off = url.indexOf(" ");

                if (off >= 0) {
                    selector = jQuery.trim(url.slice(off));
                    url = url.slice(0, off);
                }

                // If it's a function
                if (jQuery.isFunction(params)) {

                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if (params && typeof params === "object") {
                    type = "POST";
                }

                // If we have elements to modify, make the request
                if (self.length > 0) {
                    jQuery.ajax({
                        url: url,

                        // if "type" variable is undefined, then "GET" method will be used
                        type: type,
                        dataType: "html",
                        data: params
                    }).done(function (responseText) {

                        // Save response for use in complete callback
                        response = arguments;

                        self.html(selector ?

                            // If a selector was specified, locate the right elements in a dummy div
                            // Exclude scripts to avoid IE 'Permission Denied' errors
                            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                            // Otherwise use the full result
                            responseText);

                    }).complete(callback && function (jqXHR, status) {
                        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
                    });
                }

                return this;
            };


// Attach a bunch of functions for handling common AJAX events
            jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
                jQuery.fn[type] = function (fn) {
                    return this.on(type, fn);
                };
            });


            jQuery.expr.filters.animated = function (elem) {
                return jQuery.grep(jQuery.timers, function (fn) {
                    return elem === fn.elem;
                }).length;
            };


            var docElem = window.document.documentElement;

            /**
             * Gets a window from an element
             */
            function getWindow(elem) {
                return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
            }

            jQuery.offset = {
                setOffset: function (elem, options, i) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                        position = jQuery.css(elem, "position"),
                        curElem = jQuery(elem),
                        props = {};

                    // Set position first, in-case top/left are set even on static elem
                    if (position === "static") {
                        elem.style.position = "relative";
                    }

                    curOffset = curElem.offset();
                    curCSSTop = jQuery.css(elem, "top");
                    curCSSLeft = jQuery.css(elem, "left");
                    calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                    ( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

                    // Need to be able to calculate position if either
                    // top or left is auto and position is either absolute or fixed
                    if (calculatePosition) {
                        curPosition = curElem.position();
                        curTop = curPosition.top;
                        curLeft = curPosition.left;

                    } else {
                        curTop = parseFloat(curCSSTop) || 0;
                        curLeft = parseFloat(curCSSLeft) || 0;
                    }

                    if (jQuery.isFunction(options)) {
                        options = options.call(elem, i, curOffset);
                    }

                    if (options.top != null) {
                        props.top = ( options.top - curOffset.top ) + curTop;
                    }
                    if (options.left != null) {
                        props.left = ( options.left - curOffset.left ) + curLeft;
                    }

                    if ("using" in options) {
                        options.using.call(elem, props);

                    } else {
                        curElem.css(props);
                    }
                }
            };

            jQuery.fn.extend({
                offset: function (options) {
                    if (arguments.length) {
                        return options === undefined ?
                            this :
                            this.each(function (i) {
                                jQuery.offset.setOffset(this, options, i);
                            });
                    }

                    var docElem, win,
                        elem = this[0],
                        box = {top: 0, left: 0},
                        doc = elem && elem.ownerDocument;

                    if (!doc) {
                        return;
                    }

                    docElem = doc.documentElement;

                    // Make sure it's not a disconnected DOM node
                    if (!jQuery.contains(docElem, elem)) {
                        return box;
                    }

                    // Support: BlackBerry 5, iOS 3 (original iPhone)
                    // If we don't have gBCR, just use 0,0 rather than error
                    if (typeof elem.getBoundingClientRect !== strundefined) {
                        box = elem.getBoundingClientRect();
                    }
                    win = getWindow(doc);
                    return {
                        top: box.top + win.pageYOffset - docElem.clientTop,
                        left: box.left + win.pageXOffset - docElem.clientLeft
                    };
                },

                position: function () {
                    if (!this[0]) {
                        return;
                    }

                    var offsetParent, offset,
                        elem = this[0],
                        parentOffset = {top: 0, left: 0};

                    // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
                    if (jQuery.css(elem, "position") === "fixed") {
                        // Assume getBoundingClientRect is there when computed position is fixed
                        offset = elem.getBoundingClientRect();

                    } else {
                        // Get *real* offsetParent
                        offsetParent = this.offsetParent();

                        // Get correct offsets
                        offset = this.offset();
                        if (!jQuery.nodeName(offsetParent[0], "html")) {
                            parentOffset = offsetParent.offset();
                        }

                        // Add offsetParent borders
                        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
                    }

                    // Subtract parent offsets and element margins
                    return {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
                    };
                },

                offsetParent: function () {
                    return this.map(function () {
                        var offsetParent = this.offsetParent || docElem;

                        while (offsetParent && ( !jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static" )) {
                            offsetParent = offsetParent.offsetParent;
                        }

                        return offsetParent || docElem;
                    });
                }
            });

// Create scrollLeft and scrollTop methods
            jQuery.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (method, prop) {
                var top = "pageYOffset" === prop;

                jQuery.fn[method] = function (val) {
                    return access(this, function (elem, method, val) {
                        var win = getWindow(elem);

                        if (val === undefined) {
                            return win ? win[prop] : elem[method];
                        }

                        if (win) {
                            win.scrollTo(
                                !top ? val : window.pageXOffset,
                                top ? val : window.pageYOffset
                            );

                        } else {
                            elem[method] = val;
                        }
                    }, method, val, arguments.length, null);
                };
            });

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
            jQuery.each(["top", "left"], function (i, prop) {
                jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
                    function (elem, computed) {
                        if (computed) {
                            computed = curCSS(elem, prop);
                            // If curCSS returns percentage, fallback to offset
                            return rnumnonpx.test(computed) ?
                            jQuery(elem).position()[prop] + "px" :
                                computed;
                        }
                    }
                );
            });


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            jQuery.each({Height: "height", Width: "width"}, function (name, type) {
                jQuery.each({
                    padding: "inner" + name,
                    content: type,
                    "": "outer" + name
                }, function (defaultExtra, funcName) {
                    // Margin is only for outerHeight, outerWidth
                    jQuery.fn[funcName] = function (margin, value) {
                        var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                            extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                        return access(this, function (elem, type, value) {
                            var doc;

                            if (jQuery.isWindow(elem)) {
                                // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                // isn't a whole lot we can do. See pull request at this URL for discussion:
                                // https://github.com/jquery/jquery/pull/764
                                return elem.document.documentElement["client" + name];
                            }

                            // Get document width or height
                            if (elem.nodeType === 9) {
                                doc = elem.documentElement;

                                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                // whichever is greatest
                                return Math.max(
                                    elem.body["scroll" + name], doc["scroll" + name],
                                    elem.body["offset" + name], doc["offset" + name],
                                    doc["client" + name]
                                );
                            }

                            return value === undefined ?
                                // Get width or height on the element, requesting but not forcing parseFloat
                                jQuery.css(elem, type, extra) :

                                // Set width or height on the element
                                jQuery.style(elem, type, value, extra);
                        }, type, chainable ? margin : undefined, chainable, null);
                    };
                });
            });


// The number of elements contained in the matched element set
            jQuery.fn.size = function () {
                return this.length;
            };

            jQuery.fn.andSelf = jQuery.fn.addBack;


// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

            if (typeof define === "function" && define.amd) {
                define("jquery", [], function () {
                    return jQuery;
                });
            }


            var
            // Map over jQuery in case of overwrite
                _jQuery = window.jQuery,

            // Map over the $ in case of overwrite
                _$ = window.$;

            jQuery.noConflict = function (deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            };

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
            if (typeof noGlobal === strundefined) {
                window.jQuery = window.$ = jQuery;
            }


            return jQuery;

        }));

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/array/flatten.js": [function (require, module, exports) {
        var baseFlatten = require('../internal/baseFlatten'),
            isIterateeCall = require('../internal/isIterateeCall');

        /**
         * Flattens a nested array. If `isDeep` is `true` the array is recursively
         * flattened, otherwise it is only flattened a single level.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, 3, [4]]]);
         * // => [1, 2, 3, [4]]
         *
         * // using `isDeep`
         * _.flatten([1, [2, 3, [4]]], true);
         * // => [1, 2, 3, 4]
         */
        function flatten(array, isDeep, guard) {
            var length = array ? array.length : 0;
            if (guard && isIterateeCall(array, isDeep, guard)) {
                isDeep = false;
            }
            return length ? baseFlatten(array, isDeep) : [];
        }

        module.exports = flatten;

    }, {
        "../internal/baseFlatten": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFlatten.js",
        "../internal/isIterateeCall": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIterateeCall.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/array/last.js": [function (require, module, exports) {
        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
        }

        module.exports = last;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/array/uniq.js": [function (require, module, exports) {
        var baseCallback = require('../internal/baseCallback'),
            baseUniq = require('../internal/baseUniq'),
            isIterateeCall = require('../internal/isIterateeCall'),
            sortedUniq = require('../internal/sortedUniq');

        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurence of each element
         * is kept. Providing `true` for `isSorted` performs a faster search algorithm
         * for sorted arrays. If an iteratee function is provided it is invoked for
         * each element in the array to generate the criterion by which uniqueness
         * is computed. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, array).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias unique
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {boolean} [isSorted] Specify the array is sorted.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new duplicate-value-free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         *
         * // using `isSorted`
         * _.uniq([1, 1, 2], true);
         * // => [1, 2]
         *
         * // using an iteratee function
         * _.uniq([1, 2.5, 1.5, 2], function(n) {
 *   return this.floor(n);
 * }, Math);
         * // => [1, 2.5]
         *
         * // using the `_.property` callback shorthand
         * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniq(array, isSorted, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (isSorted != null && typeof isSorted != 'boolean') {
                thisArg = iteratee;
                iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
                isSorted = false;
            }
            iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);
            return (isSorted)
                ? sortedUniq(array, iteratee)
                : baseUniq(array, iteratee);
        }

        module.exports = uniq;

    }, {
        "../internal/baseCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js",
        "../internal/baseUniq": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseUniq.js",
        "../internal/isIterateeCall": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIterateeCall.js",
        "../internal/sortedUniq": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/sortedUniq.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/array/unique.js": [function (require, module, exports) {
        module.exports = require('./uniq');

    }, {"./uniq": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/array/uniq.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/chain/lodash.js": [function (require, module, exports) {
        var LazyWrapper = require('../internal/LazyWrapper'),
            LodashWrapper = require('../internal/LodashWrapper'),
            baseLodash = require('../internal/baseLodash'),
            isArray = require('../lang/isArray'),
            isObjectLike = require('../internal/isObjectLike'),
            wrapperClone = require('../internal/wrapperClone');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Creates a `lodash` object which wraps `value` to enable implicit chaining.
         * Methods that operate on and return arrays, collections, and functions can
         * be chained together. Methods that retrieve a single value or may return a
         * primitive value will automatically end the chain returning the unwrapped
         * value. Explicit chaining may be enabled using `_.chain`. The execution of
         * chained methods is lazy, that is, execution is deferred until `_#value`
         * is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
         * fusion is an optimization strategy which merge iteratee calls; this can help
         * to avoid the creation of intermediate data structures and greatly reduce the
         * number of iteratee executions.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
         * `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
         * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
         * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
         * and `where`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
         * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
         * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
         * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
         * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
         * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
         * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
         * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
         * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
         * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
         * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
         * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
         * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
         * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
         * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
         * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
         * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
         * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
         * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
         * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
         * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
         * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
         * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
         * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
         * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
         * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
         * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
         * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
         * `unescape`, `uniqueId`, `value`, and `words`
         *
         * The wrapper method `sample` will return a wrapped value when `n` is provided,
         * otherwise an unwrapped value is returned.
         *
         * @name _
         * @constructor
         * @category Chain
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // returns an unwrapped value
         * wrapped.reduce(function(total, n) {
 *   return total + n;
 * });
         * // => 6
         *
         * // returns a wrapped value
         * var squares = wrapped.map(function(n) {
 *   return n * n;
 * });
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) {
                    return value;
                }
                if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                    return wrapperClone(value);
                }
            }
            return new LodashWrapper(value);
        }

// Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;

        module.exports = lodash;

    }, {
        "../internal/LazyWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/LazyWrapper.js",
        "../internal/LodashWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/LodashWrapper.js",
        "../internal/baseLodash": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseLodash.js",
        "../internal/isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js",
        "../internal/wrapperClone": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/wrapperClone.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/every.js": [function (require, module, exports) {
        var arrayEvery = require('../internal/arrayEvery'),
            baseCallback = require('../internal/baseCallback'),
            baseEvery = require('../internal/baseEvery'),
            isArray = require('../lang/isArray'),
            isIterateeCall = require('../internal/isIterateeCall');

        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * The predicate is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias all
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'active': false },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.every(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                predicate = undefined;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
                predicate = baseCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }

        module.exports = every;

    }, {
        "../internal/arrayEvery": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayEvery.js",
        "../internal/baseCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js",
        "../internal/baseEvery": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEvery.js",
        "../internal/isIterateeCall": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIterateeCall.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/filter.js": [function (require, module, exports) {
        var arrayFilter = require('../internal/arrayFilter'),
            baseCallback = require('../internal/baseCallback'),
            baseFilter = require('../internal/baseFilter'),
            isArray = require('../lang/isArray');

        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias select
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * _.filter([4, 5, 6], function(n) {
 *   return n % 2 == 0;
 * });
         * // => [4, 6]
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.filter(users, 'active', false), 'user');
         * // => ['fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.filter(users, 'active'), 'user');
         * // => ['barney']
         */
        function filter(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = baseCallback(predicate, thisArg, 3);
            return func(collection, predicate);
        }

        module.exports = filter;

    }, {
        "../internal/arrayFilter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayFilter.js",
        "../internal/baseCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js",
        "../internal/baseFilter": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFilter.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/find.js": [function (require, module, exports) {
        var baseEach = require('../internal/baseEach'),
            createFind = require('../internal/createFind');

        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias detect
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.result(_.find(users, function(chr) {
 *   return chr.age < 40;
 * }), 'user');
         * // => 'barney'
         *
         * // using the `_.matches` callback shorthand
         * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
         * // => 'pebbles'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.result(_.find(users, 'active', false), 'user');
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.result(_.find(users, 'active'), 'user');
         * // => 'barney'
         */
        var find = createFind(baseEach);

        module.exports = find;

    }, {
        "../internal/baseEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEach.js",
        "../internal/createFind": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createFind.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/forEach.js": [function (require, module, exports) {
        var arrayEach = require('../internal/arrayEach'),
            baseEach = require('../internal/baseEach'),
            createForEach = require('../internal/createForEach');

        /**
         * Iterates over elements of `collection` invoking `iteratee` for each element.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection). Iteratee functions may exit iteration early
         * by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length" property
         * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
         * may be used for object iteration.
         *
         * @static
         * @memberOf _
         * @alias each
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2]).forEach(function(n) {
 *   console.log(n);
 * }).value();
         * // => logs each value from left to right and returns the array
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
 *   console.log(n, key);
 * });
         * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
         */
        var forEach = createForEach(arrayEach, baseEach);

        module.exports = forEach;

    }, {
        "../internal/arrayEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayEach.js",
        "../internal/baseEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEach.js",
        "../internal/createForEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createForEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/groupBy.js": [function (require, module, exports) {
        var createAggregator = require('../internal/createAggregator');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is an array of the elements responsible for generating the key.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
 *   return Math.floor(n);
 * });
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
 *   return this.floor(n);
 * }, Math);
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * // using the `_.property` callback shorthand
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
                result[key].push(value);
            } else {
                result[key] = [value];
            }
        });

        module.exports = groupBy;

    }, {"../internal/createAggregator": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createAggregator.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/includes.js": [function (require, module, exports) {
        var baseIndexOf = require('../internal/baseIndexOf'),
            getLength = require('../internal/getLength'),
            isArray = require('../lang/isArray'),
            isIterateeCall = require('../internal/isIterateeCall'),
            isLength = require('../internal/isLength'),
            isString = require('../lang/isString'),
            values = require('../object/values');

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Checks if `value` is in `collection` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it is used as the offset
         * from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @alias contains, include
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {*} target The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
         * @returns {boolean} Returns `true` if a matching element is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
         * // => true
         *
         * _.includes('pebbles', 'eb');
         * // => true
         */
        function includes(collection, target, fromIndex, guard) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
                collection = values(collection);
                length = collection.length;
            }
            if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
                fromIndex = 0;
            } else {
                fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
            }
            return (typeof collection == 'string' || !isArray(collection) && isString(collection))
                ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
                : (!!length && baseIndexOf(collection, target, fromIndex) > -1);
        }

        module.exports = includes;

    }, {
        "../internal/baseIndexOf": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIndexOf.js",
        "../internal/getLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getLength.js",
        "../internal/isIterateeCall": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIterateeCall.js",
        "../internal/isLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLength.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "../lang/isString": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isString.js",
        "../object/values": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/values.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/map.js": [function (require, module, exports) {
        var arrayMap = require('../internal/arrayMap'),
            baseCallback = require('../internal/baseCallback'),
            baseMap = require('../internal/baseMap'),
            isArray = require('../lang/isArray');

        /**
         * Creates an array of values by running each element in `collection` through
         * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
         * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
         * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
         * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
         * `sum`, `uniq`, and `words`
         *
         * @static
         * @memberOf _
         * @alias collect
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function timesThree(n) {
 *   return n * 3;
 * }
         *
         * _.map([1, 2], timesThree);
         * // => [3, 6]
         *
         * _.map({ 'a': 1, 'b': 2 }, timesThree);
         * // => [3, 6] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee, thisArg) {
            var func = isArray(collection) ? arrayMap : baseMap;
            iteratee = baseCallback(iteratee, thisArg, 3);
            return func(collection, iteratee);
        }

        module.exports = map;

    }, {
        "../internal/arrayMap": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayMap.js",
        "../internal/baseCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js",
        "../internal/baseMap": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMap.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/reduce.js": [function (require, module, exports) {
        var arrayReduce = require('../internal/arrayReduce'),
            baseEach = require('../internal/baseEach'),
            createReduce = require('../internal/createReduce');

        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` through `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not provided the first element of `collection` is used as the initial
         * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
         * and `sortByOrder`
         *
         * @static
         * @memberOf _
         * @alias foldl, inject
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.reduce([1, 2], function(total, n) {
 *   return total + n;
 * });
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
 *   result[key] = n * 3;
 *   return result;
 * }, {});
         * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
         */
        var reduce = createReduce(arrayReduce, baseEach);

        module.exports = reduce;

    }, {
        "../internal/arrayReduce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayReduce.js",
        "../internal/baseEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEach.js",
        "../internal/createReduce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createReduce.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/size.js": [function (require, module, exports) {
        var getLength = require('../internal/getLength'),
            isLength = require('../internal/isLength'),
            keys = require('../object/keys');

        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable properties for objects.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the size of `collection`.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
            var length = collection ? getLength(collection) : 0;
            return isLength(length) ? length : keys(collection).length;
        }

        module.exports = size;

    }, {
        "../internal/getLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getLength.js",
        "../internal/isLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLength.js",
        "../object/keys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/some.js": [function (require, module, exports) {
        var arraySome = require('../internal/arraySome'),
            baseCallback = require('../internal/baseCallback'),
            baseSome = require('../internal/baseSome'),
            isArray = require('../lang/isArray'),
            isIterateeCall = require('../internal/isIterateeCall');

        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * The function returns as soon as it finds a passing value and does not iterate
         * over the entire collection. The predicate is bound to `thisArg` and invoked
         * with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias any
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.some(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, thisArg) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                predicate = undefined;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
                predicate = baseCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }

        module.exports = some;

    }, {
        "../internal/arraySome": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arraySome.js",
        "../internal/baseCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js",
        "../internal/baseSome": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseSome.js",
        "../internal/isIterateeCall": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIterateeCall.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/collection/sortBy.js": [function (require, module, exports) {
        var baseCallback = require('../internal/baseCallback'),
            baseMap = require('../internal/baseMap'),
            baseSortBy = require('../internal/baseSortBy'),
            compareAscending = require('../internal/compareAscending'),
            isIterateeCall = require('../internal/isIterateeCall');

        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection through `iteratee`. This method performs
         * a stable sort, that is, it preserves the original sort order of equal elements.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * _.sortBy([1, 2, 3], function(n) {
 *   return Math.sin(n);
 * });
         * // => [3, 1, 2]
         *
         * _.sortBy([1, 2, 3], function(n) {
 *   return this.sin(n);
 * }, Math);
         * // => [3, 1, 2]
         *
         * var users = [
         *   { 'user': 'fred' },
         *   { 'user': 'pebbles' },
         *   { 'user': 'barney' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.sortBy(users, 'user'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function sortBy(collection, iteratee, thisArg) {
            if (collection == null) {
                return [];
            }
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                iteratee = undefined;
            }
            var index = -1;
            iteratee = baseCallback(iteratee, thisArg, 3);

            var result = baseMap(collection, function (value, key, collection) {
                return {'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value};
            });
            return baseSortBy(result, compareAscending);
        }

        module.exports = sortBy;

    }, {
        "../internal/baseCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js",
        "../internal/baseMap": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMap.js",
        "../internal/baseSortBy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseSortBy.js",
        "../internal/compareAscending": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/compareAscending.js",
        "../internal/isIterateeCall": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIterateeCall.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/date/now.js": [function (require, module, exports) {
        var getNative = require('../internal/getNative');

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeNow = getNative(Date, 'now');

        /**
         * Gets the number of milliseconds that have elapsed since the Unix epoch
         * (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @category Date
         * @example
         *
         * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
         * // => logs the number of milliseconds it took for the deferred function to be invoked
         */
        var now = nativeNow || function () {
                return new Date().getTime();
            };

        module.exports = now;

    }, {"../internal/getNative": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getNative.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/bind.js": [function (require, module, exports) {
        var createWrapper = require('../internal/createWrapper'),
            replaceHolders = require('../internal/replaceHolders'),
            restParam = require('./restParam');

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1,
            PARTIAL_FLAG = 32;

        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and prepends any additional `_.bind` arguments to those provided to the
         * bound function.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind` this method does not set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var greet = function(greeting, punctuation) {
 *   return greeting + ' ' + this.user + punctuation;
 * };
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // using placeholders
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = restParam(function (func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, bind.placeholder);
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
        });

// Assign default placeholders.
        bind.placeholder = {};

        module.exports = bind;

    }, {
        "../internal/createWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createWrapper.js",
        "../internal/replaceHolders": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/replaceHolders.js",
        "./restParam": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/restParam.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/debounce.js": [function (require, module, exports) {
        var isObject = require('../lang/isObject'),
            now = require('../date/now');

        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed invocations. Provide an options object to indicate that `func`
         * should be invoked on the leading and/or trailing edge of the `wait` timeout.
         * Subsequent calls to the debounced function return the result of the last
         * `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the the debounced function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=false] Specify invoking on the leading
         *  edge of the timeout.
         * @param {number} [options.maxWait] The maximum time `func` is allowed to be
         *  delayed before it is invoked.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // avoid costly calculations while the window size is in flux
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
         * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
         *
         * // ensure `batchLog` is invoked once after 1 second of debounced calls
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', _.debounce(batchLog, 250, {
 *   'maxWait': 1000
 * }));
         *
         * // cancel a debounced call
         * var todoChanges = _.debounce(batchLog, 1000);
         * Object.observe(models.todo, todoChanges);
         *
         * Object.observe(models, function(changes) {
 *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
 *     todoChanges.cancel();
 *   }
 * }, ['delete']);
         *
         * // ...at some point `models.todo` is changed
         * models.todo.completed = true;
         *
         * // ...before 1 second has passed `models.todo` is deleted
         * // which cancels the debounced `todoChanges` call
         * delete models.todo;
         */
        function debounce(func, wait, options) {
            var args,
                maxTimeoutId,
                result,
                stamp,
                thisArg,
                timeoutId,
                trailingCall,
                lastCalled = 0,
                maxWait = false,
                trailing = true;

            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = wait < 0 ? 0 : (+wait || 0);
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = !!options.leading;
                maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
                trailing = 'trailing' in options ? !!options.trailing : trailing;
            }

            function cancel() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                if (maxTimeoutId) {
                    clearTimeout(maxTimeoutId);
                }
                lastCalled = 0;
                maxTimeoutId = timeoutId = trailingCall = undefined;
            }

            function complete(isCalled, id) {
                if (id) {
                    clearTimeout(id);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (isCalled) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = undefined;
                    }
                }
            }

            function delayed() {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0 || remaining > wait) {
                    complete(trailingCall, maxTimeoutId);
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            }

            function maxDelayed() {
                complete(trailing, timeoutId);
            }

            function debounced() {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);

                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled),
                        isCalled = remaining <= 0 || remaining > maxWait;

                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    }
                    else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                }
                else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = undefined;
                }
                return result;
            }

            debounced.cancel = cancel;
            return debounced;
        }

        module.exports = debounce;

    }, {
        "../date/now": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/date/now.js",
        "../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/defer.js": [function (require, module, exports) {
        var baseDelay = require('../internal/baseDelay'),
            restParam = require('./restParam');

        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it is invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
 *   console.log(text);
 * }, 'deferred');
         * // logs 'deferred' after one or more milliseconds
         */
        var defer = restParam(function (func, args) {
            return baseDelay(func, 1, args);
        });

        module.exports = defer;

    }, {
        "../internal/baseDelay": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseDelay.js",
        "./restParam": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/restParam.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/restParam.js": [function (require, module, exports) {
        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as an array.
         *
         * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function restParam(func, start) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
            return function () {
                var args = arguments,
                    index = -1,
                    length = nativeMax(args.length - start, 0),
                    rest = Array(length);

                while (++index < length) {
                    rest[index] = args[start + index];
                }
                switch (start) {
                    case 0:
                        return func.call(this, rest);
                    case 1:
                        return func.call(this, args[0], rest);
                    case 2:
                        return func.call(this, args[0], args[1], rest);
                }
                var otherArgs = Array(start + 1);
                index = -1;
                while (++index < start) {
                    otherArgs[index] = args[index];
                }
                otherArgs[start] = rest;
                return func.apply(this, otherArgs);
            };
        }

        module.exports = restParam;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/index.js": [function (require, module, exports) {
        (function (global) {
            /**
             * @license
             * lodash 3.10.0 (Custom Build) <https://lodash.com/>
             * Build: `lodash modern -d -o ./index.js`
             * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
             * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
             * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
             * Available under MIT license <https://lodash.com/license>
             */
            ;
            (function () {

                /** Used as a safe reference for `undefined` in pre-ES5 environments. */
                var undefined;

                /** Used as the semantic version number. */
                var VERSION = '3.10.0';

                /** Used to compose bitmasks for wrapper metadata. */
                var BIND_FLAG = 1,
                    BIND_KEY_FLAG = 2,
                    CURRY_BOUND_FLAG = 4,
                    CURRY_FLAG = 8,
                    CURRY_RIGHT_FLAG = 16,
                    PARTIAL_FLAG = 32,
                    PARTIAL_RIGHT_FLAG = 64,
                    ARY_FLAG = 128,
                    REARG_FLAG = 256;

                /** Used as default options for `_.trunc`. */
                var DEFAULT_TRUNC_LENGTH = 30,
                    DEFAULT_TRUNC_OMISSION = '...';

                /** Used to detect when a function becomes hot. */
                var HOT_COUNT = 150,
                    HOT_SPAN = 16;

                /** Used as the size to enable large array optimizations. */
                var LARGE_ARRAY_SIZE = 200;

                /** Used to indicate the type of lazy iteratees. */
                var LAZY_FILTER_FLAG = 1,
                    LAZY_MAP_FLAG = 2;

                /** Used as the `TypeError` message for "Functions" methods. */
                var FUNC_ERROR_TEXT = 'Expected a function';

                /** Used as the internal argument placeholder. */
                var PLACEHOLDER = '__lodash_placeholder__';

                /** `Object#toString` result references. */
                var argsTag = '[object Arguments]',
                    arrayTag = '[object Array]',
                    boolTag = '[object Boolean]',
                    dateTag = '[object Date]',
                    errorTag = '[object Error]',
                    funcTag = '[object Function]',
                    mapTag = '[object Map]',
                    numberTag = '[object Number]',
                    objectTag = '[object Object]',
                    regexpTag = '[object RegExp]',
                    setTag = '[object Set]',
                    stringTag = '[object String]',
                    weakMapTag = '[object WeakMap]';

                var arrayBufferTag = '[object ArrayBuffer]',
                    float32Tag = '[object Float32Array]',
                    float64Tag = '[object Float64Array]',
                    int8Tag = '[object Int8Array]',
                    int16Tag = '[object Int16Array]',
                    int32Tag = '[object Int32Array]',
                    uint8Tag = '[object Uint8Array]',
                    uint8ClampedTag = '[object Uint8ClampedArray]',
                    uint16Tag = '[object Uint16Array]',
                    uint32Tag = '[object Uint32Array]';

                /** Used to match empty string literals in compiled template source. */
                var reEmptyStringLeading = /\b__p \+= '';/g,
                    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

                /** Used to match HTML entities and HTML characters. */
                var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
                    reUnescapedHtml = /[&<>"'`]/g,
                    reHasEscapedHtml = RegExp(reEscapedHtml.source),
                    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

                /** Used to match template delimiters. */
                var reEscape = /<%-([\s\S]+?)%>/g,
                    reEvaluate = /<%([\s\S]+?)%>/g,
                    reInterpolate = /<%=([\s\S]+?)%>/g;

                /** Used to match property names within property paths. */
                var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
                    reIsPlainProp = /^\w*$/,
                    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

                /**
                 * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
                 * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
                 */
                var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
                    reHasRegExpChars = RegExp(reRegExpChars.source);

                /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
                var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

                /** Used to match backslashes in property paths. */
                var reEscapeChar = /\\(\\)?/g;

                /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

                /** Used to match `RegExp` flags from their coerced string values. */
                var reFlags = /\w*$/;

                /** Used to detect hexadecimal string values. */
                var reHasHexPrefix = /^0[xX]/;

                /** Used to detect host constructors (Safari > 5). */
                var reIsHostCtor = /^\[object .+?Constructor\]$/;

                /** Used to detect unsigned integer values. */
                var reIsUint = /^\d+$/;

                /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
                var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

                /** Used to ensure capturing order of template delimiters. */
                var reNoMatch = /($^)/;

                /** Used to match unescaped characters in compiled string literals. */
                var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

                /** Used to match words to create compound words. */
                var reWords = (function () {
                    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
                        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

                    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
                }());

                /** Used to assign default `context` object properties. */
                var contextProps = [
                    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
                    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
                    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
                    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
                    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
                ];

                /** Used to make template sourceURLs easier to identify. */
                var templateCounter = -1;

                /** Used to identify `toStringTag` values of typed arrays. */
                var typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                        typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                            typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                                typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                        typedArrayTags[dateTag] = typedArrayTags[errorTag] =
                            typedArrayTags[funcTag] = typedArrayTags[mapTag] =
                                typedArrayTags[numberTag] = typedArrayTags[objectTag] =
                                    typedArrayTags[regexpTag] = typedArrayTags[setTag] =
                                        typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

                /** Used to identify `toStringTag` values supported by `_.clone`. */
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] =
                    cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
                        cloneableTags[dateTag] = cloneableTags[float32Tag] =
                            cloneableTags[float64Tag] = cloneableTags[int8Tag] =
                                cloneableTags[int16Tag] = cloneableTags[int32Tag] =
                                    cloneableTags[numberTag] = cloneableTags[objectTag] =
                                        cloneableTags[regexpTag] = cloneableTags[stringTag] =
                                            cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                                                cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] =
                    cloneableTags[mapTag] = cloneableTags[setTag] =
                        cloneableTags[weakMapTag] = false;

                /** Used to map latin-1 supplementary letters to basic latin letters. */
                var deburredLetters = {
                    '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
                    '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
                    '\xc7': 'C', '\xe7': 'c',
                    '\xd0': 'D', '\xf0': 'd',
                    '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
                    '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
                    '\xcC': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
                    '\xeC': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
                    '\xd1': 'N', '\xf1': 'n',
                    '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
                    '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
                    '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
                    '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
                    '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
                    '\xc6': 'Ae', '\xe6': 'ae',
                    '\xde': 'Th', '\xfe': 'th',
                    '\xdf': 'ss'
                };

                /** Used to map characters to HTML entities. */
                var htmlEscapes = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    '`': '&#96;'
                };

                /** Used to map HTML entities to characters. */
                var htmlUnescapes = {
                    '&amp;': '&',
                    '&lt;': '<',
                    '&gt;': '>',
                    '&quot;': '"',
                    '&#39;': "'",
                    '&#96;': '`'
                };

                /** Used to determine if values are of the language type `Object`. */
                var objectTypes = {
                    'function': true,
                    'object': true
                };

                /** Used to escape characters for inclusion in compiled regexes. */
                var regexpEscapes = {
                    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
                    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
                    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
                    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
                    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
                };

                /** Used to escape characters for inclusion in compiled string literals. */
                var stringEscapes = {
                    '\\': '\\',
                    "'": "'",
                    '\n': 'n',
                    '\r': 'r',
                    '\u2028': 'u2028',
                    '\u2029': 'u2029'
                };

                /** Detect free variable `exports`. */
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

                /** Detect free variable `module`. */
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

                /** Detect free variable `global` from Node.js. */
                var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

                /** Detect free variable `self`. */
                var freeSelf = objectTypes[typeof self] && self && self.Object && self;

                /** Detect free variable `window`. */
                var freeWindow = objectTypes[typeof window] && window && window.Object && window;

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

                /**
                 * Used as a reference to the global object.
                 *
                 * The `this` value is used if it's the global object to avoid Greasemonkey's
                 * restricted `window` object, otherwise the `window` object is used.
                 */
                var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

                /*--------------------------------------------------------------------------*/

                /**
                 * The base implementation of `compareAscending` which compares values and
                 * sorts them in ascending order without guaranteeing a stable sort.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {number} Returns the sort order indicator for `value`.
                 */
                function baseCompareAscending(value, other) {
                    if (value !== other) {
                        var valIsNull = value === null,
                            valIsUndef = value === undefined,
                            valIsReflexive = value === value;

                        var othIsNull = other === null,
                            othIsUndef = other === undefined,
                            othIsReflexive = other === other;

                        if ((value > other && !othIsNull) || !valIsReflexive ||
                            (valIsNull && !othIsUndef && othIsReflexive) ||
                            (valIsUndef && othIsReflexive)) {
                            return 1;
                        }
                        if ((value < other && !valIsNull) || !othIsReflexive ||
                            (othIsNull && !valIsUndef && valIsReflexive) ||
                            (othIsUndef && valIsReflexive)) {
                            return -1;
                        }
                    }
                    return 0;
                }

                /**
                 * The base implementation of `_.findIndex` and `_.findLastIndex` without
                 * support for callback shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {Function} predicate The function invoked per iteration.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function baseFindIndex(array, predicate, fromRight) {
                    var length = array.length,
                        index = fromRight ? length : -1;

                    while ((fromRight ? index-- : ++index < length)) {
                        if (predicate(array[index], index, array)) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * The base implementation of `_.indexOf` without support for binary searches.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {number} fromIndex The index to search from.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function baseIndexOf(array, value, fromIndex) {
                    if (value !== value) {
                        return indexOfNaN(array, fromIndex);
                    }
                    var index = fromIndex - 1,
                        length = array.length;

                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * The base implementation of `_.isFunction` without support for environments
                 * with incorrect `typeof` results.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                 */
                function baseIsFunction(value) {
                    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
                    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
                    return typeof value == 'function' || false;
                }

                /**
                 * Converts `value` to a string if it's not one. An empty string is returned
                 * for `null` or `undefined` values.
                 *
                 * @private
                 * @param {*} value The value to process.
                 * @returns {string} Returns the string.
                 */
                function baseToString(value) {
                    return value == null ? '' : (value + '');
                }

                /**
                 * Used by `_.trim` and `_.trimLeft` to get the index of the first character
                 * of `string` that is not found in `chars`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @param {string} chars The characters to find.
                 * @returns {number} Returns the index of the first character not found in `chars`.
                 */
                function charsLeftIndex(string, chars) {
                    var index = -1,
                        length = string.length;

                    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {
                    }
                    return index;
                }

                /**
                 * Used by `_.trim` and `_.trimRight` to get the index of the last character
                 * of `string` that is not found in `chars`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @param {string} chars The characters to find.
                 * @returns {number} Returns the index of the last character not found in `chars`.
                 */
                function charsRightIndex(string, chars) {
                    var index = string.length;

                    while (index-- && chars.indexOf(string.charAt(index)) > -1) {
                    }
                    return index;
                }

                /**
                 * Used by `_.sortBy` to compare transformed elements of a collection and stable
                 * sort them in ascending order.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @returns {number} Returns the sort order indicator for `object`.
                 */
                function compareAscending(object, other) {
                    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
                }

                /**
                 * Used by `_.sortByOrder` to compare multiple properties of a value to another
                 * and stable sort them.
                 *
                 * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
                 * a value is sorted in ascending order if its corresponding order is "asc", and
                 * descending if "desc".
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {boolean[]} orders The order to sort by for each property.
                 * @returns {number} Returns the sort order indicator for `object`.
                 */
                function compareMultiple(object, other, orders) {
                    var index = -1,
                        objCriteria = object.criteria,
                        othCriteria = other.criteria,
                        length = objCriteria.length,
                        ordersLength = orders.length;

                    while (++index < length) {
                        var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
                        if (result) {
                            if (index >= ordersLength) {
                                return result;
                            }
                            var order = orders[index];
                            return result * ((order === 'asc' || order === true) ? 1 : -1);
                        }
                    }
                    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                    // that causes it, under certain circumstances, to provide the same value for
                    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                    // for more details.
                    //
                    // This also ensures a stable sort in V8 and other engines.
                    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
                    return object.index - other.index;
                }

                /**
                 * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
                 *
                 * @private
                 * @param {string} letter The matched letter to deburr.
                 * @returns {string} Returns the deburred letter.
                 */
                function deburrLetter(letter) {
                    return deburredLetters[letter];
                }

                /**
                 * Used by `_.escape` to convert characters to HTML entities.
                 *
                 * @private
                 * @param {string} chr The matched character to escape.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeHtmlChar(chr) {
                    return htmlEscapes[chr];
                }

                /**
                 * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
                 *
                 * @private
                 * @param {string} chr The matched character to escape.
                 * @param {string} leadingChar The capture group for a leading character.
                 * @param {string} whitespaceChar The capture group for a whitespace character.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
                    if (leadingChar) {
                        chr = regexpEscapes[chr];
                    } else if (whitespaceChar) {
                        chr = stringEscapes[chr];
                    }
                    return '\\' + chr;
                }

                /**
                 * Used by `_.template` to escape characters for inclusion in compiled string literals.
                 *
                 * @private
                 * @param {string} chr The matched character to escape.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeStringChar(chr) {
                    return '\\' + stringEscapes[chr];
                }

                /**
                 * Gets the index at which the first occurrence of `NaN` is found in `array`.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {number} fromIndex The index to search from.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
                 */
                function indexOfNaN(array, fromIndex, fromRight) {
                    var length = array.length,
                        index = fromIndex + (fromRight ? 0 : -1);

                    while ((fromRight ? index-- : ++index < length)) {
                        var other = array[index];
                        if (other !== other) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * Checks if `value` is object-like.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                 */
                function isObjectLike(value) {
                    return !!value && typeof value == 'object';
                }

                /**
                 * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
                 * character code is whitespace.
                 *
                 * @private
                 * @param {number} charCode The character code to inspect.
                 * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
                 */
                function isSpace(charCode) {
                    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
                    (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
                }

                /**
                 * Replaces all `placeholder` elements in `array` with an internal placeholder
                 * and returns an array of their indexes.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {*} placeholder The placeholder to replace.
                 * @returns {Array} Returns the new array of placeholder indexes.
                 */
                function replaceHolders(array, placeholder) {
                    var index = -1,
                        length = array.length,
                        resIndex = -1,
                        result = [];

                    while (++index < length) {
                        if (array[index] === placeholder) {
                            array[index] = PLACEHOLDER;
                            result[++resIndex] = index;
                        }
                    }
                    return result;
                }

                /**
                 * An implementation of `_.uniq` optimized for sorted arrays without support
                 * for callback shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee] The function invoked per iteration.
                 * @returns {Array} Returns the new duplicate-value-free array.
                 */
                function sortedUniq(array, iteratee) {
                    var seen,
                        index = -1,
                        length = array.length,
                        resIndex = -1,
                        result = [];

                    while (++index < length) {
                        var value = array[index],
                            computed = iteratee ? iteratee(value, index, array) : value;

                        if (!index || seen !== computed) {
                            seen = computed;
                            result[++resIndex] = value;
                        }
                    }
                    return result;
                }

                /**
                 * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
                 * character of `string`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @returns {number} Returns the index of the first non-whitespace character.
                 */
                function trimmedLeftIndex(string) {
                    var index = -1,
                        length = string.length;

                    while (++index < length && isSpace(string.charCodeAt(index))) {
                    }
                    return index;
                }

                /**
                 * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
                 * character of `string`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @returns {number} Returns the index of the last non-whitespace character.
                 */
                function trimmedRightIndex(string) {
                    var index = string.length;

                    while (index-- && isSpace(string.charCodeAt(index))) {
                    }
                    return index;
                }

                /**
                 * Used by `_.unescape` to convert HTML entities to characters.
                 *
                 * @private
                 * @param {string} chr The matched character to unescape.
                 * @returns {string} Returns the unescaped character.
                 */
                function unescapeHtmlChar(chr) {
                    return htmlUnescapes[chr];
                }

                /*--------------------------------------------------------------------------*/

                /**
                 * Create a new pristine `lodash` function using the given `context` object.
                 *
                 * @static
                 * @memberOf _
                 * @category Utility
                 * @param {Object} [context=root] The context object.
                 * @returns {Function} Returns a new `lodash` function.
                 * @example
                 *
                 * _.mixin({ 'foo': _.constant('foo') });
                 *
                 * var lodash = _.runInContext();
                 * lodash.mixin({ 'bar': lodash.constant('bar') });
                 *
                 * _.isFunction(_.foo);
                 * // => true
                 * _.isFunction(_.bar);
                 * // => false
                 *
                 * lodash.isFunction(lodash.foo);
                 * // => false
                 * lodash.isFunction(lodash.bar);
                 * // => true
                 *
                 * // using `context` to mock `Date#getTime` use in `_.now`
                 * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
                 *
                 * // or creating a suped-up `defer` in Node.js
                 * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
                 */
                function runInContext(context) {
                    // Avoid issues with some ES3 environments that attempt to use values, named
                    // after built-in constructors like `Object`, for the creation of literals.
                    // ES5 clears this up by stating that literals must use built-in constructors.
                    // See https://es5.github.io/#x11.1.5 for more details.
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

                    /** Native constructor references. */
                    var Array = context.Array,
                        Date = context.Date,
                        Error = context.Error,
                        Function = context.Function,
                        Math = context.Math,
                        Number = context.Number,
                        Object = context.Object,
                        RegExp = context.RegExp,
                        String = context.String,
                        TypeError = context.TypeError;

                    /** Used for native method references. */
                    var arrayProto = Array.prototype,
                        objectProto = Object.prototype,
                        stringProto = String.prototype;

                    /** Used to resolve the decompiled source of functions. */
                    var fnToString = Function.prototype.toString;

                    /** Used to check objects for own properties. */
                    var hasOwnProperty = objectProto.hasOwnProperty;

                    /** Used to generate unique IDs. */
                    var idCounter = 0;

                    /**
                     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                     * of values.
                     */
                    var objToString = objectProto.toString;

                    /** Used to restore the original `_` reference in `_.noConflict`. */
                    var oldDash = root._;

                    /** Used to detect if a method is native. */
                    var reIsNative = RegExp('^' +
                        fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
                    );

                    /** Native method references. */
                    var ArrayBuffer = context.ArrayBuffer,
                        clearTimeout = context.clearTimeout,
                        parseFloat = context.parseFloat,
                        pow = Math.pow,
                        propertyIsEnumerable = objectProto.propertyIsEnumerable,
                        Set = getNative(context, 'Set'),
                        setTimeout = context.setTimeout,
                        splice = arrayProto.splice,
                        Uint8Array = context.Uint8Array,
                        WeakMap = getNative(context, 'WeakMap');

                    /* Native method references for those with the same name as other `lodash` methods. */
                    var nativeCeil = Math.ceil,
                        nativeCreate = getNative(Object, 'create'),
                        nativeFloor = Math.floor,
                        nativeIsArray = getNative(Array, 'isArray'),
                        nativeIsFinite = context.isFinite,
                        nativeKeys = getNative(Object, 'keys'),
                        nativeMax = Math.max,
                        nativeMin = Math.min,
                        nativeNow = getNative(Date, 'now'),
                        nativeParseInt = context.parseInt,
                        nativeRandom = Math.random;

                    /** Used as references for `-Infinity` and `Infinity`. */
                    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
                        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

                    /** Used as references for the maximum length and index of an array. */
                    var MAX_ARRAY_LENGTH = 4294967295,
                        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

                    /**
                     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
                     * of an array-like value.
                     */
                    var MAX_SAFE_INTEGER = 9007199254740991;

                    /** Used to store function metadata. */
                    var metaMap = WeakMap && new WeakMap;

                    /** Used to lookup unminified function names. */
                    var realNames = {};

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
                     * Methods that operate on and return arrays, collections, and functions can
                     * be chained together. Methods that retrieve a single value or may return a
                     * primitive value will automatically end the chain returning the unwrapped
                     * value. Explicit chaining may be enabled using `_.chain`. The execution of
                     * chained methods is lazy, that is, execution is deferred until `_#value`
                     * is implicitly or explicitly called.
                     *
                     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
                     * fusion is an optimization strategy which merge iteratee calls; this can help
                     * to avoid the creation of intermediate data structures and greatly reduce the
                     * number of iteratee executions.
                     *
                     * Chaining is supported in custom builds as long as the `_#value` method is
                     * directly or indirectly included in the build.
                     *
                     * In addition to lodash methods, wrappers have `Array` and `String` methods.
                     *
                     * The wrapper `Array` methods are:
                     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
                     * `splice`, and `unshift`
                     *
                     * The wrapper `String` methods are:
                     * `replace` and `split`
                     *
                     * The wrapper methods that support shortcut fusion are:
                     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
                     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
                     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
                     * and `where`
                     *
                     * The chainable wrapper methods are:
                     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
                     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
                     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
                     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
                     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
                     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
                     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
                     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
                     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
                     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
                     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
                     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
                     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
                     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
                     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
                     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
                     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
                     *
                     * The wrapper methods that are **not** chainable by default are:
                     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
                     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
                     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
                     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
                     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
                     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
                     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
                     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
                     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
                     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
                     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
                     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
                     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
                     * `unescape`, `uniqueId`, `value`, and `words`
                     *
                     * The wrapper method `sample` will return a wrapped value when `n` is provided,
                     * otherwise an unwrapped value is returned.
                     *
                     * @name _
                     * @constructor
                     * @category Chain
                     * @param {*} value The value to wrap in a `lodash` instance.
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var wrapped = _([1, 2, 3]);
                     *
                     * // returns an unwrapped value
                     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
                     * // => 6
                     *
                     * // returns a wrapped value
                     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
                     *
                     * _.isArray(squares);
                     * // => false
                     *
                     * _.isArray(squares.value());
                     * // => true
                     */
                    function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                            if (value instanceof LodashWrapper) {
                                return value;
                            }
                            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                                return wrapperClone(value);
                            }
                        }
                        return new LodashWrapper(value);
                    }

                    /**
                     * The function whose prototype all chaining wrappers inherit from.
                     *
                     * @private
                     */
                    function baseLodash() {
                        // No operation performed.
                    }

                    /**
                     * The base constructor for creating `lodash` wrapper objects.
                     *
                     * @private
                     * @param {*} value The value to wrap.
                     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
                     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
                     */
                    function LodashWrapper(value, chainAll, actions) {
                        this.__wrapped__ = value;
                        this.__actions__ = actions || [];
                        this.__chain__ = !!chainAll;
                    }

                    /**
                     * An object environment feature flags.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    var support = lodash.support = {};

                    /**
                     * By default, the template delimiters used by lodash are like those in
                     * embedded Ruby (ERB). Change the following template settings to use
                     * alternative delimiters.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    lodash.templateSettings = {

                        /**
                         * Used to detect `data` property values to be HTML-escaped.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'escape': reEscape,

                        /**
                         * Used to detect code to be evaluated.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'evaluate': reEvaluate,

                        /**
                         * Used to detect `data` property values to inject.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'interpolate': reInterpolate,

                        /**
                         * Used to reference the data object in the template text.
                         *
                         * @memberOf _.templateSettings
                         * @type string
                         */
                        'variable': '',

                        /**
                         * Used to import variables into the compiled template.
                         *
                         * @memberOf _.templateSettings
                         * @type Object
                         */
                        'imports': {

                            /**
                             * A reference to the `lodash` function.
                             *
                             * @memberOf _.templateSettings.imports
                             * @type Function
                             */
                            '_': lodash
                        }
                    };

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
                     *
                     * @private
                     * @param {*} value The value to wrap.
                     */
                    function LazyWrapper(value) {
                        this.__wrapped__ = value;
                        this.__actions__ = [];
                        this.__dir__ = 1;
                        this.__filtered__ = false;
                        this.__iteratees__ = [];
                        this.__takeCount__ = POSITIVE_INFINITY;
                        this.__views__ = [];
                    }

                    /**
                     * Creates a clone of the lazy wrapper object.
                     *
                     * @private
                     * @name clone
                     * @memberOf LazyWrapper
                     * @returns {Object} Returns the cloned `LazyWrapper` object.
                     */
                    function lazyClone() {
                        var result = new LazyWrapper(this.__wrapped__);
                        result.__actions__ = arrayCopy(this.__actions__);
                        result.__dir__ = this.__dir__;
                        result.__filtered__ = this.__filtered__;
                        result.__iteratees__ = arrayCopy(this.__iteratees__);
                        result.__takeCount__ = this.__takeCount__;
                        result.__views__ = arrayCopy(this.__views__);
                        return result;
                    }

                    /**
                     * Reverses the direction of lazy iteration.
                     *
                     * @private
                     * @name reverse
                     * @memberOf LazyWrapper
                     * @returns {Object} Returns the new reversed `LazyWrapper` object.
                     */
                    function lazyReverse() {
                        if (this.__filtered__) {
                            var result = new LazyWrapper(this);
                            result.__dir__ = -1;
                            result.__filtered__ = true;
                        } else {
                            result = this.clone();
                            result.__dir__ *= -1;
                        }
                        return result;
                    }

                    /**
                     * Extracts the unwrapped value from its lazy wrapper.
                     *
                     * @private
                     * @name value
                     * @memberOf LazyWrapper
                     * @returns {*} Returns the unwrapped value.
                     */
                    function lazyValue() {
                        var array = this.__wrapped__.value(),
                            dir = this.__dir__,
                            isArr = isArray(array),
                            isRight = dir < 0,
                            arrLength = isArr ? array.length : 0,
                            view = getView(0, arrLength, this.__views__),
                            start = view.start,
                            end = view.end,
                            length = end - start,
                            index = isRight ? end : (start - 1),
                            iteratees = this.__iteratees__,
                            iterLength = iteratees.length,
                            resIndex = 0,
                            takeCount = nativeMin(length, this.__takeCount__);

                        if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
                            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
                        }
                        var result = [];

                        outer:
                            while (length-- && resIndex < takeCount) {
                                index += dir;

                                var iterIndex = -1,
                                    value = array[index];

                                while (++iterIndex < iterLength) {
                                    var data = iteratees[iterIndex],
                                        iteratee = data.iteratee,
                                        type = data.type,
                                        computed = iteratee(value);

                                    if (type == LAZY_MAP_FLAG) {
                                        value = computed;
                                    } else if (!computed) {
                                        if (type == LAZY_FILTER_FLAG) {
                                            continue outer;
                                        } else {
                                            break outer;
                                        }
                                    }
                                }
                                result[resIndex++] = value;
                            }
                        return result;
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a cache object to store key/value pairs.
                     *
                     * @private
                     * @static
                     * @name Cache
                     * @memberOf _.memoize
                     */
                    function MapCache() {
                        this.__data__ = {};
                    }

                    /**
                     * Removes `key` and its value from the cache.
                     *
                     * @private
                     * @name delete
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
                     */
                    function mapDelete(key) {
                        return this.has(key) && delete this.__data__[key];
                    }

                    /**
                     * Gets the cached value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the cached value.
                     */
                    function mapGet(key) {
                        return key == '__proto__' ? undefined : this.__data__[key];
                    }

                    /**
                     * Checks if a cached value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */
                    function mapHas(key) {
                        return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
                    }

                    /**
                     * Sets `value` to `key` of the cache.
                     *
                     * @private
                     * @name set
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the value to cache.
                     * @param {*} value The value to cache.
                     * @returns {Object} Returns the cache object.
                     */
                    function mapSet(key, value) {
                        if (key != '__proto__') {
                            this.__data__[key] = value;
                        }
                        return this;
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     *
                     * Creates a cache object to store unique values.
                     *
                     * @private
                     * @param {Array} [values] The values to cache.
                     */
                    function SetCache(values) {
                        var length = values ? values.length : 0;

                        this.data = {'hash': nativeCreate(null), 'set': new Set};
                        while (length--) {
                            this.push(values[length]);
                        }
                    }

                    /**
                     * Checks if `value` is in `cache` mimicking the return signature of
                     * `_.indexOf` by returning `0` if the value is found, else `-1`.
                     *
                     * @private
                     * @param {Object} cache The cache to search.
                     * @param {*} value The value to search for.
                     * @returns {number} Returns `0` if `value` is found, else `-1`.
                     */
                    function cacheIndexOf(cache, value) {
                        var data = cache.data,
                            result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

                        return result ? 0 : -1;
                    }

                    /**
                     * Adds `value` to the cache.
                     *
                     * @private
                     * @name push
                     * @memberOf SetCache
                     * @param {*} value The value to cache.
                     */
                    function cachePush(value) {
                        var data = this.data;
                        if (typeof value == 'string' || isObject(value)) {
                            data.set.add(value);
                        } else {
                            data.hash[value] = true;
                        }
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a new array joining `array` with `other`.
                     *
                     * @private
                     * @param {Array} array The array to join.
                     * @param {Array} other The other array to join.
                     * @returns {Array} Returns the new concatenated array.
                     */
                    function arrayConcat(array, other) {
                        var index = -1,
                            length = array.length,
                            othIndex = -1,
                            othLength = other.length,
                            result = Array(length + othLength);

                        while (++index < length) {
                            result[index] = array[index];
                        }
                        while (++othIndex < othLength) {
                            result[index++] = other[othIndex];
                        }
                        return result;
                    }

                    /**
                     * Copies the values of `source` to `array`.
                     *
                     * @private
                     * @param {Array} source The array to copy values from.
                     * @param {Array} [array=[]] The array to copy values to.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayCopy(source, array) {
                        var index = -1,
                            length = source.length;

                        array || (array = Array(length));
                        while (++index < length) {
                            array[index] = source[index];
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.forEach` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEach(array, iteratee) {
                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            if (iteratee(array[index], index, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.forEachRight` for arrays without support for
                     * callback shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEachRight(array, iteratee) {
                        var length = array.length;

                        while (length--) {
                            if (iteratee(array[length], length, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.every` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`.
                     */
                    function arrayEvery(array, predicate) {
                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            if (!predicate(array[index], index, array)) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
                     * with one argument: (value).
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} comparator The function used to compare values.
                     * @param {*} exValue The initial extremum value.
                     * @returns {*} Returns the extremum value.
                     */
                    function arrayExtremum(array, iteratee, comparator, exValue) {
                        var index = -1,
                            length = array.length,
                            computed = exValue,
                            result = computed;

                        while (++index < length) {
                            var value = array[index],
                                current = +iteratee(value);

                            if (comparator(current, computed)) {
                                computed = current;
                                result = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.filter` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */
                    function arrayFilter(array, predicate) {
                        var index = -1,
                            length = array.length,
                            resIndex = -1,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result[++resIndex] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.map` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */
                    function arrayMap(array, iteratee) {
                        var index = -1,
                            length = array.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = iteratee(array[index], index, array);
                        }
                        return result;
                    }

                    /**
                     * Appends the elements of `values` to `array`.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {Array} values The values to append.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayPush(array, values) {
                        var index = -1,
                            length = values.length,
                            offset = array.length;

                        while (++index < length) {
                            array[offset + index] = values[index];
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.reduce` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initFromArray] Specify using the first element of `array`
                     *  as the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduce(array, iteratee, accumulator, initFromArray) {
                        var index = -1,
                            length = array.length;

                        if (initFromArray && length) {
                            accumulator = array[++index];
                        }
                        while (++index < length) {
                            accumulator = iteratee(accumulator, array[index], index, array);
                        }
                        return accumulator;
                    }

                    /**
                     * A specialized version of `_.reduceRight` for arrays without support for
                     * callback shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initFromArray] Specify using the last element of `array`
                     *  as the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
                        var length = array.length;
                        if (initFromArray && length) {
                            accumulator = array[--length];
                        }
                        while (length--) {
                            accumulator = iteratee(accumulator, array[length], length, array);
                        }
                        return accumulator;
                    }

                    /**
                     * A specialized version of `_.some` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     */
                    function arraySome(array, predicate) {
                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            if (predicate(array[index], index, array)) {
                                return true;
                            }
                        }
                        return false;
                    }

                    /**
                     * A specialized version of `_.sum` for arrays without support for callback
                     * shorthands and `this` binding..
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the sum.
                     */
                    function arraySum(array, iteratee) {
                        var length = array.length,
                            result = 0;

                        while (length--) {
                            result += +iteratee(array[length]) || 0;
                        }
                        return result;
                    }

                    /**
                     * Used by `_.defaults` to customize its `_.assign` use.
                     *
                     * @private
                     * @param {*} objectValue The destination object property value.
                     * @param {*} sourceValue The source object property value.
                     * @returns {*} Returns the value to assign to the destination object.
                     */
                    function assignDefaults(objectValue, sourceValue) {
                        return objectValue === undefined ? sourceValue : objectValue;
                    }

                    /**
                     * Used by `_.template` to customize its `_.assign` use.
                     *
                     * **Note:** This function is like `assignDefaults` except that it ignores
                     * inherited property values when checking if a property is `undefined`.
                     *
                     * @private
                     * @param {*} objectValue The destination object property value.
                     * @param {*} sourceValue The source object property value.
                     * @param {string} key The key associated with the object and source values.
                     * @param {Object} object The destination object.
                     * @returns {*} Returns the value to assign to the destination object.
                     */
                    function assignOwnDefaults(objectValue, sourceValue, key, object) {
                        return (objectValue === undefined || !hasOwnProperty.call(object, key))
                            ? sourceValue
                            : objectValue;
                    }

                    /**
                     * A specialized version of `_.assign` for customizing assigned values without
                     * support for argument juggling, multiple sources, and `this` binding `customizer`
                     * functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {Function} customizer The function to customize assigned values.
                     * @returns {Object} Returns `object`.
                     */
                    function assignWith(object, source, customizer) {
                        var index = -1,
                            props = keys(source),
                            length = props.length;

                        while (++index < length) {
                            var key = props[index],
                                value = object[key],
                                result = customizer(value, source[key], key, object, source);

                            if ((result === result ? (result !== value) : (value === value)) ||
                                (value === undefined && !(key in object))) {
                                object[key] = result;
                            }
                        }
                        return object;
                    }

                    /**
                     * The base implementation of `_.assign` without support for argument juggling,
                     * multiple sources, and `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @returns {Object} Returns `object`.
                     */
                    function baseAssign(object, source) {
                        return source == null
                            ? object
                            : baseCopy(source, keys(source), object);
                    }

                    /**
                     * The base implementation of `_.at` without support for string collections
                     * and individual key arguments.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {number[]|string[]} props The property names or indexes of elements to pick.
                     * @returns {Array} Returns the new array of picked elements.
                     */
                    function baseAt(collection, props) {
                        var index = -1,
                            isNil = collection == null,
                            isArr = !isNil && isArrayLike(collection),
                            length = isArr ? collection.length : 0,
                            propsLength = props.length,
                            result = Array(propsLength);

                        while (++index < propsLength) {
                            var key = props[index];
                            if (isArr) {
                                result[index] = isIndex(key, length) ? collection[key] : undefined;
                            } else {
                                result[index] = isNil ? undefined : collection[key];
                            }
                        }
                        return result;
                    }

                    /**
                     * Copies properties of `source` to `object`.
                     *
                     * @private
                     * @param {Object} source The object to copy properties from.
                     * @param {Array} props The property names to copy.
                     * @param {Object} [object={}] The object to copy properties to.
                     * @returns {Object} Returns `object`.
                     */
                    function baseCopy(source, props, object) {
                        object || (object = {});

                        var index = -1,
                            length = props.length;

                        while (++index < length) {
                            var key = props[index];
                            object[key] = source[key];
                        }
                        return object;
                    }

                    /**
                     * The base implementation of `_.callback` which supports specifying the
                     * number of arguments to provide to `func`.
                     *
                     * @private
                     * @param {*} [func=_.identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {number} [argCount] The number of arguments to provide to `func`.
                     * @returns {Function} Returns the callback.
                     */
                    function baseCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (type == 'function') {
                            return thisArg === undefined
                                ? func
                                : bindCallback(func, thisArg, argCount);
                        }
                        if (func == null) {
                            return identity;
                        }
                        if (type == 'object') {
                            return baseMatches(func);
                        }
                        return thisArg === undefined
                            ? property(func)
                            : baseMatchesProperty(func, thisArg);
                    }

                    /**
                     * The base implementation of `_.clone` without support for argument juggling
                     * and `this` binding `customizer` functions.
                     *
                     * @private
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @param {Function} [customizer] The function to customize cloning values.
                     * @param {string} [key] The key of `value`.
                     * @param {Object} [object] The object `value` belongs to.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates clones with source counterparts.
                     * @returns {*} Returns the cloned value.
                     */
                    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
                        var result;
                        if (customizer) {
                            result = object ? customizer(value, key, object) : customizer(value);
                        }
                        if (result !== undefined) {
                            return result;
                        }
                        if (!isObject(value)) {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isArr) {
                            result = initCloneArray(value);
                            if (!isDeep) {
                                return arrayCopy(value, result);
                            }
                        } else {
                            var tag = objToString.call(value),
                                isFunc = tag == funcTag;

                            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                                result = initCloneObject(isFunc ? {} : value);
                                if (!isDeep) {
                                    return baseAssign(result, value);
                                }
                            } else {
                                return cloneableTags[tag]
                                    ? initCloneByTag(value, tag, isDeep)
                                    : (object ? value : {});
                            }
                        }
                        // Check for circular references and return its corresponding clone.
                        stackA || (stackA = []);
                        stackB || (stackB = []);

                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == value) {
                                return stackB[length];
                            }
                        }
                        // Add the source value to the stack of traversed objects and associate it with its clone.
                        stackA.push(value);
                        stackB.push(result);

                        // Recursively populate clone (susceptible to call stack limits).
                        (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
                            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.create` without support for assigning
                     * properties to the created object.
                     *
                     * @private
                     * @param {Object} prototype The object to inherit from.
                     * @returns {Object} Returns the new object.
                     */
                    var baseCreate = (function () {
                        function object() {
                        }

                        return function (prototype) {
                            if (isObject(prototype)) {
                                object.prototype = prototype;
                                var result = new object;
                                object.prototype = undefined;
                            }
                            return result || {};
                        };
                    }());

                    /**
                     * The base implementation of `_.delay` and `_.defer` which accepts an index
                     * of where to slice the arguments to provide to `func`.
                     *
                     * @private
                     * @param {Function} func The function to delay.
                     * @param {number} wait The number of milliseconds to delay invocation.
                     * @param {Object} args The arguments provide to `func`.
                     * @returns {number} Returns the timer id.
                     */
                    function baseDelay(func, wait, args) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return setTimeout(function () {
                            func.apply(undefined, args);
                        }, wait);
                    }

                    /**
                     * The base implementation of `_.difference` which accepts a single array
                     * of values to exclude.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Array} values The values to exclude.
                     * @returns {Array} Returns the new array of filtered values.
                     */
                    function baseDifference(array, values) {
                        var length = array ? array.length : 0,
                            result = [];

                        if (!length) {
                            return result;
                        }
                        var index = -1,
                            indexOf = getIndexOf(),
                            isCommon = indexOf == baseIndexOf,
                            cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
                            valuesLength = values.length;

                        if (cache) {
                            indexOf = cacheIndexOf;
                            isCommon = false;
                            values = cache;
                        }
                        outer:
                            while (++index < length) {
                                var value = array[index];

                                if (isCommon && value === value) {
                                    var valuesIndex = valuesLength;
                                    while (valuesIndex--) {
                                        if (values[valuesIndex] === value) {
                                            continue outer;
                                        }
                                    }
                                    result.push(value);
                                }
                                else if (indexOf(values, value, 0) < 0) {
                                    result.push(value);
                                }
                            }
                        return result;
                    }

                    /**
                     * The base implementation of `_.forEach` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array|Object|string} Returns `collection`.
                     */
                    var baseEach = createBaseEach(baseForOwn);

                    /**
                     * The base implementation of `_.forEachRight` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array|Object|string} Returns `collection`.
                     */
                    var baseEachRight = createBaseEach(baseForOwnRight, true);

                    /**
                     * The base implementation of `_.every` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`
                     */
                    function baseEvery(collection, predicate) {
                        var result = true;
                        baseEach(collection, function (value, index, collection) {
                            result = !!predicate(value, index, collection);
                            return result;
                        });
                        return result;
                    }

                    /**
                     * Gets the extremum value of `collection` invoking `iteratee` for each value
                     * in `collection` to generate the criterion by which the value is ranked.
                     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} comparator The function used to compare values.
                     * @param {*} exValue The initial extremum value.
                     * @returns {*} Returns the extremum value.
                     */
                    function baseExtremum(collection, iteratee, comparator, exValue) {
                        var computed = exValue,
                            result = computed;

                        baseEach(collection, function (value, index, collection) {
                            var current = +iteratee(value, index, collection);
                            if (comparator(current, computed) || (current === exValue && current === result)) {
                                computed = current;
                                result = value;
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.fill` without an iteratee call guard.
                     *
                     * @private
                     * @param {Array} array The array to fill.
                     * @param {*} value The value to fill `array` with.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns `array`.
                     */
                    function baseFill(array, value, start, end) {
                        var length = array.length;

                        start = start == null ? 0 : (+start || 0);
                        if (start < 0) {
                            start = -start > length ? 0 : (length + start);
                        }
                        end = (end === undefined || end > length) ? length : (+end || 0);
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : (end >>> 0);
                        start >>>= 0;

                        while (start < length) {
                            array[start++] = value;
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.filter` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */
                    function baseFilter(collection, predicate) {
                        var result = [];
                        baseEach(collection, function (value, index, collection) {
                            if (predicate(value, index, collection)) {
                                result.push(value);
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
                     * without support for callback shorthands and `this` binding, which iterates
                     * over `collection` using the provided `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @param {boolean} [retKey] Specify returning the key of the found element
                     *  instead of the element itself.
                     * @returns {*} Returns the found element or its key, else `undefined`.
                     */
                    function baseFind(collection, predicate, eachFunc, retKey) {
                        var result;
                        eachFunc(collection, function (value, key, collection) {
                            if (predicate(value, key, collection)) {
                                result = retKey ? key : value;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.flatten` with added support for restricting
                     * flattening and specifying the start index.
                     *
                     * @private
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isDeep] Specify a deep flatten.
                     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
                     * @param {Array} [result=[]] The initial result value.
                     * @returns {Array} Returns the new flattened array.
                     */
                    function baseFlatten(array, isDeep, isStrict, result) {
                        result || (result = []);

                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            var value = array[index];
                            if (isObjectLike(value) && isArrayLike(value) &&
                                (isStrict || isArray(value) || isArguments(value))) {
                                if (isDeep) {
                                    // Recursively flatten arrays (susceptible to call stack limits).
                                    baseFlatten(value, isDeep, isStrict, result);
                                } else {
                                    arrayPush(result, value);
                                }
                            } else if (!isStrict) {
                                result[result.length] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `baseForIn` and `baseForOwn` which iterates
                     * over `object` properties returned by `keysFunc` invoking `iteratee` for
                     * each property. Iteratee functions may exit iteration early by explicitly
                     * returning `false`.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} keysFunc The function to get the keys of `object`.
                     * @returns {Object} Returns `object`.
                     */
                    var baseFor = createBaseFor();

                    /**
                     * This function is like `baseFor` except that it iterates over properties
                     * in the opposite order.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} keysFunc The function to get the keys of `object`.
                     * @returns {Object} Returns `object`.
                     */
                    var baseForRight = createBaseFor(true);

                    /**
                     * The base implementation of `_.forIn` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */
                    function baseForIn(object, iteratee) {
                        return baseFor(object, iteratee, keysIn);
                    }

                    /**
                     * The base implementation of `_.forOwn` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */
                    function baseForOwn(object, iteratee) {
                        return baseFor(object, iteratee, keys);
                    }

                    /**
                     * The base implementation of `_.forOwnRight` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */
                    function baseForOwnRight(object, iteratee) {
                        return baseForRight(object, iteratee, keys);
                    }

                    /**
                     * The base implementation of `_.functions` which creates an array of
                     * `object` function property names filtered from those provided.
                     *
                     * @private
                     * @param {Object} object The object to inspect.
                     * @param {Array} props The property names to filter.
                     * @returns {Array} Returns the new array of filtered property names.
                     */
                    function baseFunctions(object, props) {
                        var index = -1,
                            length = props.length,
                            resIndex = -1,
                            result = [];

                        while (++index < length) {
                            var key = props[index];
                            if (isFunction(object[key])) {
                                result[++resIndex] = key;
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `get` without support for string paths
                     * and default values.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} path The path of the property to get.
                     * @param {string} [pathKey] The key representation of path.
                     * @returns {*} Returns the resolved value.
                     */
                    function baseGet(object, path, pathKey) {
                        if (object == null) {
                            return;
                        }
                        if (pathKey !== undefined && pathKey in toObject(object)) {
                            path = [pathKey];
                        }
                        var index = 0,
                            length = path.length;

                        while (object != null && index < length) {
                            object = object[path[index++]];
                        }
                        return (index && index == length) ? object : undefined;
                    }

                    /**
                     * The base implementation of `_.isEqual` without support for `this` binding
                     * `customizer` functions.
                     *
                     * @private
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @param {Function} [customizer] The function to customize comparing values.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA] Tracks traversed `value` objects.
                     * @param {Array} [stackB] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     */
                    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
                        if (value === other) {
                            return true;
                        }
                        if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
                            return value !== value && other !== other;
                        }
                        return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
                    }

                    /**
                     * A specialized version of `baseIsEqual` for arrays and objects which performs
                     * deep comparisons and tracks traversed objects enabling objects with circular
                     * references to be compared.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Function} [customizer] The function to customize comparing objects.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
                     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objIsArr = isArray(object),
                            othIsArr = isArray(other),
                            objTag = arrayTag,
                            othTag = arrayTag;

                        if (!objIsArr) {
                            objTag = objToString.call(object);
                            if (objTag == argsTag) {
                                objTag = objectTag;
                            } else if (objTag != objectTag) {
                                objIsArr = isTypedArray(object);
                            }
                        }
                        if (!othIsArr) {
                            othTag = objToString.call(other);
                            if (othTag == argsTag) {
                                othTag = objectTag;
                            } else if (othTag != objectTag) {
                                othIsArr = isTypedArray(other);
                            }
                        }
                        var objIsObj = objTag == objectTag,
                            othIsObj = othTag == objectTag,
                            isSameTag = objTag == othTag;

                        if (isSameTag && !(objIsArr || objIsObj)) {
                            return equalByTag(object, other, objTag);
                        }
                        if (!isLoose) {
                            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                            if (objIsWrapped || othIsWrapped) {
                                return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                            }
                        }
                        if (!isSameTag) {
                            return false;
                        }
                        // Assume cyclic values are equal.
                        // For more information on detecting circular references see https://es5.github.io/#JO.
                        stackA || (stackA = []);
                        stackB || (stackB = []);

                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == object) {
                                return stackB[length] == other;
                            }
                        }
                        // Add `object` and `other` to the stack of traversed objects.
                        stackA.push(object);
                        stackB.push(other);

                        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

                        stackA.pop();
                        stackB.pop();

                        return result;
                    }

                    /**
                     * The base implementation of `_.isMatch` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to inspect.
                     * @param {Array} matchData The propery names, values, and compare flags to match.
                     * @param {Function} [customizer] The function to customize comparing objects.
                     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                     */
                    function baseIsMatch(object, matchData, customizer) {
                        var index = matchData.length,
                            length = index,
                            noCustomizer = !customizer;

                        if (object == null) {
                            return !length;
                        }
                        object = toObject(object);
                        while (index--) {
                            var data = matchData[index];
                            if ((noCustomizer && data[2])
                                    ? data[1] !== object[data[0]]
                                    : !(data[0] in object)
                            ) {
                                return false;
                            }
                        }
                        while (++index < length) {
                            data = matchData[index];
                            var key = data[0],
                                objValue = object[key],
                                srcValue = data[1];

                            if (noCustomizer && data[2]) {
                                if (objValue === undefined && !(key in object)) {
                                    return false;
                                }
                            } else {
                                var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                                if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }

                    /**
                     * The base implementation of `_.map` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */
                    function baseMap(collection, iteratee) {
                        var index = -1,
                            result = isArrayLike(collection) ? Array(collection.length) : [];

                        baseEach(collection, function (value, key, collection) {
                            result[++index] = iteratee(value, key, collection);
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.matches` which does not clone `source`.
                     *
                     * @private
                     * @param {Object} source The object of property values to match.
                     * @returns {Function} Returns the new function.
                     */
                    function baseMatches(source) {
                        var matchData = getMatchData(source);
                        if (matchData.length == 1 && matchData[0][2]) {
                            var key = matchData[0][0],
                                value = matchData[0][1];

                            return function (object) {
                                if (object == null) {
                                    return false;
                                }
                                return object[key] === value && (value !== undefined || (key in toObject(object)));
                            };
                        }
                        return function (object) {
                            return baseIsMatch(object, matchData);
                        };
                    }

                    /**
                     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
                     *
                     * @private
                     * @param {string} path The path of the property to get.
                     * @param {*} srcValue The value to compare.
                     * @returns {Function} Returns the new function.
                     */
                    function baseMatchesProperty(path, srcValue) {
                        var isArr = isArray(path),
                            isCommon = isKey(path) && isStrictComparable(srcValue),
                            pathKey = (path + '');

                        path = toPath(path);
                        return function (object) {
                            if (object == null) {
                                return false;
                            }
                            var key = pathKey;
                            object = toObject(object);
                            if ((isArr || !isCommon) && !(key in object)) {
                                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                if (object == null) {
                                    return false;
                                }
                                key = last(path);
                                object = toObject(object);
                            }
                            return object[key] === srcValue
                                ? (srcValue !== undefined || (key in object))
                                : baseIsEqual(srcValue, object[key], undefined, true);
                        };
                    }

                    /**
                     * The base implementation of `_.merge` without support for argument juggling,
                     * multiple sources, and `this` binding `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {Function} [customizer] The function to customize merged values.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                     * @returns {Object} Returns `object`.
                     */
                    function baseMerge(object, source, customizer, stackA, stackB) {
                        if (!isObject(object)) {
                            return object;
                        }
                        var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
                            props = isSrcArr ? undefined : keys(source);

                        arrayEach(props || source, function (srcValue, key) {
                            if (props) {
                                key = srcValue;
                                srcValue = source[key];
                            }
                            if (isObjectLike(srcValue)) {
                                stackA || (stackA = []);
                                stackB || (stackB = []);
                                baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                            }
                            else {
                                var value = object[key],
                                    result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                                    isCommon = result === undefined;

                                if (isCommon) {
                                    result = srcValue;
                                }
                                if ((result !== undefined || (isSrcArr && !(key in object))) &&
                                    (isCommon || (result === result ? (result !== value) : (value === value)))) {
                                    object[key] = result;
                                }
                            }
                        });
                        return object;
                    }

                    /**
                     * A specialized version of `baseMerge` for arrays and objects which performs
                     * deep merges and tracks traversed objects enabling objects with circular
                     * references to be merged.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {string} key The key of the value to merge.
                     * @param {Function} mergeFunc The function to merge values.
                     * @param {Function} [customizer] The function to customize merged values.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
                        var length = stackA.length,
                            srcValue = source[key];

                        while (length--) {
                            if (stackA[length] == srcValue) {
                                object[key] = stackB[length];
                                return;
                            }
                        }
                        var value = object[key],
                            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                            isCommon = result === undefined;

                        if (isCommon) {
                            result = srcValue;
                            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                                result = isArray(value)
                                    ? value
                                    : (isArrayLike(value) ? arrayCopy(value) : []);
                            }
                            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                result = isArguments(value)
                                    ? toPlainObject(value)
                                    : (isPlainObject(value) ? value : {});
                            }
                            else {
                                isCommon = false;
                            }
                        }
                        // Add the source value to the stack of traversed objects and associate
                        // it with its merged value.
                        stackA.push(srcValue);
                        stackB.push(result);

                        if (isCommon) {
                            // Recursively merge objects and arrays (susceptible to call stack limits).
                            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
                        } else if (result === result ? (result !== value) : (value === value)) {
                            object[key] = result;
                        }
                    }

                    /**
                     * The base implementation of `_.property` without support for deep paths.
                     *
                     * @private
                     * @param {string} key The key of the property to get.
                     * @returns {Function} Returns the new function.
                     */
                    function baseProperty(key) {
                        return function (object) {
                            return object == null ? undefined : object[key];
                        };
                    }

                    /**
                     * A specialized version of `baseProperty` which supports deep paths.
                     *
                     * @private
                     * @param {Array|string} path The path of the property to get.
                     * @returns {Function} Returns the new function.
                     */
                    function basePropertyDeep(path) {
                        var pathKey = (path + '');
                        path = toPath(path);
                        return function (object) {
                            return baseGet(object, path, pathKey);
                        };
                    }

                    /**
                     * The base implementation of `_.pullAt` without support for individual
                     * index arguments and capturing the removed elements.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {number[]} indexes The indexes of elements to remove.
                     * @returns {Array} Returns `array`.
                     */
                    function basePullAt(array, indexes) {
                        var length = array ? indexes.length : 0;
                        while (length--) {
                            var index = indexes[length];
                            if (index != previous && isIndex(index)) {
                                var previous = index;
                                splice.call(array, index, 1);
                            }
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.random` without support for argument juggling
                     * and returning floating-point numbers.
                     *
                     * @private
                     * @param {number} min The minimum possible value.
                     * @param {number} max The maximum possible value.
                     * @returns {number} Returns the random number.
                     */
                    function baseRandom(min, max) {
                        return min + nativeFloor(nativeRandom() * (max - min + 1));
                    }

                    /**
                     * The base implementation of `_.reduce` and `_.reduceRight` without support
                     * for callback shorthands and `this` binding, which iterates over `collection`
                     * using the provided `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} accumulator The initial value.
                     * @param {boolean} initFromCollection Specify using the first or last element
                     *  of `collection` as the initial value.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @returns {*} Returns the accumulated value.
                     */
                    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
                        eachFunc(collection, function (value, index, collection) {
                            accumulator = initFromCollection
                                ? (initFromCollection = false, value)
                                : iteratee(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }

                    /**
                     * The base implementation of `setData` without support for hot loop detection.
                     *
                     * @private
                     * @param {Function} func The function to associate metadata with.
                     * @param {*} data The metadata.
                     * @returns {Function} Returns `func`.
                     */
                    var baseSetData = !metaMap ? identity : function (func, data) {
                        metaMap.set(func, data);
                        return func;
                    };

                    /**
                     * The base implementation of `_.slice` without an iteratee call guard.
                     *
                     * @private
                     * @param {Array} array The array to slice.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function baseSlice(array, start, end) {
                        var index = -1,
                            length = array.length;

                        start = start == null ? 0 : (+start || 0);
                        if (start < 0) {
                            start = -start > length ? 0 : (length + start);
                        }
                        end = (end === undefined || end > length) ? length : (+end || 0);
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : ((end - start) >>> 0);
                        start >>>= 0;

                        var result = Array(length);
                        while (++index < length) {
                            result[index] = array[index + start];
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.some` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     */
                    function baseSome(collection, predicate) {
                        var result;

                        baseEach(collection, function (value, index, collection) {
                            result = predicate(value, index, collection);
                            return !result;
                        });
                        return !!result;
                    }

                    /**
                     * The base implementation of `_.sortBy` which uses `comparer` to define
                     * the sort order of `array` and replaces criteria objects with their
                     * corresponding values.
                     *
                     * @private
                     * @param {Array} array The array to sort.
                     * @param {Function} comparer The function to define sort order.
                     * @returns {Array} Returns `array`.
                     */
                    function baseSortBy(array, comparer) {
                        var length = array.length;

                        array.sort(comparer);
                        while (length--) {
                            array[length] = array[length].value;
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.sortByOrder` without param guards.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                     * @param {boolean[]} orders The sort orders of `iteratees`.
                     * @returns {Array} Returns the new sorted array.
                     */
                    function baseSortByOrder(collection, iteratees, orders) {
                        var callback = getCallback(),
                            index = -1;

                        iteratees = arrayMap(iteratees, function (iteratee) {
                            return callback(iteratee);
                        });

                        var result = baseMap(collection, function (value) {
                            var criteria = arrayMap(iteratees, function (iteratee) {
                                return iteratee(value);
                            });
                            return {'criteria': criteria, 'index': ++index, 'value': value};
                        });

                        return baseSortBy(result, function (object, other) {
                            return compareMultiple(object, other, orders);
                        });
                    }

                    /**
                     * The base implementation of `_.sum` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the sum.
                     */
                    function baseSum(collection, iteratee) {
                        var result = 0;
                        baseEach(collection, function (value, index, collection) {
                            result += +iteratee(value, index, collection) || 0;
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.uniq` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Function} [iteratee] The function invoked per iteration.
                     * @returns {Array} Returns the new duplicate-value-free array.
                     */
                    function baseUniq(array, iteratee) {
                        var index = -1,
                            indexOf = getIndexOf(),
                            length = array.length,
                            isCommon = indexOf == baseIndexOf,
                            isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
                            seen = isLarge ? createCache() : null,
                            result = [];

                        if (seen) {
                            indexOf = cacheIndexOf;
                            isCommon = false;
                        } else {
                            isLarge = false;
                            seen = iteratee ? [] : result;
                        }
                        outer:
                            while (++index < length) {
                                var value = array[index],
                                    computed = iteratee ? iteratee(value, index, array) : value;

                                if (isCommon && value === value) {
                                    var seenIndex = seen.length;
                                    while (seenIndex--) {
                                        if (seen[seenIndex] === computed) {
                                            continue outer;
                                        }
                                    }
                                    if (iteratee) {
                                        seen.push(computed);
                                    }
                                    result.push(value);
                                }
                                else if (indexOf(seen, computed, 0) < 0) {
                                    if (iteratee || isLarge) {
                                        seen.push(computed);
                                    }
                                    result.push(value);
                                }
                            }
                        return result;
                    }

                    /**
                     * The base implementation of `_.values` and `_.valuesIn` which creates an
                     * array of `object` property values corresponding to the property names
                     * of `props`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} props The property names to get values for.
                     * @returns {Object} Returns the array of property values.
                     */
                    function baseValues(object, props) {
                        var index = -1,
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
                     * and `_.takeWhile` without support for callback shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to query.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function baseWhile(array, predicate, isDrop, fromRight) {
                        var length = array.length,
                            index = fromRight ? length : -1;

                        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                        }
                        return isDrop
                            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
                            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
                    }

                    /**
                     * The base implementation of `wrapperValue` which returns the result of
                     * performing a sequence of actions on the unwrapped `value`, where each
                     * successive action is supplied the return value of the previous.
                     *
                     * @private
                     * @param {*} value The unwrapped value.
                     * @param {Array} actions Actions to peform to resolve the unwrapped value.
                     * @returns {*} Returns the resolved value.
                     */
                    function baseWrapperValue(value, actions) {
                        var result = value;
                        if (result instanceof LazyWrapper) {
                            result = result.value();
                        }
                        var index = -1,
                            length = actions.length;

                        while (++index < length) {
                            var action = actions[index];
                            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
                        }
                        return result;
                    }

                    /**
                     * Performs a binary search of `array` to determine the index at which `value`
                     * should be inserted into `array` in order to maintain its sort order.
                     *
                     * @private
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     */
                    function binaryIndex(array, value, retHighest) {
                        var low = 0,
                            high = array ? array.length : low;

                        if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                            while (low < high) {
                                var mid = (low + high) >>> 1,
                                    computed = array[mid];

                                if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                                    low = mid + 1;
                                } else {
                                    high = mid;
                                }
                            }
                            return high;
                        }
                        return binaryIndexBy(array, value, identity, retHighest);
                    }

                    /**
                     * This function is like `binaryIndex` except that it invokes `iteratee` for
                     * `value` and each element of `array` to compute their sort ranking. The
                     * iteratee is invoked with one argument; (value).
                     *
                     * @private
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     */
                    function binaryIndexBy(array, value, iteratee, retHighest) {
                        value = iteratee(value);

                        var low = 0,
                            high = array ? array.length : 0,
                            valIsNaN = value !== value,
                            valIsNull = value === null,
                            valIsUndef = value === undefined;

                        while (low < high) {
                            var mid = nativeFloor((low + high) / 2),
                                computed = iteratee(array[mid]),
                                isDef = computed !== undefined,
                                isReflexive = computed === computed;

                            if (valIsNaN) {
                                var setLow = isReflexive || retHighest;
                            } else if (valIsNull) {
                                setLow = isReflexive && isDef && (retHighest || computed != null);
                            } else if (valIsUndef) {
                                setLow = isReflexive && (retHighest || isDef);
                            } else if (computed == null) {
                                setLow = false;
                            } else {
                                setLow = retHighest ? (computed <= value) : (computed < value);
                            }
                            if (setLow) {
                                low = mid + 1;
                            } else {
                                high = mid;
                            }
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX);
                    }

                    /**
                     * A specialized version of `baseCallback` which only supports `this` binding
                     * and specifying the number of arguments to provide to `func`.
                     *
                     * @private
                     * @param {Function} func The function to bind.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {number} [argCount] The number of arguments to provide to `func`.
                     * @returns {Function} Returns the callback.
                     */
                    function bindCallback(func, thisArg, argCount) {
                        if (typeof func != 'function') {
                            return identity;
                        }
                        if (thisArg === undefined) {
                            return func;
                        }
                        switch (argCount) {
                            case 1:
                                return function (value) {
                                    return func.call(thisArg, value);
                                };
                            case 3:
                                return function (value, index, collection) {
                                    return func.call(thisArg, value, index, collection);
                                };
                            case 4:
                                return function (accumulator, value, index, collection) {
                                    return func.call(thisArg, accumulator, value, index, collection);
                                };
                            case 5:
                                return function (value, other, key, object, source) {
                                    return func.call(thisArg, value, other, key, object, source);
                                };
                        }
                        return function () {
                            return func.apply(thisArg, arguments);
                        };
                    }

                    /**
                     * Creates a clone of the given array buffer.
                     *
                     * @private
                     * @param {ArrayBuffer} buffer The array buffer to clone.
                     * @returns {ArrayBuffer} Returns the cloned array buffer.
                     */
                    function bufferClone(buffer) {
                        var result = new ArrayBuffer(buffer.byteLength),
                            view = new Uint8Array(result);

                        view.set(new Uint8Array(buffer));
                        return result;
                    }

                    /**
                     * Creates an array that is the composition of partially applied arguments,
                     * placeholders, and provided arguments into a single array of arguments.
                     *
                     * @private
                     * @param {Array|Object} args The provided arguments.
                     * @param {Array} partials The arguments to prepend to those provided.
                     * @param {Array} holders The `partials` placeholder indexes.
                     * @returns {Array} Returns the new array of composed arguments.
                     */
                    function composeArgs(args, partials, holders) {
                        var holdersLength = holders.length,
                            argsIndex = -1,
                            argsLength = nativeMax(args.length - holdersLength, 0),
                            leftIndex = -1,
                            leftLength = partials.length,
                            result = Array(leftLength + argsLength);

                        while (++leftIndex < leftLength) {
                            result[leftIndex] = partials[leftIndex];
                        }
                        while (++argsIndex < holdersLength) {
                            result[holders[argsIndex]] = args[argsIndex];
                        }
                        while (argsLength--) {
                            result[leftIndex++] = args[argsIndex++];
                        }
                        return result;
                    }

                    /**
                     * This function is like `composeArgs` except that the arguments composition
                     * is tailored for `_.partialRight`.
                     *
                     * @private
                     * @param {Array|Object} args The provided arguments.
                     * @param {Array} partials The arguments to append to those provided.
                     * @param {Array} holders The `partials` placeholder indexes.
                     * @returns {Array} Returns the new array of composed arguments.
                     */
                    function composeArgsRight(args, partials, holders) {
                        var holdersIndex = -1,
                            holdersLength = holders.length,
                            argsIndex = -1,
                            argsLength = nativeMax(args.length - holdersLength, 0),
                            rightIndex = -1,
                            rightLength = partials.length,
                            result = Array(argsLength + rightLength);

                        while (++argsIndex < argsLength) {
                            result[argsIndex] = args[argsIndex];
                        }
                        var offset = argsIndex;
                        while (++rightIndex < rightLength) {
                            result[offset + rightIndex] = partials[rightIndex];
                        }
                        while (++holdersIndex < holdersLength) {
                            result[offset + holders[holdersIndex]] = args[argsIndex++];
                        }
                        return result;
                    }

                    /**
                     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
                     *
                     * @private
                     * @param {Function} setter The function to set keys and values of the accumulator object.
                     * @param {Function} [initializer] The function to initialize the accumulator object.
                     * @returns {Function} Returns the new aggregator function.
                     */
                    function createAggregator(setter, initializer) {
                        return function (collection, iteratee, thisArg) {
                            var result = initializer ? initializer() : {};
                            iteratee = getCallback(iteratee, thisArg, 3);

                            if (isArray(collection)) {
                                var index = -1,
                                    length = collection.length;

                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, iteratee(value, index, collection), collection);
                                }
                            } else {
                                baseEach(collection, function (value, key, collection) {
                                    setter(result, value, iteratee(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
                     *
                     * @private
                     * @param {Function} assigner The function to assign values.
                     * @returns {Function} Returns the new assigner function.
                     */
                    function createAssigner(assigner) {
                        return restParam(function (object, sources) {
                            var index = -1,
                                length = object == null ? 0 : sources.length,
                                customizer = length > 2 ? sources[length - 2] : undefined,
                                guard = length > 2 ? sources[2] : undefined,
                                thisArg = length > 1 ? sources[length - 1] : undefined;

                            if (typeof customizer == 'function') {
                                customizer = bindCallback(customizer, thisArg, 5);
                                length -= 2;
                            } else {
                                customizer = typeof thisArg == 'function' ? thisArg : undefined;
                                length -= (customizer ? 1 : 0);
                            }
                            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                customizer = length < 3 ? undefined : customizer;
                                length = 1;
                            }
                            while (++index < length) {
                                var source = sources[index];
                                if (source) {
                                    assigner(object, source, customizer);
                                }
                            }
                            return object;
                        });
                    }

                    /**
                     * Creates a `baseEach` or `baseEachRight` function.
                     *
                     * @private
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new base function.
                     */
                    function createBaseEach(eachFunc, fromRight) {
                        return function (collection, iteratee) {
                            var length = collection ? getLength(collection) : 0;
                            if (!isLength(length)) {
                                return eachFunc(collection, iteratee);
                            }
                            var index = fromRight ? length : -1,
                                iterable = toObject(collection);

                            while ((fromRight ? index-- : ++index < length)) {
                                if (iteratee(iterable[index], index, iterable) === false) {
                                    break;
                                }
                            }
                            return collection;
                        };
                    }

                    /**
                     * Creates a base function for `_.forIn` or `_.forInRight`.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new base function.
                     */
                    function createBaseFor(fromRight) {
                        return function (object, iteratee, keysFunc) {
                            var iterable = toObject(object),
                                props = keysFunc(object),
                                length = props.length,
                                index = fromRight ? length : -1;

                            while ((fromRight ? index-- : ++index < length)) {
                                var key = props[index];
                                if (iteratee(iterable[key], key, iterable) === false) {
                                    break;
                                }
                            }
                            return object;
                        };
                    }

                    /**
                     * Creates a function that wraps `func` and invokes it with the `this`
                     * binding of `thisArg`.
                     *
                     * @private
                     * @param {Function} func The function to bind.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @returns {Function} Returns the new bound function.
                     */
                    function createBindWrapper(func, thisArg) {
                        var Ctor = createCtorWrapper(func);

                        function wrapper() {
                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                            return fn.apply(thisArg, arguments);
                        }

                        return wrapper;
                    }

                    /**
                     * Creates a `Set` cache object to optimize linear searches of large arrays.
                     *
                     * @private
                     * @param {Array} [values] The values to cache.
                     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
                     */
                    function createCache(values) {
                        return (nativeCreate && Set) ? new SetCache(values) : null;
                    }

                    /**
                     * Creates a function that produces compound words out of the words in a
                     * given string.
                     *
                     * @private
                     * @param {Function} callback The function to combine each word.
                     * @returns {Function} Returns the new compounder function.
                     */
                    function createCompounder(callback) {
                        return function (string) {
                            var index = -1,
                                array = words(deburr(string)),
                                length = array.length,
                                result = '';

                            while (++index < length) {
                                result = callback(result, array[index], index);
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a function that produces an instance of `Ctor` regardless of
                     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
                     *
                     * @private
                     * @param {Function} Ctor The constructor to wrap.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createCtorWrapper(Ctor) {
                        return function () {
                            // Use a `switch` statement to work with class constructors.
                            // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                            // for more details.
                            var args = arguments;
                            switch (args.length) {
                                case 0:
                                    return new Ctor;
                                case 1:
                                    return new Ctor(args[0]);
                                case 2:
                                    return new Ctor(args[0], args[1]);
                                case 3:
                                    return new Ctor(args[0], args[1], args[2]);
                                case 4:
                                    return new Ctor(args[0], args[1], args[2], args[3]);
                                case 5:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                case 6:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                case 7:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                            }
                            var thisBinding = baseCreate(Ctor.prototype),
                                result = Ctor.apply(thisBinding, args);

                            // Mimic the constructor's `return` behavior.
                            // See https://es5.github.io/#x13.2.2 for more details.
                            return isObject(result) ? result : thisBinding;
                        };
                    }

                    /**
                     * Creates a `_.curry` or `_.curryRight` function.
                     *
                     * @private
                     * @param {boolean} flag The curry bit flag.
                     * @returns {Function} Returns the new curry function.
                     */
                    function createCurry(flag) {
                        function curryFunc(func, arity, guard) {
                            if (guard && isIterateeCall(func, arity, guard)) {
                                arity = undefined;
                            }
                            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curryFunc.placeholder;
                            return result;
                        }

                        return curryFunc;
                    }

                    /**
                     * Creates a `_.defaults` or `_.defaultsDeep` function.
                     *
                     * @private
                     * @param {Function} assigner The function to assign values.
                     * @param {Function} customizer The function to customize assigned values.
                     * @returns {Function} Returns the new defaults function.
                     */
                    function createDefaults(assigner, customizer) {
                        return restParam(function (args) {
                            var object = args[0];
                            if (object == null) {
                                return object;
                            }
                            args.push(customizer);
                            return assigner.apply(undefined, args);
                        });
                    }

                    /**
                     * Creates a `_.max` or `_.min` function.
                     *
                     * @private
                     * @param {Function} comparator The function used to compare values.
                     * @param {*} exValue The initial extremum value.
                     * @returns {Function} Returns the new extremum function.
                     */
                    function createExtremum(comparator, exValue) {
                        return function (collection, iteratee, thisArg) {
                            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                                iteratee = undefined;
                            }
                            iteratee = getCallback(iteratee, thisArg, 3);
                            if (iteratee.length == 1) {
                                collection = isArray(collection) ? collection : toIterable(collection);
                                var result = arrayExtremum(collection, iteratee, comparator, exValue);
                                if (!(collection.length && result === exValue)) {
                                    return result;
                                }
                            }
                            return baseExtremum(collection, iteratee, comparator, exValue);
                        };
                    }

                    /**
                     * Creates a `_.find` or `_.findLast` function.
                     *
                     * @private
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new find function.
                     */
                    function createFind(eachFunc, fromRight) {
                        return function (collection, predicate, thisArg) {
                            predicate = getCallback(predicate, thisArg, 3);
                            if (isArray(collection)) {
                                var index = baseFindIndex(collection, predicate, fromRight);
                                return index > -1 ? collection[index] : undefined;
                            }
                            return baseFind(collection, predicate, eachFunc);
                        };
                    }

                    /**
                     * Creates a `_.findIndex` or `_.findLastIndex` function.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new find function.
                     */
                    function createFindIndex(fromRight) {
                        return function (array, predicate, thisArg) {
                            if (!(array && array.length)) {
                                return -1;
                            }
                            predicate = getCallback(predicate, thisArg, 3);
                            return baseFindIndex(array, predicate, fromRight);
                        };
                    }

                    /**
                     * Creates a `_.findKey` or `_.findLastKey` function.
                     *
                     * @private
                     * @param {Function} objectFunc The function to iterate over an object.
                     * @returns {Function} Returns the new find function.
                     */
                    function createFindKey(objectFunc) {
                        return function (object, predicate, thisArg) {
                            predicate = getCallback(predicate, thisArg, 3);
                            return baseFind(object, predicate, objectFunc, true);
                        };
                    }

                    /**
                     * Creates a `_.flow` or `_.flowRight` function.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new flow function.
                     */
                    function createFlow(fromRight) {
                        return function () {
                            var wrapper,
                                length = arguments.length,
                                index = fromRight ? length : -1,
                                leftIndex = 0,
                                funcs = Array(length);

                            while ((fromRight ? index-- : ++index < length)) {
                                var func = funcs[leftIndex++] = arguments[index];
                                if (typeof func != 'function') {
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                }
                                if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                                    wrapper = new LodashWrapper([], true);
                                }
                            }
                            index = wrapper ? -1 : length;
                            while (++index < length) {
                                func = funcs[index];

                                var funcName = getFuncName(func),
                                    data = funcName == 'wrapper' ? getData(func) : undefined;

                                if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                                    wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                } else {
                                    wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
                                }
                            }
                            return function () {
                                var args = arguments,
                                    value = args[0];

                                if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                                    return wrapper.plant(value).value();
                                }
                                var index = 0,
                                    result = length ? funcs[index].apply(this, args) : value;

                                while (++index < length) {
                                    result = funcs[index].call(this, result);
                                }
                                return result;
                            };
                        };
                    }

                    /**
                     * Creates a function for `_.forEach` or `_.forEachRight`.
                     *
                     * @private
                     * @param {Function} arrayFunc The function to iterate over an array.
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @returns {Function} Returns the new each function.
                     */
                    function createForEach(arrayFunc, eachFunc) {
                        return function (collection, iteratee, thisArg) {
                            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                                ? arrayFunc(collection, iteratee)
                                : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
                        };
                    }

                    /**
                     * Creates a function for `_.forIn` or `_.forInRight`.
                     *
                     * @private
                     * @param {Function} objectFunc The function to iterate over an object.
                     * @returns {Function} Returns the new each function.
                     */
                    function createForIn(objectFunc) {
                        return function (object, iteratee, thisArg) {
                            if (typeof iteratee != 'function' || thisArg !== undefined) {
                                iteratee = bindCallback(iteratee, thisArg, 3);
                            }
                            return objectFunc(object, iteratee, keysIn);
                        };
                    }

                    /**
                     * Creates a function for `_.forOwn` or `_.forOwnRight`.
                     *
                     * @private
                     * @param {Function} objectFunc The function to iterate over an object.
                     * @returns {Function} Returns the new each function.
                     */
                    function createForOwn(objectFunc) {
                        return function (object, iteratee, thisArg) {
                            if (typeof iteratee != 'function' || thisArg !== undefined) {
                                iteratee = bindCallback(iteratee, thisArg, 3);
                            }
                            return objectFunc(object, iteratee);
                        };
                    }

                    /**
                     * Creates a function for `_.mapKeys` or `_.mapValues`.
                     *
                     * @private
                     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
                     * @returns {Function} Returns the new map function.
                     */
                    function createObjectMapper(isMapKeys) {
                        return function (object, iteratee, thisArg) {
                            var result = {};
                            iteratee = getCallback(iteratee, thisArg, 3);

                            baseForOwn(object, function (value, key, object) {
                                var mapped = iteratee(value, key, object);
                                key = isMapKeys ? mapped : key;
                                value = isMapKeys ? value : mapped;
                                result[key] = value;
                            });
                            return result;
                        };
                    }

                    /**
                     * Creates a function for `_.padLeft` or `_.padRight`.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify padding from the right.
                     * @returns {Function} Returns the new pad function.
                     */
                    function createPadDir(fromRight) {
                        return function (string, length, chars) {
                            string = baseToString(string);
                            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
                        };
                    }

                    /**
                     * Creates a `_.partial` or `_.partialRight` function.
                     *
                     * @private
                     * @param {boolean} flag The partial bit flag.
                     * @returns {Function} Returns the new partial function.
                     */
                    function createPartial(flag) {
                        var partialFunc = restParam(function (func, partials) {
                            var holders = replaceHolders(partials, partialFunc.placeholder);
                            return createWrapper(func, flag, undefined, partials, holders);
                        });
                        return partialFunc;
                    }

                    /**
                     * Creates a function for `_.reduce` or `_.reduceRight`.
                     *
                     * @private
                     * @param {Function} arrayFunc The function to iterate over an array.
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @returns {Function} Returns the new each function.
                     */
                    function createReduce(arrayFunc, eachFunc) {
                        return function (collection, iteratee, accumulator, thisArg) {
                            var initFromArray = arguments.length < 3;
                            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                                ? arrayFunc(collection, iteratee, accumulator, initFromArray)
                                : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
                        };
                    }

                    /**
                     * Creates a function that wraps `func` and invokes it with optional `this`
                     * binding of, partial application, and currying.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
                     * @param {Array} [holders] The `partials` placeholder indexes.
                     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
                     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
                     * @param {Array} [argPos] The argument positions of the new function.
                     * @param {number} [ary] The arity cap of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        var isAry = bitmask & ARY_FLAG,
                            isBind = bitmask & BIND_FLAG,
                            isBindKey = bitmask & BIND_KEY_FLAG,
                            isCurry = bitmask & CURRY_FLAG,
                            isCurryBound = bitmask & CURRY_BOUND_FLAG,
                            isCurryRight = bitmask & CURRY_RIGHT_FLAG,
                            Ctor = isBindKey ? undefined : createCtorWrapper(func);

                        function wrapper() {
                            // Avoid `arguments` object use disqualifying optimizations by
                            // converting it to an array before providing it to other functions.
                            var length = arguments.length,
                                index = length,
                                args = Array(length);

                            while (index--) {
                                args[index] = arguments[index];
                            }
                            if (partials) {
                                args = composeArgs(args, partials, holders);
                            }
                            if (partialsRight) {
                                args = composeArgsRight(args, partialsRight, holdersRight);
                            }
                            if (isCurry || isCurryRight) {
                                var placeholder = wrapper.placeholder,
                                    argsHolders = replaceHolders(args, placeholder);

                                length -= argsHolders.length;
                                if (length < arity) {
                                    var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                                        newArity = nativeMax(arity - length, 0),
                                        newsHolders = isCurry ? argsHolders : undefined,
                                        newHoldersRight = isCurry ? undefined : argsHolders,
                                        newPartials = isCurry ? args : undefined,
                                        newPartialsRight = isCurry ? undefined : args;

                                    bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                                    bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                                    if (!isCurryBound) {
                                        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                                    }
                                    var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                                        result = createHybridWrapper.apply(undefined, newData);

                                    if (isLaziable(func)) {
                                        setData(result, newData);
                                    }
                                    result.placeholder = placeholder;
                                    return result;
                                }
                            }
                            var thisBinding = isBind ? thisArg : this,
                                fn = isBindKey ? thisBinding[func] : func;

                            if (argPos) {
                                args = reorder(args, argPos);
                            }
                            if (isAry && ary < args.length) {
                                args.length = ary;
                            }
                            if (this && this !== root && this instanceof wrapper) {
                                fn = Ctor || createCtorWrapper(func);
                            }
                            return fn.apply(thisBinding, args);
                        }

                        return wrapper;
                    }

                    /**
                     * Creates the padding required for `string` based on the given `length`.
                     * The `chars` string is truncated if the number of characters exceeds `length`.
                     *
                     * @private
                     * @param {string} string The string to create padding for.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the pad for `string`.
                     */
                    function createPadding(string, length, chars) {
                        var strLength = string.length;
                        length = +length;

                        if (strLength >= length || !nativeIsFinite(length)) {
                            return '';
                        }
                        var padLength = length - strLength;
                        chars = chars == null ? ' ' : (chars + '');
                        return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
                    }

                    /**
                     * Creates a function that wraps `func` and invokes it with the optional `this`
                     * binding of `thisArg` and the `partials` prepended to those provided to
                     * the wrapper.
                     *
                     * @private
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {Array} partials The arguments to prepend to those provided to the new function.
                     * @returns {Function} Returns the new bound function.
                     */
                    function createPartialWrapper(func, bitmask, thisArg, partials) {
                        var isBind = bitmask & BIND_FLAG,
                            Ctor = createCtorWrapper(func);

                        function wrapper() {
                            // Avoid `arguments` object use disqualifying optimizations by
                            // converting it to an array before providing it `func`.
                            var argsIndex = -1,
                                argsLength = arguments.length,
                                leftIndex = -1,
                                leftLength = partials.length,
                                args = Array(leftLength + argsLength);

                            while (++leftIndex < leftLength) {
                                args[leftIndex] = partials[leftIndex];
                            }
                            while (argsLength--) {
                                args[leftIndex++] = arguments[++argsIndex];
                            }
                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                            return fn.apply(isBind ? thisArg : this, args);
                        }

                        return wrapper;
                    }

                    /**
                     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
                     *
                     * @private
                     * @param {string} methodName The name of the `Math` method to use when rounding.
                     * @returns {Function} Returns the new round function.
                     */
                    function createRound(methodName) {
                        var func = Math[methodName];
                        return function (number, precision) {
                            precision = precision === undefined ? 0 : (+precision || 0);
                            if (precision) {
                                precision = pow(10, precision);
                                return func(number * precision) / precision;
                            }
                            return func(number);
                        };
                    }

                    /**
                     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
                     *
                     * @private
                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                     * @returns {Function} Returns the new index function.
                     */
                    function createSortedIndex(retHighest) {
                        return function (array, value, iteratee, thisArg) {
                            var callback = getCallback(iteratee);
                            return (iteratee == null && callback === baseCallback)
                                ? binaryIndex(array, value, retHighest)
                                : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
                        };
                    }

                    /**
                     * Creates a function that either curries or invokes `func` with optional
                     * `this` binding and partially applied arguments.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of flags.
                     *  The bitmask may be composed of the following flags:
                     *     1 - `_.bind`
                     *     2 - `_.bindKey`
                     *     4 - `_.curry` or `_.curryRight` of a bound function
                     *     8 - `_.curry`
                     *    16 - `_.curryRight`
                     *    32 - `_.partial`
                     *    64 - `_.partialRight`
                     *   128 - `_.rearg`
                     *   256 - `_.ary`
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {Array} [partials] The arguments to be partially applied.
                     * @param {Array} [holders] The `partials` placeholder indexes.
                     * @param {Array} [argPos] The argument positions of the new function.
                     * @param {number} [ary] The arity cap of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                        var isBindKey = bitmask & BIND_KEY_FLAG;
                        if (!isBindKey && typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var length = partials ? partials.length : 0;
                        if (!length) {
                            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                            partials = holders = undefined;
                        }
                        length -= (holders ? holders.length : 0);
                        if (bitmask & PARTIAL_RIGHT_FLAG) {
                            var partialsRight = partials,
                                holdersRight = holders;

                            partials = holders = undefined;
                        }
                        var data = isBindKey ? undefined : getData(func),
                            newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

                        if (data) {
                            mergeData(newData, data);
                            bitmask = newData[1];
                            arity = newData[9];
                        }
                        newData[9] = arity == null
                            ? (isBindKey ? 0 : func.length)
                            : (nativeMax(arity - length, 0) || 0);

                        if (bitmask == BIND_FLAG) {
                            var result = createBindWrapper(newData[0], newData[2]);
                        } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                            result = createPartialWrapper.apply(undefined, newData);
                        } else {
                            result = createHybridWrapper.apply(undefined, newData);
                        }
                        var setter = data ? baseSetData : setData;
                        return setter(result, newData);
                    }

                    /**
                     * A specialized version of `baseIsEqualDeep` for arrays with support for
                     * partial deep comparisons.
                     *
                     * @private
                     * @param {Array} array The array to compare.
                     * @param {Array} other The other array to compare.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Function} [customizer] The function to customize comparing arrays.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA] Tracks traversed `value` objects.
                     * @param {Array} [stackB] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                     */
                    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var index = -1,
                            arrLength = array.length,
                            othLength = other.length;

                        if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                            return false;
                        }
                        // Ignore non-index properties.
                        while (++index < arrLength) {
                            var arrValue = array[index],
                                othValue = other[index],
                                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

                            if (result !== undefined) {
                                if (result) {
                                    continue;
                                }
                                return false;
                            }
                            // Recursively compare arrays (susceptible to call stack limits).
                            if (isLoose) {
                                if (!arraySome(other, function (othValue) {
                                        return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                                    })) {
                                    return false;
                                }
                            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * A specialized version of `baseIsEqualDeep` for comparing objects of
                     * the same `toStringTag`.
                     *
                     * **Note:** This function only supports comparing values with tags of
                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {string} tag The `toStringTag` of the objects to compare.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function equalByTag(object, other, tag) {
                        switch (tag) {
                            case boolTag:
                            case dateTag:
                                // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                                return +object == +other;

                            case errorTag:
                                return object.name == other.name && object.message == other.message;

                            case numberTag:
                                // Treat `NaN` vs. `NaN` as equal.
                                return (object != +object)
                                    ? other != +other
                                    : object == +other;

                            case regexpTag:
                            case stringTag:
                                // Coerce regexes to strings and treat strings primitives and string
                                // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                                return object == (other + '');
                        }
                        return false;
                    }

                    /**
                     * A specialized version of `baseIsEqualDeep` for objects with support for
                     * partial deep comparisons.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Function} [customizer] The function to customize comparing values.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA] Tracks traversed `value` objects.
                     * @param {Array} [stackB] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objProps = keys(object),
                            objLength = objProps.length,
                            othProps = keys(other),
                            othLength = othProps.length;

                        if (objLength != othLength && !isLoose) {
                            return false;
                        }
                        var index = objLength;
                        while (index--) {
                            var key = objProps[index];
                            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                                return false;
                            }
                        }
                        var skipCtor = isLoose;
                        while (++index < objLength) {
                            key = objProps[index];
                            var objValue = object[key],
                                othValue = other[key],
                                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;

                            // Recursively compare objects (susceptible to call stack limits).
                            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                                return false;
                            }
                            skipCtor || (skipCtor = key == 'constructor');
                        }
                        if (!skipCtor) {
                            var objCtor = object.constructor,
                                othCtor = other.constructor;

                            // Non `Object` object instances with different constructors are not equal.
                            if (objCtor != othCtor &&
                                ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                                typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * Gets the appropriate "callback" function. If the `_.callback` method is
                     * customized this function returns the custom method, otherwise it returns
                     * the `baseCallback` function. If arguments are provided the chosen function
                     * is invoked with them and its result is returned.
                     *
                     * @private
                     * @returns {Function} Returns the chosen function or its result.
                     */
                    function getCallback(func, thisArg, argCount) {
                        var result = lodash.callback || callback;
                        result = result === callback ? baseCallback : result;
                        return argCount ? result(func, thisArg, argCount) : result;
                    }

                    /**
                     * Gets metadata for `func`.
                     *
                     * @private
                     * @param {Function} func The function to query.
                     * @returns {*} Returns the metadata for `func`.
                     */
                    var getData = !metaMap ? noop : function (func) {
                        return metaMap.get(func);
                    };

                    /**
                     * Gets the name of `func`.
                     *
                     * @private
                     * @param {Function} func The function to query.
                     * @returns {string} Returns the function name.
                     */
                    function getFuncName(func) {
                        var result = func.name,
                            array = realNames[result],
                            length = array ? array.length : 0;

                        while (length--) {
                            var data = array[length],
                                otherFunc = data.func;
                            if (otherFunc == null || otherFunc == func) {
                                return data.name;
                            }
                        }
                        return result;
                    }

                    /**
                     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
                     * customized this function returns the custom method, otherwise it returns
                     * the `baseIndexOf` function. If arguments are provided the chosen function
                     * is invoked with them and its result is returned.
                     *
                     * @private
                     * @returns {Function|number} Returns the chosen function or its result.
                     */
                    function getIndexOf(collection, target, fromIndex) {
                        var result = lodash.indexOf || indexOf;
                        result = result === indexOf ? baseIndexOf : result;
                        return collection ? result(collection, target, fromIndex) : result;
                    }

                    /**
                     * Gets the "length" property value of `object`.
                     *
                     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
                     * that affects Safari on at least iOS 8.1-8.3 ARM64.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {*} Returns the "length" value.
                     */
                    var getLength = baseProperty('length');

                    /**
                     * Gets the propery names, values, and compare flags of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the match data of `object`.
                     */
                    function getMatchData(object) {
                        var result = pairs(object),
                            length = result.length;

                        while (length--) {
                            result[length][2] = isStrictComparable(result[length][1]);
                        }
                        return result;
                    }

                    /**
                     * Gets the native function at `key` of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {string} key The key of the method to get.
                     * @returns {*} Returns the function if it's native, else `undefined`.
                     */
                    function getNative(object, key) {
                        var value = object == null ? undefined : object[key];
                        return isNative(value) ? value : undefined;
                    }

                    /**
                     * Gets the view, applying any `transforms` to the `start` and `end` positions.
                     *
                     * @private
                     * @param {number} start The start of the view.
                     * @param {number} end The end of the view.
                     * @param {Array} transforms The transformations to apply to the view.
                     * @returns {Object} Returns an object containing the `start` and `end`
                     *  positions of the view.
                     */
                    function getView(start, end, transforms) {
                        var index = -1,
                            length = transforms.length;

                        while (++index < length) {
                            var data = transforms[index],
                                size = data.size;

                            switch (data.type) {
                                case 'drop':
                                    start += size;
                                    break;
                                case 'dropRight':
                                    end -= size;
                                    break;
                                case 'take':
                                    end = nativeMin(end, start + size);
                                    break;
                                case 'takeRight':
                                    start = nativeMax(start, end - size);
                                    break;
                            }
                        }
                        return {'start': start, 'end': end};
                    }

                    /**
                     * Initializes an array clone.
                     *
                     * @private
                     * @param {Array} array The array to clone.
                     * @returns {Array} Returns the initialized clone.
                     */
                    function initCloneArray(array) {
                        var length = array.length,
                            result = new array.constructor(length);

                        // Add array properties assigned by `RegExp#exec`.
                        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                            result.index = array.index;
                            result.input = array.input;
                        }
                        return result;
                    }

                    /**
                     * Initializes an object clone.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @returns {Object} Returns the initialized clone.
                     */
                    function initCloneObject(object) {
                        var Ctor = object.constructor;
                        if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
                            Ctor = Object;
                        }
                        return new Ctor;
                    }

                    /**
                     * Initializes an object clone based on its `toStringTag`.
                     *
                     * **Note:** This function only supports cloning values with tags of
                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @param {string} tag The `toStringTag` of the object to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the initialized clone.
                     */
                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;
                        switch (tag) {
                            case arrayBufferTag:
                                return bufferClone(object);

                            case boolTag:
                            case dateTag:
                                return new Ctor(+object);

                            case float32Tag:
                            case float64Tag:
                            case int8Tag:
                            case int16Tag:
                            case int32Tag:
                            case uint8Tag:
                            case uint8ClampedTag:
                            case uint16Tag:
                            case uint32Tag:
                                var buffer = object.buffer;
                                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

                            case numberTag:
                            case stringTag:
                                return new Ctor(object);

                            case regexpTag:
                                var result = new Ctor(object.source, reFlags.exec(object));
                                result.lastIndex = object.lastIndex;
                        }
                        return result;
                    }

                    /**
                     * Invokes the method at `path` on `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the method to invoke.
                     * @param {Array} args The arguments to invoke the method with.
                     * @returns {*} Returns the result of the invoked method.
                     */
                    function invokePath(object, path, args) {
                        if (object != null && !isKey(path, object)) {
                            path = toPath(path);
                            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                            path = last(path);
                        }
                        var func = object == null ? object : object[path];
                        return func == null ? undefined : func.apply(object, args);
                    }

                    /**
                     * Checks if `value` is array-like.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                     */
                    function isArrayLike(value) {
                        return value != null && isLength(getLength(value));
                    }

                    /**
                     * Checks if `value` is a valid array-like index.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                     */
                    function isIndex(value, length) {
                        value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
                        length = length == null ? MAX_SAFE_INTEGER : length;
                        return value > -1 && value % 1 == 0 && value < length;
                    }

                    /**
                     * Checks if the provided arguments are from an iteratee call.
                     *
                     * @private
                     * @param {*} value The potential iteratee value argument.
                     * @param {*} index The potential iteratee index or key argument.
                     * @param {*} object The potential iteratee object argument.
                     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
                     */
                    function isIterateeCall(value, index, object) {
                        if (!isObject(object)) {
                            return false;
                        }
                        var type = typeof index;
                        if (type == 'number'
                                ? (isArrayLike(object) && isIndex(index, object.length))
                                : (type == 'string' && index in object)) {
                            var other = object[index];
                            return value === value ? (value === other) : (other !== other);
                        }
                        return false;
                    }

                    /**
                     * Checks if `value` is a property name and not a property path.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {Object} [object] The object to query keys on.
                     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                     */
                    function isKey(value, object) {
                        var type = typeof value;
                        if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
                            return true;
                        }
                        if (isArray(value)) {
                            return false;
                        }
                        var result = !reIsDeepProp.test(value);
                        return result || (object != null && value in toObject(object));
                    }

                    /**
                     * Checks if `func` has a lazy counterpart.
                     *
                     * @private
                     * @param {Function} func The function to check.
                     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
                     */
                    function isLaziable(func) {
                        var funcName = getFuncName(func);
                        if (!(funcName in LazyWrapper.prototype)) {
                            return false;
                        }
                        var other = lodash[funcName];
                        if (func === other) {
                            return true;
                        }
                        var data = getData(other);
                        return !!data && func === data[0];
                    }

                    /**
                     * Checks if `value` is a valid array-like length.
                     *
                     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                     */
                    function isLength(value) {
                        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                    }

                    /**
                     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` if suitable for strict
                     *  equality comparisons, else `false`.
                     */
                    function isStrictComparable(value) {
                        return value === value && !isObject(value);
                    }

                    /**
                     * Merges the function metadata of `source` into `data`.
                     *
                     * Merging metadata reduces the number of wrappers required to invoke a function.
                     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
                     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
                     * augment function arguments, making the order in which they are executed important,
                     * preventing the merging of metadata. However, we make an exception for a safe
                     * common case where curried functions have `_.ary` and or `_.rearg` applied.
                     *
                     * @private
                     * @param {Array} data The destination metadata.
                     * @param {Array} source The source metadata.
                     * @returns {Array} Returns `data`.
                     */
                    function mergeData(data, source) {
                        var bitmask = data[1],
                            srcBitmask = source[1],
                            newBitmask = bitmask | srcBitmask,
                            isCommon = newBitmask < ARY_FLAG;

                        var isCombo =
                            (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
                            (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
                            (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

                        // Exit early if metadata can't be merged.
                        if (!(isCommon || isCombo)) {
                            return data;
                        }
                        // Use source `thisArg` if available.
                        if (srcBitmask & BIND_FLAG) {
                            data[2] = source[2];
                            // Set when currying a bound function.
                            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
                        }
                        // Compose partial arguments.
                        var value = source[3];
                        if (value) {
                            var partials = data[3];
                            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
                        }
                        // Compose partial right arguments.
                        value = source[5];
                        if (value) {
                            partials = data[5];
                            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
                        }
                        // Use source `argPos` if available.
                        value = source[7];
                        if (value) {
                            data[7] = arrayCopy(value);
                        }
                        // Use source `ary` if it's smaller.
                        if (srcBitmask & ARY_FLAG) {
                            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                        }
                        // Use source `arity` if one is not provided.
                        if (data[9] == null) {
                            data[9] = source[9];
                        }
                        // Use source `func` and merge bitmasks.
                        data[0] = source[0];
                        data[1] = newBitmask;

                        return data;
                    }

                    /**
                     * Used by `_.defaultsDeep` to customize its `_.merge` use.
                     *
                     * @private
                     * @param {*} objectValue The destination object property value.
                     * @param {*} sourceValue The source object property value.
                     * @returns {*} Returns the value to assign to the destination object.
                     */
                    function mergeDefaults(objectValue, sourceValue) {
                        return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
                    }

                    /**
                     * A specialized version of `_.pick` which picks `object` properties specified
                     * by `props`.
                     *
                     * @private
                     * @param {Object} object The source object.
                     * @param {string[]} props The property names to pick.
                     * @returns {Object} Returns the new object.
                     */
                    function pickByArray(object, props) {
                        object = toObject(object);

                        var index = -1,
                            length = props.length,
                            result = {};

                        while (++index < length) {
                            var key = props[index];
                            if (key in object) {
                                result[key] = object[key];
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.pick` which picks `object` properties `predicate`
                     * returns truthy for.
                     *
                     * @private
                     * @param {Object} object The source object.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Object} Returns the new object.
                     */
                    function pickByCallback(object, predicate) {
                        var result = {};
                        baseForIn(object, function (value, key, object) {
                            if (predicate(value, key, object)) {
                                result[key] = value;
                            }
                        });
                        return result;
                    }

                    /**
                     * Reorder `array` according to the specified indexes where the element at
                     * the first index is assigned as the first element, the element at
                     * the second index is assigned as the second element, and so on.
                     *
                     * @private
                     * @param {Array} array The array to reorder.
                     * @param {Array} indexes The arranged array indexes.
                     * @returns {Array} Returns `array`.
                     */
                    function reorder(array, indexes) {
                        var arrLength = array.length,
                            length = nativeMin(indexes.length, arrLength),
                            oldArray = arrayCopy(array);

                        while (length--) {
                            var index = indexes[length];
                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                        }
                        return array;
                    }

                    /**
                     * Sets metadata for `func`.
                     *
                     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
                     * period of time, it will trip its breaker and transition to an identity function
                     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
                     * for more details.
                     *
                     * @private
                     * @param {Function} func The function to associate metadata with.
                     * @param {*} data The metadata.
                     * @returns {Function} Returns `func`.
                     */
                    var setData = (function () {
                        var count = 0,
                            lastCalled = 0;

                        return function (key, value) {
                            var stamp = now(),
                                remaining = HOT_SPAN - (stamp - lastCalled);

                            lastCalled = stamp;
                            if (remaining > 0) {
                                if (++count >= HOT_COUNT) {
                                    return key;
                                }
                            } else {
                                count = 0;
                            }
                            return baseSetData(key, value);
                        };
                    }());

                    /**
                     * A fallback implementation of `Object.keys` which creates an array of the
                     * own enumerable property names of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     */
                    function shimKeys(object) {
                        var props = keysIn(object),
                            propsLength = props.length,
                            length = propsLength && object.length;

                        var allowIndexes = !!length && isLength(length) &&
                            (isArray(object) || isArguments(object));

                        var index = -1,
                            result = [];

                        while (++index < propsLength) {
                            var key = props[index];
                            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                                result.push(key);
                            }
                        }
                        return result;
                    }

                    /**
                     * Converts `value` to an array-like object if it's not one.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {Array|Object} Returns the array-like object.
                     */
                    function toIterable(value) {
                        if (value == null) {
                            return [];
                        }
                        if (!isArrayLike(value)) {
                            return values(value);
                        }
                        return isObject(value) ? value : Object(value);
                    }

                    /**
                     * Converts `value` to an object if it's not one.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {Object} Returns the object.
                     */
                    function toObject(value) {
                        return isObject(value) ? value : Object(value);
                    }

                    /**
                     * Converts `value` to property path array if it's not one.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {Array} Returns the property path array.
                     */
                    function toPath(value) {
                        if (isArray(value)) {
                            return value;
                        }
                        var result = [];
                        baseToString(value).replace(rePropName, function (match, number, quote, string) {
                            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
                        });
                        return result;
                    }

                    /**
                     * Creates a clone of `wrapper`.
                     *
                     * @private
                     * @param {Object} wrapper The wrapper to clone.
                     * @returns {Object} Returns the cloned wrapper.
                     */
                    function wrapperClone(wrapper) {
                        return wrapper instanceof LazyWrapper
                            ? wrapper.clone()
                            : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates an array of elements split into groups the length of `size`.
                     * If `collection` can't be split evenly, the final chunk will be the remaining
                     * elements.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to process.
                     * @param {number} [size=1] The length of each chunk.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the new array containing chunks.
                     * @example
                     *
                     * _.chunk(['a', 'b', 'c', 'd'], 2);
                     * // => [['a', 'b'], ['c', 'd']]
                     *
                     * _.chunk(['a', 'b', 'c', 'd'], 3);
                     * // => [['a', 'b', 'c'], ['d']]
                     */
                    function chunk(array, size, guard) {
                        if (guard ? isIterateeCall(array, size, guard) : size == null) {
                            size = 1;
                        } else {
                            size = nativeMax(nativeFloor(size) || 1, 1);
                        }
                        var index = 0,
                            length = array ? array.length : 0,
                            resIndex = -1,
                            result = Array(nativeCeil(length / size));

                        while (index < length) {
                            result[++resIndex] = baseSlice(array, index, (index += size));
                        }
                        return result;
                    }

                    /**
                     * Creates an array with all falsey values removed. The values `false`, `null`,
                     * `0`, `""`, `undefined`, and `NaN` are falsey.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to compact.
                     * @returns {Array} Returns the new array of filtered values.
                     * @example
                     *
                     * _.compact([0, 1, false, 2, '', 3]);
                     * // => [1, 2, 3]
                     */
                    function compact(array) {
                        var index = -1,
                            length = array ? array.length : 0,
                            resIndex = -1,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result[++resIndex] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * Creates an array of unique `array` values not included in the other
                     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to inspect.
                     * @param {...Array} [values] The arrays of values to exclude.
                     * @returns {Array} Returns the new array of filtered values.
                     * @example
                     *
                     * _.difference([1, 2, 3], [4, 2]);
                     * // => [1, 3]
                     */
                    var difference = restParam(function (array, values) {
                        return (isObjectLike(array) && isArrayLike(array))
                            ? baseDifference(array, baseFlatten(values, false, true))
                            : [];
                    });

                    /**
                     * Creates a slice of `array` with `n` elements dropped from the beginning.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to drop.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.drop([1, 2, 3]);
                     * // => [2, 3]
                     *
                     * _.drop([1, 2, 3], 2);
                     * // => [3]
                     *
                     * _.drop([1, 2, 3], 5);
                     * // => []
                     *
                     * _.drop([1, 2, 3], 0);
                     * // => [1, 2, 3]
                     */
                    function drop(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        return baseSlice(array, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` with `n` elements dropped from the end.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to drop.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.dropRight([1, 2, 3]);
                     * // => [1, 2]
                     *
                     * _.dropRight([1, 2, 3], 2);
                     * // => [1]
                     *
                     * _.dropRight([1, 2, 3], 5);
                     * // => []
                     *
                     * _.dropRight([1, 2, 3], 0);
                     * // => [1, 2, 3]
                     */
                    function dropRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        n = length - (+n || 0);
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` excluding elements dropped from the end.
                     * Elements are dropped until `predicate` returns falsey. The predicate is
                     * bound to `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that match the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
                     * // => [1]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': true },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
                     * // => ['barney', 'fred']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
                     * // => ['barney', 'fred', 'pebbles']
                     */
                    function dropRightWhile(array, predicate, thisArg) {
                        return (array && array.length)
                            ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
                            : [];
                    }

                    /**
                     * Creates a slice of `array` excluding elements dropped from the beginning.
                     * Elements are dropped until `predicate` returns falsey. The predicate is
                     * bound to `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
                     * // => [3]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
                     * // => ['fred', 'pebbles']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.dropWhile(users, 'active', false), 'user');
                     * // => ['pebbles']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.dropWhile(users, 'active'), 'user');
                     * // => ['barney', 'fred', 'pebbles']
                     */
                    function dropWhile(array, predicate, thisArg) {
                        return (array && array.length)
                            ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
                            : [];
                    }

                    /**
                     * Fills elements of `array` with `value` from `start` up to, but not
                     * including, `end`.
                     *
                     * **Note:** This method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to fill.
                     * @param {*} value The value to fill `array` with.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns `array`.
                     * @example
                     *
                     * var array = [1, 2, 3];
                     *
                     * _.fill(array, 'a');
                     * console.log(array);
                     * // => ['a', 'a', 'a']
                     *
                     * _.fill(Array(3), 2);
                     * // => [2, 2, 2]
                     *
                     * _.fill([4, 6, 8], '*', 1, 2);
                     * // => [4, '*', 8]
                     */
                    function fill(array, value, start, end) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                            start = 0;
                            end = length;
                        }
                        return baseFill(array, value, start, end);
                    }

                    /**
                     * This method is like `_.find` except that it returns the index of the first
                     * element `predicate` returns truthy for instead of the element itself.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
                     * // => 0
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findIndex(users, { 'user': 'fred', 'active': false });
                     * // => 1
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findIndex(users, 'active', false);
                     * // => 0
                     *
                     * // using the `_.property` callback shorthand
                     * _.findIndex(users, 'active');
                     * // => 2
                     */
                    var findIndex = createFindIndex();

                    /**
                     * This method is like `_.findIndex` except that it iterates over elements
                     * of `collection` from right to left.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': true },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': false }
                     * ];
                     *
                     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
                     * // => 2
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
                     * // => 0
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findLastIndex(users, 'active', false);
                     * // => 2
                     *
                     * // using the `_.property` callback shorthand
                     * _.findLastIndex(users, 'active');
                     * // => 0
                     */
                    var findLastIndex = createFindIndex(true);

                    /**
                     * Gets the first element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @alias head
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {*} Returns the first element of `array`.
                     * @example
                     *
                     * _.first([1, 2, 3]);
                     * // => 1
                     *
                     * _.first([]);
                     * // => undefined
                     */
                    function first(array) {
                        return array ? array[0] : undefined;
                    }

                    /**
                     * Flattens a nested array. If `isDeep` is `true` the array is recursively
                     * flattened, otherwise it is only flattened a single level.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isDeep] Specify a deep flatten.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the new flattened array.
                     * @example
                     *
                     * _.flatten([1, [2, 3, [4]]]);
                     * // => [1, 2, 3, [4]]
                     *
                     * // using `isDeep`
                     * _.flatten([1, [2, 3, [4]]], true);
                     * // => [1, 2, 3, 4]
                     */
                    function flatten(array, isDeep, guard) {
                        var length = array ? array.length : 0;
                        if (guard && isIterateeCall(array, isDeep, guard)) {
                            isDeep = false;
                        }
                        return length ? baseFlatten(array, isDeep) : [];
                    }

                    /**
                     * Recursively flattens a nested array.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to recursively flatten.
                     * @returns {Array} Returns the new flattened array.
                     * @example
                     *
                     * _.flattenDeep([1, [2, 3, [4]]]);
                     * // => [1, 2, 3, 4]
                     */
                    function flattenDeep(array) {
                        var length = array ? array.length : 0;
                        return length ? baseFlatten(array, true) : [];
                    }

                    /**
                     * Gets the index at which the first occurrence of `value` is found in `array`
                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
                     * performs a faster binary search.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
                     *  to perform a binary search on a sorted array.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     * @example
                     *
                     * _.indexOf([1, 2, 1, 2], 2);
                     * // => 1
                     *
                     * // using `fromIndex`
                     * _.indexOf([1, 2, 1, 2], 2, 2);
                     * // => 3
                     *
                     * // performing a binary search
                     * _.indexOf([1, 1, 2, 2], 2, true);
                     * // => 2
                     */
                    function indexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return -1;
                        }
                        if (typeof fromIndex == 'number') {
                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
                        } else if (fromIndex) {
                            var index = binaryIndex(array, value);
                            if (index < length &&
                                (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
                                return index;
                            }
                            return -1;
                        }
                        return baseIndexOf(array, value, fromIndex || 0);
                    }

                    /**
                     * Gets all but the last element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.initial([1, 2, 3]);
                     * // => [1, 2]
                     */
                    function initial(array) {
                        return dropRight(array, 1);
                    }

                    /**
                     * Creates an array of unique values that are included in all of the provided
                     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of shared values.
                     * @example
                     * _.intersection([1, 2], [4, 2], [2, 1]);
                     * // => [2]
                     */
                    var intersection = restParam(function (arrays) {
                        var othLength = arrays.length,
                            othIndex = othLength,
                            caches = Array(length),
                            indexOf = getIndexOf(),
                            isCommon = indexOf == baseIndexOf,
                            result = [];

                        while (othIndex--) {
                            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
                            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
                        }
                        var array = arrays[0],
                            index = -1,
                            length = array ? array.length : 0,
                            seen = caches[0];

                        outer:
                            while (++index < length) {
                                value = array[index];
                                if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                                    var othIndex = othLength;
                                    while (--othIndex) {
                                        var cache = caches[othIndex];
                                        if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                                            continue outer;
                                        }
                                    }
                                    if (seen) {
                                        seen.push(value);
                                    }
                                    result.push(value);
                                }
                            }
                        return result;
                    });

                    /**
                     * Gets the last element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {*} Returns the last element of `array`.
                     * @example
                     *
                     * _.last([1, 2, 3]);
                     * // => 3
                     */
                    function last(array) {
                        var length = array ? array.length : 0;
                        return length ? array[length - 1] : undefined;
                    }

                    /**
                     * This method is like `_.indexOf` except that it iterates over elements of
                     * `array` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
                     *  or `true` to perform a binary search on a sorted array.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     * @example
                     *
                     * _.lastIndexOf([1, 2, 1, 2], 2);
                     * // => 3
                     *
                     * // using `fromIndex`
                     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
                     * // => 1
                     *
                     * // performing a binary search
                     * _.lastIndexOf([1, 1, 2, 2], 2, true);
                     * // => 3
                     */
                    function lastIndexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return -1;
                        }
                        var index = length;
                        if (typeof fromIndex == 'number') {
                            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
                        } else if (fromIndex) {
                            index = binaryIndex(array, value, true) - 1;
                            var other = array[index];
                            if (value === value ? (value === other) : (other !== other)) {
                                return index;
                            }
                            return -1;
                        }
                        if (value !== value) {
                            return indexOfNaN(array, index, true);
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * Removes all provided values from `array` using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * **Note:** Unlike `_.without`, this method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to modify.
                     * @param {...*} [values] The values to remove.
                     * @returns {Array} Returns `array`.
                     * @example
                     *
                     * var array = [1, 2, 3, 1, 2, 3];
                     *
                     * _.pull(array, 2, 3);
                     * console.log(array);
                     * // => [1, 1]
                     */
                    function pull() {
                        var args = arguments,
                            array = args[0];

                        if (!(array && array.length)) {
                            return array;
                        }
                        var index = 0,
                            indexOf = getIndexOf(),
                            length = args.length;

                        while (++index < length) {
                            var fromIndex = 0,
                                value = args[index];

                            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                                splice.call(array, fromIndex, 1);
                            }
                        }
                        return array;
                    }

                    /**
                     * Removes elements from `array` corresponding to the given indexes and returns
                     * an array of the removed elements. Indexes may be specified as an array of
                     * indexes or as individual arguments.
                     *
                     * **Note:** Unlike `_.at`, this method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to modify.
                     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
                     *  specified as individual indexes or arrays of indexes.
                     * @returns {Array} Returns the new array of removed elements.
                     * @example
                     *
                     * var array = [5, 10, 15, 20];
                     * var evens = _.pullAt(array, 1, 3);
                     *
                     * console.log(array);
                     * // => [5, 15]
                     *
                     * console.log(evens);
                     * // => [10, 20]
                     */
                    var pullAt = restParam(function (array, indexes) {
                        indexes = baseFlatten(indexes);

                        var result = baseAt(array, indexes);
                        basePullAt(array, indexes.sort(baseCompareAscending));
                        return result;
                    });

                    /**
                     * Removes all elements from `array` that `predicate` returns truthy for
                     * and returns an array of the removed elements. The predicate is bound to
                     * `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * **Note:** Unlike `_.filter`, this method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to modify.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the new array of removed elements.
                     * @example
                     *
                     * var array = [1, 2, 3, 4];
                     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
                     *
                     * console.log(array);
                     * // => [1, 3]
                     *
                     * console.log(evens);
                     * // => [2, 4]
                     */
                    function remove(array, predicate, thisArg) {
                        var result = [];
                        if (!(array && array.length)) {
                            return result;
                        }
                        var index = -1,
                            indexes = [],
                            length = array.length;

                        predicate = getCallback(predicate, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result.push(value);
                                indexes.push(index);
                            }
                        }
                        basePullAt(array, indexes);
                        return result;
                    }

                    /**
                     * Gets all but the first element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @alias tail
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.rest([1, 2, 3]);
                     * // => [2, 3]
                     */
                    function rest(array) {
                        return drop(array, 1);
                    }

                    /**
                     * Creates a slice of `array` from `start` up to, but not including, `end`.
                     *
                     * **Note:** This method is used instead of `Array#slice` to support node
                     * lists in IE < 9 and to ensure dense arrays are returned.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to slice.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function slice(array, start, end) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                            start = 0;
                            end = length;
                        }
                        return baseSlice(array, start, end);
                    }

                    /**
                     * Uses a binary search to determine the lowest index at which `value` should
                     * be inserted into `array` in order to maintain its sort order. If an iteratee
                     * function is provided it is invoked for `value` and each element of `array`
                     * to compute their sort ranking. The iteratee is bound to `thisArg` and
                     * invoked with one argument; (value).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     * @example
                     *
                     * _.sortedIndex([30, 50], 40);
                     * // => 1
                     *
                     * _.sortedIndex([4, 4, 5, 5], 5);
                     * // => 2
                     *
                     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
                     *
                     * // using an iteratee function
                     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
                     * // => 1
                     *
                     * // using the `_.property` callback shorthand
                     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
                     * // => 1
                     */
                    var sortedIndex = createSortedIndex();

                    /**
                     * This method is like `_.sortedIndex` except that it returns the highest
                     * index at which `value` should be inserted into `array` in order to
                     * maintain its sort order.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     * @example
                     *
                     * _.sortedLastIndex([4, 4, 5, 5], 5);
                     * // => 4
                     */
                    var sortedLastIndex = createSortedIndex(true);

                    /**
                     * Creates a slice of `array` with `n` elements taken from the beginning.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to take.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.take([1, 2, 3]);
                     * // => [1]
                     *
                     * _.take([1, 2, 3], 2);
                     * // => [1, 2]
                     *
                     * _.take([1, 2, 3], 5);
                     * // => [1, 2, 3]
                     *
                     * _.take([1, 2, 3], 0);
                     * // => []
                     */
                    function take(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` with `n` elements taken from the end.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to take.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.takeRight([1, 2, 3]);
                     * // => [3]
                     *
                     * _.takeRight([1, 2, 3], 2);
                     * // => [2, 3]
                     *
                     * _.takeRight([1, 2, 3], 5);
                     * // => [1, 2, 3]
                     *
                     * _.takeRight([1, 2, 3], 0);
                     * // => []
                     */
                    function takeRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        n = length - (+n || 0);
                        return baseSlice(array, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` with elements taken from the end. Elements are
                     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
                     * and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
                     * // => [2, 3]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': true },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
                     * // => ['pebbles']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
                     * // => ['fred', 'pebbles']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
                     * // => []
                     */
                    function takeRightWhile(array, predicate, thisArg) {
                        return (array && array.length)
                            ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
                            : [];
                    }

                    /**
                     * Creates a slice of `array` with elements taken from the beginning. Elements
                     * are taken until `predicate` returns falsey. The predicate is bound to
                     * `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
                     * // => [1, 2]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false},
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.takeWhile(users, 'active', false), 'user');
                     * // => ['barney', 'fred']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.takeWhile(users, 'active'), 'user');
                     * // => []
                     */
                    function takeWhile(array, predicate, thisArg) {
                        return (array && array.length)
                            ? baseWhile(array, getCallback(predicate, thisArg, 3))
                            : [];
                    }

                    /**
                     * Creates an array of unique values, in order, from all of the provided arrays
                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of combined values.
                     * @example
                     *
                     * _.union([1, 2], [4, 2], [2, 1]);
                     * // => [1, 2, 4]
                     */
                    var union = restParam(function (arrays) {
                        return baseUniq(baseFlatten(arrays, false, true));
                    });

                    /**
                     * Creates a duplicate-free version of an array, using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons, in which only the first occurence of each element
                     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
                     * for sorted arrays. If an iteratee function is provided it is invoked for
                     * each element in the array to generate the criterion by which uniqueness
                     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index, array).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias unique
                     * @category Array
                     * @param {Array} array The array to inspect.
                     * @param {boolean} [isSorted] Specify the array is sorted.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new duplicate-value-free array.
                     * @example
                     *
                     * _.uniq([2, 1, 2]);
                     * // => [2, 1]
                     *
                     * // using `isSorted`
                     * _.uniq([1, 1, 2], true);
                     * // => [1, 2]
                     *
                     * // using an iteratee function
                     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
                     * // => [1, 2.5]
                     *
                     * // using the `_.property` callback shorthand
                     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                     * // => [{ 'x': 1 }, { 'x': 2 }]
                     */
                    function uniq(array, isSorted, iteratee, thisArg) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (isSorted != null && typeof isSorted != 'boolean') {
                            thisArg = iteratee;
                            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
                            isSorted = false;
                        }
                        var callback = getCallback();
                        if (!(iteratee == null && callback === baseCallback)) {
                            iteratee = callback(iteratee, thisArg, 3);
                        }
                        return (isSorted && getIndexOf() == baseIndexOf)
                            ? sortedUniq(array, iteratee)
                            : baseUniq(array, iteratee);
                    }

                    /**
                     * This method is like `_.zip` except that it accepts an array of grouped
                     * elements and creates an array regrouping the elements to their pre-zip
                     * configuration.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array of grouped elements to process.
                     * @returns {Array} Returns the new array of regrouped elements.
                     * @example
                     *
                     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
                     * // => [['fred', 30, true], ['barney', 40, false]]
                     *
                     * _.unzip(zipped);
                     * // => [['fred', 'barney'], [30, 40], [true, false]]
                     */
                    function unzip(array) {
                        if (!(array && array.length)) {
                            return [];
                        }
                        var index = -1,
                            length = 0;

                        array = arrayFilter(array, function (group) {
                            if (isArrayLike(group)) {
                                length = nativeMax(group.length, length);
                                return true;
                            }
                        });
                        var result = Array(length);
                        while (++index < length) {
                            result[index] = arrayMap(array, baseProperty(index));
                        }
                        return result;
                    }

                    /**
                     * This method is like `_.unzip` except that it accepts an iteratee to specify
                     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
                     * and invoked with four arguments: (accumulator, value, index, group).
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array of grouped elements to process.
                     * @param {Function} [iteratee] The function to combine regrouped values.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new array of regrouped elements.
                     * @example
                     *
                     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
                     * // => [[1, 10, 100], [2, 20, 200]]
                     *
                     * _.unzipWith(zipped, _.add);
                     * // => [3, 30, 300]
                     */
                    function unzipWith(array, iteratee, thisArg) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        var result = unzip(array);
                        if (iteratee == null) {
                            return result;
                        }
                        iteratee = bindCallback(iteratee, thisArg, 4);
                        return arrayMap(result, function (group) {
                            return arrayReduce(group, iteratee, undefined, true);
                        });
                    }

                    /**
                     * Creates an array excluding all provided values using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to filter.
                     * @param {...*} [values] The values to exclude.
                     * @returns {Array} Returns the new array of filtered values.
                     * @example
                     *
                     * _.without([1, 2, 1, 3], 1, 2);
                     * // => [3]
                     */
                    var without = restParam(function (array, values) {
                        return isArrayLike(array)
                            ? baseDifference(array, values)
                            : [];
                    });

                    /**
                     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
                     * of the provided arrays.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of values.
                     * @example
                     *
                     * _.xor([1, 2], [4, 2]);
                     * // => [1, 4]
                     */
                    function xor() {
                        var index = -1,
                            length = arguments.length;

                        while (++index < length) {
                            var array = arguments[index];
                            if (isArrayLike(array)) {
                                var result = result
                                    ? arrayPush(baseDifference(result, array), baseDifference(array, result))
                                    : array;
                            }
                        }
                        return result ? baseUniq(result) : [];
                    }

                    /**
                     * Creates an array of grouped elements, the first of which contains the first
                     * elements of the given arrays, the second of which contains the second elements
                     * of the given arrays, and so on.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to process.
                     * @returns {Array} Returns the new array of grouped elements.
                     * @example
                     *
                     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
                     * // => [['fred', 30, true], ['barney', 40, false]]
                     */
                    var zip = restParam(unzip);

                    /**
                     * The inverse of `_.pairs`; this method returns an object composed from arrays
                     * of property names and values. Provide either a single two dimensional array,
                     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
                     * and one of corresponding values.
                     *
                     * @static
                     * @memberOf _
                     * @alias object
                     * @category Array
                     * @param {Array} props The property names.
                     * @param {Array} [values=[]] The property values.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * _.zipObject([['fred', 30], ['barney', 40]]);
                     * // => { 'fred': 30, 'barney': 40 }
                     *
                     * _.zipObject(['fred', 'barney'], [30, 40]);
                     * // => { 'fred': 30, 'barney': 40 }
                     */
                    function zipObject(props, values) {
                        var index = -1,
                            length = props ? props.length : 0,
                            result = {};

                        if (length && !values && !isArray(props[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = props[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }

                    /**
                     * This method is like `_.zip` except that it accepts an iteratee to specify
                     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
                     * and invoked with four arguments: (accumulator, value, index, group).
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to process.
                     * @param {Function} [iteratee] The function to combine grouped values.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new array of grouped elements.
                     * @example
                     *
                     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
                     * // => [111, 222]
                     */
                    var zipWith = restParam(function (arrays) {
                        var length = arrays.length,
                            iteratee = length > 2 ? arrays[length - 2] : undefined,
                            thisArg = length > 1 ? arrays[length - 1] : undefined;

                        if (length > 2 && typeof iteratee == 'function') {
                            length -= 2;
                        } else {
                            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
                            thisArg = undefined;
                        }
                        arrays.length = length;
                        return unzipWith(arrays, iteratee, thisArg);
                    });

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object that wraps `value` with explicit method
                     * chaining enabled.
                     *
                     * @static
                     * @memberOf _
                     * @category Chain
                     * @param {*} value The value to wrap.
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36 },
                     *   { 'user': 'fred',    'age': 40 },
                     *   { 'user': 'pebbles', 'age': 1 }
                     * ];
                     *
                     * var youngest = _.chain(users)
                     *   .sortBy('age')
                     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
                     *   .first()
                     *   .value();
                     * // => 'pebbles is 1'
                     */
                    function chain(value) {
                        var result = lodash(value);
                        result.__chain__ = true;
                        return result;
                    }

                    /**
                     * This method invokes `interceptor` and returns `value`. The interceptor is
                     * bound to `thisArg` and invoked with one argument; (value). The purpose of
                     * this method is to "tap into" a method chain in order to perform operations
                     * on intermediate results within the chain.
                     *
                     * @static
                     * @memberOf _
                     * @category Chain
                     * @param {*} value The value to provide to `interceptor`.
                     * @param {Function} interceptor The function to invoke.
                     * @param {*} [thisArg] The `this` binding of `interceptor`.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * _([1, 2, 3])
                     *  .tap(function(array) {
     *    array.pop();
     *  })
                     *  .reverse()
                     *  .value();
                     * // => [2, 1]
                     */
                    function tap(value, interceptor, thisArg) {
                        interceptor.call(thisArg, value);
                        return value;
                    }

                    /**
                     * This method is like `_.tap` except that it returns the result of `interceptor`.
                     *
                     * @static
                     * @memberOf _
                     * @category Chain
                     * @param {*} value The value to provide to `interceptor`.
                     * @param {Function} interceptor The function to invoke.
                     * @param {*} [thisArg] The `this` binding of `interceptor`.
                     * @returns {*} Returns the result of `interceptor`.
                     * @example
                     *
                     * _('  abc  ')
                     *  .chain()
                     *  .trim()
                     *  .thru(function(value) {
     *    return [value];
     *  })
                     *  .value();
                     * // => ['abc']
                     */
                    function thru(value, interceptor, thisArg) {
                        return interceptor.call(thisArg, value);
                    }

                    /**
                     * Enables explicit method chaining on the wrapper object.
                     *
                     * @name chain
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * // without explicit chaining
                     * _(users).first();
                     * // => { 'user': 'barney', 'age': 36 }
                     *
                     * // with explicit chaining
                     * _(users).chain()
                     *   .first()
                     *   .pick('user')
                     *   .value();
                     * // => { 'user': 'barney' }
                     */
                    function wrapperChain() {
                        return chain(this);
                    }

                    /**
                     * Executes the chained sequence and returns the wrapped result.
                     *
                     * @name commit
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var array = [1, 2];
                     * var wrapped = _(array).push(3);
                     *
                     * console.log(array);
                     * // => [1, 2]
                     *
                     * wrapped = wrapped.commit();
                     * console.log(array);
                     * // => [1, 2, 3]
                     *
                     * wrapped.last();
                     * // => 3
                     *
                     * console.log(array);
                     * // => [1, 2, 3]
                     */
                    function wrapperCommit() {
                        return new LodashWrapper(this.value(), this.__chain__);
                    }

                    /**
                     * Creates a new array joining a wrapped array with any additional arrays
                     * and/or values.
                     *
                     * @name concat
                     * @memberOf _
                     * @category Chain
                     * @param {...*} [values] The values to concatenate.
                     * @returns {Array} Returns the new concatenated array.
                     * @example
                     *
                     * var array = [1];
                     * var wrapped = _(array).concat(2, [3], [[4]]);
                     *
                     * console.log(wrapped.value());
                     * // => [1, 2, 3, [4]]
                     *
                     * console.log(array);
                     * // => [1]
                     */
                    var wrapperConcat = restParam(function (values) {
                        values = baseFlatten(values);
                        return this.thru(function (array) {
                            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
                        });
                    });

                    /**
                     * Creates a clone of the chained sequence planting `value` as the wrapped value.
                     *
                     * @name plant
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var array = [1, 2];
                     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
                     *
                     * var other = [3, 4];
                     * var otherWrapped = wrapped.plant(other);
                     *
                     * otherWrapped.value();
                     * // => [9, 16]
                     *
                     * wrapped.value();
                     * // => [1, 4]
                     */
                    function wrapperPlant(value) {
                        var result,
                            parent = this;

                        while (parent instanceof baseLodash) {
                            var clone = wrapperClone(parent);
                            if (result) {
                                previous.__wrapped__ = clone;
                            } else {
                                result = clone;
                            }
                            var previous = clone;
                            parent = parent.__wrapped__;
                        }
                        previous.__wrapped__ = value;
                        return result;
                    }

                    /**
                     * Reverses the wrapped array so the first element becomes the last, the
                     * second element becomes the second to last, and so on.
                     *
                     * **Note:** This method mutates the wrapped array.
                     *
                     * @name reverse
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
                     * @example
                     *
                     * var array = [1, 2, 3];
                     *
                     * _(array).reverse().value()
                     * // => [3, 2, 1]
                     *
                     * console.log(array);
                     * // => [3, 2, 1]
                     */
                    function wrapperReverse() {
                        var value = this.__wrapped__;

                        var interceptor = function (value) {
                            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
                        };
                        if (value instanceof LazyWrapper) {
                            var wrapped = value;
                            if (this.__actions__.length) {
                                wrapped = new LazyWrapper(this);
                            }
                            wrapped = wrapped.reverse();
                            wrapped.__actions__.push({'func': thru, 'args': [interceptor], 'thisArg': undefined});
                            return new LodashWrapper(wrapped, this.__chain__);
                        }
                        return this.thru(interceptor);
                    }

                    /**
                     * Produces the result of coercing the unwrapped value to a string.
                     *
                     * @name toString
                     * @memberOf _
                     * @category Chain
                     * @returns {string} Returns the coerced string value.
                     * @example
                     *
                     * _([1, 2, 3]).toString();
                     * // => '1,2,3'
                     */
                    function wrapperToString() {
                        return (this.value() + '');
                    }

                    /**
                     * Executes the chained sequence to extract the unwrapped value.
                     *
                     * @name value
                     * @memberOf _
                     * @alias run, toJSON, valueOf
                     * @category Chain
                     * @returns {*} Returns the resolved unwrapped value.
                     * @example
                     *
                     * _([1, 2, 3]).value();
                     * // => [1, 2, 3]
                     */
                    function wrapperValue() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__);
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates an array of elements corresponding to the given keys, or indexes,
                     * of `collection`. Keys may be specified as individual arguments or as arrays
                     * of keys.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {...(number|number[]|string|string[])} [props] The property names
                     *  or indexes of elements to pick, specified individually or in arrays.
                     * @returns {Array} Returns the new array of picked elements.
                     * @example
                     *
                     * _.at(['a', 'b', 'c'], [0, 2]);
                     * // => ['a', 'c']
                     *
                     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
                     * // => ['barney', 'pebbles']
                     */
                    var at = restParam(function (collection, props) {
                        return baseAt(collection, baseFlatten(props));
                    });

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through `iteratee`. The corresponding value
                     * of each key is the number of times the key was returned by `iteratee`.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy(['one', 'two', 'three'], 'length');
                     * // => { '3': 2, '5': 1 }
                     */
                    var countBy = createAggregator(function (result, value, key) {
                        hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
                    });

                    /**
                     * Checks if `predicate` returns truthy for **all** elements of `collection`.
                     * The predicate is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias all
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`.
                     * @example
                     *
                     * _.every([true, 1, null, 'yes'], Boolean);
                     * // => false
                     *
                     * var users = [
                     *   { 'user': 'barney', 'active': false },
                     *   { 'user': 'fred',   'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.every(users, { 'user': 'barney', 'active': false });
                     * // => false
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.every(users, 'active', false);
                     * // => true
                     *
                     * // using the `_.property` callback shorthand
                     * _.every(users, 'active');
                     * // => false
                     */
                    function every(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                            predicate = undefined;
                        }
                        if (typeof predicate != 'function' || thisArg !== undefined) {
                            predicate = getCallback(predicate, thisArg, 3);
                        }
                        return func(collection, predicate);
                    }

                    /**
                     * Iterates over elements of `collection`, returning an array of all elements
                     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
                     * invoked with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias select
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the new filtered array.
                     * @example
                     *
                     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
                     * // => [4, 6]
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.filter(users, 'active', false), 'user');
                     * // => ['fred']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.filter(users, 'active'), 'user');
                     * // => ['barney']
                     */
                    function filter(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        predicate = getCallback(predicate, thisArg, 3);
                        return func(collection, predicate);
                    }

                    /**
                     * Iterates over elements of `collection`, returning the first element
                     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
                     * invoked with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias detect
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36, 'active': true },
                     *   { 'user': 'fred',    'age': 40, 'active': false },
                     *   { 'user': 'pebbles', 'age': 1,  'active': true }
                     * ];
                     *
                     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
                     * // => 'barney'
                     *
                     * // using the `_.matches` callback shorthand
                     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
                     * // => 'pebbles'
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.result(_.find(users, 'active', false), 'user');
                     * // => 'fred'
                     *
                     * // using the `_.property` callback shorthand
                     * _.result(_.find(users, 'active'), 'user');
                     * // => 'barney'
                     */
                    var find = createFind(baseEach);

                    /**
                     * This method is like `_.find` except that it iterates over elements of
                     * `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
                     * // => 3
                     */
                    var findLast = createFind(baseEachRight, true);

                    /**
                     * Performs a deep comparison between each element in `collection` and the
                     * source object, returning the first element that has equivalent property
                     * values.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. For comparing a single
                     * own or inherited property value see `_.matchesProperty`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Object} source The object of property values to match.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
                     * // => 'barney'
                     *
                     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
                     * // => 'fred'
                     */
                    function findWhere(collection, source) {
                        return find(collection, baseMatches(source));
                    }

                    /**
                     * Iterates over elements of `collection` invoking `iteratee` for each element.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection). Iteratee functions may exit iteration early
                     * by explicitly returning `false`.
                     *
                     * **Note:** As with other "Collections" methods, objects with a "length" property
                     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
                     * may be used for object iteration.
                     *
                     * @static
                     * @memberOf _
                     * @alias each
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
                     * // => logs each value from left to right and returns the array
                     *
                     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
                     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
                     */
                    var forEach = createForEach(arrayEach, baseEach);

                    /**
                     * This method is like `_.forEach` except that it iterates over elements of
                     * `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias eachRight
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
                     * // => logs each value from right to left and returns the array
                     */
                    var forEachRight = createForEach(arrayEachRight, baseEachRight);

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through `iteratee`. The corresponding value
                     * of each key is an array of the elements responsible for generating the key.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * // using the `_.property` callback shorthand
                     * _.groupBy(['one', 'two', 'three'], 'length');
                     * // => { '3': ['one', 'two'], '5': ['three'] }
                     */
                    var groupBy = createAggregator(function (result, value, key) {
                        if (hasOwnProperty.call(result, key)) {
                            result[key].push(value);
                        } else {
                            result[key] = [value];
                        }
                    });

                    /**
                     * Checks if `value` is in `collection` using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                     * from the end of `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @alias contains, include
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {*} target The value to search for.
                     * @param {number} [fromIndex=0] The index to search from.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
                     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
                     * @example
                     *
                     * _.includes([1, 2, 3], 1);
                     * // => true
                     *
                     * _.includes([1, 2, 3], 1, 2);
                     * // => false
                     *
                     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
                     * // => true
                     *
                     * _.includes('pebbles', 'eb');
                     * // => true
                     */
                    function includes(collection, target, fromIndex, guard) {
                        var length = collection ? getLength(collection) : 0;
                        if (!isLength(length)) {
                            collection = values(collection);
                            length = collection.length;
                        }
                        if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
                            fromIndex = 0;
                        } else {
                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
                        }
                        return (typeof collection == 'string' || !isArray(collection) && isString(collection))
                            ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
                            : (!!length && getIndexOf(collection, target, fromIndex) > -1);
                    }

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through `iteratee`. The corresponding value
                     * of each key is the last element responsible for generating the key. The
                     * iteratee function is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * var keyData = [
                     *   { 'dir': 'left', 'code': 97 },
                     *   { 'dir': 'right', 'code': 100 }
                     * ];
                     *
                     * _.indexBy(keyData, 'dir');
                     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     */
                    var indexBy = createAggregator(function (result, value, key) {
                        result[key] = value;
                    });

                    /**
                     * Invokes the method at `path` of each element in `collection`, returning
                     * an array of the results of each invoked method. Any additional arguments
                     * are provided to each invoked method. If `methodName` is a function it is
                     * invoked for, and `this` bound to, each element in `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Array|Function|string} path The path of the method to invoke or
                     *  the function invoked per iteration.
                     * @param {...*} [args] The arguments to invoke the method with.
                     * @returns {Array} Returns the array of results.
                     * @example
                     *
                     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
                     * // => [[1, 5, 7], [1, 2, 3]]
                     *
                     * _.invoke([123, 456], String.prototype.split, '');
                     * // => [['1', '2', '3'], ['4', '5', '6']]
                     */
                    var invoke = restParam(function (collection, path, args) {
                        var index = -1,
                            isFunc = typeof path == 'function',
                            isProp = isKey(path),
                            result = isArrayLike(collection) ? Array(collection.length) : [];

                        baseEach(collection, function (value) {
                            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
                            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
                        });
                        return result;
                    });

                    /**
                     * Creates an array of values by running each element in `collection` through
                     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * Many lodash methods are guarded to work as iteratees for methods like
                     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                     *
                     * The guarded methods are:
                     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
                     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
                     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
                     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
                     * `sum`, `uniq`, and `words`
                     *
                     * @static
                     * @memberOf _
                     * @alias collect
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new mapped array.
                     * @example
                     *
                     * function timesThree(n) {
     *   return n * 3;
     * }
                     *
                     * _.map([1, 2], timesThree);
                     * // => [3, 6]
                     *
                     * _.map({ 'a': 1, 'b': 2 }, timesThree);
                     * // => [3, 6] (iteration order is not guaranteed)
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * // using the `_.property` callback shorthand
                     * _.map(users, 'user');
                     * // => ['barney', 'fred']
                     */
                    function map(collection, iteratee, thisArg) {
                        var func = isArray(collection) ? arrayMap : baseMap;
                        iteratee = getCallback(iteratee, thisArg, 3);
                        return func(collection, iteratee);
                    }

                    /**
                     * Creates an array of elements split into two groups, the first of which
                     * contains elements `predicate` returns truthy for, while the second of which
                     * contains elements `predicate` returns falsey for. The predicate is bound
                     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the array of grouped elements.
                     * @example
                     *
                     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
                     * // => [[1, 3], [2]]
                     *
                     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
                     * // => [[1.2, 3.4], [2.3]]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36, 'active': false },
                     *   { 'user': 'fred',    'age': 40, 'active': true },
                     *   { 'user': 'pebbles', 'age': 1,  'active': false }
                     * ];
                     *
                     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
                     *
                     * // using the `_.matches` callback shorthand
                     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
                     * // => [['pebbles'], ['barney', 'fred']]
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.map(_.partition(users, 'active', false), mapper);
                     * // => [['barney', 'pebbles'], ['fred']]
                     *
                     * // using the `_.property` callback shorthand
                     * _.map(_.partition(users, 'active'), mapper);
                     * // => [['fred'], ['barney', 'pebbles']]
                     */
                    var partition = createAggregator(function (result, value, key) {
                        result[key ? 0 : 1].push(value);
                    }, function () {
                        return [[], []];
                    });

                    /**
                     * Gets the property value of `path` from all elements in `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Array|string} path The path of the property to pluck.
                     * @returns {Array} Returns the property values.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.pluck(users, 'user');
                     * // => ['barney', 'fred']
                     *
                     * var userIndex = _.indexBy(users, 'user');
                     * _.pluck(userIndex, 'age');
                     * // => [36, 40] (iteration order is not guaranteed)
                     */
                    function pluck(collection, path) {
                        return map(collection, property(path));
                    }

                    /**
                     * Reduces `collection` to a value which is the accumulated result of running
                     * each element in `collection` through `iteratee`, where each successive
                     * invocation is supplied the return value of the previous. If `accumulator`
                     * is not provided the first element of `collection` is used as the initial
                     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
                     * (accumulator, value, index|key, collection).
                     *
                     * Many lodash methods are guarded to work as iteratees for methods like
                     * `_.reduce`, `_.reduceRight`, and `_.transform`.
                     *
                     * The guarded methods are:
                     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
                     * and `sortByOrder`
                     *
                     * @static
                     * @memberOf _
                     * @alias foldl, inject
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
                     * // => 3
                     *
                     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
                     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
                     */
                    var reduce = createReduce(arrayReduce, baseEach);

                    /**
                     * This method is like `_.reduce` except that it iterates over elements of
                     * `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias foldr
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var array = [[0, 1], [2, 3], [4, 5]];
                     *
                     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
                     * // => [4, 5, 2, 3, 0, 1]
                     */
                    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

                    /**
                     * The opposite of `_.filter`; this method returns the elements of `collection`
                     * that `predicate` does **not** return truthy for.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the new filtered array.
                     * @example
                     *
                     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
                     * // => [1, 3]
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': false },
                     *   { 'user': 'fred',   'age': 40, 'active': true }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.reject(users, 'active', false), 'user');
                     * // => ['fred']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.reject(users, 'active'), 'user');
                     * // => ['barney']
                     */
                    function reject(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        predicate = getCallback(predicate, thisArg, 3);
                        return func(collection, function (value, index, collection) {
                            return !predicate(value, index, collection);
                        });
                    }

                    /**
                     * Gets a random element or `n` random elements from a collection.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to sample.
                     * @param {number} [n] The number of elements to sample.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {*} Returns the random sample(s).
                     * @example
                     *
                     * _.sample([1, 2, 3, 4]);
                     * // => 2
                     *
                     * _.sample([1, 2, 3, 4], 2);
                     * // => [3, 1]
                     */
                    function sample(collection, n, guard) {
                        if (guard ? isIterateeCall(collection, n, guard) : n == null) {
                            collection = toIterable(collection);
                            var length = collection.length;
                            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
                        }
                        var index = -1,
                            result = toArray(collection),
                            length = result.length,
                            lastIndex = length - 1;

                        n = nativeMin(n < 0 ? 0 : (+n || 0), length);
                        while (++index < n) {
                            var rand = baseRandom(index, lastIndex),
                                value = result[rand];

                            result[rand] = result[index];
                            result[index] = value;
                        }
                        result.length = n;
                        return result;
                    }

                    /**
                     * Creates an array of shuffled values, using a version of the
                     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to shuffle.
                     * @returns {Array} Returns the new shuffled array.
                     * @example
                     *
                     * _.shuffle([1, 2, 3, 4]);
                     * // => [4, 1, 3, 2]
                     */
                    function shuffle(collection) {
                        return sample(collection, POSITIVE_INFINITY);
                    }

                    /**
                     * Gets the size of `collection` by returning its length for array-like
                     * values or the number of own enumerable properties for objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to inspect.
                     * @returns {number} Returns the size of `collection`.
                     * @example
                     *
                     * _.size([1, 2, 3]);
                     * // => 3
                     *
                     * _.size({ 'a': 1, 'b': 2 });
                     * // => 2
                     *
                     * _.size('pebbles');
                     * // => 7
                     */
                    function size(collection) {
                        var length = collection ? getLength(collection) : 0;
                        return isLength(length) ? length : keys(collection).length;
                    }

                    /**
                     * Checks if `predicate` returns truthy for **any** element of `collection`.
                     * The function returns as soon as it finds a passing value and does not iterate
                     * over the entire collection. The predicate is bound to `thisArg` and invoked
                     * with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias any
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     * @example
                     *
                     * _.some([null, 0, 'yes', false], Boolean);
                     * // => true
                     *
                     * var users = [
                     *   { 'user': 'barney', 'active': true },
                     *   { 'user': 'fred',   'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.some(users, { 'user': 'barney', 'active': false });
                     * // => false
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.some(users, 'active', false);
                     * // => true
                     *
                     * // using the `_.property` callback shorthand
                     * _.some(users, 'active');
                     * // => true
                     */
                    function some(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                            predicate = undefined;
                        }
                        if (typeof predicate != 'function' || thisArg !== undefined) {
                            predicate = getCallback(predicate, thisArg, 3);
                        }
                        return func(collection, predicate);
                    }

                    /**
                     * Creates an array of elements, sorted in ascending order by the results of
                     * running each element in a collection through `iteratee`. This method performs
                     * a stable sort, that is, it preserves the original sort order of equal elements.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
                     * // => [3, 1, 2]
                     *
                     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
                     * // => [3, 1, 2]
                     *
                     * var users = [
                     *   { 'user': 'fred' },
                     *   { 'user': 'pebbles' },
                     *   { 'user': 'barney' }
                     * ];
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.sortBy(users, 'user'), 'user');
                     * // => ['barney', 'fred', 'pebbles']
                     */
                    function sortBy(collection, iteratee, thisArg) {
                        if (collection == null) {
                            return [];
                        }
                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                            iteratee = undefined;
                        }
                        var index = -1;
                        iteratee = getCallback(iteratee, thisArg, 3);

                        var result = baseMap(collection, function (value, key, collection) {
                            return {'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value};
                        });
                        return baseSortBy(result, compareAscending);
                    }

                    /**
                     * This method is like `_.sortBy` except that it can sort by multiple iteratees
                     * or property names.
                     *
                     * If a property name is provided for an iteratee the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If an object is provided for an iteratee the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
                     *  The iteratees to sort by, specified as individual values or arrays of values.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'fred',   'age': 48 },
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 42 },
                     *   { 'user': 'barney', 'age': 34 }
                     * ];
                     *
                     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
                     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
                     *
                     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
                     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
                     */
                    var sortByAll = restParam(function (collection, iteratees) {
                        if (collection == null) {
                            return [];
                        }
                        var guard = iteratees[2];
                        if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
                            iteratees.length = 1;
                        }
                        return baseSortByOrder(collection, baseFlatten(iteratees), []);
                    });

                    /**
                     * This method is like `_.sortByAll` except that it allows specifying the
                     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
                     * values are sorted in ascending order. Otherwise, a value is sorted in
                     * ascending order if its corresponding order is "asc", and descending if "desc".
                     *
                     * If a property name is provided for an iteratee the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If an object is provided for an iteratee the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                     * @param {boolean[]} [orders] The sort orders of `iteratees`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'fred',   'age': 48 },
                     *   { 'user': 'barney', 'age': 34 },
                     *   { 'user': 'fred',   'age': 42 },
                     *   { 'user': 'barney', 'age': 36 }
                     * ];
                     *
                     * // sort by `user` in ascending order and by `age` in descending order
                     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
                     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
                     */
                    function sortByOrder(collection, iteratees, orders, guard) {
                        if (collection == null) {
                            return [];
                        }
                        if (guard && isIterateeCall(iteratees, orders, guard)) {
                            orders = undefined;
                        }
                        if (!isArray(iteratees)) {
                            iteratees = iteratees == null ? [] : [iteratees];
                        }
                        if (!isArray(orders)) {
                            orders = orders == null ? [] : [orders];
                        }
                        return baseSortByOrder(collection, iteratees, orders);
                    }

                    /**
                     * Performs a deep comparison between each element in `collection` and the
                     * source object, returning an array of all elements that have equivalent
                     * property values.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. For comparing a single
                     * own or inherited property value see `_.matchesProperty`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Object} source The object of property values to match.
                     * @returns {Array} Returns the new filtered array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
                     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
                     * ];
                     *
                     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
                     * // => ['barney']
                     *
                     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
                     * // => ['fred']
                     */
                    function where(collection, source) {
                        return filter(collection, baseMatches(source));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Gets the number of milliseconds that have elapsed since the Unix epoch
                     * (1 January 1970 00:00:00 UTC).
                     *
                     * @static
                     * @memberOf _
                     * @category Date
                     * @example
                     *
                     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
                     * // => logs the number of milliseconds it took for the deferred function to be invoked
                     */
                    var now = nativeNow || function () {
                            return new Date().getTime();
                        };

                    /*------------------------------------------------------------------------*/

                    /**
                     * The opposite of `_.before`; this method creates a function that invokes
                     * `func` once it is called `n` or more times.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {number} n The number of calls before `func` is invoked.
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var saves = ['profile', 'settings'];
                     *
                     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
                     *
                     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
                     * // => logs 'done saving!' after the two async saves have completed
                     */
                    function after(n, func) {
                        if (typeof func != 'function') {
                            if (typeof n == 'function') {
                                var temp = n;
                                n = func;
                                func = temp;
                            } else {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                        }
                        n = nativeIsFinite(n = +n) ? n : 0;
                        return function () {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }

                    /**
                     * Creates a function that accepts up to `n` arguments ignoring any
                     * additional arguments.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to cap arguments for.
                     * @param {number} [n=func.length] The arity cap.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
                     * // => [6, 8, 10]
                     */
                    function ary(func, n, guard) {
                        if (guard && isIterateeCall(func, n, guard)) {
                            n = undefined;
                        }
                        n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
                        return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
                    }

                    /**
                     * Creates a function that invokes `func`, with the `this` binding and arguments
                     * of the created function, while it is called less than `n` times. Subsequent
                     * calls to the created function return the result of the last `func` invocation.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {number} n The number of calls at which `func` is no longer invoked.
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * jQuery('#add').on('click', _.before(5, addContactToList));
                     * // => allows adding up to 4 contacts to the list
                     */
                    function before(n, func) {
                        var result;
                        if (typeof func != 'function') {
                            if (typeof n == 'function') {
                                var temp = n;
                                n = func;
                                func = temp;
                            } else {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                        }
                        return function () {
                            if (--n > 0) {
                                result = func.apply(this, arguments);
                            }
                            if (n <= 1) {
                                func = undefined;
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a function that invokes `func` with the `this` binding of `thisArg`
                     * and prepends any additional `_.bind` arguments to those provided to the
                     * bound function.
                     *
                     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
                     * may be used as a placeholder for partially applied arguments.
                     *
                     * **Note:** Unlike native `Function#bind` this method does not set the "length"
                     * property of bound functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to bind.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
                     *
                     * var object = { 'user': 'fred' };
                     *
                     * var bound = _.bind(greet, object, 'hi');
                     * bound('!');
                     * // => 'hi fred!'
                     *
                     * // using placeholders
                     * var bound = _.bind(greet, object, _, '!');
                     * bound('hi');
                     * // => 'hi fred!'
                     */
                    var bind = restParam(function (func, thisArg, partials) {
                        var bitmask = BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bind.placeholder);
                            bitmask |= PARTIAL_FLAG;
                        }
                        return createWrapper(func, bitmask, thisArg, partials, holders);
                    });

                    /**
                     * Binds methods of an object to the object itself, overwriting the existing
                     * method. Method names may be specified as individual arguments or as arrays
                     * of method names. If no method names are provided all enumerable function
                     * properties, own and inherited, of `object` are bound.
                     *
                     * **Note:** This method does not set the "length" property of bound functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Object} object The object to bind and assign the bound methods to.
                     * @param {...(string|string[])} [methodNames] The object method names to bind,
                     *  specified as individual method names or arrays of method names.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
                     *
                     * _.bindAll(view);
                     * jQuery('#docs').on('click', view.onClick);
                     * // => logs 'clicked docs' when the element is clicked
                     */
                    var bindAll = restParam(function (object, methodNames) {
                        methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

                        var index = -1,
                            length = methodNames.length;

                        while (++index < length) {
                            var key = methodNames[index];
                            object[key] = createWrapper(object[key], BIND_FLAG, object);
                        }
                        return object;
                    });

                    /**
                     * Creates a function that invokes the method at `object[key]` and prepends
                     * any additional `_.bindKey` arguments to those provided to the bound function.
                     *
                     * This method differs from `_.bind` by allowing bound functions to reference
                     * methods that may be redefined or don't yet exist.
                     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
                     * for more details.
                     *
                     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for partially applied arguments.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Object} object The object the method belongs to.
                     * @param {string} key The key of the method.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
                     *
                     * var bound = _.bindKey(object, 'greet', 'hi');
                     * bound('!');
                     * // => 'hi fred!'
                     *
                     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
                     *
                     * bound('!');
                     * // => 'hiya fred!'
                     *
                     * // using placeholders
                     * var bound = _.bindKey(object, 'greet', _, '!');
                     * bound('hi');
                     * // => 'hiya fred!'
                     */
                    var bindKey = restParam(function (object, key, partials) {
                        var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bindKey.placeholder);
                            bitmask |= PARTIAL_FLAG;
                        }
                        return createWrapper(key, bitmask, object, partials, holders);
                    });

                    /**
                     * Creates a function that accepts one or more arguments of `func` that when
                     * called either invokes `func` returning its result, if all `func` arguments
                     * have been provided, or returns a function that accepts one or more of the
                     * remaining `func` arguments, and so on. The arity of `func` may be specified
                     * if `func.length` is not sufficient.
                     *
                     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
                     * may be used as a placeholder for provided arguments.
                     *
                     * **Note:** This method does not set the "length" property of curried functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to curry.
                     * @param {number} [arity=func.length] The arity of `func`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the new curried function.
                     * @example
                     *
                     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
                     *
                     * var curried = _.curry(abc);
                     *
                     * curried(1)(2)(3);
                     * // => [1, 2, 3]
                     *
                     * curried(1, 2)(3);
                     * // => [1, 2, 3]
                     *
                     * curried(1, 2, 3);
                     * // => [1, 2, 3]
                     *
                     * // using placeholders
                     * curried(1)(_, 3)(2);
                     * // => [1, 2, 3]
                     */
                    var curry = createCurry(CURRY_FLAG);

                    /**
                     * This method is like `_.curry` except that arguments are applied to `func`
                     * in the manner of `_.partialRight` instead of `_.partial`.
                     *
                     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for provided arguments.
                     *
                     * **Note:** This method does not set the "length" property of curried functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to curry.
                     * @param {number} [arity=func.length] The arity of `func`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the new curried function.
                     * @example
                     *
                     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
                     *
                     * var curried = _.curryRight(abc);
                     *
                     * curried(3)(2)(1);
                     * // => [1, 2, 3]
                     *
                     * curried(2, 3)(1);
                     * // => [1, 2, 3]
                     *
                     * curried(1, 2, 3);
                     * // => [1, 2, 3]
                     *
                     * // using placeholders
                     * curried(3)(1, _)(2);
                     * // => [1, 2, 3]
                     */
                    var curryRight = createCurry(CURRY_RIGHT_FLAG);

                    /**
                     * Creates a debounced function that delays invoking `func` until after `wait`
                     * milliseconds have elapsed since the last time the debounced function was
                     * invoked. The debounced function comes with a `cancel` method to cancel
                     * delayed invocations. Provide an options object to indicate that `func`
                     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
                     * Subsequent calls to the debounced function return the result of the last
                     * `func` invocation.
                     *
                     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
                     * on the trailing edge of the timeout only if the the debounced function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
                     * for details over the differences between `_.debounce` and `_.throttle`.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to debounce.
                     * @param {number} [wait=0] The number of milliseconds to delay.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=false] Specify invoking on the leading
                     *  edge of the timeout.
                     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
                     *  delayed before it is invoked.
                     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
                     *  edge of the timeout.
                     * @returns {Function} Returns the new debounced function.
                     * @example
                     *
                     * // avoid costly calculations while the window size is in flux
                     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
                     *
                     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
                     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
                     *
                     * // ensure `batchLog` is invoked once after 1 second of debounced calls
                     * var source = new EventSource('/stream');
                     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
                     *
                     * // cancel a debounced call
                     * var todoChanges = _.debounce(batchLog, 1000);
                     * Object.observe(models.todo, todoChanges);
                     *
                     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
                     *
                     * // ...at some point `models.todo` is changed
                     * models.todo.completed = true;
                     *
                     * // ...before 1 second has passed `models.todo` is deleted
                     * // which cancels the debounced `todoChanges` call
                     * delete models.todo;
                     */
                    function debounce(func, wait, options) {
                        var args,
                            maxTimeoutId,
                            result,
                            stamp,
                            thisArg,
                            timeoutId,
                            trailingCall,
                            lastCalled = 0,
                            maxWait = false,
                            trailing = true;

                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        wait = wait < 0 ? 0 : (+wait || 0);
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = !!options.leading;
                            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                        }

                        function cancel() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            if (maxTimeoutId) {
                                clearTimeout(maxTimeoutId);
                            }
                            lastCalled = 0;
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                        }

                        function complete(isCalled, id) {
                            if (id) {
                                clearTimeout(id);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (isCalled) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = undefined;
                                }
                            }
                        }

                        function delayed() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0 || remaining > wait) {
                                complete(trailingCall, maxTimeoutId);
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        }

                        function maxDelayed() {
                            complete(trailing, timeoutId);
                        }

                        function debounced() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);

                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled),
                                    isCalled = remaining <= 0 || remaining > maxWait;

                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                }
                                else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            }
                            else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = undefined;
                            }
                            return result;
                        }

                        debounced.cancel = cancel;
                        return debounced;
                    }

                    /**
                     * Defers invoking the `func` until the current call stack has cleared. Any
                     * additional arguments are provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to defer.
                     * @param {...*} [args] The arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
                     * // logs 'deferred' after one or more milliseconds
                     */
                    var defer = restParam(function (func, args) {
                        return baseDelay(func, 1, args);
                    });

                    /**
                     * Invokes `func` after `wait` milliseconds. Any additional arguments are
                     * provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to delay.
                     * @param {number} wait The number of milliseconds to delay invocation.
                     * @param {...*} [args] The arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
                     * // => logs 'later' after one second
                     */
                    var delay = restParam(function (func, wait, args) {
                        return baseDelay(func, wait, args);
                    });

                    /**
                     * Creates a function that returns the result of invoking the provided
                     * functions with the `this` binding of the created function, where each
                     * successive invocation is supplied the return value of the previous.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {...Function} [funcs] Functions to invoke.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function square(n) {
     *   return n * n;
     * }
                     *
                     * var addSquare = _.flow(_.add, square);
                     * addSquare(1, 2);
                     * // => 9
                     */
                    var flow = createFlow();

                    /**
                     * This method is like `_.flow` except that it creates a function that
                     * invokes the provided functions from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias backflow, compose
                     * @category Function
                     * @param {...Function} [funcs] Functions to invoke.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function square(n) {
     *   return n * n;
     * }
                     *
                     * var addSquare = _.flowRight(square, _.add);
                     * addSquare(1, 2);
                     * // => 9
                     */
                    var flowRight = createFlow(true);

                    /**
                     * Creates a function that memoizes the result of `func`. If `resolver` is
                     * provided it determines the cache key for storing the result based on the
                     * arguments provided to the memoized function. By default, the first argument
                     * provided to the memoized function is coerced to a string and used as the
                     * cache key. The `func` is invoked with the `this` binding of the memoized
                     * function.
                     *
                     * **Note:** The cache is exposed as the `cache` property on the memoized
                     * function. Its creation may be customized by replacing the `_.memoize.Cache`
                     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
                     * method interface of `get`, `has`, and `set`.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to have its output memoized.
                     * @param {Function} [resolver] The function to resolve the cache key.
                     * @returns {Function} Returns the new memoizing function.
                     * @example
                     *
                     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
                     *
                     * upperCase('fred');
                     * // => 'FRED'
                     *
                     * // modifying the result cache
                     * upperCase.cache.set('fred', 'BARNEY');
                     * upperCase('fred');
                     * // => 'BARNEY'
                     *
                     * // replacing `_.memoize.Cache`
                     * var object = { 'user': 'fred' };
                     * var other = { 'user': 'barney' };
                     * var identity = _.memoize(_.identity);
                     *
                     * identity(object);
                     * // => { 'user': 'fred' }
                     * identity(other);
                     * // => { 'user': 'fred' }
                     *
                     * _.memoize.Cache = WeakMap;
                     * var identity = _.memoize(_.identity);
                     *
                     * identity(object);
                     * // => { 'user': 'fred' }
                     * identity(other);
                     * // => { 'user': 'barney' }
                     */
                    function memoize(func, resolver) {
                        if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var memoized = function () {
                            var args = arguments,
                                key = resolver ? resolver.apply(this, args) : args[0],
                                cache = memoized.cache;

                            if (cache.has(key)) {
                                return cache.get(key);
                            }
                            var result = func.apply(this, args);
                            memoized.cache = cache.set(key, result);
                            return result;
                        };
                        memoized.cache = new memoize.Cache;
                        return memoized;
                    }

                    /**
                     * Creates a function that runs each argument through a corresponding
                     * transform function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to wrap.
                     * @param {...(Function|Function[])} [transforms] The functions to transform
                     * arguments, specified as individual functions or arrays of functions.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function doubled(n) {
     *   return n * 2;
     * }
                     *
                     * function square(n) {
     *   return n * n;
     * }
                     *
                     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
                     *
                     * modded(1, 2);
                     * // => [1, 4]
                     *
                     * modded(5, 10);
                     * // => [25, 20]
                     */
                    var modArgs = restParam(function (func, transforms) {
                        transforms = baseFlatten(transforms);
                        if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var length = transforms.length;
                        return restParam(function (args) {
                            var index = nativeMin(args.length, length);
                            while (index--) {
                                args[index] = transforms[index](args[index]);
                            }
                            return func.apply(this, args);
                        });
                    });

                    /**
                     * Creates a function that negates the result of the predicate `func`. The
                     * `func` predicate is invoked with the `this` binding and arguments of the
                     * created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} predicate The predicate to negate.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function isEven(n) {
     *   return n % 2 == 0;
     * }
                     *
                     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
                     * // => [1, 3, 5]
                     */
                    function negate(predicate) {
                        if (typeof predicate != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function () {
                            return !predicate.apply(this, arguments);
                        };
                    }

                    /**
                     * Creates a function that is restricted to invoking `func` once. Repeat calls
                     * to the function return the value of the first call. The `func` is invoked
                     * with the `this` binding and arguments of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var initialize = _.once(createApplication);
                     * initialize();
                     * initialize();
                     * // `initialize` invokes `createApplication` once
                     */
                    function once(func) {
                        return before(2, func);
                    }

                    /**
                     * Creates a function that invokes `func` with `partial` arguments prepended
                     * to those provided to the new function. This method is like `_.bind` except
                     * it does **not** alter the `this` binding.
                     *
                     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for partially applied arguments.
                     *
                     * **Note:** This method does not set the "length" property of partially
                     * applied functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
                     *
                     * var sayHelloTo = _.partial(greet, 'hello');
                     * sayHelloTo('fred');
                     * // => 'hello fred'
                     *
                     * // using placeholders
                     * var greetFred = _.partial(greet, _, 'fred');
                     * greetFred('hi');
                     * // => 'hi fred'
                     */
                    var partial = createPartial(PARTIAL_FLAG);

                    /**
                     * This method is like `_.partial` except that partially applied arguments
                     * are appended to those provided to the new function.
                     *
                     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for partially applied arguments.
                     *
                     * **Note:** This method does not set the "length" property of partially
                     * applied functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
                     *
                     * var greetFred = _.partialRight(greet, 'fred');
                     * greetFred('hi');
                     * // => 'hi fred'
                     *
                     * // using placeholders
                     * var sayHelloTo = _.partialRight(greet, 'hello', _);
                     * sayHelloTo('fred');
                     * // => 'hello fred'
                     */
                    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

                    /**
                     * Creates a function that invokes `func` with arguments arranged according
                     * to the specified indexes where the argument value at the first index is
                     * provided as the first argument, the argument value at the second index is
                     * provided as the second argument, and so on.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to rearrange arguments for.
                     * @param {...(number|number[])} indexes The arranged argument indexes,
                     *  specified as individual indexes or arrays of indexes.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
                     *
                     * rearged('b', 'c', 'a')
                     * // => ['a', 'b', 'c']
                     *
                     * var map = _.rearg(_.map, [1, 0]);
                     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
                     * // => [3, 6, 9]
                     */
                    var rearg = restParam(function (func, indexes) {
                        return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
                    });

                    /**
                     * Creates a function that invokes `func` with the `this` binding of the
                     * created function and arguments from `start` and beyond provided as an array.
                     *
                     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to apply a rest parameter to.
                     * @param {number} [start=func.length-1] The start position of the rest parameter.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
                     *
                     * say('hello', 'fred', 'barney', 'pebbles');
                     * // => 'hello fred, barney, & pebbles'
                     */
                    function restParam(func, start) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
                        return function () {
                            var args = arguments,
                                index = -1,
                                length = nativeMax(args.length - start, 0),
                                rest = Array(length);

                            while (++index < length) {
                                rest[index] = args[start + index];
                            }
                            switch (start) {
                                case 0:
                                    return func.call(this, rest);
                                case 1:
                                    return func.call(this, args[0], rest);
                                case 2:
                                    return func.call(this, args[0], args[1], rest);
                            }
                            var otherArgs = Array(start + 1);
                            index = -1;
                            while (++index < start) {
                                otherArgs[index] = args[index];
                            }
                            otherArgs[start] = rest;
                            return func.apply(this, otherArgs);
                        };
                    }

                    /**
                     * Creates a function that invokes `func` with the `this` binding of the created
                     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
                     *
                     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to spread arguments over.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
                     *
                     * say(['fred', 'hello']);
                     * // => 'fred says hello'
                     *
                     * // with a Promise
                     * var numbers = Promise.all([
                     *   Promise.resolve(40),
                     *   Promise.resolve(36)
                     * ]);
                     *
                     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
                     * // => a Promise of 76
                     */
                    function spread(func) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function (array) {
                            return func.apply(this, array);
                        };
                    }

                    /**
                     * Creates a throttled function that only invokes `func` at most once per
                     * every `wait` milliseconds. The throttled function comes with a `cancel`
                     * method to cancel delayed invocations. Provide an options object to indicate
                     * that `func` should be invoked on the leading and/or trailing edge of the
                     * `wait` timeout. Subsequent calls to the throttled function return the
                     * result of the last `func` call.
                     *
                     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
                     * on the trailing edge of the timeout only if the the throttled function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
                     * for details over the differences between `_.throttle` and `_.debounce`.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to throttle.
                     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=true] Specify invoking on the leading
                     *  edge of the timeout.
                     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
                     *  edge of the timeout.
                     * @returns {Function} Returns the new throttled function.
                     * @example
                     *
                     * // avoid excessively updating the position while scrolling
                     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
                     *
                     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
                     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
                     *
                     * // cancel a trailing throttled call
                     * jQuery(window).on('popstate', throttled.cancel);
                     */
                    function throttle(func, wait, options) {
                        var leading = true,
                            trailing = true;

                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = 'leading' in options ? !!options.leading : leading;
                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                        }
                        return debounce(func, wait, {'leading': leading, 'maxWait': +wait, 'trailing': trailing});
                    }

                    /**
                     * Creates a function that provides `value` to the wrapper function as its
                     * first argument. Any additional arguments provided to the function are
                     * appended to those provided to the wrapper function. The wrapper is invoked
                     * with the `this` binding of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {*} value The value to wrap.
                     * @param {Function} wrapper The wrapper function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
                     *
                     * p('fred, barney, & pebbles');
                     * // => '<p>fred, barney, &amp; pebbles</p>'
                     */
                    function wrap(value, wrapper) {
                        wrapper = wrapper == null ? identity : wrapper;
                        return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
                     * otherwise they are assigned by reference. If `customizer` is provided it is
                     * invoked to produce the cloned values. If `customizer` returns `undefined`
                     * cloning is handled by the method instead. The `customizer` is bound to
                     * `thisArg` and invoked with two argument; (value [, index|key, object]).
                     *
                     * **Note:** This method is loosely based on the
                     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
                     * The enumerable properties of `arguments` objects and objects created by
                     * constructors other than `Object` are cloned to plain `Object` objects. An
                     * empty object is returned for uncloneable values such as functions, DOM nodes,
                     * Maps, Sets, and WeakMaps.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @param {Function} [customizer] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {*} Returns the cloned value.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * var shallow = _.clone(users);
                     * shallow[0] === users[0];
                     * // => true
                     *
                     * var deep = _.clone(users, true);
                     * deep[0] === users[0];
                     * // => false
                     *
                     * // using a customizer callback
                     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
                     *
                     * el === document.body
                     * // => false
                     * el.nodeName
                     * // => BODY
                     * el.childNodes.length;
                     * // => 0
                     */
                    function clone(value, isDeep, customizer, thisArg) {
                        if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
                            isDeep = false;
                        }
                        else if (typeof isDeep == 'function') {
                            thisArg = customizer;
                            customizer = isDeep;
                            isDeep = false;
                        }
                        return typeof customizer == 'function'
                            ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
                            : baseClone(value, isDeep);
                    }

                    /**
                     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
                     * to produce the cloned values. If `customizer` returns `undefined` cloning
                     * is handled by the method instead. The `customizer` is bound to `thisArg`
                     * and invoked with two argument; (value [, index|key, object]).
                     *
                     * **Note:** This method is loosely based on the
                     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
                     * The enumerable properties of `arguments` objects and objects created by
                     * constructors other than `Object` are cloned to plain `Object` objects. An
                     * empty object is returned for uncloneable values such as functions, DOM nodes,
                     * Maps, Sets, and WeakMaps.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to deep clone.
                     * @param {Function} [customizer] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {*} Returns the deep cloned value.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * var deep = _.cloneDeep(users);
                     * deep[0] === users[0];
                     * // => false
                     *
                     * // using a customizer callback
                     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
                     *
                     * el === document.body
                     * // => false
                     * el.nodeName
                     * // => BODY
                     * el.childNodes.length;
                     * // => 20
                     */
                    function cloneDeep(value, customizer, thisArg) {
                        return typeof customizer == 'function'
                            ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
                            : baseClone(value, true);
                    }

                    /**
                     * Checks if `value` is greater than `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
                     * @example
                     *
                     * _.gt(3, 1);
                     * // => true
                     *
                     * _.gt(3, 3);
                     * // => false
                     *
                     * _.gt(1, 3);
                     * // => false
                     */
                    function gt(value, other) {
                        return value > other;
                    }

                    /**
                     * Checks if `value` is greater than or equal to `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
                     * @example
                     *
                     * _.gte(3, 1);
                     * // => true
                     *
                     * _.gte(3, 3);
                     * // => true
                     *
                     * _.gte(1, 3);
                     * // => false
                     */
                    function gte(value, other) {
                        return value >= other;
                    }

                    /**
                     * Checks if `value` is classified as an `arguments` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isArguments(function() { return arguments; }());
                     * // => true
                     *
                     * _.isArguments([1, 2, 3]);
                     * // => false
                     */
                    function isArguments(value) {
                        return isObjectLike(value) && isArrayLike(value) &&
                            hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
                    }

                    /**
                     * Checks if `value` is classified as an `Array` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isArray([1, 2, 3]);
                     * // => true
                     *
                     * _.isArray(function() { return arguments; }());
                     * // => false
                     */
                    var isArray = nativeIsArray || function (value) {
                            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
                        };

                    /**
                     * Checks if `value` is classified as a boolean primitive or object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isBoolean(false);
                     * // => true
                     *
                     * _.isBoolean(null);
                     * // => false
                     */
                    function isBoolean(value) {
                        return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
                    }

                    /**
                     * Checks if `value` is classified as a `Date` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isDate(new Date);
                     * // => true
                     *
                     * _.isDate('Mon April 23 2012');
                     * // => false
                     */
                    function isDate(value) {
                        return isObjectLike(value) && objToString.call(value) == dateTag;
                    }

                    /**
                     * Checks if `value` is a DOM element.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
                     * @example
                     *
                     * _.isElement(document.body);
                     * // => true
                     *
                     * _.isElement('<body>');
                     * // => false
                     */
                    function isElement(value) {
                        return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
                    }

                    /**
                     * Checks if `value` is empty. A value is considered empty unless it is an
                     * `arguments` object, array, string, or jQuery-like collection with a length
                     * greater than `0` or an object with own enumerable properties.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {Array|Object|string} value The value to inspect.
                     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                     * @example
                     *
                     * _.isEmpty(null);
                     * // => true
                     *
                     * _.isEmpty(true);
                     * // => true
                     *
                     * _.isEmpty(1);
                     * // => true
                     *
                     * _.isEmpty([1, 2, 3]);
                     * // => false
                     *
                     * _.isEmpty({ 'a': 1 });
                     * // => false
                     */
                    function isEmpty(value) {
                        if (value == null) {
                            return true;
                        }
                        if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
                            (isObjectLike(value) && isFunction(value.splice)))) {
                            return !value.length;
                        }
                        return !keys(value).length;
                    }

                    /**
                     * Performs a deep comparison between two values to determine if they are
                     * equivalent. If `customizer` is provided it is invoked to compare values.
                     * If `customizer` returns `undefined` comparisons are handled by the method
                     * instead. The `customizer` is bound to `thisArg` and invoked with three
                     * arguments: (value, other [, index|key]).
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. Functions and DOM nodes
                     * are **not** supported. Provide a customizer function to extend support
                     * for comparing other values.
                     *
                     * @static
                     * @memberOf _
                     * @alias eq
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @param {Function} [customizer] The function to customize value comparisons.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     * var other = { 'user': 'fred' };
                     *
                     * object == other;
                     * // => false
                     *
                     * _.isEqual(object, other);
                     * // => true
                     *
                     * // using a customizer callback
                     * var array = ['hello', 'goodbye'];
                     * var other = ['hi', 'goodbye'];
                     *
                     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
                     * // => true
                     */
                    function isEqual(value, other, customizer, thisArg) {
                        customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
                        var result = customizer ? customizer(value, other) : undefined;
                        return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
                    }

                    /**
                     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
                     * `SyntaxError`, `TypeError`, or `URIError` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
                     * @example
                     *
                     * _.isError(new Error);
                     * // => true
                     *
                     * _.isError(Error);
                     * // => false
                     */
                    function isError(value) {
                        return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
                    }

                    /**
                     * Checks if `value` is a finite primitive number.
                     *
                     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
                     * @example
                     *
                     * _.isFinite(10);
                     * // => true
                     *
                     * _.isFinite('10');
                     * // => false
                     *
                     * _.isFinite(true);
                     * // => false
                     *
                     * _.isFinite(Object(10));
                     * // => false
                     *
                     * _.isFinite(Infinity);
                     * // => false
                     */
                    function isFinite(value) {
                        return typeof value == 'number' && nativeIsFinite(value);
                    }

                    /**
                     * Checks if `value` is classified as a `Function` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isFunction(_);
                     * // => true
                     *
                     * _.isFunction(/abc/);
                     * // => false
                     */
                    function isFunction(value) {
                        // The use of `Object#toString` avoids issues with the `typeof` operator
                        // in older versions of Chrome and Safari which return 'function' for regexes
                        // and Safari 8 equivalents which return 'object' for typed array constructors.
                        return isObject(value) && objToString.call(value) == funcTag;
                    }

                    /**
                     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
                     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                     * @example
                     *
                     * _.isObject({});
                     * // => true
                     *
                     * _.isObject([1, 2, 3]);
                     * // => true
                     *
                     * _.isObject(1);
                     * // => false
                     */
                    function isObject(value) {
                        // Avoid a V8 JIT bug in Chrome 19-20.
                        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
                        var type = typeof value;
                        return !!value && (type == 'object' || type == 'function');
                    }

                    /**
                     * Performs a deep comparison between `object` and `source` to determine if
                     * `object` contains equivalent property values. If `customizer` is provided
                     * it is invoked to compare values. If `customizer` returns `undefined`
                     * comparisons are handled by the method instead. The `customizer` is bound
                     * to `thisArg` and invoked with three arguments: (value, other, index|key).
                     *
                     * **Note:** This method supports comparing properties of arrays, booleans,
                     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
                     * and DOM nodes are **not** supported. Provide a customizer function to extend
                     * support for comparing other values.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {Object} object The object to inspect.
                     * @param {Object} source The object of property values to match.
                     * @param {Function} [customizer] The function to customize value comparisons.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                     * @example
                     *
                     * var object = { 'user': 'fred', 'age': 40 };
                     *
                     * _.isMatch(object, { 'age': 40 });
                     * // => true
                     *
                     * _.isMatch(object, { 'age': 36 });
                     * // => false
                     *
                     * // using a customizer callback
                     * var object = { 'greeting': 'hello' };
                     * var source = { 'greeting': 'hi' };
                     *
                     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
                     * // => true
                     */
                    function isMatch(object, source, customizer, thisArg) {
                        customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
                        return baseIsMatch(object, getMatchData(source), customizer);
                    }

                    /**
                     * Checks if `value` is `NaN`.
                     *
                     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
                     * which returns `true` for `undefined` and other non-numeric values.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                     * @example
                     *
                     * _.isNaN(NaN);
                     * // => true
                     *
                     * _.isNaN(new Number(NaN));
                     * // => true
                     *
                     * isNaN(undefined);
                     * // => true
                     *
                     * _.isNaN(undefined);
                     * // => false
                     */
                    function isNaN(value) {
                        // An `NaN` primitive is the only value that is not equal to itself.
                        // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
                        return isNumber(value) && value != +value;
                    }

                    /**
                     * Checks if `value` is a native function.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
                     * @example
                     *
                     * _.isNative(Array.prototype.push);
                     * // => true
                     *
                     * _.isNative(_);
                     * // => false
                     */
                    function isNative(value) {
                        if (value == null) {
                            return false;
                        }
                        if (isFunction(value)) {
                            return reIsNative.test(fnToString.call(value));
                        }
                        return isObjectLike(value) && reIsHostCtor.test(value);
                    }

                    /**
                     * Checks if `value` is `null`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
                     * @example
                     *
                     * _.isNull(null);
                     * // => true
                     *
                     * _.isNull(void 0);
                     * // => false
                     */
                    function isNull(value) {
                        return value === null;
                    }

                    /**
                     * Checks if `value` is classified as a `Number` primitive or object.
                     *
                     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
                     * as numbers, use the `_.isFinite` method.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isNumber(8.4);
                     * // => true
                     *
                     * _.isNumber(NaN);
                     * // => true
                     *
                     * _.isNumber('8.4');
                     * // => false
                     */
                    function isNumber(value) {
                        return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
                    }

                    /**
                     * Checks if `value` is a plain object, that is, an object created by the
                     * `Object` constructor or one with a `[[Prototype]]` of `null`.
                     *
                     * **Note:** This method assumes objects created by the `Object` constructor
                     * have no inherited enumerable properties.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     * @example
                     *
                     * function Foo() {
     *   this.a = 1;
     * }
                     *
                     * _.isPlainObject(new Foo);
                     * // => false
                     *
                     * _.isPlainObject([1, 2, 3]);
                     * // => false
                     *
                     * _.isPlainObject({ 'x': 0, 'y': 0 });
                     * // => true
                     *
                     * _.isPlainObject(Object.create(null));
                     * // => true
                     */
                    function isPlainObject(value) {
                        var Ctor;

                        // Exit early for non `Object` objects.
                        if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
                            (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
                            return false;
                        }
                        // IE < 9 iterates inherited properties before own properties. If the first
                        // iterated property is an object's own property then there are no inherited
                        // enumerable properties.
                        var result;
                        // In most environments an object's own properties are iterated before
                        // its inherited properties. If the last iterated property is an object's
                        // own property then there are no inherited enumerable properties.
                        baseForIn(value, function (subValue, key) {
                            result = key;
                        });
                        return result === undefined || hasOwnProperty.call(value, result);
                    }

                    /**
                     * Checks if `value` is classified as a `RegExp` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isRegExp(/abc/);
                     * // => true
                     *
                     * _.isRegExp('/abc/');
                     * // => false
                     */
                    function isRegExp(value) {
                        return isObject(value) && objToString.call(value) == regexpTag;
                    }

                    /**
                     * Checks if `value` is classified as a `String` primitive or object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isString('abc');
                     * // => true
                     *
                     * _.isString(1);
                     * // => false
                     */
                    function isString(value) {
                        return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
                    }

                    /**
                     * Checks if `value` is classified as a typed array.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isTypedArray(new Uint8Array);
                     * // => true
                     *
                     * _.isTypedArray([]);
                     * // => false
                     */
                    function isTypedArray(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
                    }

                    /**
                     * Checks if `value` is `undefined`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                     * @example
                     *
                     * _.isUndefined(void 0);
                     * // => true
                     *
                     * _.isUndefined(null);
                     * // => false
                     */
                    function isUndefined(value) {
                        return value === undefined;
                    }

                    /**
                     * Checks if `value` is less than `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
                     * @example
                     *
                     * _.lt(1, 3);
                     * // => true
                     *
                     * _.lt(3, 3);
                     * // => false
                     *
                     * _.lt(3, 1);
                     * // => false
                     */
                    function lt(value, other) {
                        return value < other;
                    }

                    /**
                     * Checks if `value` is less than or equal to `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
                     * @example
                     *
                     * _.lte(1, 3);
                     * // => true
                     *
                     * _.lte(3, 3);
                     * // => true
                     *
                     * _.lte(3, 1);
                     * // => false
                     */
                    function lte(value, other) {
                        return value <= other;
                    }

                    /**
                     * Converts `value` to an array.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {Array} Returns the converted array.
                     * @example
                     *
                     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
                     * // => [2, 3]
                     */
                    function toArray(value) {
                        var length = value ? getLength(value) : 0;
                        if (!isLength(length)) {
                            return values(value);
                        }
                        if (!length) {
                            return [];
                        }
                        return arrayCopy(value);
                    }

                    /**
                     * Converts `value` to a plain object flattening inherited enumerable
                     * properties of `value` to own properties of the plain object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {Object} Returns the converted plain object.
                     * @example
                     *
                     * function Foo() {
     *   this.b = 2;
     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.assign({ 'a': 1 }, new Foo);
                     * // => { 'a': 1, 'b': 2 }
                     *
                     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                     * // => { 'a': 1, 'b': 2, 'c': 3 }
                     */
                    function toPlainObject(value) {
                        return baseCopy(value, keysIn(value));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Recursively merges own enumerable properties of the source object(s), that
                     * don't resolve to `undefined` into the destination object. Subsequent sources
                     * overwrite property assignments of previous sources. If `customizer` is
                     * provided it is invoked to produce the merged values of the destination and
                     * source properties. If `customizer` returns `undefined` merging is handled
                     * by the method instead. The `customizer` is bound to `thisArg` and invoked
                     * with five arguments: (objectValue, sourceValue, key, object, source).
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @param {Function} [customizer] The function to customize assigned values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
                     *
                     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
                     *
                     * _.merge(users, ages);
                     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
                     *
                     * // using a customizer callback
                     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
                     *
                     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
                     *
                     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
                     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
                     */
                    var merge = createAssigner(baseMerge);

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object. Subsequent sources overwrite property assignments of previous sources.
                     * If `customizer` is provided it is invoked to produce the assigned values.
                     * The `customizer` is bound to `thisArg` and invoked with five arguments:
                     * (objectValue, sourceValue, key, object, source).
                     *
                     * **Note:** This method mutates `object` and is based on
                     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
                     *
                     * @static
                     * @memberOf _
                     * @alias extend
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @param {Function} [customizer] The function to customize assigned values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
                     * // => { 'user': 'fred', 'age': 40 }
                     *
                     * // using a customizer callback
                     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
                     *
                     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
                     * // => { 'user': 'barney', 'age': 36 }
                     */
                    var assign = createAssigner(function (object, source, customizer) {
                        return customizer
                            ? assignWith(object, source, customizer)
                            : baseAssign(object, source);
                    });

                    /**
                     * Creates an object that inherits from the given `prototype` object. If a
                     * `properties` object is provided its own enumerable properties are assigned
                     * to the created object.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} prototype The object to inherit from.
                     * @param {Object} [properties] The properties to assign to the object.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
                     *
                     * function Circle() {
     *   Shape.call(this);
     * }
                     *
                     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
                     *
                     * var circle = new Circle;
                     * circle instanceof Circle;
                     * // => true
                     *
                     * circle instanceof Shape;
                     * // => true
                     */
                    function create(prototype, properties, guard) {
                        var result = baseCreate(prototype);
                        if (guard && isIterateeCall(prototype, properties, guard)) {
                            properties = undefined;
                        }
                        return properties ? baseAssign(result, properties) : result;
                    }

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object for all destination properties that resolve to `undefined`. Once a
                     * property is set, additional values of the same property are ignored.
                     *
                     * **Note:** This method mutates `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
                     * // => { 'user': 'barney', 'age': 36 }
                     */
                    var defaults = createDefaults(assign, assignDefaults);

                    /**
                     * This method is like `_.defaults` except that it recursively assigns
                     * default properties.
                     *
                     * **Note:** This method mutates `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
                     * // => { 'user': { 'name': 'barney', 'age': 36 } }
                     *
                     */
                    var defaultsDeep = createDefaults(merge, mergeDefaults);

                    /**
                     * This method is like `_.find` except that it returns the key of the first
                     * element `predicate` returns truthy for instead of the element itself.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
                     * @example
                     *
                     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
                     *
                     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
                     * // => 'barney' (iteration order is not guaranteed)
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findKey(users, { 'age': 1, 'active': true });
                     * // => 'pebbles'
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findKey(users, 'active', false);
                     * // => 'fred'
                     *
                     * // using the `_.property` callback shorthand
                     * _.findKey(users, 'active');
                     * // => 'barney'
                     */
                    var findKey = createFindKey(baseForOwn);

                    /**
                     * This method is like `_.findKey` except that it iterates over elements of
                     * a collection in the opposite order.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
                     * @example
                     *
                     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
                     *
                     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
                     * // => returns `pebbles` assuming `_.findKey` returns `barney`
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findLastKey(users, { 'age': 36, 'active': true });
                     * // => 'barney'
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findLastKey(users, 'active', false);
                     * // => 'fred'
                     *
                     * // using the `_.property` callback shorthand
                     * _.findLastKey(users, 'active');
                     * // => 'pebbles'
                     */
                    var findLastKey = createFindKey(baseForOwnRight);

                    /**
                     * Iterates over own and inherited enumerable properties of an object invoking
                     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
                     * with three arguments: (value, key, object). Iteratee functions may exit
                     * iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
                     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
                     */
                    var forIn = createForIn(baseFor);

                    /**
                     * This method is like `_.forIn` except that it iterates over properties of
                     * `object` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
                     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
                     */
                    var forInRight = createForIn(baseForRight);

                    /**
                     * Iterates over own enumerable properties of an object invoking `iteratee`
                     * for each property. The `iteratee` is bound to `thisArg` and invoked with
                     * three arguments: (value, key, object). Iteratee functions may exit iteration
                     * early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
                     * // => logs 'a' and 'b' (iteration order is not guaranteed)
                     */
                    var forOwn = createForOwn(baseForOwn);

                    /**
                     * This method is like `_.forOwn` except that it iterates over properties of
                     * `object` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
                     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
                     */
                    var forOwnRight = createForOwn(baseForOwnRight);

                    /**
                     * Creates an array of function property names from all enumerable properties,
                     * own and inherited, of `object`.
                     *
                     * @static
                     * @memberOf _
                     * @alias methods
                     * @category Object
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns the new array of property names.
                     * @example
                     *
                     * _.functions(_);
                     * // => ['after', 'ary', 'assign', ...]
                     */
                    function functions(object) {
                        return baseFunctions(object, keysIn(object));
                    }

                    /**
                     * Gets the property value at `path` of `object`. If the resolved value is
                     * `undefined` the `defaultValue` is used in its place.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the property to get.
                     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                     *
                     * _.get(object, 'a[0].b.c');
                     * // => 3
                     *
                     * _.get(object, ['a', '0', 'b', 'c']);
                     * // => 3
                     *
                     * _.get(object, 'a.b.c', 'default');
                     * // => 'default'
                     */
                    function get(object, path, defaultValue) {
                        var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
                        return result === undefined ? defaultValue : result;
                    }

                    /**
                     * Checks if `path` is a direct property.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path to check.
                     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
                     * @example
                     *
                     * var object = { 'a': { 'b': { 'c': 3 } } };
                     *
                     * _.has(object, 'a');
                     * // => true
                     *
                     * _.has(object, 'a.b.c');
                     * // => true
                     *
                     * _.has(object, ['a', 'b', 'c']);
                     * // => true
                     */
                    function has(object, path) {
                        if (object == null) {
                            return false;
                        }
                        var result = hasOwnProperty.call(object, path);
                        if (!result && !isKey(path)) {
                            path = toPath(path);
                            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                            if (object == null) {
                                return false;
                            }
                            path = last(path);
                            result = hasOwnProperty.call(object, path);
                        }
                        return result || (isLength(object.length) && isIndex(path, object.length) &&
                            (isArray(object) || isArguments(object)));
                    }

                    /**
                     * Creates an object composed of the inverted keys and values of `object`.
                     * If `object` contains duplicate values, subsequent values overwrite property
                     * assignments of previous values unless `multiValue` is `true`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to invert.
                     * @param {boolean} [multiValue] Allow multiple values per key.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Object} Returns the new inverted object.
                     * @example
                     *
                     * var object = { 'a': 1, 'b': 2, 'c': 1 };
                     *
                     * _.invert(object);
                     * // => { '1': 'c', '2': 'b' }
                     *
                     * // with `multiValue`
                     * _.invert(object, true);
                     * // => { '1': ['a', 'c'], '2': ['b'] }
                     */
                    function invert(object, multiValue, guard) {
                        if (guard && isIterateeCall(object, multiValue, guard)) {
                            multiValue = undefined;
                        }
                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = {};

                        while (++index < length) {
                            var key = props[index],
                                value = object[key];

                            if (multiValue) {
                                if (hasOwnProperty.call(result, value)) {
                                    result[value].push(key);
                                } else {
                                    result[value] = [key];
                                }
                            }
                            else {
                                result[value] = key;
                            }
                        }
                        return result;
                    }

                    /**
                     * Creates an array of the own enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects. See the
                     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
                     * for more details.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keys(new Foo);
                     * // => ['a', 'b'] (iteration order is not guaranteed)
                     *
                     * _.keys('hi');
                     * // => ['0', '1']
                     */
                    var keys = !nativeKeys ? shimKeys : function (object) {
                        var Ctor = object == null ? undefined : object.constructor;
                        if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
                            (typeof object != 'function' && isArrayLike(object))) {
                            return shimKeys(object);
                        }
                        return isObject(object) ? nativeKeys(object) : [];
                    };

                    /**
                     * Creates an array of the own and inherited enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keysIn(new Foo);
                     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                     */
                    function keysIn(object) {
                        if (object == null) {
                            return [];
                        }
                        if (!isObject(object)) {
                            object = Object(object);
                        }
                        var length = object.length;
                        length = (length && isLength(length) &&
                        (isArray(object) || isArguments(object)) && length) || 0;

                        var Ctor = object.constructor,
                            index = -1,
                            isProto = typeof Ctor == 'function' && Ctor.prototype === object,
                            result = Array(length),
                            skipIndexes = length > 0;

                        while (++index < length) {
                            result[index] = (index + '');
                        }
                        for (var key in object) {
                            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                                result.push(key);
                            }
                        }
                        return result;
                    }

                    /**
                     * The opposite of `_.mapValues`; this method creates an object with the
                     * same values as `object` and keys generated by running each own enumerable
                     * property of `object` through `iteratee`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the new mapped object.
                     * @example
                     *
                     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
                     * // => { 'a1': 1, 'b2': 2 }
                     */
                    var mapKeys = createObjectMapper(true);

                    /**
                     * Creates an object with the same keys as `object` and values generated by
                     * running each own enumerable property of `object` through `iteratee`. The
                     * iteratee function is bound to `thisArg` and invoked with three arguments:
                     * (value, key, object).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the new mapped object.
                     * @example
                     *
                     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
                     * // => { 'a': 3, 'b': 6 }
                     *
                     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
                     *
                     * // using the `_.property` callback shorthand
                     * _.mapValues(users, 'age');
                     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                     */
                    var mapValues = createObjectMapper();

                    /**
                     * The opposite of `_.pick`; this method creates an object composed of the
                     * own and inherited enumerable properties of `object` that are not omitted.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The source object.
                     * @param {Function|...(string|string[])} [predicate] The function invoked per
                     *  iteration or property names to omit, specified as individual property
                     *  names or arrays of property names.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * var object = { 'user': 'fred', 'age': 40 };
                     *
                     * _.omit(object, 'age');
                     * // => { 'user': 'fred' }
                     *
                     * _.omit(object, _.isNumber);
                     * // => { 'user': 'fred' }
                     */
                    var omit = restParam(function (object, props) {
                        if (object == null) {
                            return {};
                        }
                        if (typeof props[0] != 'function') {
                            var props = arrayMap(baseFlatten(props), String);
                            return pickByArray(object, baseDifference(keysIn(object), props));
                        }
                        var predicate = bindCallback(props[0], props[1], 3);
                        return pickByCallback(object, function (value, key, object) {
                            return !predicate(value, key, object);
                        });
                    });

                    /**
                     * Creates a two dimensional array of the key-value pairs for `object`,
                     * e.g. `[[key1, value1], [key2, value2]]`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the new array of key-value pairs.
                     * @example
                     *
                     * _.pairs({ 'barney': 36, 'fred': 40 });
                     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
                     */
                    function pairs(object) {
                        object = toObject(object);

                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            var key = props[index];
                            result[index] = [key, object[key]];
                        }
                        return result;
                    }

                    /**
                     * Creates an object composed of the picked `object` properties. Property
                     * names may be specified as individual arguments or as arrays of property
                     * names. If `predicate` is provided it is invoked for each property of `object`
                     * picking the properties `predicate` returns truthy for. The predicate is
                     * bound to `thisArg` and invoked with three arguments: (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The source object.
                     * @param {Function|...(string|string[])} [predicate] The function invoked per
                     *  iteration or property names to pick, specified as individual property
                     *  names or arrays of property names.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * var object = { 'user': 'fred', 'age': 40 };
                     *
                     * _.pick(object, 'user');
                     * // => { 'user': 'fred' }
                     *
                     * _.pick(object, _.isString);
                     * // => { 'user': 'fred' }
                     */
                    var pick = restParam(function (object, props) {
                        if (object == null) {
                            return {};
                        }
                        return typeof props[0] == 'function'
                            ? pickByCallback(object, bindCallback(props[0], props[1], 3))
                            : pickByArray(object, baseFlatten(props));
                    });

                    /**
                     * This method is like `_.get` except that if the resolved value is a function
                     * it is invoked with the `this` binding of its parent object and its result
                     * is returned.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the property to resolve.
                     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
                     *
                     * _.result(object, 'a[0].b.c1');
                     * // => 3
                     *
                     * _.result(object, 'a[0].b.c2');
                     * // => 4
                     *
                     * _.result(object, 'a.b.c', 'default');
                     * // => 'default'
                     *
                     * _.result(object, 'a.b.c', _.constant('default'));
                     * // => 'default'
                     */
                    function result(object, path, defaultValue) {
                        var result = object == null ? undefined : object[path];
                        if (result === undefined) {
                            if (object != null && !isKey(path, object)) {
                                path = toPath(path);
                                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                result = object == null ? undefined : object[last(path)];
                            }
                            result = result === undefined ? defaultValue : result;
                        }
                        return isFunction(result) ? result.call(object) : result;
                    }

                    /**
                     * Sets the property value of `path` on `object`. If a portion of `path`
                     * does not exist it is created.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to augment.
                     * @param {Array|string} path The path of the property to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                     *
                     * _.set(object, 'a[0].b.c', 4);
                     * console.log(object.a[0].b.c);
                     * // => 4
                     *
                     * _.set(object, 'x[0].y.z', 5);
                     * console.log(object.x[0].y.z);
                     * // => 5
                     */
                    function set(object, path, value) {
                        if (object == null) {
                            return object;
                        }
                        var pathKey = (path + '');
                        path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

                        var index = -1,
                            length = path.length,
                            lastIndex = length - 1,
                            nested = object;

                        while (nested != null && ++index < length) {
                            var key = path[index];
                            if (isObject(nested)) {
                                if (index == lastIndex) {
                                    nested[key] = value;
                                } else if (nested[key] == null) {
                                    nested[key] = isIndex(path[index + 1]) ? [] : {};
                                }
                            }
                            nested = nested[key];
                        }
                        return object;
                    }

                    /**
                     * An alternative to `_.reduce`; this method transforms `object` to a new
                     * `accumulator` object which is the result of running each of its own enumerable
                     * properties through `iteratee`, with each invocation potentially mutating
                     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
                     * with four arguments: (accumulator, value, key, object). Iteratee functions
                     * may exit iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Array|Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The custom accumulator value.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
                     * // => [4, 9]
                     *
                     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
                     * // => { 'a': 3, 'b': 6 }
                     */
                    function transform(object, iteratee, accumulator, thisArg) {
                        var isArr = isArray(object) || isTypedArray(object);
                        iteratee = getCallback(iteratee, thisArg, 4);

                        if (accumulator == null) {
                            if (isArr || isObject(object)) {
                                var Ctor = object.constructor;
                                if (isArr) {
                                    accumulator = isArray(object) ? new Ctor : [];
                                } else {
                                    accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
                                }
                            } else {
                                accumulator = {};
                            }
                        }
                        (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
                            return iteratee(accumulator, value, index, object);
                        });
                        return accumulator;
                    }

                    /**
                     * Creates an array of the own enumerable property values of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property values.
                     * @example
                     *
                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.values(new Foo);
                     * // => [1, 2] (iteration order is not guaranteed)
                     *
                     * _.values('hi');
                     * // => ['h', 'i']
                     */
                    function values(object) {
                        return baseValues(object, keys(object));
                    }

                    /**
                     * Creates an array of the own and inherited enumerable property values
                     * of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property values.
                     * @example
                     *
                     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.valuesIn(new Foo);
                     * // => [1, 2, 3] (iteration order is not guaranteed)
                     */
                    function valuesIn(object) {
                        return baseValues(object, keysIn(object));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Checks if `n` is between `start` and up to but not including, `end`. If
                     * `end` is not specified it is set to `start` with `start` then set to `0`.
                     *
                     * @static
                     * @memberOf _
                     * @category Number
                     * @param {number} n The number to check.
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
                     * @example
                     *
                     * _.inRange(3, 2, 4);
                     * // => true
                     *
                     * _.inRange(4, 8);
                     * // => true
                     *
                     * _.inRange(4, 2);
                     * // => false
                     *
                     * _.inRange(2, 2);
                     * // => false
                     *
                     * _.inRange(1.2, 2);
                     * // => true
                     *
                     * _.inRange(5.2, 4);
                     * // => false
                     */
                    function inRange(value, start, end) {
                        start = +start || 0;
                        if (end === undefined) {
                            end = start;
                            start = 0;
                        } else {
                            end = +end || 0;
                        }
                        return value >= nativeMin(start, end) && value < nativeMax(start, end);
                    }

                    /**
                     * Produces a random number between `min` and `max` (inclusive). If only one
                     * argument is provided a number between `0` and the given number is returned.
                     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
                     * number is returned instead of an integer.
                     *
                     * @static
                     * @memberOf _
                     * @category Number
                     * @param {number} [min=0] The minimum possible value.
                     * @param {number} [max=1] The maximum possible value.
                     * @param {boolean} [floating] Specify returning a floating-point number.
                     * @returns {number} Returns the random number.
                     * @example
                     *
                     * _.random(0, 5);
                     * // => an integer between 0 and 5
                     *
                     * _.random(5);
                     * // => also an integer between 0 and 5
                     *
                     * _.random(5, true);
                     * // => a floating-point number between 0 and 5
                     *
                     * _.random(1.2, 5.2);
                     * // => a floating-point number between 1.2 and 5.2
                     */
                    function random(min, max, floating) {
                        if (floating && isIterateeCall(min, max, floating)) {
                            max = floating = undefined;
                        }
                        var noMin = min == null,
                            noMax = max == null;

                        if (floating == null) {
                            if (noMax && typeof min == 'boolean') {
                                floating = min;
                                min = 1;
                            }
                            else if (typeof max == 'boolean') {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                            noMax = false;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
                        }
                        return baseRandom(min, max);
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the camel cased string.
                     * @example
                     *
                     * _.camelCase('Foo Bar');
                     * // => 'fooBar'
                     *
                     * _.camelCase('--foo-bar');
                     * // => 'fooBar'
                     *
                     * _.camelCase('__foo_bar__');
                     * // => 'fooBar'
                     */
                    var camelCase = createCompounder(function (result, word, index) {
                        word = word.toLowerCase();
                        return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
                    });

                    /**
                     * Capitalizes the first character of `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to capitalize.
                     * @returns {string} Returns the capitalized string.
                     * @example
                     *
                     * _.capitalize('fred');
                     * // => 'Fred'
                     */
                    function capitalize(string) {
                        string = baseToString(string);
                        return string && (string.charAt(0).toUpperCase() + string.slice(1));
                    }

                    /**
                     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
                     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to deburr.
                     * @returns {string} Returns the deburred string.
                     * @example
                     *
                     * _.deburr('déjà vu');
                     * // => 'deja vu'
                     */
                    function deburr(string) {
                        string = baseToString(string);
                        return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
                    }

                    /**
                     * Checks if `string` ends with the given target string.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to search.
                     * @param {string} [target] The string to search for.
                     * @param {number} [position=string.length] The position to search from.
                     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
                     * @example
                     *
                     * _.endsWith('abc', 'c');
                     * // => true
                     *
                     * _.endsWith('abc', 'b');
                     * // => false
                     *
                     * _.endsWith('abc', 'b', 2);
                     * // => true
                     */
                    function endsWith(string, target, position) {
                        string = baseToString(string);
                        target = (target + '');

                        var length = string.length;
                        position = position === undefined
                            ? length
                            : nativeMin(position < 0 ? 0 : (+position || 0), length);

                        position -= target.length;
                        return position >= 0 && string.indexOf(target, position) == position;
                    }

                    /**
                     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
                     * their corresponding HTML entities.
                     *
                     * **Note:** No other characters are escaped. To escape additional characters
                     * use a third-party library like [_he_](https://mths.be/he).
                     *
                     * Though the ">" character is escaped for symmetry, characters like
                     * ">" and "/" don't need escaping in HTML and have no special meaning
                     * unless they're part of a tag or unquoted attribute value.
                     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
                     * (under "semi-related fun fact") for more details.
                     *
                     * Backticks are escaped because in Internet Explorer < 9, they can break out
                     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
                     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
                     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
                     * for more details.
                     *
                     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
                     * to reduce XSS vectors.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to escape.
                     * @returns {string} Returns the escaped string.
                     * @example
                     *
                     * _.escape('fred, barney, & pebbles');
                     * // => 'fred, barney, &amp; pebbles'
                     */
                    function escape(string) {
                        // Reset `lastIndex` because in IE < 9 `String#replace` does not.
                        string = baseToString(string);
                        return (string && reHasUnescapedHtml.test(string))
                            ? string.replace(reUnescapedHtml, escapeHtmlChar)
                            : string;
                    }

                    /**
                     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
                     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to escape.
                     * @returns {string} Returns the escaped string.
                     * @example
                     *
                     * _.escapeRegExp('[lodash](https://lodash.com/)');
                     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
                     */
                    function escapeRegExp(string) {
                        string = baseToString(string);
                        return (string && reHasRegExpChars.test(string))
                            ? string.replace(reRegExpChars, escapeRegExpChar)
                            : (string || '(?:)');
                    }

                    /**
                     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the kebab cased string.
                     * @example
                     *
                     * _.kebabCase('Foo Bar');
                     * // => 'foo-bar'
                     *
                     * _.kebabCase('fooBar');
                     * // => 'foo-bar'
                     *
                     * _.kebabCase('__foo_bar__');
                     * // => 'foo-bar'
                     */
                    var kebabCase = createCompounder(function (result, word, index) {
                        return result + (index ? '-' : '') + word.toLowerCase();
                    });

                    /**
                     * Pads `string` on the left and right sides if it's shorter than `length`.
                     * Padding characters are truncated if they can't be evenly divided by `length`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to pad.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the padded string.
                     * @example
                     *
                     * _.pad('abc', 8);
                     * // => '  abc   '
                     *
                     * _.pad('abc', 8, '_-');
                     * // => '_-abc_-_'
                     *
                     * _.pad('abc', 3);
                     * // => 'abc'
                     */
                    function pad(string, length, chars) {
                        string = baseToString(string);
                        length = +length;

                        var strLength = string.length;
                        if (strLength >= length || !nativeIsFinite(length)) {
                            return string;
                        }
                        var mid = (length - strLength) / 2,
                            leftLength = nativeFloor(mid),
                            rightLength = nativeCeil(mid);

                        chars = createPadding('', rightLength, chars);
                        return chars.slice(0, leftLength) + string + chars;
                    }

                    /**
                     * Pads `string` on the left side if it's shorter than `length`. Padding
                     * characters are truncated if they exceed `length`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to pad.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the padded string.
                     * @example
                     *
                     * _.padLeft('abc', 6);
                     * // => '   abc'
                     *
                     * _.padLeft('abc', 6, '_-');
                     * // => '_-_abc'
                     *
                     * _.padLeft('abc', 3);
                     * // => 'abc'
                     */
                    var padLeft = createPadDir();

                    /**
                     * Pads `string` on the right side if it's shorter than `length`. Padding
                     * characters are truncated if they exceed `length`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to pad.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the padded string.
                     * @example
                     *
                     * _.padRight('abc', 6);
                     * // => 'abc   '
                     *
                     * _.padRight('abc', 6, '_-');
                     * // => 'abc_-_'
                     *
                     * _.padRight('abc', 3);
                     * // => 'abc'
                     */
                    var padRight = createPadDir(true);

                    /**
                     * Converts `string` to an integer of the specified radix. If `radix` is
                     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
                     * in which case a `radix` of `16` is used.
                     *
                     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
                     * of `parseInt`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} string The string to convert.
                     * @param {number} [radix] The radix to interpret `value` by.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {number} Returns the converted integer.
                     * @example
                     *
                     * _.parseInt('08');
                     * // => 8
                     *
                     * _.map(['6', '08', '10'], _.parseInt);
                     * // => [6, 8, 10]
                     */
                    function parseInt(string, radix, guard) {
                        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
                        // Chrome fails to trim leading <BOM> whitespace characters.
                        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
                        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
                            radix = 0;
                        } else if (radix) {
                            radix = +radix;
                        }
                        string = trim(string);
                        return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
                    }

                    /**
                     * Repeats the given string `n` times.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to repeat.
                     * @param {number} [n=0] The number of times to repeat the string.
                     * @returns {string} Returns the repeated string.
                     * @example
                     *
                     * _.repeat('*', 3);
                     * // => '***'
                     *
                     * _.repeat('abc', 2);
                     * // => 'abcabc'
                     *
                     * _.repeat('abc', 0);
                     * // => ''
                     */
                    function repeat(string, n) {
                        var result = '';
                        string = baseToString(string);
                        n = +n;
                        if (n < 1 || !string || !nativeIsFinite(n)) {
                            return result;
                        }
                        // Leverage the exponentiation by squaring algorithm for a faster repeat.
                        // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                        do {
                            if (n % 2) {
                                result += string;
                            }
                            n = nativeFloor(n / 2);
                            string += string;
                        } while (n);

                        return result;
                    }

                    /**
                     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the snake cased string.
                     * @example
                     *
                     * _.snakeCase('Foo Bar');
                     * // => 'foo_bar'
                     *
                     * _.snakeCase('fooBar');
                     * // => 'foo_bar'
                     *
                     * _.snakeCase('--foo-bar');
                     * // => 'foo_bar'
                     */
                    var snakeCase = createCompounder(function (result, word, index) {
                        return result + (index ? '_' : '') + word.toLowerCase();
                    });

                    /**
                     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the start cased string.
                     * @example
                     *
                     * _.startCase('--foo-bar');
                     * // => 'Foo Bar'
                     *
                     * _.startCase('fooBar');
                     * // => 'Foo Bar'
                     *
                     * _.startCase('__foo_bar__');
                     * // => 'Foo Bar'
                     */
                    var startCase = createCompounder(function (result, word, index) {
                        return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
                    });

                    /**
                     * Checks if `string` starts with the given target string.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to search.
                     * @param {string} [target] The string to search for.
                     * @param {number} [position=0] The position to search from.
                     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
                     * @example
                     *
                     * _.startsWith('abc', 'a');
                     * // => true
                     *
                     * _.startsWith('abc', 'b');
                     * // => false
                     *
                     * _.startsWith('abc', 'b', 1);
                     * // => true
                     */
                    function startsWith(string, target, position) {
                        string = baseToString(string);
                        position = position == null
                            ? 0
                            : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

                        return string.lastIndexOf(target, position) == position;
                    }

                    /**
                     * Creates a compiled template function that can interpolate data properties
                     * in "interpolate" delimiters, HTML-escape interpolated data properties in
                     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
                     * properties may be accessed as free variables in the template. If a setting
                     * object is provided it takes precedence over `_.templateSettings` values.
                     *
                     * **Note:** In the development build `_.template` utilizes
                     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
                     * for easier debugging.
                     *
                     * For more information on precompiling templates see
                     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
                     *
                     * For more information on Chrome extension sandboxes see
                     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The template string.
                     * @param {Object} [options] The options object.
                     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
                     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
                     * @param {Object} [options.imports] An object to import into the template as free variables.
                     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
                     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
                     * @param {string} [options.variable] The data object variable name.
                     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
                     * @returns {Function} Returns the compiled template function.
                     * @example
                     *
                     * // using the "interpolate" delimiter to create a compiled template
                     * var compiled = _.template('hello <%= user %>!');
                     * compiled({ 'user': 'fred' });
                     * // => 'hello fred!'
                     *
                     * // using the HTML "escape" delimiter to escape data property values
                     * var compiled = _.template('<b><%- value %></b>');
                     * compiled({ 'value': '<script>' });
                     * // => '<b>&lt;script&gt;</b>'
                     *
                     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
                     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
                     * compiled({ 'users': ['fred', 'barney'] });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the internal `print` function in "evaluate" delimiters
                     * var compiled = _.template('<% print("hello " + user); %>!');
                     * compiled({ 'user': 'barney' });
                     * // => 'hello barney!'
                     *
                     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
                     * var compiled = _.template('hello ${ user }!');
                     * compiled({ 'user': 'pebbles' });
                     * // => 'hello pebbles!'
                     *
                     * // using custom template delimiters
                     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
                     * var compiled = _.template('hello {{ user }}!');
                     * compiled({ 'user': 'mustache' });
                     * // => 'hello mustache!'
                     *
                     * // using backslashes to treat delimiters as plain text
                     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
                     * compiled({ 'value': 'ignored' });
                     * // => '<%- value %>'
                     *
                     * // using the `imports` option to import `jQuery` as `jq`
                     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
                     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
                     * compiled({ 'users': ['fred', 'barney'] });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the `sourceURL` option to specify a custom sourceURL for the template
                     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
                     * compiled(data);
                     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
                     *
                     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
                     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
                     * compiled.source;
                     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
                     *
                     * // using the `source` property to inline compiled templates for meaningful
                     * // line numbers in error messages and a stack trace
                     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
                     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
                     * ');
                     */
                    function template(string, options, otherOptions) {
                        // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
                        // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                        var settings = lodash.templateSettings;

                        if (otherOptions && isIterateeCall(string, options, otherOptions)) {
                            options = otherOptions = undefined;
                        }
                        string = baseToString(string);
                        options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

                        var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
                            importsKeys = keys(imports),
                            importsValues = baseValues(imports, importsKeys);

                        var isEscaping,
                            isEvaluating,
                            index = 0,
                            interpolate = options.interpolate || reNoMatch,
                            source = "__p += '";

                        // Compile the regexp to match each delimiter.
                        var reDelimiters = RegExp(
                            (options.escape || reNoMatch).source + '|' +
                            interpolate.source + '|' +
                            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                            (options.evaluate || reNoMatch).source + '|$'
                            , 'g');

                        // Use a sourceURL for easier debugging.
                        var sourceURL = '//# sourceURL=' +
                            ('sourceURL' in options
                                ? options.sourceURL
                                : ('lodash.templateSources[' + (++templateCounter) + ']')
                            ) + '\n';

                        string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);

                            // Escape characters that can't be included in string literals.
                            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                            // Replace delimiters with snippets.
                            if (escapeValue) {
                                isEscaping = true;
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;

                            // The JS engine embedded in Adobe products requires returning the `match`
                            // string in order to produce the correct `offset` value.
                            return match;
                        });

                        source += "';\n";

                        // If `variable` is not specified wrap a with-statement around the generated
                        // code to add the data object to the top of the scope chain.
                        var variable = options.variable;
                        if (!variable) {
                            source = 'with (obj) {\n' + source + '\n}\n';
                        }
                        // Cleanup code by stripping empty strings.
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                            .replace(reEmptyStringMiddle, '$1')
                            .replace(reEmptyStringTrailing, '$1;');

                        // Frame code as the function body.
                        source = 'function(' + (variable || 'obj') + ') {\n' +
                        (variable
                            ? ''
                            : 'obj || (obj = {});\n'
                        ) +
                        "var __t, __p = ''" +
                        (isEscaping
                            ? ', __e = _.escape'
                            : ''
                        ) +
                        (isEvaluating
                            ? ', __j = Array.prototype.join;\n' +
                        "function print() { __p += __j.call(arguments, '') }\n"
                            : ';\n'
                        ) +
                        source +
                        'return __p\n}';

                        var result = attempt(function () {
                            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
                        });

                        // Provide the compiled function's source by its `toString` method or
                        // the `source` property as a convenience for inlining compiled templates.
                        result.source = source;
                        if (isError(result)) {
                            throw result;
                        }
                        return result;
                    }

                    /**
                     * Removes leading and trailing whitespace or specified characters from `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to trim.
                     * @param {string} [chars=whitespace] The characters to trim.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the trimmed string.
                     * @example
                     *
                     * _.trim('  abc  ');
                     * // => 'abc'
                     *
                     * _.trim('-_-abc-_-', '_-');
                     * // => 'abc'
                     *
                     * _.map(['  foo  ', '  bar  '], _.trim);
                     * // => ['foo', 'bar']
                     */
                    function trim(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
                        }
                        chars = (chars + '');
                        return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
                    }

                    /**
                     * Removes leading whitespace or specified characters from `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to trim.
                     * @param {string} [chars=whitespace] The characters to trim.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the trimmed string.
                     * @example
                     *
                     * _.trimLeft('  abc  ');
                     * // => 'abc  '
                     *
                     * _.trimLeft('-_-abc-_-', '_-');
                     * // => 'abc-_-'
                     */
                    function trimLeft(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(trimmedLeftIndex(string));
                        }
                        return string.slice(charsLeftIndex(string, (chars + '')));
                    }

                    /**
                     * Removes trailing whitespace or specified characters from `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to trim.
                     * @param {string} [chars=whitespace] The characters to trim.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the trimmed string.
                     * @example
                     *
                     * _.trimRight('  abc  ');
                     * // => '  abc'
                     *
                     * _.trimRight('-_-abc-_-', '_-');
                     * // => '-_-abc'
                     */
                    function trimRight(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(0, trimmedRightIndex(string) + 1);
                        }
                        return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
                    }

                    /**
                     * Truncates `string` if it's longer than the given maximum string length.
                     * The last characters of the truncated string are replaced with the omission
                     * string which defaults to "...".
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to truncate.
                     * @param {Object|number} [options] The options object or maximum string length.
                     * @param {number} [options.length=30] The maximum string length.
                     * @param {string} [options.omission='...'] The string to indicate text is omitted.
                     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the truncated string.
                     * @example
                     *
                     * _.trunc('hi-diddly-ho there, neighborino');
                     * // => 'hi-diddly-ho there, neighbo...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', 24);
                     * // => 'hi-diddly-ho there, n...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
                     * // => 'hi-diddly-ho there,...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
                     * // => 'hi-diddly-ho there...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
                     * // => 'hi-diddly-ho there, neig [...]'
                     */
                    function trunc(string, options, guard) {
                        if (guard && isIterateeCall(string, options, guard)) {
                            options = undefined;
                        }
                        var length = DEFAULT_TRUNC_LENGTH,
                            omission = DEFAULT_TRUNC_OMISSION;

                        if (options != null) {
                            if (isObject(options)) {
                                var separator = 'separator' in options ? options.separator : separator;
                                length = 'length' in options ? (+options.length || 0) : length;
                                omission = 'omission' in options ? baseToString(options.omission) : omission;
                            } else {
                                length = +options || 0;
                            }
                        }
                        string = baseToString(string);
                        if (length >= string.length) {
                            return string;
                        }
                        var end = length - omission.length;
                        if (end < 1) {
                            return omission;
                        }
                        var result = string.slice(0, end);
                        if (separator == null) {
                            return result + omission;
                        }
                        if (isRegExp(separator)) {
                            if (string.slice(end).search(separator)) {
                                var match,
                                    newEnd,
                                    substring = string.slice(0, end);

                                if (!separator.global) {
                                    separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
                                }
                                separator.lastIndex = 0;
                                while ((match = separator.exec(substring))) {
                                    newEnd = match.index;
                                }
                                result = result.slice(0, newEnd == null ? end : newEnd);
                            }
                        } else if (string.indexOf(separator, end) != end) {
                            var index = result.lastIndexOf(separator);
                            if (index > -1) {
                                result = result.slice(0, index);
                            }
                        }
                        return result + omission;
                    }

                    /**
                     * The inverse of `_.escape`; this method converts the HTML entities
                     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
                     * corresponding characters.
                     *
                     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
                     * entities use a third-party library like [_he_](https://mths.be/he).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to unescape.
                     * @returns {string} Returns the unescaped string.
                     * @example
                     *
                     * _.unescape('fred, barney, &amp; pebbles');
                     * // => 'fred, barney, & pebbles'
                     */
                    function unescape(string) {
                        string = baseToString(string);
                        return (string && reHasEscapedHtml.test(string))
                            ? string.replace(reEscapedHtml, unescapeHtmlChar)
                            : string;
                    }

                    /**
                     * Splits `string` into an array of its words.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to inspect.
                     * @param {RegExp|string} [pattern] The pattern to match words.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the words of `string`.
                     * @example
                     *
                     * _.words('fred, barney, & pebbles');
                     * // => ['fred', 'barney', 'pebbles']
                     *
                     * _.words('fred, barney, & pebbles', /[^, ]+/g);
                     * // => ['fred', 'barney', '&', 'pebbles']
                     */
                    function words(string, pattern, guard) {
                        if (guard && isIterateeCall(string, pattern, guard)) {
                            pattern = undefined;
                        }
                        string = baseToString(string);
                        return string.match(pattern || reWords) || [];
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Attempts to invoke `func`, returning either the result or the caught error
                     * object. Any additional arguments are provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Function} func The function to attempt.
                     * @returns {*} Returns the `func` result or error object.
                     * @example
                     *
                     * // avoid throwing errors for invalid selectors
                     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
                     *
                     * if (_.isError(elements)) {
     *   elements = [];
     * }
                     */
                    var attempt = restParam(function (func, args) {
                        try {
                            return func.apply(undefined, args);
                        } catch (e) {
                            return isError(e) ? e : new Error(e);
                        }
                    });

                    /**
                     * Creates a function that invokes `func` with the `this` binding of `thisArg`
                     * and arguments of the created function. If `func` is a property name the
                     * created callback returns the property value for a given element. If `func`
                     * is an object the created callback returns `true` for elements that contain
                     * the equivalent object properties, otherwise it returns `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias iteratee
                     * @category Utility
                     * @param {*} [func=_.identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the callback.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * // wrap to create custom callback shorthands
                     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
                     *
                     * _.filter(users, 'age__gt36');
                     * // => [{ 'user': 'fred', 'age': 40 }]
                     */
                    function callback(func, thisArg, guard) {
                        if (guard && isIterateeCall(func, thisArg, guard)) {
                            thisArg = undefined;
                        }
                        return isObjectLike(func)
                            ? matches(func)
                            : baseCallback(func, thisArg);
                    }

                    /**
                     * Creates a function that returns `value`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {*} value The value to return from the new function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     * var getter = _.constant(object);
                     *
                     * getter() === object;
                     * // => true
                     */
                    function constant(value) {
                        return function () {
                            return value;
                        };
                    }

                    /**
                     * This method returns the first argument provided to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {*} value Any value.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     *
                     * _.identity(object) === object;
                     * // => true
                     */
                    function identity(value) {
                        return value;
                    }

                    /**
                     * Creates a function that performs a deep comparison between a given object
                     * and `source`, returning `true` if the given object has equivalent property
                     * values, else `false`.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. For comparing a single
                     * own or inherited property value see `_.matchesProperty`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Object} source The object of property values to match.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
                     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
                     */
                    function matches(source) {
                        return baseMatches(baseClone(source, true));
                    }

                    /**
                     * Creates a function that compares the property value of `path` on a given
                     * object to `value`.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Array|string} path The path of the property to get.
                     * @param {*} srcValue The value to match.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * _.find(users, _.matchesProperty('user', 'fred'));
                     * // => { 'user': 'fred' }
                     */
                    function matchesProperty(path, srcValue) {
                        return baseMatchesProperty(path, baseClone(srcValue, true));
                    }

                    /**
                     * Creates a function that invokes the method at `path` on a given object.
                     * Any additional arguments are provided to the invoked method.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Array|string} path The path of the method to invoke.
                     * @param {...*} [args] The arguments to invoke the method with.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var objects = [
                     *   { 'a': { 'b': { 'c': _.constant(2) } } },
                     *   { 'a': { 'b': { 'c': _.constant(1) } } }
                     * ];
                     *
                     * _.map(objects, _.method('a.b.c'));
                     * // => [2, 1]
                     *
                     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
                     * // => [1, 2]
                     */
                    var method = restParam(function (path, args) {
                        return function (object) {
                            return invokePath(object, path, args);
                        };
                    });

                    /**
                     * The opposite of `_.method`; this method creates a function that invokes
                     * the method at a given path on `object`. Any additional arguments are
                     * provided to the invoked method.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Object} object The object to query.
                     * @param {...*} [args] The arguments to invoke the method with.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var array = _.times(3, _.constant),
                     *     object = { 'a': array, 'b': array, 'c': array };
                     *
                     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
                     * // => [2, 0]
                     *
                     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
                     * // => [2, 0]
                     */
                    var methodOf = restParam(function (object, args) {
                        return function (path) {
                            return invokePath(object, path, args);
                        };
                    });

                    /**
                     * Adds all own enumerable function properties of a source object to the
                     * destination object. If `object` is a function then methods are added to
                     * its prototype as well.
                     *
                     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
                     * avoid conflicts caused by modifying the original.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Function|Object} [object=lodash] The destination object.
                     * @param {Object} source The object of functions to add.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.chain=true] Specify whether the functions added
                     *  are chainable.
                     * @returns {Function|Object} Returns `object`.
                     * @example
                     *
                     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
                     *
                     * _.mixin({ 'vowels': vowels });
                     * _.vowels('fred');
                     * // => ['e']
                     *
                     * _('fred').vowels().value();
                     * // => ['e']
                     *
                     * _.mixin({ 'vowels': vowels }, { 'chain': false });
                     * _('fred').vowels();
                     * // => ['e']
                     */
                    function mixin(object, source, options) {
                        if (options == null) {
                            var isObj = isObject(source),
                                props = isObj ? keys(source) : undefined,
                                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

                            if (!(methodNames ? methodNames.length : isObj)) {
                                methodNames = false;
                                options = source;
                                source = object;
                                object = this;
                            }
                        }
                        if (!methodNames) {
                            methodNames = baseFunctions(source, keys(source));
                        }
                        var chain = true,
                            index = -1,
                            isFunc = isFunction(object),
                            length = methodNames.length;

                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && 'chain' in options) {
                            chain = options.chain;
                        }
                        while (++index < length) {
                            var methodName = methodNames[index],
                                func = source[methodName];

                            object[methodName] = func;
                            if (isFunc) {
                                object.prototype[methodName] = (function (func) {
                                    return function () {
                                        var chainAll = this.__chain__;
                                        if (chain || chainAll) {
                                            var result = object(this.__wrapped__),
                                                actions = result.__actions__ = arrayCopy(this.__actions__);

                                            actions.push({'func': func, 'args': arguments, 'thisArg': object});
                                            result.__chain__ = chainAll;
                                            return result;
                                        }
                                        return func.apply(object, arrayPush([this.value()], arguments));
                                    };
                                }(func));
                            }
                        }
                        return object;
                    }

                    /**
                     * Reverts the `_` variable to its previous value and returns a reference to
                     * the `lodash` function.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @returns {Function} Returns the `lodash` function.
                     * @example
                     *
                     * var lodash = _.noConflict();
                     */
                    function noConflict() {
                        root._ = oldDash;
                        return this;
                    }

                    /**
                     * A no-operation function that returns `undefined` regardless of the
                     * arguments it receives.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     *
                     * _.noop(object) === undefined;
                     * // => true
                     */
                    function noop() {
                        // No operation performed.
                    }

                    /**
                     * Creates a function that returns the property value at `path` on a
                     * given object.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Array|string} path The path of the property to get.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var objects = [
                     *   { 'a': { 'b': { 'c': 2 } } },
                     *   { 'a': { 'b': { 'c': 1 } } }
                     * ];
                     *
                     * _.map(objects, _.property('a.b.c'));
                     * // => [2, 1]
                     *
                     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
                     * // => [1, 2]
                     */
                    function property(path) {
                        return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
                    }

                    /**
                     * The opposite of `_.property`; this method creates a function that returns
                     * the property value at a given path on `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Object} object The object to query.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var array = [0, 1, 2],
                     *     object = { 'a': array, 'b': array, 'c': array };
                     *
                     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
                     * // => [2, 0]
                     *
                     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
                     * // => [2, 0]
                     */
                    function propertyOf(object) {
                        return function (path) {
                            return baseGet(object, toPath(path), path + '');
                        };
                    }

                    /**
                     * Creates an array of numbers (positive and/or negative) progressing from
                     * `start` up to, but not including, `end`. If `end` is not specified it is
                     * set to `start` with `start` then set to `0`. If `end` is less than `start`
                     * a zero-length range is created unless a negative `step` is specified.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @param {number} [step=1] The value to increment or decrement by.
                     * @returns {Array} Returns the new array of numbers.
                     * @example
                     *
                     * _.range(4);
                     * // => [0, 1, 2, 3]
                     *
                     * _.range(1, 5);
                     * // => [1, 2, 3, 4]
                     *
                     * _.range(0, 20, 5);
                     * // => [0, 5, 10, 15]
                     *
                     * _.range(0, -4, -1);
                     * // => [0, -1, -2, -3]
                     *
                     * _.range(1, 4, 0);
                     * // => [1, 1, 1]
                     *
                     * _.range(0);
                     * // => []
                     */
                    function range(start, end, step) {
                        if (step && isIterateeCall(start, end, step)) {
                            end = step = undefined;
                        }
                        start = +start || 0;
                        step = step == null ? 1 : (+step || 0);

                        if (end == null) {
                            end = start;
                            start = 0;
                        } else {
                            end = +end || 0;
                        }
                        // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
                        // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
                        var index = -1,
                            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                            result = Array(length);

                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }

                    /**
                     * Invokes the iteratee function `n` times, returning an array of the results
                     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
                     * one argument; (index).
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {number} n The number of times to invoke `iteratee`.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the array of results.
                     * @example
                     *
                     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
                     * // => [3, 6, 4]
                     *
                     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
                     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
                     *
                     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
                     * // => also invokes `mage.castSpell(n)` three times
                     */
                    function times(n, iteratee, thisArg) {
                        n = nativeFloor(n);

                        // Exit early to avoid a JSC JIT bug in Safari 8
                        // where `Array(0)` is treated as `Array(1)`.
                        if (n < 1 || !nativeIsFinite(n)) {
                            return [];
                        }
                        var index = -1,
                            result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

                        iteratee = bindCallback(iteratee, thisArg, 1);
                        while (++index < n) {
                            if (index < MAX_ARRAY_LENGTH) {
                                result[index] = iteratee(index);
                            } else {
                                iteratee(index);
                            }
                        }
                        return result;
                    }

                    /**
                     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {string} [prefix] The value to prefix the ID with.
                     * @returns {string} Returns the unique ID.
                     * @example
                     *
                     * _.uniqueId('contact_');
                     * // => 'contact_104'
                     *
                     * _.uniqueId();
                     * // => '105'
                     */
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return baseToString(prefix) + id;
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Adds two numbers.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} augend The first number to add.
                     * @param {number} addend The second number to add.
                     * @returns {number} Returns the sum.
                     * @example
                     *
                     * _.add(6, 4);
                     * // => 10
                     */
                    function add(augend, addend) {
                        return (+augend || 0) + (+addend || 0);
                    }

                    /**
                     * Calculates `n` rounded up to `precision`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} n The number to round up.
                     * @param {number} [precision=0] The precision to round up to.
                     * @returns {number} Returns the rounded up number.
                     * @example
                     *
                     * _.ceil(4.006);
                     * // => 5
                     *
                     * _.ceil(6.004, 2);
                     * // => 6.01
                     *
                     * _.ceil(6040, -2);
                     * // => 6100
                     */
                    var ceil = createRound('ceil');

                    /**
                     * Calculates `n` rounded down to `precision`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} n The number to round down.
                     * @param {number} [precision=0] The precision to round down to.
                     * @returns {number} Returns the rounded down number.
                     * @example
                     *
                     * _.floor(4.006);
                     * // => 4
                     *
                     * _.floor(0.046, 2);
                     * // => 0.04
                     *
                     * _.floor(4060, -2);
                     * // => 4000
                     */
                    var floor = createRound('floor');

                    /**
                     * Gets the maximum value of `collection`. If `collection` is empty or falsey
                     * `-Infinity` is returned. If an iteratee function is provided it is invoked
                     * for each value in `collection` to generate the criterion by which the value
                     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the maximum value.
                     * @example
                     *
                     * _.max([4, 2, 8, 6]);
                     * // => 8
                     *
                     * _.max([]);
                     * // => -Infinity
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.max(users, function(chr) {
     *   return chr.age;
     * });
                     * // => { 'user': 'fred', 'age': 40 }
                     *
                     * // using the `_.property` callback shorthand
                     * _.max(users, 'age');
                     * // => { 'user': 'fred', 'age': 40 }
                     */
                    var max = createExtremum(gt, NEGATIVE_INFINITY);

                    /**
                     * Gets the minimum value of `collection`. If `collection` is empty or falsey
                     * `Infinity` is returned. If an iteratee function is provided it is invoked
                     * for each value in `collection` to generate the criterion by which the value
                     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the minimum value.
                     * @example
                     *
                     * _.min([4, 2, 8, 6]);
                     * // => 2
                     *
                     * _.min([]);
                     * // => Infinity
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.min(users, function(chr) {
     *   return chr.age;
     * });
                     * // => { 'user': 'barney', 'age': 36 }
                     *
                     * // using the `_.property` callback shorthand
                     * _.min(users, 'age');
                     * // => { 'user': 'barney', 'age': 36 }
                     */
                    var min = createExtremum(lt, POSITIVE_INFINITY);

                    /**
                     * Calculates `n` rounded to `precision`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} n The number to round.
                     * @param {number} [precision=0] The precision to round to.
                     * @returns {number} Returns the rounded number.
                     * @example
                     *
                     * _.round(4.006);
                     * // => 4
                     *
                     * _.round(4.006, 2);
                     * // => 4.01
                     *
                     * _.round(4060, -2);
                     * // => 4100
                     */
                    var round = createRound('round');

                    /**
                     * Gets the sum of the values in `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {number} Returns the sum.
                     * @example
                     *
                     * _.sum([4, 6]);
                     * // => 10
                     *
                     * _.sum({ 'a': 4, 'b': 6 });
                     * // => 10
                     *
                     * var objects = [
                     *   { 'n': 4 },
                     *   { 'n': 6 }
                     * ];
                     *
                     * _.sum(objects, function(object) {
     *   return object.n;
     * });
                     * // => 10
                     *
                     * // using the `_.property` callback shorthand
                     * _.sum(objects, 'n');
                     * // => 10
                     */
                    function sum(collection, iteratee, thisArg) {
                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                            iteratee = undefined;
                        }
                        iteratee = getCallback(iteratee, thisArg, 3);
                        return iteratee.length == 1
                            ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
                            : baseSum(collection, iteratee);
                    }

                    /*------------------------------------------------------------------------*/

                    // Ensure wrappers are instances of `baseLodash`.
                    lodash.prototype = baseLodash.prototype;

                    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                    LodashWrapper.prototype.constructor = LodashWrapper;

                    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                    LazyWrapper.prototype.constructor = LazyWrapper;

                    // Add functions to the `Map` cache.
                    MapCache.prototype['delete'] = mapDelete;
                    MapCache.prototype.get = mapGet;
                    MapCache.prototype.has = mapHas;
                    MapCache.prototype.set = mapSet;

                    // Add functions to the `Set` cache.
                    SetCache.prototype.push = cachePush;

                    // Assign cache to `_.memoize`.
                    memoize.Cache = MapCache;

                    // Add functions that return wrapped values when chaining.
                    lodash.after = after;
                    lodash.ary = ary;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.before = before;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.callback = callback;
                    lodash.chain = chain;
                    lodash.chunk = chunk;
                    lodash.compact = compact;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.curry = curry;
                    lodash.curryRight = curryRight;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defaultsDeep = defaultsDeep;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.drop = drop;
                    lodash.dropRight = dropRight;
                    lodash.dropRightWhile = dropRightWhile;
                    lodash.dropWhile = dropWhile;
                    lodash.fill = fill;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.flattenDeep = flattenDeep;
                    lodash.flow = flow;
                    lodash.flowRight = flowRight;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.keysIn = keysIn;
                    lodash.map = map;
                    lodash.mapKeys = mapKeys;
                    lodash.mapValues = mapValues;
                    lodash.matches = matches;
                    lodash.matchesProperty = matchesProperty;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.method = method;
                    lodash.methodOf = methodOf;
                    lodash.mixin = mixin;
                    lodash.modArgs = modArgs;
                    lodash.negate = negate;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.partition = partition;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.propertyOf = propertyOf;
                    lodash.pull = pull;
                    lodash.pullAt = pullAt;
                    lodash.range = range;
                    lodash.rearg = rearg;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.restParam = restParam;
                    lodash.set = set;
                    lodash.shuffle = shuffle;
                    lodash.slice = slice;
                    lodash.sortBy = sortBy;
                    lodash.sortByAll = sortByAll;
                    lodash.sortByOrder = sortByOrder;
                    lodash.spread = spread;
                    lodash.take = take;
                    lodash.takeRight = takeRight;
                    lodash.takeRightWhile = takeRightWhile;
                    lodash.takeWhile = takeWhile;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.thru = thru;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.toPlainObject = toPlainObject;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.unzip = unzip;
                    lodash.unzipWith = unzipWith;
                    lodash.values = values;
                    lodash.valuesIn = valuesIn;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.zipWith = zipWith;

                    // Add aliases.
                    lodash.backflow = flowRight;
                    lodash.collect = map;
                    lodash.compose = flowRight;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.iteratee = callback;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;

                    // Add functions to `lodash.prototype`.
                    mixin(lodash, lodash);

                    /*------------------------------------------------------------------------*/

                    // Add functions that return unwrapped values when chaining.
                    lodash.add = add;
                    lodash.attempt = attempt;
                    lodash.camelCase = camelCase;
                    lodash.capitalize = capitalize;
                    lodash.ceil = ceil;
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.deburr = deburr;
                    lodash.endsWith = endsWith;
                    lodash.escape = escape;
                    lodash.escapeRegExp = escapeRegExp;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.findWhere = findWhere;
                    lodash.first = first;
                    lodash.floor = floor;
                    lodash.get = get;
                    lodash.gt = gt;
                    lodash.gte = gte;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.includes = includes;
                    lodash.indexOf = indexOf;
                    lodash.inRange = inRange;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isError = isError;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isMatch = isMatch;
                    lodash.isNaN = isNaN;
                    lodash.isNative = isNative;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isTypedArray = isTypedArray;
                    lodash.isUndefined = isUndefined;
                    lodash.kebabCase = kebabCase;
                    lodash.last = last;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.lt = lt;
                    lodash.lte = lte;
                    lodash.max = max;
                    lodash.min = min;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.pad = pad;
                    lodash.padLeft = padLeft;
                    lodash.padRight = padRight;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.repeat = repeat;
                    lodash.result = result;
                    lodash.round = round;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.snakeCase = snakeCase;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.sortedLastIndex = sortedLastIndex;
                    lodash.startCase = startCase;
                    lodash.startsWith = startsWith;
                    lodash.sum = sum;
                    lodash.template = template;
                    lodash.trim = trim;
                    lodash.trimLeft = trimLeft;
                    lodash.trimRight = trimRight;
                    lodash.trunc = trunc;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.words = words;

                    // Add aliases.
                    lodash.all = every;
                    lodash.any = some;
                    lodash.contains = includes;
                    lodash.eq = isEqual;
                    lodash.detect = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.head = first;
                    lodash.include = includes;
                    lodash.inject = reduce;

                    mixin(lodash, (function () {
                        var source = {};
                        baseForOwn(lodash, function (func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }()), false);

                    /*------------------------------------------------------------------------*/

                    // Add functions capable of returning wrapped and unwrapped values when chaining.
                    lodash.sample = sample;

                    lodash.prototype.sample = function (n) {
                        if (!this.__chain__ && n == null) {
                            return sample(this.value());
                        }
                        return this.thru(function (value) {
                            return sample(value, n);
                        });
                    };

                    /*------------------------------------------------------------------------*/

                    /**
                     * The semantic version number.
                     *
                     * @static
                     * @memberOf _
                     * @type string
                     */
                    lodash.VERSION = VERSION;

                    // Assign default placeholders.
                    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
                        lodash[methodName].placeholder = lodash;
                    });

                    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
                    arrayEach(['drop', 'take'], function (methodName, index) {
                        LazyWrapper.prototype[methodName] = function (n) {
                            var filtered = this.__filtered__;
                            if (filtered && !index) {
                                return new LazyWrapper(this);
                            }
                            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

                            var result = this.clone();
                            if (filtered) {
                                result.__takeCount__ = nativeMin(result.__takeCount__, n);
                            } else {
                                result.__views__.push({
                                    'size': n,
                                    'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                                });
                            }
                            return result;
                        };

                        LazyWrapper.prototype[methodName + 'Right'] = function (n) {
                            return this.reverse()[methodName](n).reverse();
                        };
                    });

                    // Add `LazyWrapper` methods that accept an `iteratee` value.
                    arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
                        var type = index + 1,
                            isFilter = type != LAZY_MAP_FLAG;

                        LazyWrapper.prototype[methodName] = function (iteratee, thisArg) {
                            var result = this.clone();
                            result.__iteratees__.push({'iteratee': getCallback(iteratee, thisArg, 1), 'type': type});
                            result.__filtered__ = result.__filtered__ || isFilter;
                            return result;
                        };
                    });

                    // Add `LazyWrapper` methods for `_.first` and `_.last`.
                    arrayEach(['first', 'last'], function (methodName, index) {
                        var takeName = 'take' + (index ? 'Right' : '');

                        LazyWrapper.prototype[methodName] = function () {
                            return this[takeName](1).value()[0];
                        };
                    });

                    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
                    arrayEach(['initial', 'rest'], function (methodName, index) {
                        var dropName = 'drop' + (index ? '' : 'Right');

                        LazyWrapper.prototype[methodName] = function () {
                            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                        };
                    });

                    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
                    arrayEach(['pluck', 'where'], function (methodName, index) {
                        var operationName = index ? 'filter' : 'map',
                            createCallback = index ? baseMatches : property;

                        LazyWrapper.prototype[methodName] = function (value) {
                            return this[operationName](createCallback(value));
                        };
                    });

                    LazyWrapper.prototype.compact = function () {
                        return this.filter(identity);
                    };

                    LazyWrapper.prototype.reject = function (predicate, thisArg) {
                        predicate = getCallback(predicate, thisArg, 1);
                        return this.filter(function (value) {
                            return !predicate(value);
                        });
                    };

                    LazyWrapper.prototype.slice = function (start, end) {
                        start = start == null ? 0 : (+start || 0);

                        var result = this;
                        if (result.__filtered__ && (start > 0 || end < 0)) {
                            return new LazyWrapper(result);
                        }
                        if (start < 0) {
                            result = result.takeRight(-start);
                        } else if (start) {
                            result = result.drop(start);
                        }
                        if (end !== undefined) {
                            end = (+end || 0);
                            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                        }
                        return result;
                    };

                    LazyWrapper.prototype.takeRightWhile = function (predicate, thisArg) {
                        return this.reverse().takeWhile(predicate, thisArg).reverse();
                    };

                    LazyWrapper.prototype.toArray = function () {
                        return this.take(POSITIVE_INFINITY);
                    };

                    // Add `LazyWrapper` methods to `lodash.prototype`.
                    baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                        var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
                            retUnwrapped = /^(?:first|last)$/.test(methodName),
                            lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

                        if (!lodashFunc) {
                            return;
                        }
                        lodash.prototype[methodName] = function () {
                            var args = retUnwrapped ? [1] : arguments,
                                chainAll = this.__chain__,
                                value = this.__wrapped__,
                                isHybrid = !!this.__actions__.length,
                                isLazy = value instanceof LazyWrapper,
                                iteratee = args[0],
                                useLazy = isLazy || isArray(value);

                            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                                // Avoid lazy use if the iteratee has a "length" value other than `1`.
                                isLazy = useLazy = false;
                            }
                            var interceptor = function (value) {
                                return (retUnwrapped && chainAll)
                                    ? lodashFunc(value, 1)[0]
                                    : lodashFunc.apply(undefined, arrayPush([value], args));
                            };

                            var action = {'func': thru, 'args': [interceptor], 'thisArg': undefined},
                                onlyLazy = isLazy && !isHybrid;

                            if (retUnwrapped && !chainAll) {
                                if (onlyLazy) {
                                    value = value.clone();
                                    value.__actions__.push(action);
                                    return func.call(value);
                                }
                                return lodashFunc.call(undefined, this.value())[0];
                            }
                            if (!retUnwrapped && useLazy) {
                                value = onlyLazy ? value : new LazyWrapper(this);
                                var result = func.apply(value, args);
                                result.__actions__.push(action);
                                return new LodashWrapper(result, chainAll);
                            }
                            return this.thru(interceptor);
                        };
                    });

                    // Add `Array` and `String` methods to `lodash.prototype`.
                    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function (methodName) {
                        var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
                            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                            retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

                        lodash.prototype[methodName] = function () {
                            var args = arguments;
                            if (retUnwrapped && !this.__chain__) {
                                return func.apply(this.value(), args);
                            }
                            return this[chainName](function (value) {
                                return func.apply(value, args);
                            });
                        };
                    });

                    // Map minified function names to their real names.
                    baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                            var key = lodashFunc.name,
                                names = realNames[key] || (realNames[key] = []);

                            names.push({'name': methodName, 'func': lodashFunc});
                        }
                    });

                    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
                        'name': 'wrapper',
                        'func': undefined
                    }];

                    // Add functions to the lazy wrapper.
                    LazyWrapper.prototype.clone = lazyClone;
                    LazyWrapper.prototype.reverse = lazyReverse;
                    LazyWrapper.prototype.value = lazyValue;

                    // Add chaining functions to the `lodash` wrapper.
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.commit = wrapperCommit;
                    lodash.prototype.concat = wrapperConcat;
                    lodash.prototype.plant = wrapperPlant;
                    lodash.prototype.reverse = wrapperReverse;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

                    // Add function aliases to the `lodash` wrapper.
                    lodash.prototype.collect = lodash.prototype.map;
                    lodash.prototype.head = lodash.prototype.first;
                    lodash.prototype.select = lodash.prototype.filter;
                    lodash.prototype.tail = lodash.prototype.rest;

                    return lodash;
                }

                /*--------------------------------------------------------------------------*/

                // Export lodash.
                var _ = runInContext();

                // Some AMD build optimizers like r.js check for condition patterns like the following:
                if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                    // Expose lodash to the global object when an AMD loader is present to avoid
                    // errors in cases where lodash is loaded by a script tag and not intended
                    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
                    // more details.
                    root._ = _;

                    // Define as an anonymous module so, through path mapping, it can be
                    // referenced as the "underscore" module.
                    define(function () {
                        return _;
                    });
                }
                // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
                else if (freeExports && freeModule) {
                    // Export for Node.js or RingoJS.
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    }
                    // Export for Rhino with CommonJS support.
                    else {
                        freeExports._ = _;
                    }
                }
                else {
                    // Export for a browser or Rhino.
                    root._ = _;
                }
            }.call(this));

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/LazyWrapper.js": [function (require, module, exports) {
        var baseCreate = require('./baseCreate'),
            baseLodash = require('./baseLodash');

        /** Used as references for `-Infinity` and `Infinity`. */
        var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = POSITIVE_INFINITY;
            this.__views__ = [];
        }

        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;

        module.exports = LazyWrapper;

    }, {
        "./baseCreate": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCreate.js",
        "./baseLodash": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseLodash.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/LodashWrapper.js": [function (require, module, exports) {
        var baseCreate = require('./baseCreate'),
            baseLodash = require('./baseLodash');

        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
         * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
         */
        function LodashWrapper(value, chainAll, actions) {
            this.__wrapped__ = value;
            this.__actions__ = actions || [];
            this.__chain__ = !!chainAll;
        }

        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;

        module.exports = LodashWrapper;

    }, {
        "./baseCreate": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCreate.js",
        "./baseLodash": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseLodash.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/SetCache.js": [function (require, module, exports) {
        (function (global) {
            var cachePush = require('./cachePush'),
                getNative = require('./getNative');

            /** Native method references. */
            var Set = getNative(global, 'Set');

            /* Native method references for those with the same name as other `lodash` methods. */
            var nativeCreate = getNative(Object, 'create');

            /**
             *
             * Creates a cache object to store unique values.
             *
             * @private
             * @param {Array} [values] The values to cache.
             */
            function SetCache(values) {
                var length = values ? values.length : 0;

                this.data = {'hash': nativeCreate(null), 'set': new Set};
                while (length--) {
                    this.push(values[length]);
                }
            }

// Add functions to the `Set` cache.
            SetCache.prototype.push = cachePush;

            module.exports = SetCache;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
        "./cachePush": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/cachePush.js",
        "./getNative": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getNative.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayCopy.js": [function (require, module, exports) {
        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function arrayCopy(source, array) {
            var index = -1,
                length = source.length;

            array || (array = Array(length));
            while (++index < length) {
                array[index] = source[index];
            }
            return array;
        }

        module.exports = arrayCopy;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayEach.js": [function (require, module, exports) {
        /**
         * A specialized version of `_.forEach` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
            var index = -1,
                length = array.length;

            while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                    break;
                }
            }
            return array;
        }

        module.exports = arrayEach;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayEvery.js": [function (require, module, exports) {
        /**
         * A specialized version of `_.every` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         */
        function arrayEvery(array, predicate) {
            var index = -1,
                length = array.length;

            while (++index < length) {
                if (!predicate(array[index], index, array)) {
                    return false;
                }
            }
            return true;
        }

        module.exports = arrayEvery;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayFilter.js": [function (require, module, exports) {
        /**
         * A specialized version of `_.filter` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
            var index = -1,
                length = array.length,
                resIndex = -1,
                result = [];

            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }

        module.exports = arrayFilter;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayMap.js": [function (require, module, exports) {
        /**
         * A specialized version of `_.map` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
            var index = -1,
                length = array.length,
                result = Array(length);

            while (++index < length) {
                result[index] = iteratee(array[index], index, array);
            }
            return result;
        }

        module.exports = arrayMap;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayPush.js": [function (require, module, exports) {
        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
            var index = -1,
                length = values.length,
                offset = array.length;

            while (++index < length) {
                array[offset + index] = values[index];
            }
            return array;
        }

        module.exports = arrayPush;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayReduce.js": [function (require, module, exports) {
        /**
         * A specialized version of `_.reduce` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initFromArray] Specify using the first element of `array`
         *  as the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
            var index = -1,
                length = array.length;

            if (initFromArray && length) {
                accumulator = array[++index];
            }
            while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
        }

        module.exports = arrayReduce;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arraySome.js": [function (require, module, exports) {
        /**
         * A specialized version of `_.some` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
            var index = -1,
                length = array.length;

            while (++index < length) {
                if (predicate(array[index], index, array)) {
                    return true;
                }
            }
            return false;
        }

        module.exports = arraySome;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/assignWith.js": [function (require, module, exports) {
        var keys = require('../object/keys');

        /**
         * A specialized version of `_.assign` for customizing assigned values without
         * support for argument juggling, multiple sources, and `this` binding `customizer`
         * functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         */
        function assignWith(object, source, customizer) {
            var index = -1,
                props = keys(source),
                length = props.length;

            while (++index < length) {
                var key = props[index],
                    value = object[key],
                    result = customizer(value, source[key], key, object, source);

                if ((result === result ? (result !== value) : (value === value)) ||
                    (value === undefined && !(key in object))) {
                    object[key] = result;
                }
            }
            return object;
        }

        module.exports = assignWith;

    }, {"../object/keys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseAssign.js": [function (require, module, exports) {
        var baseCopy = require('./baseCopy'),
            keys = require('../object/keys');

        /**
         * The base implementation of `_.assign` without support for argument juggling,
         * multiple sources, and `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
            return source == null
                ? object
                : baseCopy(source, keys(source), object);
        }

        module.exports = baseAssign;

    }, {
        "../object/keys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js",
        "./baseCopy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCopy.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js": [function (require, module, exports) {
        var baseMatches = require('./baseMatches'),
            baseMatchesProperty = require('./baseMatchesProperty'),
            bindCallback = require('./bindCallback'),
            identity = require('../utility/identity'),
            property = require('../utility/property');

        /**
         * The base implementation of `_.callback` which supports specifying the
         * number of arguments to provide to `func`.
         *
         * @private
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function baseCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (type == 'function') {
                return thisArg === undefined
                    ? func
                    : bindCallback(func, thisArg, argCount);
            }
            if (func == null) {
                return identity;
            }
            if (type == 'object') {
                return baseMatches(func);
            }
            return thisArg === undefined
                ? property(func)
                : baseMatchesProperty(func, thisArg);
        }

        module.exports = baseCallback;

    }, {
        "../utility/identity": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/utility/identity.js",
        "../utility/property": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/utility/property.js",
        "./baseMatches": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMatches.js",
        "./baseMatchesProperty": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMatchesProperty.js",
        "./bindCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/bindCallback.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCompareAscending.js": [function (require, module, exports) {
        /**
         * The base implementation of `compareAscending` which compares values and
         * sorts them in ascending order without guaranteeing a stable sort.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function baseCompareAscending(value, other) {
            if (value !== other) {
                var valIsNull = value === null,
                    valIsUndef = value === undefined,
                    valIsReflexive = value === value;

                var othIsNull = other === null,
                    othIsUndef = other === undefined,
                    othIsReflexive = other === other;

                if ((value > other && !othIsNull) || !valIsReflexive ||
                    (valIsNull && !othIsUndef && othIsReflexive) ||
                    (valIsUndef && othIsReflexive)) {
                    return 1;
                }
                if ((value < other && !valIsNull) || !othIsReflexive ||
                    (othIsNull && !valIsUndef && valIsReflexive) ||
                    (othIsUndef && valIsReflexive)) {
                    return -1;
                }
            }
            return 0;
        }

        module.exports = baseCompareAscending;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCopy.js": [function (require, module, exports) {
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property names to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @returns {Object} Returns `object`.
         */
        function baseCopy(source, props, object) {
            object || (object = {});

            var index = -1,
                length = props.length;

            while (++index < length) {
                var key = props[index];
                object[key] = source[key];
            }
            return object;
        }

        module.exports = baseCopy;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCreate.js": [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} prototype The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function () {
            function object() {
            }

            return function (prototype) {
                if (isObject(prototype)) {
                    object.prototype = prototype;
                    var result = new object;
                    object.prototype = undefined;
                }
                return result || {};
            };
        }());

        module.exports = baseCreate;

    }, {"../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseDelay.js": [function (require, module, exports) {
        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /**
         * The base implementation of `_.delay` and `_.defer` which accepts an index
         * of where to slice the arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Object} args The arguments provide to `func`.
         * @returns {number} Returns the timer id.
         */
        function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function () {
                func.apply(undefined, args);
            }, wait);
        }

        module.exports = baseDelay;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseDifference.js": [function (require, module, exports) {
        var baseIndexOf = require('./baseIndexOf'),
            cacheIndexOf = require('./cacheIndexOf'),
            createCache = require('./createCache');

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE = 200;

        /**
         * The base implementation of `_.difference` which accepts a single array
         * of values to exclude.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values) {
            var length = array ? array.length : 0,
                result = [];

            if (!length) {
                return result;
            }
            var index = -1,
                indexOf = baseIndexOf,
                isCommon = true,
                cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
                valuesLength = values.length;

            if (cache) {
                indexOf = cacheIndexOf;
                isCommon = false;
                values = cache;
            }
            outer:
                while (++index < length) {
                    var value = array[index];

                    if (isCommon && value === value) {
                        var valuesIndex = valuesLength;
                        while (valuesIndex--) {
                            if (values[valuesIndex] === value) {
                                continue outer;
                            }
                        }
                        result.push(value);
                    }
                    else if (indexOf(values, value, 0) < 0) {
                        result.push(value);
                    }
                }
            return result;
        }

        module.exports = baseDifference;

    }, {
        "./baseIndexOf": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIndexOf.js",
        "./cacheIndexOf": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/cacheIndexOf.js",
        "./createCache": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createCache.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEach.js": [function (require, module, exports) {
        var baseForOwn = require('./baseForOwn'),
            createBaseEach = require('./createBaseEach');

        /**
         * The base implementation of `_.forEach` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object|string} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);

        module.exports = baseEach;

    }, {
        "./baseForOwn": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseForOwn.js",
        "./createBaseEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createBaseEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEvery.js": [function (require, module, exports) {
        var baseEach = require('./baseEach');

        /**
         * The base implementation of `_.every` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function (value, index, collection) {
                result = !!predicate(value, index, collection);
                return result;
            });
            return result;
        }

        module.exports = baseEvery;

    }, {"./baseEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEach.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFilter.js": [function (require, module, exports) {
        var baseEach = require('./baseEach');

        /**
         * The base implementation of `_.filter` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function (value, index, collection) {
                if (predicate(value, index, collection)) {
                    result.push(value);
                }
            });
            return result;
        }

        module.exports = baseFilter;

    }, {"./baseEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEach.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFind.js": [function (require, module, exports) {
        /**
         * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
         * without support for callback shorthands and `this` binding, which iterates
         * over `collection` using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function} predicate The function invoked per iteration.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @param {boolean} [retKey] Specify returning the key of the found element
         *  instead of the element itself.
         * @returns {*} Returns the found element or its key, else `undefined`.
         */
        function baseFind(collection, predicate, eachFunc, retKey) {
            var result;
            eachFunc(collection, function (value, key, collection) {
                if (predicate(value, key, collection)) {
                    result = retKey ? key : value;
                    return false;
                }
            });
            return result;
        }

        module.exports = baseFind;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFindIndex.js": [function (require, module, exports) {
        /**
         * The base implementation of `_.findIndex` and `_.findLastIndex` without
         * support for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseFindIndex(array, predicate, fromRight) {
            var length = array.length,
                index = fromRight ? length : -1;

            while ((fromRight ? index-- : ++index < length)) {
                if (predicate(array[index], index, array)) {
                    return index;
                }
            }
            return -1;
        }

        module.exports = baseFindIndex;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFlatten.js": [function (require, module, exports) {
        var arrayPush = require('./arrayPush'),
            isArguments = require('../lang/isArguments'),
            isArray = require('../lang/isArray'),
            isArrayLike = require('./isArrayLike'),
            isObjectLike = require('./isObjectLike');

        /**
         * The base implementation of `_.flatten` with added support for restricting
         * flattening and specifying the start index.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, isDeep, isStrict, result) {
            result || (result = []);

            var index = -1,
                length = array.length;

            while (++index < length) {
                var value = array[index];
                if (isObjectLike(value) && isArrayLike(value) &&
                    (isStrict || isArray(value) || isArguments(value))) {
                    if (isDeep) {
                        // Recursively flatten arrays (susceptible to call stack limits).
                        baseFlatten(value, isDeep, isStrict, result);
                    } else {
                        arrayPush(result, value);
                    }
                } else if (!isStrict) {
                    result[result.length] = value;
                }
            }
            return result;
        }

        module.exports = baseFlatten;

    }, {
        "../lang/isArguments": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArguments.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "./arrayPush": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayPush.js",
        "./isArrayLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isArrayLike.js",
        "./isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFor.js": [function (require, module, exports) {
        var createBaseFor = require('./createBaseFor');

        /**
         * The base implementation of `baseForIn` and `baseForOwn` which iterates
         * over `object` properties returned by `keysFunc` invoking `iteratee` for
         * each property. Iteratee functions may exit iteration early by explicitly
         * returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();

        module.exports = baseFor;

    }, {"./createBaseFor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createBaseFor.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseForIn.js": [function (require, module, exports) {
        var baseFor = require('./baseFor'),
            keysIn = require('../object/keysIn');

        /**
         * The base implementation of `_.forIn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForIn(object, iteratee) {
            return baseFor(object, iteratee, keysIn);
        }

        module.exports = baseForIn;

    }, {
        "../object/keysIn": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keysIn.js",
        "./baseFor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFor.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseForOwn.js": [function (require, module, exports) {
        var baseFor = require('./baseFor'),
            keys = require('../object/keys');

        /**
         * The base implementation of `_.forOwn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
            return baseFor(object, iteratee, keys);
        }

        module.exports = baseForOwn;

    }, {
        "../object/keys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js",
        "./baseFor": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFor.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseGet.js": [function (require, module, exports) {
        var toObject = require('./toObject');

        /**
         * The base implementation of `get` without support for string paths
         * and default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path of the property to get.
         * @param {string} [pathKey] The key representation of path.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path, pathKey) {
            if (object == null) {
                return;
            }
            if (pathKey !== undefined && pathKey in toObject(object)) {
                path = [pathKey];
            }
            var index = 0,
                length = path.length;

            while (object != null && index < length) {
                object = object[path[index++]];
            }
            return (index && index == length) ? object : undefined;
        }

        module.exports = baseGet;

    }, {"./toObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIndexOf.js": [function (require, module, exports) {
        var indexOfNaN = require('./indexOfNaN');

        /**
         * The base implementation of `_.indexOf` without support for binary searches.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
            if (value !== value) {
                return indexOfNaN(array, fromIndex);
            }
            var index = fromIndex - 1,
                length = array.length;

            while (++index < length) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }

        module.exports = baseIndexOf;

    }, {"./indexOfNaN": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/indexOfNaN.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIsEqual.js": [function (require, module, exports) {
        var baseIsEqualDeep = require('./baseIsEqualDeep'),
            isObject = require('../lang/isObject'),
            isObjectLike = require('./isObjectLike');

        /**
         * The base implementation of `_.isEqual` without support for `this` binding
         * `customizer` functions.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
            if (value === other) {
                return true;
            }
            if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
                return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }

        module.exports = baseIsEqual;

    }, {
        "../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js",
        "./baseIsEqualDeep": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIsEqualDeep.js",
        "./isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIsEqualDeep.js": [function (require, module, exports) {
        var equalArrays = require('./equalArrays'),
            equalByTag = require('./equalByTag'),
            equalObjects = require('./equalObjects'),
            isArray = require('../lang/isArray'),
            isTypedArray = require('../lang/isTypedArray');

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            objectTag = '[object Object]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA=[]] Tracks traversed `value` objects.
         * @param {Array} [stackB=[]] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = arrayTag,
                othTag = arrayTag;

            if (!objIsArr) {
                objTag = objToString.call(object);
                if (objTag == argsTag) {
                    objTag = objectTag;
                } else if (objTag != objectTag) {
                    objIsArr = isTypedArray(object);
                }
            }
            if (!othIsArr) {
                othTag = objToString.call(other);
                if (othTag == argsTag) {
                    othTag = objectTag;
                } else if (othTag != objectTag) {
                    othIsArr = isTypedArray(other);
                }
            }
            var objIsObj = objTag == objectTag,
                othIsObj = othTag == objectTag,
                isSameTag = objTag == othTag;

            if (isSameTag && !(objIsArr || objIsObj)) {
                return equalByTag(object, other, objTag);
            }
            if (!isLoose) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                    othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                if (objIsWrapped || othIsWrapped) {
                    return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                }
            }
            if (!isSameTag) {
                return false;
            }
            // Assume cyclic values are equal.
            // For more information on detecting circular references see https://es5.github.io/#JO.
            stackA || (stackA = []);
            stackB || (stackB = []);

            var length = stackA.length;
            while (length--) {
                if (stackA[length] == object) {
                    return stackB[length] == other;
                }
            }
            // Add `object` and `other` to the stack of traversed objects.
            stackA.push(object);
            stackB.push(other);

            var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

            stackA.pop();
            stackB.pop();

            return result;
        }

        module.exports = baseIsEqualDeep;

    }, {
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "../lang/isTypedArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isTypedArray.js",
        "./equalArrays": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/equalArrays.js",
        "./equalByTag": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/equalByTag.js",
        "./equalObjects": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/equalObjects.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIsMatch.js": [function (require, module, exports) {
        var baseIsEqual = require('./baseIsEqual'),
            toObject = require('./toObject');

        /**
         * The base implementation of `_.isMatch` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} matchData The propery names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, matchData, customizer) {
            var index = matchData.length,
                length = index,
                noCustomizer = !customizer;

            if (object == null) {
                return !length;
            }
            object = toObject(object);
            while (index--) {
                var data = matchData[index];
                if ((noCustomizer && data[2])
                        ? data[1] !== object[data[0]]
                        : !(data[0] in object)
                ) {
                    return false;
                }
            }
            while (++index < length) {
                data = matchData[index];
                var key = data[0],
                    objValue = object[key],
                    srcValue = data[1];

                if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) {
                        return false;
                    }
                } else {
                    var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                        return false;
                    }
                }
            }
            return true;
        }

        module.exports = baseIsMatch;

    }, {
        "./baseIsEqual": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIsEqual.js",
        "./toObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseLodash.js": [function (require, module, exports) {
        /**
         * The function whose prototype all chaining wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
            // No operation performed.
        }

        module.exports = baseLodash;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMap.js": [function (require, module, exports) {
        var baseEach = require('./baseEach'),
            isArrayLike = require('./isArrayLike');

        /**
         * The base implementation of `_.map` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
            var index = -1,
                result = isArrayLike(collection) ? Array(collection.length) : [];

            baseEach(collection, function (value, key, collection) {
                result[++index] = iteratee(value, key, collection);
            });
            return result;
        }

        module.exports = baseMap;

    }, {
        "./baseEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEach.js",
        "./isArrayLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isArrayLike.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMatches.js": [function (require, module, exports) {
        var baseIsMatch = require('./baseIsMatch'),
            getMatchData = require('./getMatchData'),
            toObject = require('./toObject');

        /**
         * The base implementation of `_.matches` which does not clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         */
        function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
                var key = matchData[0][0],
                    value = matchData[0][1];

                return function (object) {
                    if (object == null) {
                        return false;
                    }
                    return object[key] === value && (value !== undefined || (key in toObject(object)));
                };
            }
            return function (object) {
                return baseIsMatch(object, matchData);
            };
        }

        module.exports = baseMatches;

    }, {
        "./baseIsMatch": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIsMatch.js",
        "./getMatchData": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getMatchData.js",
        "./toObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMatchesProperty.js": [function (require, module, exports) {
        var baseGet = require('./baseGet'),
            baseIsEqual = require('./baseIsEqual'),
            baseSlice = require('./baseSlice'),
            isArray = require('../lang/isArray'),
            isKey = require('./isKey'),
            isStrictComparable = require('./isStrictComparable'),
            last = require('../array/last'),
            toObject = require('./toObject'),
            toPath = require('./toPath');

        /**
         * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to compare.
         * @returns {Function} Returns the new function.
         */
        function baseMatchesProperty(path, srcValue) {
            var isArr = isArray(path),
                isCommon = isKey(path) && isStrictComparable(srcValue),
                pathKey = (path + '');

            path = toPath(path);
            return function (object) {
                if (object == null) {
                    return false;
                }
                var key = pathKey;
                object = toObject(object);
                if ((isArr || !isCommon) && !(key in object)) {
                    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                    if (object == null) {
                        return false;
                    }
                    key = last(path);
                    object = toObject(object);
                }
                return object[key] === srcValue
                    ? (srcValue !== undefined || (key in object))
                    : baseIsEqual(srcValue, object[key], undefined, true);
            };
        }

        module.exports = baseMatchesProperty;

    }, {
        "../array/last": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/array/last.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "./baseGet": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseGet.js",
        "./baseIsEqual": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIsEqual.js",
        "./baseSlice": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseSlice.js",
        "./isKey": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isKey.js",
        "./isStrictComparable": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isStrictComparable.js",
        "./toObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js",
        "./toPath": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toPath.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMerge.js": [function (require, module, exports) {
        var arrayEach = require('./arrayEach'),
            baseMergeDeep = require('./baseMergeDeep'),
            isArray = require('../lang/isArray'),
            isArrayLike = require('./isArrayLike'),
            isObject = require('../lang/isObject'),
            isObjectLike = require('./isObjectLike'),
            isTypedArray = require('../lang/isTypedArray'),
            keys = require('../object/keys');

        /**
         * The base implementation of `_.merge` without support for argument juggling,
         * multiple sources, and `this` binding `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {Object} Returns `object`.
         */
        function baseMerge(object, source, customizer, stackA, stackB) {
            if (!isObject(object)) {
                return object;
            }
            var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
                props = isSrcArr ? undefined : keys(source);

            arrayEach(props || source, function (srcValue, key) {
                if (props) {
                    key = srcValue;
                    srcValue = source[key];
                }
                if (isObjectLike(srcValue)) {
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                }
                else {
                    var value = object[key],
                        result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                        isCommon = result === undefined;

                    if (isCommon) {
                        result = srcValue;
                    }
                    if ((result !== undefined || (isSrcArr && !(key in object))) &&
                        (isCommon || (result === result ? (result !== value) : (value === value)))) {
                        object[key] = result;
                    }
                }
            });
            return object;
        }

        module.exports = baseMerge;

    }, {
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js",
        "../lang/isTypedArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isTypedArray.js",
        "../object/keys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js",
        "./arrayEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayEach.js",
        "./baseMergeDeep": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMergeDeep.js",
        "./isArrayLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isArrayLike.js",
        "./isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMergeDeep.js": [function (require, module, exports) {
        var arrayCopy = require('./arrayCopy'),
            isArguments = require('../lang/isArguments'),
            isArray = require('../lang/isArray'),
            isArrayLike = require('./isArrayLike'),
            isPlainObject = require('../lang/isPlainObject'),
            isTypedArray = require('../lang/isTypedArray'),
            toPlainObject = require('../lang/toPlainObject');

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
            var length = stackA.length,
                srcValue = source[key];

            while (length--) {
                if (stackA[length] == srcValue) {
                    object[key] = stackB[length];
                    return;
                }
            }
            var value = object[key],
                result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                isCommon = result === undefined;

            if (isCommon) {
                result = srcValue;
                if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                    result = isArray(value)
                        ? value
                        : (isArrayLike(value) ? arrayCopy(value) : []);
                }
                else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    result = isArguments(value)
                        ? toPlainObject(value)
                        : (isPlainObject(value) ? value : {});
                }
                else {
                    isCommon = false;
                }
            }
            // Add the source value to the stack of traversed objects and associate
            // it with its merged value.
            stackA.push(srcValue);
            stackB.push(result);

            if (isCommon) {
                // Recursively merge objects and arrays (susceptible to call stack limits).
                object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
            } else if (result === result ? (result !== value) : (value === value)) {
                object[key] = result;
            }
        }

        module.exports = baseMergeDeep;

    }, {
        "../lang/isArguments": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArguments.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "../lang/isPlainObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isPlainObject.js",
        "../lang/isTypedArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isTypedArray.js",
        "../lang/toPlainObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/toPlainObject.js",
        "./arrayCopy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayCopy.js",
        "./isArrayLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isArrayLike.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseProperty.js": [function (require, module, exports) {
        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new function.
         */
        function baseProperty(key) {
            return function (object) {
                return object == null ? undefined : object[key];
            };
        }

        module.exports = baseProperty;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/basePropertyDeep.js": [function (require, module, exports) {
        var baseGet = require('./baseGet'),
            toPath = require('./toPath');

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         */
        function basePropertyDeep(path) {
            var pathKey = (path + '');
            path = toPath(path);
            return function (object) {
                return baseGet(object, path, pathKey);
            };
        }

        module.exports = basePropertyDeep;

    }, {
        "./baseGet": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseGet.js",
        "./toPath": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toPath.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseReduce.js": [function (require, module, exports) {
        /**
         * The base implementation of `_.reduce` and `_.reduceRight` without support
         * for callback shorthands and `this` binding, which iterates over `collection`
         * using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} accumulator The initial value.
         * @param {boolean} initFromCollection Specify using the first or last element
         *  of `collection` as the initial value.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the accumulated value.
         */
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
            eachFunc(collection, function (value, index, collection) {
                accumulator = initFromCollection
                    ? (initFromCollection = false, value)
                    : iteratee(accumulator, value, index, collection);
            });
            return accumulator;
        }

        module.exports = baseReduce;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseSetData.js": [function (require, module, exports) {
        var identity = require('../utility/identity'),
            metaMap = require('./metaMap');

        /**
         * The base implementation of `setData` without support for hot loop detection.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
        };

        module.exports = baseSetData;

    }, {
        "../utility/identity": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/utility/identity.js",
        "./metaMap": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/metaMap.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseSlice.js": [function (require, module, exports) {
        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
            var index = -1,
                length = array.length;

            start = start == null ? 0 : (+start || 0);
            if (start < 0) {
                start = -start > length ? 0 : (length + start);
            }
            end = (end === undefined || end > length) ? length : (+end || 0);
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : ((end - start) >>> 0);
            start >>>= 0;

            var result = Array(length);
            while (++index < length) {
                result[index] = array[index + start];
            }
            return result;
        }

        module.exports = baseSlice;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseSome.js": [function (require, module, exports) {
        var baseEach = require('./baseEach');

        /**
         * The base implementation of `_.some` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
            var result;

            baseEach(collection, function (value, index, collection) {
                result = predicate(value, index, collection);
                return !result;
            });
            return !!result;
        }

        module.exports = baseSome;

    }, {"./baseEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEach.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseSortBy.js": [function (require, module, exports) {
        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define
         * the sort order of `array` and replaces criteria objects with their
         * corresponding values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */
        function baseSortBy(array, comparer) {
            var length = array.length;

            array.sort(comparer);
            while (length--) {
                array[length] = array[length].value;
            }
            return array;
        }

        module.exports = baseSortBy;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseToString.js": [function (require, module, exports) {
        /**
         * Converts `value` to a string if it's not one. An empty string is returned
         * for `null` or `undefined` values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
            return value == null ? '' : (value + '');
        }

        module.exports = baseToString;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseUniq.js": [function (require, module, exports) {
        var baseIndexOf = require('./baseIndexOf'),
            cacheIndexOf = require('./cacheIndexOf'),
            createCache = require('./createCache');

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE = 200;

        /**
         * The base implementation of `_.uniq` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The function invoked per iteration.
         * @returns {Array} Returns the new duplicate-value-free array.
         */
        function baseUniq(array, iteratee) {
            var index = -1,
                indexOf = baseIndexOf,
                length = array.length,
                isCommon = true,
                isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
                seen = isLarge ? createCache() : null,
                result = [];

            if (seen) {
                indexOf = cacheIndexOf;
                isCommon = false;
            } else {
                isLarge = false;
                seen = iteratee ? [] : result;
            }
            outer:
                while (++index < length) {
                    var value = array[index],
                        computed = iteratee ? iteratee(value, index, array) : value;

                    if (isCommon && value === value) {
                        var seenIndex = seen.length;
                        while (seenIndex--) {
                            if (seen[seenIndex] === computed) {
                                continue outer;
                            }
                        }
                        if (iteratee) {
                            seen.push(computed);
                        }
                        result.push(value);
                    }
                    else if (indexOf(seen, computed, 0) < 0) {
                        if (iteratee || isLarge) {
                            seen.push(computed);
                        }
                        result.push(value);
                    }
                }
            return result;
        }

        module.exports = baseUniq;

    }, {
        "./baseIndexOf": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseIndexOf.js",
        "./cacheIndexOf": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/cacheIndexOf.js",
        "./createCache": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createCache.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseValues.js": [function (require, module, exports) {
        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */
        function baseValues(object, props) {
            var index = -1,
                length = props.length,
                result = Array(length);

            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }

        module.exports = baseValues;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/bindCallback.js": [function (require, module, exports) {
        var identity = require('../utility/identity');

        /**
         * A specialized version of `baseCallback` which only supports `this` binding
         * and specifying the number of arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function bindCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
                return identity;
            }
            if (thisArg === undefined) {
                return func;
            }
            switch (argCount) {
                case 1:
                    return function (value) {
                        return func.call(thisArg, value);
                    };
                case 3:
                    return function (value, index, collection) {
                        return func.call(thisArg, value, index, collection);
                    };
                case 4:
                    return function (accumulator, value, index, collection) {
                        return func.call(thisArg, accumulator, value, index, collection);
                    };
                case 5:
                    return function (value, other, key, object, source) {
                        return func.call(thisArg, value, other, key, object, source);
                    };
            }
            return function () {
                return func.apply(thisArg, arguments);
            };
        }

        module.exports = bindCallback;

    }, {"../utility/identity": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/utility/identity.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/cacheIndexOf.js": [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * Checks if `value` is in `cache` mimicking the return signature of
         * `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache to search.
         * @param {*} value The value to search for.
         * @returns {number} Returns `0` if `value` is found, else `-1`.
         */
        function cacheIndexOf(cache, value) {
            var data = cache.data,
                result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

            return result ? 0 : -1;
        }

        module.exports = cacheIndexOf;

    }, {"../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/cachePush.js": [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * Adds `value` to the cache.
         *
         * @private
         * @name push
         * @memberOf SetCache
         * @param {*} value The value to cache.
         */
        function cachePush(value) {
            var data = this.data;
            if (typeof value == 'string' || isObject(value)) {
                data.set.add(value);
            } else {
                data.hash[value] = true;
            }
        }

        module.exports = cachePush;

    }, {"../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/compareAscending.js": [function (require, module, exports) {
        var baseCompareAscending = require('./baseCompareAscending');

        /**
         * Used by `_.sortBy` to compare transformed elements of a collection and stable
         * sort them in ascending order.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareAscending(object, other) {
            return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
        }

        module.exports = compareAscending;

    }, {"./baseCompareAscending": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCompareAscending.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/composeArgs.js": [function (require, module, exports) {
        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders) {
            var holdersLength = holders.length,
                argsIndex = -1,
                argsLength = nativeMax(args.length - holdersLength, 0),
                leftIndex = -1,
                leftLength = partials.length,
                result = Array(leftLength + argsLength);

            while (++leftIndex < leftLength) {
                result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
                result[holders[argsIndex]] = args[argsIndex];
            }
            while (argsLength--) {
                result[leftIndex++] = args[argsIndex++];
            }
            return result;
        }

        module.exports = composeArgs;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/composeArgsRight.js": [function (require, module, exports) {
        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders) {
            var holdersIndex = -1,
                holdersLength = holders.length,
                argsIndex = -1,
                argsLength = nativeMax(args.length - holdersLength, 0),
                rightIndex = -1,
                rightLength = partials.length,
                result = Array(argsLength + rightLength);

            while (++argsIndex < argsLength) {
                result[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
                result[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
                result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
            return result;
        }

        module.exports = composeArgsRight;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createAggregator.js": [function (require, module, exports) {
        var baseCallback = require('./baseCallback'),
            baseEach = require('./baseEach'),
            isArray = require('../lang/isArray');

        /**
         * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
         *
         * @private
         * @param {Function} setter The function to set keys and values of the accumulator object.
         * @param {Function} [initializer] The function to initialize the accumulator object.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
            return function (collection, iteratee, thisArg) {
                var result = initializer ? initializer() : {};
                iteratee = baseCallback(iteratee, thisArg, 3);

                if (isArray(collection)) {
                    var index = -1,
                        length = collection.length;

                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, iteratee(value, index, collection), collection);
                    }
                } else {
                    baseEach(collection, function (value, key, collection) {
                        setter(result, value, iteratee(value, key, collection), collection);
                    });
                }
                return result;
            };
        }

        module.exports = createAggregator;

    }, {
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "./baseCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js",
        "./baseEach": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseEach.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createAssigner.js": [function (require, module, exports) {
        var bindCallback = require('./bindCallback'),
            isIterateeCall = require('./isIterateeCall'),
            restParam = require('../function/restParam');

        /**
         * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
            return restParam(function (object, sources) {
                var index = -1,
                    length = object == null ? 0 : sources.length,
                    customizer = length > 2 ? sources[length - 2] : undefined,
                    guard = length > 2 ? sources[2] : undefined,
                    thisArg = length > 1 ? sources[length - 1] : undefined;

                if (typeof customizer == 'function') {
                    customizer = bindCallback(customizer, thisArg, 5);
                    length -= 2;
                } else {
                    customizer = typeof thisArg == 'function' ? thisArg : undefined;
                    length -= (customizer ? 1 : 0);
                }
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                }
                while (++index < length) {
                    var source = sources[index];
                    if (source) {
                        assigner(object, source, customizer);
                    }
                }
                return object;
            });
        }

        module.exports = createAssigner;

    }, {
        "../function/restParam": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/restParam.js",
        "./bindCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/bindCallback.js",
        "./isIterateeCall": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIterateeCall.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createBaseEach.js": [function (require, module, exports) {
        var getLength = require('./getLength'),
            isLength = require('./isLength'),
            toObject = require('./toObject');

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
                var length = collection ? getLength(collection) : 0;
                if (!isLength(length)) {
                    return eachFunc(collection, iteratee);
                }
                var index = fromRight ? length : -1,
                    iterable = toObject(collection);

                while ((fromRight ? index-- : ++index < length)) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                        break;
                    }
                }
                return collection;
            };
        }

        module.exports = createBaseEach;

    }, {
        "./getLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getLength.js",
        "./isLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLength.js",
        "./toObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createBaseFor.js": [function (require, module, exports) {
        var toObject = require('./toObject');

        /**
         * Creates a base function for `_.forIn` or `_.forInRight`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
                var iterable = toObject(object),
                    props = keysFunc(object),
                    length = props.length,
                    index = fromRight ? length : -1;

                while ((fromRight ? index-- : ++index < length)) {
                    var key = props[index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                        break;
                    }
                }
                return object;
            };
        }

        module.exports = createBaseFor;

    }, {"./toObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createBindWrapper.js": [function (require, module, exports) {
        (function (global) {
            var createCtorWrapper = require('./createCtorWrapper');

            /**
             * Creates a function that wraps `func` and invokes it with the `this`
             * binding of `thisArg`.
             *
             * @private
             * @param {Function} func The function to bind.
             * @param {*} [thisArg] The `this` binding of `func`.
             * @returns {Function} Returns the new bound function.
             */
            function createBindWrapper(func, thisArg) {
                var Ctor = createCtorWrapper(func);

                function wrapper() {
                    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
                    return fn.apply(thisArg, arguments);
                }

                return wrapper;
            }

            module.exports = createBindWrapper;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {"./createCtorWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createCtorWrapper.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createCache.js": [function (require, module, exports) {
        (function (global) {
            var SetCache = require('./SetCache'),
                getNative = require('./getNative');

            /** Native method references. */
            var Set = getNative(global, 'Set');

            /* Native method references for those with the same name as other `lodash` methods. */
            var nativeCreate = getNative(Object, 'create');

            /**
             * Creates a `Set` cache object to optimize linear searches of large arrays.
             *
             * @private
             * @param {Array} [values] The values to cache.
             * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
             */
            function createCache(values) {
                return (nativeCreate && Set) ? new SetCache(values) : null;
            }

            module.exports = createCache;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
        "./SetCache": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/SetCache.js",
        "./getNative": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getNative.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createCtorWrapper.js": [function (require, module, exports) {
        var baseCreate = require('./baseCreate'),
            isObject = require('../lang/isObject');

        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtorWrapper(Ctor) {
            return function () {
                // Use a `switch` statement to work with class constructors.
                // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                // for more details.
                var args = arguments;
                switch (args.length) {
                    case 0:
                        return new Ctor;
                    case 1:
                        return new Ctor(args[0]);
                    case 2:
                        return new Ctor(args[0], args[1]);
                    case 3:
                        return new Ctor(args[0], args[1], args[2]);
                    case 4:
                        return new Ctor(args[0], args[1], args[2], args[3]);
                    case 5:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                    case 6:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case 7:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                }
                var thisBinding = baseCreate(Ctor.prototype),
                    result = Ctor.apply(thisBinding, args);

                // Mimic the constructor's `return` behavior.
                // See https://es5.github.io/#x13.2.2 for more details.
                return isObject(result) ? result : thisBinding;
            };
        }

        module.exports = createCtorWrapper;

    }, {
        "../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js",
        "./baseCreate": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCreate.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createFind.js": [function (require, module, exports) {
        var baseCallback = require('./baseCallback'),
            baseFind = require('./baseFind'),
            baseFindIndex = require('./baseFindIndex'),
            isArray = require('../lang/isArray');

        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new find function.
         */
        function createFind(eachFunc, fromRight) {
            return function (collection, predicate, thisArg) {
                predicate = baseCallback(predicate, thisArg, 3);
                if (isArray(collection)) {
                    var index = baseFindIndex(collection, predicate, fromRight);
                    return index > -1 ? collection[index] : undefined;
                }
                return baseFind(collection, predicate, eachFunc);
            };
        }

        module.exports = createFind;

    }, {
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "./baseCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js",
        "./baseFind": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFind.js",
        "./baseFindIndex": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFindIndex.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createForEach.js": [function (require, module, exports) {
        var bindCallback = require('./bindCallback'),
            isArray = require('../lang/isArray');

        /**
         * Creates a function for `_.forEach` or `_.forEachRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createForEach(arrayFunc, eachFunc) {
            return function (collection, iteratee, thisArg) {
                return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                    ? arrayFunc(collection, iteratee)
                    : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
            };
        }

        module.exports = createForEach;

    }, {
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "./bindCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/bindCallback.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createHybridWrapper.js": [function (require, module, exports) {
        (function (global) {
            var arrayCopy = require('./arrayCopy'),
                composeArgs = require('./composeArgs'),
                composeArgsRight = require('./composeArgsRight'),
                createCtorWrapper = require('./createCtorWrapper'),
                isLaziable = require('./isLaziable'),
                reorder = require('./reorder'),
                replaceHolders = require('./replaceHolders'),
                setData = require('./setData');

            /** Used to compose bitmasks for wrapper metadata. */
            var BIND_FLAG = 1,
                BIND_KEY_FLAG = 2,
                CURRY_BOUND_FLAG = 4,
                CURRY_FLAG = 8,
                CURRY_RIGHT_FLAG = 16,
                PARTIAL_FLAG = 32,
                PARTIAL_RIGHT_FLAG = 64,
                ARY_FLAG = 128;

            /* Native method references for those with the same name as other `lodash` methods. */
            var nativeMax = Math.max;

            /**
             * Creates a function that wraps `func` and invokes it with optional `this`
             * binding of, partial application, and currying.
             *
             * @private
             * @param {Function|string} func The function or method name to reference.
             * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
             * @param {*} [thisArg] The `this` binding of `func`.
             * @param {Array} [partials] The arguments to prepend to those provided to the new function.
             * @param {Array} [holders] The `partials` placeholder indexes.
             * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
             * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
             * @param {Array} [argPos] The argument positions of the new function.
             * @param {number} [ary] The arity cap of `func`.
             * @param {number} [arity] The arity of `func`.
             * @returns {Function} Returns the new wrapped function.
             */
            function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                var isAry = bitmask & ARY_FLAG,
                    isBind = bitmask & BIND_FLAG,
                    isBindKey = bitmask & BIND_KEY_FLAG,
                    isCurry = bitmask & CURRY_FLAG,
                    isCurryBound = bitmask & CURRY_BOUND_FLAG,
                    isCurryRight = bitmask & CURRY_RIGHT_FLAG,
                    Ctor = isBindKey ? undefined : createCtorWrapper(func);

                function wrapper() {
                    // Avoid `arguments` object use disqualifying optimizations by
                    // converting it to an array before providing it to other functions.
                    var length = arguments.length,
                        index = length,
                        args = Array(length);

                    while (index--) {
                        args[index] = arguments[index];
                    }
                    if (partials) {
                        args = composeArgs(args, partials, holders);
                    }
                    if (partialsRight) {
                        args = composeArgsRight(args, partialsRight, holdersRight);
                    }
                    if (isCurry || isCurryRight) {
                        var placeholder = wrapper.placeholder,
                            argsHolders = replaceHolders(args, placeholder);

                        length -= argsHolders.length;
                        if (length < arity) {
                            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                                newArity = nativeMax(arity - length, 0),
                                newsHolders = isCurry ? argsHolders : undefined,
                                newHoldersRight = isCurry ? undefined : argsHolders,
                                newPartials = isCurry ? args : undefined,
                                newPartialsRight = isCurry ? undefined : args;

                            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                            if (!isCurryBound) {
                                bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                            }
                            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                                result = createHybridWrapper.apply(undefined, newData);

                            if (isLaziable(func)) {
                                setData(result, newData);
                            }
                            result.placeholder = placeholder;
                            return result;
                        }
                    }
                    var thisBinding = isBind ? thisArg : this,
                        fn = isBindKey ? thisBinding[func] : func;

                    if (argPos) {
                        args = reorder(args, argPos);
                    }
                    if (isAry && ary < args.length) {
                        args.length = ary;
                    }
                    if (this && this !== global && this instanceof wrapper) {
                        fn = Ctor || createCtorWrapper(func);
                    }
                    return fn.apply(thisBinding, args);
                }

                return wrapper;
            }

            module.exports = createHybridWrapper;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {
        "./arrayCopy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayCopy.js",
        "./composeArgs": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/composeArgs.js",
        "./composeArgsRight": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/composeArgsRight.js",
        "./createCtorWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createCtorWrapper.js",
        "./isLaziable": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLaziable.js",
        "./reorder": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/reorder.js",
        "./replaceHolders": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/replaceHolders.js",
        "./setData": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/setData.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createPartialWrapper.js": [function (require, module, exports) {
        (function (global) {
            var createCtorWrapper = require('./createCtorWrapper');

            /** Used to compose bitmasks for wrapper metadata. */
            var BIND_FLAG = 1;

            /**
             * Creates a function that wraps `func` and invokes it with the optional `this`
             * binding of `thisArg` and the `partials` prepended to those provided to
             * the wrapper.
             *
             * @private
             * @param {Function} func The function to partially apply arguments to.
             * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
             * @param {*} thisArg The `this` binding of `func`.
             * @param {Array} partials The arguments to prepend to those provided to the new function.
             * @returns {Function} Returns the new bound function.
             */
            function createPartialWrapper(func, bitmask, thisArg, partials) {
                var isBind = bitmask & BIND_FLAG,
                    Ctor = createCtorWrapper(func);

                function wrapper() {
                    // Avoid `arguments` object use disqualifying optimizations by
                    // converting it to an array before providing it `func`.
                    var argsIndex = -1,
                        argsLength = arguments.length,
                        leftIndex = -1,
                        leftLength = partials.length,
                        args = Array(leftLength + argsLength);

                    while (++leftIndex < leftLength) {
                        args[leftIndex] = partials[leftIndex];
                    }
                    while (argsLength--) {
                        args[leftIndex++] = arguments[++argsIndex];
                    }
                    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
                    return fn.apply(isBind ? thisArg : this, args);
                }

                return wrapper;
            }

            module.exports = createPartialWrapper;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {"./createCtorWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createCtorWrapper.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createReduce.js": [function (require, module, exports) {
        var baseCallback = require('./baseCallback'),
            baseReduce = require('./baseReduce'),
            isArray = require('../lang/isArray');

        /**
         * Creates a function for `_.reduce` or `_.reduceRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createReduce(arrayFunc, eachFunc) {
            return function (collection, iteratee, accumulator, thisArg) {
                var initFromArray = arguments.length < 3;
                return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                    ? arrayFunc(collection, iteratee, accumulator, initFromArray)
                    : baseReduce(collection, baseCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
            };
        }

        module.exports = createReduce;

    }, {
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "./baseCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCallback.js",
        "./baseReduce": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseReduce.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createWrapper.js": [function (require, module, exports) {
        var baseSetData = require('./baseSetData'),
            createBindWrapper = require('./createBindWrapper'),
            createHybridWrapper = require('./createHybridWrapper'),
            createPartialWrapper = require('./createPartialWrapper'),
            getData = require('./getData'),
            mergeData = require('./mergeData'),
            setData = require('./setData');

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1,
            BIND_KEY_FLAG = 2,
            PARTIAL_FLAG = 32,
            PARTIAL_RIGHT_FLAG = 64;

        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of flags.
         *  The bitmask may be composed of the following flags:
         *     1 - `_.bind`
         *     2 - `_.bindKey`
         *     4 - `_.curry` or `_.curryRight` of a bound function
         *     8 - `_.curry`
         *    16 - `_.curryRight`
         *    32 - `_.partial`
         *    64 - `_.partialRight`
         *   128 - `_.rearg`
         *   256 - `_.ary`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
                bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                partials = holders = undefined;
            }
            length -= (holders ? holders.length : 0);
            if (bitmask & PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials,
                    holdersRight = holders;

                partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func),
                newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

            if (data) {
                mergeData(newData, data);
                bitmask = newData[1];
                arity = newData[9];
            }
            newData[9] = arity == null
                ? (isBindKey ? 0 : func.length)
                : (nativeMax(arity - length, 0) || 0);

            if (bitmask == BIND_FLAG) {
                var result = createBindWrapper(newData[0], newData[2]);
            } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                result = createPartialWrapper.apply(undefined, newData);
            } else {
                result = createHybridWrapper.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setter(result, newData);
        }

        module.exports = createWrapper;

    }, {
        "./baseSetData": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseSetData.js",
        "./createBindWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createBindWrapper.js",
        "./createHybridWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createHybridWrapper.js",
        "./createPartialWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createPartialWrapper.js",
        "./getData": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getData.js",
        "./mergeData": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/mergeData.js",
        "./setData": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/setData.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/equalArrays.js": [function (require, module, exports) {
        var arraySome = require('./arraySome');

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing arrays.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var index = -1,
                arrLength = array.length,
                othLength = other.length;

            if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                return false;
            }
            // Ignore non-index properties.
            while (++index < arrLength) {
                var arrValue = array[index],
                    othValue = other[index],
                    result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

                if (result !== undefined) {
                    if (result) {
                        continue;
                    }
                    return false;
                }
                // Recursively compare arrays (susceptible to call stack limits).
                if (isLoose) {
                    if (!arraySome(other, function (othValue) {
                            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                        })) {
                        return false;
                    }
                } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                    return false;
                }
            }
            return true;
        }

        module.exports = equalArrays;

    }, {"./arraySome": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arraySome.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/equalByTag.js": [function (require, module, exports) {
        /** `Object#toString` result references. */
        var boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            numberTag = '[object Number]',
            regexpTag = '[object RegExp]',
            stringTag = '[object String]';

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag) {
            switch (tag) {
                case boolTag:
                case dateTag:
                    // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                    // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                    return +object == +other;

                case errorTag:
                    return object.name == other.name && object.message == other.message;

                case numberTag:
                    // Treat `NaN` vs. `NaN` as equal.
                    return (object != +object)
                        ? other != +other
                        : object == +other;

                case regexpTag:
                case stringTag:
                    // Coerce regexes to strings and treat strings primitives and string
                    // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                    return object == (other + '');
            }
            return false;
        }

        module.exports = equalByTag;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/equalObjects.js": [function (require, module, exports) {
        var keys = require('../object/keys');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objProps = keys(object),
                objLength = objProps.length,
                othProps = keys(other),
                othLength = othProps.length;

            if (objLength != othLength && !isLoose) {
                return false;
            }
            var index = objLength;
            while (index--) {
                var key = objProps[index];
                if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                }
            }
            var skipCtor = isLoose;
            while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key],
                    othValue = other[key],
                    result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;

                // Recursively compare objects (susceptible to call stack limits).
                if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                    return false;
                }
                skipCtor || (skipCtor = key == 'constructor');
            }
            if (!skipCtor) {
                var objCtor = object.constructor,
                    othCtor = other.constructor;

                // Non `Object` object instances with different constructors are not equal.
                if (objCtor != othCtor &&
                    ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                    typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                    return false;
                }
            }
            return true;
        }

        module.exports = equalObjects;

    }, {"../object/keys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getData.js": [function (require, module, exports) {
        var metaMap = require('./metaMap'),
            noop = require('../utility/noop');

        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
        };

        module.exports = getData;

    }, {
        "../utility/noop": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/utility/noop.js",
        "./metaMap": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/metaMap.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getFuncName.js": [function (require, module, exports) {
        var realNames = require('./realNames');

        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
            var result = func.name,
                array = realNames[result],
                length = array ? array.length : 0;

            while (length--) {
                var data = array[length],
                    otherFunc = data.func;
                if (otherFunc == null || otherFunc == func) {
                    return data.name;
                }
            }
            return result;
        }

        module.exports = getFuncName;

    }, {"./realNames": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/realNames.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getLength.js": [function (require, module, exports) {
        var baseProperty = require('./baseProperty');

        /**
         * Gets the "length" property value of `object`.
         *
         * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
         * that affects Safari on at least iOS 8.1-8.3 ARM64.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {*} Returns the "length" value.
         */
        var getLength = baseProperty('length');

        module.exports = getLength;

    }, {"./baseProperty": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseProperty.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getMatchData.js": [function (require, module, exports) {
        var isStrictComparable = require('./isStrictComparable'),
            pairs = require('../object/pairs');

        /**
         * Gets the propery names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
            var result = pairs(object),
                length = result.length;

            while (length--) {
                result[length][2] = isStrictComparable(result[length][1]);
            }
            return result;
        }

        module.exports = getMatchData;

    }, {
        "../object/pairs": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/pairs.js",
        "./isStrictComparable": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isStrictComparable.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getNative.js": [function (require, module, exports) {
        var isNative = require('../lang/isNative');

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
            var value = object == null ? undefined : object[key];
            return isNative(value) ? value : undefined;
        }

        module.exports = getNative;

    }, {"../lang/isNative": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isNative.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/indexOfNaN.js": [function (require, module, exports) {
        /**
         * Gets the index at which the first occurrence of `NaN` is found in `array`.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {number} fromIndex The index to search from.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched `NaN`, else `-1`.
         */
        function indexOfNaN(array, fromIndex, fromRight) {
            var length = array.length,
                index = fromIndex + (fromRight ? 0 : -1);

            while ((fromRight ? index-- : ++index < length)) {
                var other = array[index];
                if (other !== other) {
                    return index;
                }
            }
            return -1;
        }

        module.exports = indexOfNaN;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isArrayLike.js": [function (require, module, exports) {
        var getLength = require('./getLength'),
            isLength = require('./isLength');

        /**
         * Checks if `value` is array-like.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         */
        function isArrayLike(value) {
            return value != null && isLength(getLength(value));
        }

        module.exports = isArrayLike;

    }, {
        "./getLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getLength.js",
        "./isLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLength.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIndex.js": [function (require, module, exports) {
        /** Used to detect unsigned integer values. */
        var reIsUint = /^\d+$/;

        /**
         * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
         * of an array-like value.
         */
        var MAX_SAFE_INTEGER = 9007199254740991;

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
            value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return value > -1 && value % 1 == 0 && value < length;
        }

        module.exports = isIndex;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIterateeCall.js": [function (require, module, exports) {
        var isArrayLike = require('./isArrayLike'),
            isIndex = require('./isIndex'),
            isObject = require('../lang/isObject');

        /**
         * Checks if the provided arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
         */
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
                return false;
            }
            var type = typeof index;
            if (type == 'number'
                    ? (isArrayLike(object) && isIndex(index, object.length))
                    : (type == 'string' && index in object)) {
                var other = object[index];
                return value === value ? (value === other) : (other !== other);
            }
            return false;
        }

        module.exports = isIterateeCall;

    }, {
        "../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js",
        "./isArrayLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isArrayLike.js",
        "./isIndex": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIndex.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isKey.js": [function (require, module, exports) {
        var isArray = require('../lang/isArray'),
            toObject = require('./toObject');

        /** Used to match property names within property paths. */
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/;

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
            var type = typeof value;
            if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
                return true;
            }
            if (isArray(value)) {
                return false;
            }
            var result = !reIsDeepProp.test(value);
            return result || (object != null && value in toObject(object));
        }

        module.exports = isKey;

    }, {
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "./toObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLaziable.js": [function (require, module, exports) {
        var LazyWrapper = require('./LazyWrapper'),
            getData = require('./getData'),
            getFuncName = require('./getFuncName'),
            lodash = require('../chain/lodash');

        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
         */
        function isLaziable(func) {
            var funcName = getFuncName(func);
            if (!(funcName in LazyWrapper.prototype)) {
                return false;
            }
            var other = lodash[funcName];
            if (func === other) {
                return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
        }

        module.exports = isLaziable;

    }, {
        "../chain/lodash": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/chain/lodash.js",
        "./LazyWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/LazyWrapper.js",
        "./getData": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getData.js",
        "./getFuncName": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getFuncName.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLength.js": [function (require, module, exports) {
        /**
         * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
         * of an array-like value.
         */
        var MAX_SAFE_INTEGER = 9007199254740991;

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         */
        function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }

        module.exports = isLength;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js": [function (require, module, exports) {
        /**
         * Checks if `value` is object-like.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         */
        function isObjectLike(value) {
            return !!value && typeof value == 'object';
        }

        module.exports = isObjectLike;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isStrictComparable.js": [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
            return value === value && !isObject(value);
        }

        module.exports = isStrictComparable;

    }, {"../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/mergeData.js": [function (require, module, exports) {
        var arrayCopy = require('./arrayCopy'),
            composeArgs = require('./composeArgs'),
            composeArgsRight = require('./composeArgsRight'),
            replaceHolders = require('./replaceHolders');

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1,
            CURRY_BOUND_FLAG = 4,
            CURRY_FLAG = 8,
            ARY_FLAG = 128,
            REARG_FLAG = 256;

        /** Used as the internal argument placeholder. */
        var PLACEHOLDER = '__lodash_placeholder__';

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMin = Math.min;

        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers required to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
         * augment function arguments, making the order in which they are executed important,
         * preventing the merging of metadata. However, we make an exception for a safe
         * common case where curried functions have `_.ary` and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
            var bitmask = data[1],
                srcBitmask = source[1],
                newBitmask = bitmask | srcBitmask,
                isCommon = newBitmask < ARY_FLAG;

            var isCombo =
                (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
                (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
                (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

            // Exit early if metadata can't be merged.
            if (!(isCommon || isCombo)) {
                return data;
            }
            // Use source `thisArg` if available.
            if (srcBitmask & BIND_FLAG) {
                data[2] = source[2];
                // Set when currying a bound function.
                newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
            }
            // Compose partial arguments.
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
            }
            // Compose partial right arguments.
            value = source[5];
            if (value) {
                partials = data[5];
                data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
            }
            // Use source `argPos` if available.
            value = source[7];
            if (value) {
                data[7] = arrayCopy(value);
            }
            // Use source `ary` if it's smaller.
            if (srcBitmask & ARY_FLAG) {
                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            // Use source `arity` if one is not provided.
            if (data[9] == null) {
                data[9] = source[9];
            }
            // Use source `func` and merge bitmasks.
            data[0] = source[0];
            data[1] = newBitmask;

            return data;
        }

        module.exports = mergeData;

    }, {
        "./arrayCopy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayCopy.js",
        "./composeArgs": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/composeArgs.js",
        "./composeArgsRight": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/composeArgsRight.js",
        "./replaceHolders": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/replaceHolders.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/metaMap.js": [function (require, module, exports) {
        (function (global) {
            var getNative = require('./getNative');

            /** Native method references. */
            var WeakMap = getNative(global, 'WeakMap');

            /** Used to store function metadata. */
            var metaMap = WeakMap && new WeakMap;

            module.exports = metaMap;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {"./getNative": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getNative.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/pickByArray.js": [function (require, module, exports) {
        var toObject = require('./toObject');

        /**
         * A specialized version of `_.pick` which picks `object` properties specified
         * by `props`.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} props The property names to pick.
         * @returns {Object} Returns the new object.
         */
        function pickByArray(object, props) {
            object = toObject(object);

            var index = -1,
                length = props.length,
                result = {};

            while (++index < length) {
                var key = props[index];
                if (key in object) {
                    result[key] = object[key];
                }
            }
            return result;
        }

        module.exports = pickByArray;

    }, {"./toObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/pickByCallback.js": [function (require, module, exports) {
        var baseForIn = require('./baseForIn');

        /**
         * A specialized version of `_.pick` which picks `object` properties `predicate`
         * returns truthy for.
         *
         * @private
         * @param {Object} object The source object.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Object} Returns the new object.
         */
        function pickByCallback(object, predicate) {
            var result = {};
            baseForIn(object, function (value, key, object) {
                if (predicate(value, key, object)) {
                    result[key] = value;
                }
            });
            return result;
        }

        module.exports = pickByCallback;

    }, {"./baseForIn": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseForIn.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/realNames.js": [function (require, module, exports) {
        /** Used to lookup unminified function names. */
        var realNames = {};

        module.exports = realNames;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/reorder.js": [function (require, module, exports) {
        var arrayCopy = require('./arrayCopy'),
            isIndex = require('./isIndex');

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMin = Math.min;

        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
            var arrLength = array.length,
                length = nativeMin(indexes.length, arrLength),
                oldArray = arrayCopy(array);

            while (length--) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }

        module.exports = reorder;

    }, {
        "./arrayCopy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayCopy.js",
        "./isIndex": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIndex.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/replaceHolders.js": [function (require, module, exports) {
        /** Used as the internal argument placeholder. */
        var PLACEHOLDER = '__lodash_placeholder__';

        /**
         * Replaces all `placeholder` elements in `array` with an internal placeholder
         * and returns an array of their indexes.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {*} placeholder The placeholder to replace.
         * @returns {Array} Returns the new array of placeholder indexes.
         */
        function replaceHolders(array, placeholder) {
            var index = -1,
                length = array.length,
                resIndex = -1,
                result = [];

            while (++index < length) {
                if (array[index] === placeholder) {
                    array[index] = PLACEHOLDER;
                    result[++resIndex] = index;
                }
            }
            return result;
        }

        module.exports = replaceHolders;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/setData.js": [function (require, module, exports) {
        var baseSetData = require('./baseSetData'),
            now = require('../date/now');

        /** Used to detect when a function becomes hot. */
        var HOT_COUNT = 150,
            HOT_SPAN = 16;

        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity function
         * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = (function () {
            var count = 0,
                lastCalled = 0;

            return function (key, value) {
                var stamp = now(),
                    remaining = HOT_SPAN - (stamp - lastCalled);

                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                        return key;
                    }
                } else {
                    count = 0;
                }
                return baseSetData(key, value);
            };
        }());

        module.exports = setData;

    }, {
        "../date/now": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/date/now.js",
        "./baseSetData": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseSetData.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/shimKeys.js": [function (require, module, exports) {
        var isArguments = require('../lang/isArguments'),
            isArray = require('../lang/isArray'),
            isIndex = require('./isIndex'),
            isLength = require('./isLength'),
            keysIn = require('../object/keysIn');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * A fallback implementation of `Object.keys` which creates an array of the
         * own enumerable property names of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function shimKeys(object) {
            var props = keysIn(object),
                propsLength = props.length,
                length = propsLength && object.length;

            var allowIndexes = !!length && isLength(length) &&
                (isArray(object) || isArguments(object));

            var index = -1,
                result = [];

            while (++index < propsLength) {
                var key = props[index];
                if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                    result.push(key);
                }
            }
            return result;
        }

        module.exports = shimKeys;

    }, {
        "../lang/isArguments": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArguments.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "../object/keysIn": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keysIn.js",
        "./isIndex": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIndex.js",
        "./isLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLength.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/sortedUniq.js": [function (require, module, exports) {
        /**
         * An implementation of `_.uniq` optimized for sorted arrays without support
         * for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The function invoked per iteration.
         * @returns {Array} Returns the new duplicate-value-free array.
         */
        function sortedUniq(array, iteratee) {
            var seen,
                index = -1,
                length = array.length,
                resIndex = -1,
                result = [];

            while (++index < length) {
                var value = array[index],
                    computed = iteratee ? iteratee(value, index, array) : value;

                if (!index || seen !== computed) {
                    seen = computed;
                    result[++resIndex] = value;
                }
            }
            return result;
        }

        module.exports = sortedUniq;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js": [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * Converts `value` to an object if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Object} Returns the object.
         */
        function toObject(value) {
            return isObject(value) ? value : Object(value);
        }

        module.exports = toObject;

    }, {"../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toPath.js": [function (require, module, exports) {
        var baseToString = require('./baseToString'),
            isArray = require('../lang/isArray');

        /** Used to match property names within property paths. */
        var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

        /** Used to match backslashes in property paths. */
        var reEscapeChar = /\\(\\)?/g;

        /**
         * Converts `value` to property path array if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Array} Returns the property path array.
         */
        function toPath(value) {
            if (isArray(value)) {
                return value;
            }
            var result = [];
            baseToString(value).replace(rePropName, function (match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
            });
            return result;
        }

        module.exports = toPath;

    }, {
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "./baseToString": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseToString.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/wrapperClone.js": [function (require, module, exports) {
        var LazyWrapper = require('./LazyWrapper'),
            LodashWrapper = require('./LodashWrapper'),
            arrayCopy = require('./arrayCopy');

        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
            return wrapper instanceof LazyWrapper
                ? wrapper.clone()
                : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }

        module.exports = wrapperClone;

    }, {
        "./LazyWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/LazyWrapper.js",
        "./LodashWrapper": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/LodashWrapper.js",
        "./arrayCopy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayCopy.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArguments.js": [function (require, module, exports) {
        var isArrayLike = require('../internal/isArrayLike'),
            isObjectLike = require('../internal/isObjectLike');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Native method references. */
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;

        /**
         * Checks if `value` is classified as an `arguments` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        function isArguments(value) {
            return isObjectLike(value) && isArrayLike(value) &&
                hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }

        module.exports = isArguments;

    }, {
        "../internal/isArrayLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isArrayLike.js",
        "../internal/isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js": [function (require, module, exports) {
        var getNative = require('../internal/getNative'),
            isLength = require('../internal/isLength'),
            isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var arrayTag = '[object Array]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeIsArray = getNative(Array, 'isArray');

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(function() { return arguments; }());
         * // => false
         */
        var isArray = nativeIsArray || function (value) {
                return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
            };

        module.exports = isArray;

    }, {
        "../internal/getNative": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getNative.js",
        "../internal/isLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLength.js",
        "../internal/isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isFunction.js": [function (require, module, exports) {
        var isObject = require('./isObject');

        /** `Object#toString` result references. */
        var funcTag = '[object Function]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in older versions of Chrome and Safari which return 'function' for regexes
            // and Safari 8 equivalents which return 'object' for typed array constructors.
            return isObject(value) && objToString.call(value) == funcTag;
        }

        module.exports = isFunction;

    }, {"./isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isNative.js": [function (require, module, exports) {
        var isFunction = require('./isFunction'),
            isObjectLike = require('../internal/isObjectLike');

        /** Used to detect host constructors (Safari > 5). */
        var reIsHostCtor = /^\[object .+?Constructor\]$/;

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var fnToString = Function.prototype.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
            fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );

        /**
         * Checks if `value` is a native function.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
            if (value == null) {
                return false;
            }
            if (isFunction(value)) {
                return reIsNative.test(fnToString.call(value));
            }
            return isObjectLike(value) && reIsHostCtor.test(value);
        }

        module.exports = isNative;

    }, {
        "../internal/isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js",
        "./isFunction": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isFunction.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isNumber.js": [function (require, module, exports) {
        var isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var numberTag = '[object Number]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
         * as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isNumber(8.4);
         * // => true
         *
         * _.isNumber(NaN);
         * // => true
         *
         * _.isNumber('8.4');
         * // => false
         */
        function isNumber(value) {
            return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }

        module.exports = isNumber;

    }, {"../internal/isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js": [function (require, module, exports) {
        /**
         * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
         * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(1);
         * // => false
         */
        function isObject(value) {
            // Avoid a V8 JIT bug in Chrome 19-20.
            // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
        }

        module.exports = isObject;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isPlainObject.js": [function (require, module, exports) {
        var baseForIn = require('../internal/baseForIn'),
            isArguments = require('./isArguments'),
            isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var objectTag = '[object Object]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * **Note:** This method assumes objects created by the `Object` constructor
         * have no inherited enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
 *   this.a = 1;
 * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
            var Ctor;

            // Exit early for non `Object` objects.
            if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
                (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
                return false;
            }
            // IE < 9 iterates inherited properties before own properties. If the first
            // iterated property is an object's own property then there are no inherited
            // enumerable properties.
            var result;
            // In most environments an object's own properties are iterated before
            // its inherited properties. If the last iterated property is an object's
            // own property then there are no inherited enumerable properties.
            baseForIn(value, function (subValue, key) {
                result = key;
            });
            return result === undefined || hasOwnProperty.call(value, result);
        }

        module.exports = isPlainObject;

    }, {
        "../internal/baseForIn": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseForIn.js",
        "../internal/isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js",
        "./isArguments": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArguments.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isString.js": [function (require, module, exports) {
        var isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var stringTag = '[object String]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
            return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }

        module.exports = isString;

    }, {"../internal/isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js"}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isTypedArray.js": [function (require, module, exports) {
        var isLength = require('../internal/isLength'),
            isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            objectTag = '[object Object]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            weakMapTag = '[object WeakMap]';

        var arrayBufferTag = '[object ArrayBuffer]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
            typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                        typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
            typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                typedArrayTags[dateTag] = typedArrayTags[errorTag] =
                    typedArrayTags[funcTag] = typedArrayTags[mapTag] =
                        typedArrayTags[numberTag] = typedArrayTags[objectTag] =
                            typedArrayTags[regexpTag] = typedArrayTags[setTag] =
                                typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }

        module.exports = isTypedArray;

    }, {
        "../internal/isLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLength.js",
        "../internal/isObjectLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isObjectLike.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/toPlainObject.js": [function (require, module, exports) {
        var baseCopy = require('../internal/baseCopy'),
            keysIn = require('../object/keysIn');

        /**
         * Converts `value` to a plain object flattening inherited enumerable
         * properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
 *   this.b = 2;
 * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
            return baseCopy(value, keysIn(value));
        }

        module.exports = toPlainObject;

    }, {
        "../internal/baseCopy": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseCopy.js",
        "../object/keysIn": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keysIn.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/assign.js": [function (require, module, exports) {
        var assignWith = require('../internal/assignWith'),
            baseAssign = require('../internal/baseAssign'),
            createAssigner = require('../internal/createAssigner');

        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object. Subsequent sources overwrite property assignments of previous sources.
         * If `customizer` is provided it is invoked to produce the assigned values.
         * The `customizer` is bound to `thisArg` and invoked with five arguments:
         * (objectValue, sourceValue, key, object, source).
         *
         * **Note:** This method mutates `object` and is based on
         * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
         *
         * @static
         * @memberOf _
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
         * // => { 'user': 'fred', 'age': 40 }
         *
         * // using a customizer callback
         * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return _.isUndefined(value) ? other : value;
 * });
         *
         * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
         * // => { 'user': 'barney', 'age': 36 }
         */
        var assign = createAssigner(function (object, source, customizer) {
            return customizer
                ? assignWith(object, source, customizer)
                : baseAssign(object, source);
        });

        module.exports = assign;

    }, {
        "../internal/assignWith": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/assignWith.js",
        "../internal/baseAssign": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseAssign.js",
        "../internal/createAssigner": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createAssigner.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js": [function (require, module, exports) {
        var getNative = require('../internal/getNative'),
            isArrayLike = require('../internal/isArrayLike'),
            isObject = require('../lang/isObject'),
            shimKeys = require('../internal/shimKeys');

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeKeys = getNative(Object, 'keys');

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        var keys = !nativeKeys ? shimKeys : function (object) {
            var Ctor = object == null ? undefined : object.constructor;
            if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
                (typeof object != 'function' && isArrayLike(object))) {
                return shimKeys(object);
            }
            return isObject(object) ? nativeKeys(object) : [];
        };

        module.exports = keys;

    }, {
        "../internal/getNative": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/getNative.js",
        "../internal/isArrayLike": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isArrayLike.js",
        "../internal/shimKeys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/shimKeys.js",
        "../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keysIn.js": [function (require, module, exports) {
        var isArguments = require('../lang/isArguments'),
            isArray = require('../lang/isArray'),
            isIndex = require('../internal/isIndex'),
            isLength = require('../internal/isLength'),
            isObject = require('../lang/isObject');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
            if (object == null) {
                return [];
            }
            if (!isObject(object)) {
                object = Object(object);
            }
            var length = object.length;
            length = (length && isLength(length) &&
            (isArray(object) || isArguments(object)) && length) || 0;

            var Ctor = object.constructor,
                index = -1,
                isProto = typeof Ctor == 'function' && Ctor.prototype === object,
                result = Array(length),
                skipIndexes = length > 0;

            while (++index < length) {
                result[index] = (index + '');
            }
            for (var key in object) {
                if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                }
            }
            return result;
        }

        module.exports = keysIn;

    }, {
        "../internal/isIndex": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isIndex.js",
        "../internal/isLength": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isLength.js",
        "../lang/isArguments": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArguments.js",
        "../lang/isArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isArray.js",
        "../lang/isObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/lang/isObject.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/merge.js": [function (require, module, exports) {
        var baseMerge = require('../internal/baseMerge'),
            createAssigner = require('../internal/createAssigner');

        /**
         * Recursively merges own enumerable properties of the source object(s), that
         * don't resolve to `undefined` into the destination object. Subsequent sources
         * overwrite property assignments of previous sources. If `customizer` is
         * provided it is invoked to produce the merged values of the destination and
         * source properties. If `customizer` returns `undefined` merging is handled
         * by the method instead. The `customizer` is bound to `thisArg` and invoked
         * with five arguments: (objectValue, sourceValue, key, object, source).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var users = {
 *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 * };
         *
         * var ages = {
 *   'data': [{ 'age': 36 }, { 'age': 40 }]
 * };
         *
         * _.merge(users, ages);
         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
         *
         * // using a customizer callback
         * var object = {
 *   'fruits': ['apple'],
 *   'vegetables': ['beet']
 * };
         *
         * var other = {
 *   'fruits': ['banana'],
 *   'vegetables': ['carrot']
 * };
         *
         * _.merge(object, other, function(a, b) {
 *   if (_.isArray(a)) {
 *     return a.concat(b);
 *   }
 * });
         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
         */
        var merge = createAssigner(baseMerge);

        module.exports = merge;

    }, {
        "../internal/baseMerge": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseMerge.js",
        "../internal/createAssigner": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/createAssigner.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/omit.js": [function (require, module, exports) {
        var arrayMap = require('../internal/arrayMap'),
            baseDifference = require('../internal/baseDifference'),
            baseFlatten = require('../internal/baseFlatten'),
            bindCallback = require('../internal/bindCallback'),
            keysIn = require('./keysIn'),
            pickByArray = require('../internal/pickByArray'),
            pickByCallback = require('../internal/pickByCallback'),
            restParam = require('../function/restParam');

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable properties of `object` that are not omitted.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to omit, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.omit(object, 'age');
         * // => { 'user': 'fred' }
         *
         * _.omit(object, _.isNumber);
         * // => { 'user': 'fred' }
         */
        var omit = restParam(function (object, props) {
            if (object == null) {
                return {};
            }
            if (typeof props[0] != 'function') {
                var props = arrayMap(baseFlatten(props), String);
                return pickByArray(object, baseDifference(keysIn(object), props));
            }
            var predicate = bindCallback(props[0], props[1], 3);
            return pickByCallback(object, function (value, key, object) {
                return !predicate(value, key, object);
            });
        });

        module.exports = omit;

    }, {
        "../function/restParam": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/restParam.js",
        "../internal/arrayMap": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/arrayMap.js",
        "../internal/baseDifference": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseDifference.js",
        "../internal/baseFlatten": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFlatten.js",
        "../internal/bindCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/bindCallback.js",
        "../internal/pickByArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/pickByArray.js",
        "../internal/pickByCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/pickByCallback.js",
        "./keysIn": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keysIn.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/pairs.js": [function (require, module, exports) {
        var keys = require('./keys'),
            toObject = require('../internal/toObject');

        /**
         * Creates a two dimensional array of the key-value pairs for `object`,
         * e.g. `[[key1, value1], [key2, value2]]`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the new array of key-value pairs.
         * @example
         *
         * _.pairs({ 'barney': 36, 'fred': 40 });
         * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
         */
        function pairs(object) {
            object = toObject(object);

            var index = -1,
                props = keys(object),
                length = props.length,
                result = Array(length);

            while (++index < length) {
                var key = props[index];
                result[index] = [key, object[key]];
            }
            return result;
        }

        module.exports = pairs;

    }, {
        "../internal/toObject": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/toObject.js",
        "./keys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/pick.js": [function (require, module, exports) {
        var baseFlatten = require('../internal/baseFlatten'),
            bindCallback = require('../internal/bindCallback'),
            pickByArray = require('../internal/pickByArray'),
            pickByCallback = require('../internal/pickByCallback'),
            restParam = require('../function/restParam');

        /**
         * Creates an object composed of the picked `object` properties. Property
         * names may be specified as individual arguments or as arrays of property
         * names. If `predicate` is provided it is invoked for each property of `object`
         * picking the properties `predicate` returns truthy for. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to pick, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.pick(object, 'user');
         * // => { 'user': 'fred' }
         *
         * _.pick(object, _.isString);
         * // => { 'user': 'fred' }
         */
        var pick = restParam(function (object, props) {
            if (object == null) {
                return {};
            }
            return typeof props[0] == 'function'
                ? pickByCallback(object, bindCallback(props[0], props[1], 3))
                : pickByArray(object, baseFlatten(props));
        });

        module.exports = pick;

    }, {
        "../function/restParam": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/function/restParam.js",
        "../internal/baseFlatten": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseFlatten.js",
        "../internal/bindCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/bindCallback.js",
        "../internal/pickByArray": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/pickByArray.js",
        "../internal/pickByCallback": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/pickByCallback.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/values.js": [function (require, module, exports) {
        var baseValues = require('../internal/baseValues'),
            keys = require('./keys');

        /**
         * Creates an array of the own enumerable property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
            return baseValues(object, keys(object));
        }

        module.exports = values;

    }, {
        "../internal/baseValues": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseValues.js",
        "./keys": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/object/keys.js"
    }],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/utility/identity.js": [function (require, module, exports) {
        /**
         * This method returns the first argument provided to it.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.identity(object) === object;
         * // => true
         */
        function identity(value) {
            return value;
        }

        module.exports = identity;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/utility/noop.js": [function (require, module, exports) {
        /**
         * A no-operation function that returns `undefined` regardless of the
         * arguments it receives.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.noop(object) === undefined;
         * // => true
         */
        function noop() {
            // No operation performed.
        }

        module.exports = noop;

    }, {}],
    "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/utility/property.js": [function (require, module, exports) {
        var baseProperty = require('../internal/baseProperty'),
            basePropertyDeep = require('../internal/basePropertyDeep'),
            isKey = require('../internal/isKey');

        /**
         * Creates a function that returns the property value at `path` on a
         * given object.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': 2 } } },
         *   { 'a': { 'b': { 'c': 1 } } }
         * ];
         *
         * _.map(objects, _.property('a.b.c'));
         * // => [2, 1]
         *
         * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        function property(path) {
            return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }

        module.exports = property;

    }, {
        "../internal/baseProperty": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/baseProperty.js",
        "../internal/basePropertyDeep": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/basePropertyDeep.js",
        "../internal/isKey": "/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/node_modules/lodash/internal/isKey.js"
    }]
}, {}, ["/home/amiraqa/Desktop/bpmn-js-examples-master/modeler/app/index.js"]);
